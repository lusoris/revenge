doc_title: Tracearr Analytics Service
doc_category: feature
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Real-time monitoring, analytics, and account sharing detection for Revenge'
wiki_tagline: '> See what is being watched and detect account sharing'
wiki_overview: The Tracearr analytics dashboard shows real-time server activity. See what is being watched right now, popular
  content this week, and overall library statistics. Track bandwidth usage and transcoding load. Account sharing detection
  spots when the same user watches from multiple locations simultaneously. Export reports for server administrators.
sources:
- name: Casbin
  url: https://pkg.go.dev/github.com/casbin/casbin/v2
  note: Auto-resolved from casbin
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: Go io
  url: https://pkg.go.dev/io
  note: Auto-resolved from go-io
- name: pgx PostgreSQL Driver
  url: https://pkg.go.dev/github.com/jackc/pgx/v5
  note: Auto-resolved from pgx
- name: PostgreSQL Arrays
  url: https://www.postgresql.org/docs/current/arrays.html
  note: Auto-resolved from postgresql-arrays
- name: PostgreSQL JSON Functions
  url: https://www.postgresql.org/docs/current/functions-json.html
  note: Auto-resolved from postgresql-json
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: rueidis
  url: https://pkg.go.dev/github.com/redis/rueidis
  note: Auto-resolved from rueidis
- name: rueidis GitHub README
  url: https://github.com/redis/rueidis
  note: Auto-resolved from rueidis-docs
- name: sqlc
  url: https://docs.sqlc.dev/en/stable/
  note: Auto-resolved from sqlc
- name: sqlc Configuration
  url: https://docs.sqlc.dev/en/stable/reference/config.html
  note: Auto-resolved from sqlc-config
- name: Svelte 5 Runes
  url: https://svelte.dev/docs/svelte/$state
  note: Auto-resolved from svelte-runes
- name: Svelte 5 Documentation
  url: https://svelte.dev/docs/svelte/overview
  note: Auto-resolved from svelte5
- name: SvelteKit Documentation
  url: https://svelte.dev/docs/kit/introduction
  note: Auto-resolved from sveltekit
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
feature_name: Tracearr Analytics Service
module_name: tracearr_analytics_service
schema_name: public
architecture_diagram: |-
  ```mermaid
  flowchart TD
      subgraph row1[ ]
          direction LR
          node1(["Client<br/>(Web/App)"])
          node2[["API Handler<br/>(ogen)"]]
          node3[["Service<br/>(Logic)"]]
      end
      subgraph row2[ ]
          direction LR
          node4["Repository<br/>(sqlc)"]
          node5[["Metadata<br/>Service"]]
          node6[("Cache<br/>(otter)")]
      end
      subgraph row3[ ]
          direction LR
          node7[("PostgreSQL<br/>(pgx)")]
          node8(["External<br/>APIs"])
      end
      node1 --> node2
      node2 --> node3
      node4 --> node5
      node5 --> node6
      node7 --> node8
      node3 --> node4
      node6 --> node7

      %% Hide row subgraph borders
      style row1 fill:transparent,stroke:transparent
      style row2 fill:transparent,stroke:transparent
      style row3 fill:transparent,stroke:transparent
  ```
database_schema: |
  **Schema**: `public`

  ```sql
  -- Playback sessions (real-time and historical)
  CREATE TABLE playback_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Content reference
    content_type VARCHAR(50) NOT NULL,              -- 'movie', 'episode', 'track', 'scene'
    content_id UUID NOT NULL,

    -- Session metadata
    started_at TIMESTAMPTZ DEFAULT now(),
    ended_at TIMESTAMPTZ,
    duration_seconds INTEGER,
    progress_seconds INTEGER,

    -- Client information
    client_name VARCHAR(100),                       -- 'Web', 'Android', 'iOS', 'Roku'
    client_version VARCHAR(50),
    device_id VARCHAR(255),
    device_name VARCHAR(100),

    -- Network information
    ip_address INET,
    user_agent TEXT,
    location_country VARCHAR(2),                    -- ISO 3166-1 alpha-2
    location_city VARCHAR(100),

    -- Streaming details
    bandwidth_mbps DECIMAL(8,2),
    transcoded BOOLEAN DEFAULT false,
    transcode_codec VARCHAR(20),
    original_codec VARCHAR(20),
    resolution VARCHAR(20),                         -- '4K', '1080p', '720p', etc.

    -- Status
    status VARCHAR(20) DEFAULT 'active',            -- 'active', 'paused', 'stopped', 'completed'

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_playback_sessions_user ON playback_sessions(user_id, started_at DESC);
  CREATE INDEX idx_playback_sessions_content ON playback_sessions(content_type, content_id);
  CREATE INDEX idx_playback_sessions_status ON playback_sessions(status) WHERE status = 'active';
  CREATE INDEX idx_playback_sessions_started ON playback_sessions(started_at DESC);
  CREATE INDEX idx_playback_sessions_device ON playback_sessions(device_id);

  -- Aggregated statistics (daily rollup)
  CREATE TABLE analytics_daily (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    date DATE NOT NULL,

    -- Overall stats
    total_sessions INTEGER DEFAULT 0,
    total_duration_minutes INTEGER DEFAULT 0,
    unique_users INTEGER DEFAULT 0,
    total_bandwidth_gb DECIMAL(12,2) DEFAULT 0,

    -- Content stats
    movies_watched INTEGER DEFAULT 0,
    episodes_watched INTEGER DEFAULT 0,
    tracks_played INTEGER DEFAULT 0,

    -- Transcoding stats
    transcoded_sessions INTEGER DEFAULT 0,
    transcoding_minutes INTEGER DEFAULT 0,

    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE UNIQUE INDEX idx_analytics_daily_date ON analytics_daily(date);
  CREATE INDEX idx_analytics_daily_date_desc ON analytics_daily(date DESC);

  -- Popular content tracking
  CREATE TABLE analytics_popular_content (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content_type VARCHAR(50) NOT NULL,
    content_id UUID NOT NULL,

    -- Time windows
    plays_today INTEGER DEFAULT 0,
    plays_this_week INTEGER DEFAULT 0,
    plays_this_month INTEGER DEFAULT 0,
    plays_all_time INTEGER DEFAULT 0,

    -- User engagement
    unique_users_today INTEGER DEFAULT 0,
    unique_users_this_week INTEGER DEFAULT 0,
    unique_users_this_month INTEGER DEFAULT 0,

    last_played_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE UNIQUE INDEX idx_analytics_popular_unique ON analytics_popular_content(content_type, content_id);
  CREATE INDEX idx_analytics_popular_week ON analytics_popular_content(plays_this_week DESC);
  CREATE INDEX idx_analytics_popular_month ON analytics_popular_content(plays_this_month DESC);

  -- Account sharing detection
  CREATE TABLE sharing_alerts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Detection details
    alert_type VARCHAR(50) NOT NULL,               -- 'concurrent_streams', 'geo_impossible', 'device_spike'
    severity VARCHAR(20) DEFAULT 'low',            -- 'low', 'medium', 'high'

    -- Evidence
    evidence JSONB,                                 -- {\"sessions\": [\"uuid1\", \"uuid2\"], \"distance_km\": 5000}

    -- Status
    status VARCHAR(20) DEFAULT 'active',           -- 'active', 'dismissed', 'resolved'
    reviewed_by_user_id UUID REFERENCES users(id),
    reviewed_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_sharing_alerts_user ON sharing_alerts(user_id, created_at DESC);
  CREATE INDEX idx_sharing_alerts_status ON sharing_alerts(status) WHERE status = 'active';
  ```
module_structure: |
  ```
  internal/analytics/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ types.go                     # Domain types
  â”œâ”€â”€ repository.go                # Database operations (sqlc)
  â”œâ”€â”€ service.go                   # Analytics logic
  â”œâ”€â”€ collector.go                 # Collect playback events
  â”œâ”€â”€ aggregator.go                # Daily/weekly aggregation (River job)
  â”œâ”€â”€ detector.go                  # Account sharing detection
  â”œâ”€â”€ geolocation.go               # IP geolocation lookup
  â”œâ”€â”€ handler.go                   # HTTP API handlers
  â””â”€â”€ analytics_test.go

  web/src/routes/(app)/analytics/
  â”œâ”€â”€ +page.svelte                 # Analytics dashboard
  â”œâ”€â”€ +page.ts                     # Data loading
  â””â”€â”€ components/
      â”œâ”€â”€ RealTimeActivity.svelte  # Real-time playback activity
      â”œâ”€â”€ PopularContent.svelte    # Most popular content charts
      â”œâ”€â”€ BandwidthChart.svelte    # Bandwidth usage over time
      â”œâ”€â”€ UserStats.svelte         # User activity statistics
      â””â”€â”€ SharingAlerts.svelte     # Account sharing alerts
  ```
key_interfaces: |
  ```go
  type AnalyticsService interface {
    // Real-time sessions
    GetActiveSessions(ctx context.Context) ([]PlaybackSession, error)
    GetUserSessions(ctx context.Context, userID uuid.UUID, limit int) ([]PlaybackSession, error)
    RecordSession(ctx context.Context, session PlaybackSessionCreate) (*PlaybackSession, error)
    UpdateSession(ctx context.Context, sessionID uuid.UUID, update SessionUpdate) error
    EndSession(ctx context.Context, sessionID uuid.UUID) error

    // Statistics
    GetDailyStats(ctx context.Context, start, end time.Time) ([]DailyStat, error)
    GetPopularContent(ctx context.Context, window TimeWindow, limit int) ([]PopularContentItem, error)

    // Account sharing
    DetectSharing(ctx context.Context) ([]SharingAlert, error)
    GetSharingAlerts(ctx context.Context, userID uuid.UUID) ([]SharingAlert, error)
    DismissAlert(ctx context.Context, alertID uuid.UUID) error
  }

  type PlaybackSession struct {
    ID              uuid.UUID  `db:"id" json:"id"`
    UserID          uuid.UUID  `db:"user_id" json:"user_id"`
    ContentType     string     `db:"content_type" json:"content_type"`
    ContentID       uuid.UUID  `db:"content_id" json:"content_id"`
    StartedAt       time.Time  `db:"started_at" json:"started_at"`
    EndedAt         *time.Time `db:"ended_at" json:"ended_at,omitempty"`
    DurationSeconds int        `db:"duration_seconds" json:"duration_seconds"`
    ClientName      string     `db:"client_name" json:"client_name"`
    DeviceName      string     `db:"device_name" json:"device_name"`
    IPAddress       string     `db:"ip_address" json:"ip_address"`
    Transcoded      bool       `db:"transcoded" json:"transcoded"`
    Resolution      string     `db:"resolution" json:"resolution"`
    Status          string     `db:"status" json:"status"`
  }

  type DailyStat struct {
    Date                  time.Time `db:"date" json:"date"`
    TotalSessions         int       `db:"total_sessions" json:"total_sessions"`
    TotalDurationMinutes  int       `db:"total_duration_minutes" json:"total_duration_minutes"`
    UniqueUsers           int       `db:"unique_users" json:"unique_users"`
    TotalBandwidthGB      float64   `db:"total_bandwidth_gb" json:"total_bandwidth_gb"`
    TranscodedSessions    int       `db:"transcoded_sessions" json:"transcoded_sessions"`
  }

  type SharingAlert struct {
    ID         uuid.UUID              `db:"id" json:"id"`
    UserID     uuid.UUID              `db:"user_id" json:"user_id"`
    AlertType  string                 `db:"alert_type" json:"alert_type"`
    Severity   string                 `db:"severity" json:"severity"`
    Evidence   map[string]interface{} `db:"evidence" json:"evidence"`
    Status     string                 `db:"status" json:"status"`
    CreatedAt  time.Time              `db:"created_at" json:"created_at"`
  }

  type SharingDetector interface {
    DetectConcurrentStreams(ctx context.Context) ([]SharingAlert, error)
    DetectGeoImpossible(ctx context.Context) ([]SharingAlert, error)
    DetectDeviceSpike(ctx context.Context) ([]SharingAlert, error)
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/google/uuid`
  - `github.com/jackc/pgx/v5`
  - `github.com/riverqueue/river` - Daily aggregation jobs
  - `github.com/oschwald/geoip2-golang` - IP geolocation
  - `go.uber.org/fx`

  **External Data**:
  - MaxMind GeoLite2 database for IP geolocation
env_vars: |
  ```bash
  ANALYTICS_ENABLED=true
  ANALYTICS_GEOIP_DB_PATH=/data/GeoLite2-City.mmdb
  ANALYTICS_RETENTION_DAYS=90
  ANALYTICS_SHARING_DETECTION_ENABLED=true
  ```
config_keys: |
  ```yaml
  analytics:
    enabled: true
    retention_days: 90

    sharing_detection:
      enabled: true
      concurrent_streams_threshold: 3       # Alert if user has >3 concurrent streams
      geo_distance_threshold_km: 500        # Alert if streams from >500km apart
      device_spike_threshold: 5             # Alert if >5 new devices in 24h
  ```
component_interaction: |
  **Session Recording Flow**:
  1. Client starts playback, sends session start event
  2. Service creates playback_sessions record with status='active'
  3. Client sends heartbeat every 30 seconds with progress
  4. Service updates session progress and calculates bandwidth
  5. On playback end, client sends stop event
  6. Service updates ended_at, duration, marks status='completed'

  **Real-Time Activity Flow**:
  1. Admin requests GET /api/v1/analytics/sessions/active
  2. Service queries playback_sessions WHERE status='active'
  3. Join with users/content tables for display names
  4. Cache active sessions in otter for 10 seconds
  5. Return to frontend for real-time dashboard

  **Daily Aggregation Flow**:
  1. River job runs at midnight UTC
  2. Aggregate yesterday's playback_sessions into analytics_daily
  3. Calculate total sessions, duration, unique users, bandwidth
  4. Store aggregated stats for reporting
  5. Update analytics_popular_content counters

  **Account Sharing Detection Flow**:
  1. Background job runs every 15 minutes
  2. Query active sessions grouped by user_id
  3. Check for concurrent streams from same user
  4. Calculate distance between IP addresses using GeoIP
  5. If >500km apart, create sharing_alert
  6. Check device_id counts in last 24h
  7. If >5 new devices, create alert
api_endpoints: |
  ```
  GET  /api/v1/analytics/sessions/active         # Get currently active sessions
  GET  /api/v1/analytics/sessions/user/:userId   # Get user's session history
  POST /api/v1/analytics/sessions                # Start new session
  PUT  /api/v1/analytics/sessions/:id            # Update session (heartbeat)
  DELETE /api/v1/analytics/sessions/:id          # End session

  GET  /api/v1/analytics/stats/daily?start=&end= # Get daily statistics
  GET  /api/v1/analytics/popular?window=week     # Get popular content

  GET  /api/v1/analytics/sharing/alerts          # Get sharing alerts
  POST /api/v1/analytics/sharing/alerts/:id/dismiss  # Dismiss alert
  ```
unit_tests: |
  ```go
  func TestAnalyticsService_RecordSession(t *testing.T) {
    // Test creating playback session
  }

  func TestAnalyticsService_GetActiveSessions(t *testing.T) {
    // Test querying active sessions
  }

  func TestSharingDetector_DetectConcurrentStreams(t *testing.T) {
    tests := []struct {
      name       string
      sessions   []PlaybackSession
      wantAlerts int
    }{
      {
        name: "concurrent streams detected",
        sessions: []PlaybackSession{
          {UserID: uuid1, Status: "active", IPAddress: "1.2.3.4"},
          {UserID: uuid1, Status: "active", IPAddress: "5.6.7.8"},
        },
        wantAlerts: 1,
      },
    }
    for _, tt := range tests {
      t.Run(tt.name, func(t *testing.T) {
        // Test implementation
      })
    }
  }

  func TestSharingDetector_DetectGeoImpossible(t *testing.T) {
    // Test geo-distance sharing detection
  }
  ```
integration_tests: |
  ```go
  func TestAnalytics_EndToEnd(t *testing.T) {
    // 1. Start playback session
    // 2. Send heartbeat updates
    // 3. End session
    // 4. Verify session recorded correctly
    // 5. Verify stats updated
  }

  func TestAnalytics_Aggregation(t *testing.T) {
    // Test daily aggregation job
    // Create multiple sessions for a day
    // Run aggregation
    // Verify analytics_daily row created
  }

  func TestAnalytics_SharingDetection(t *testing.T) {
    // Create concurrent sessions from different IPs
    // Run sharing detection
    // Verify alert created
  }
  ```
