doc_title: Library Types
doc_category: feature
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: ðŸŸ¡
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Per-module library architecture and supported content types'
wiki_tagline: '> Organize content into movies, TV, music, and more'
wiki_overview: Create separate libraries for different content types. Movies, TV Shows, Music, Audiobooks, Photos, Comics,
  and Adult content each have their own library type with tailored features. Point multiple folders at one library or separate
  by quality (4K vs 1080p). Each library type has specialized metadata handling, artwork display, and playback behavior.
sources:
- name: Casbin
  url: https://pkg.go.dev/github.com/casbin/casbin/v2
  note: Auto-resolved from casbin
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: rueidis
  url: https://pkg.go.dev/github.com/redis/rueidis
  note: Auto-resolved from rueidis
- name: rueidis GitHub README
  url: https://github.com/redis/rueidis
  note: Auto-resolved from rueidis-docs
- name: sqlc
  url: https://docs.sqlc.dev/en/stable/
  note: Auto-resolved from sqlc
- name: sqlc Configuration
  url: https://docs.sqlc.dev/en/stable/reference/config.html
  note: Auto-resolved from sqlc-config
- name: StashDB GraphQL API
  url: https://stashdb.org/graphql
  note: Auto-resolved from stashdb
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
feature_name: Library Types
module_name: library_types
schema_name: public
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1["Client<br/>(Web/App)"]
      node2["API Handler<br/>(ogen)"]
      node3["Service<br/>(Logic)"]
      node4["itory<br/>Metadata<br/>Cac"]
      node5["PostgreSQL<br/>(pgx)"]
      node6["External<br/>APIs"]
      node1 --> node2
      node2 --> node3
      node5 --> node6
      node3 --> node4
      node4 --> node5
  ```
database_schema: |
  **Schema**: `public`

  ```sql
  -- Libraries (top-level organizational unit)
  CREATE TABLE libraries (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Library details
    name TEXT NOT NULL,
    type VARCHAR(50) NOT NULL,                     -- 'movie', 'tvshow', 'music', 'photo', 'book', 'audiobook', 'comic', 'podcast', 'adult'

    -- File system paths
    paths TEXT[] NOT NULL DEFAULT '{}',            -- ['/media/movies', '/media/movies-4k']

    -- Settings
    enabled BOOLEAN DEFAULT true,
    scan_on_startup BOOLEAN DEFAULT false,
    realtime_monitoring BOOLEAN DEFAULT true,      -- Watch for file changes

    -- Metadata settings
    metadata_provider VARCHAR(50),                 -- 'tmdb', 'tvdb', 'musicbrainz', 'openlib', etc.
    preferred_language VARCHAR(10) DEFAULT 'en',

    -- Scanner settings
    scanner_config JSONB,                          -- Type-specific scanner configuration

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_libraries_type ON libraries(type);
  CREATE INDEX idx_libraries_enabled ON libraries(enabled) WHERE enabled = true;

  -- Library scan jobs
  CREATE TABLE library_scans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    library_id UUID NOT NULL REFERENCES libraries(id) ON DELETE CASCADE,

    -- Scan details
    scan_type VARCHAR(20) NOT NULL,                -- 'full', 'incremental', 'metadata'
    status VARCHAR(20) DEFAULT 'running',          -- 'running', 'completed', 'failed', 'cancelled'

    -- Progress tracking
    items_scanned INTEGER DEFAULT 0,
    items_added INTEGER DEFAULT 0,
    items_updated INTEGER DEFAULT 0,
    items_removed INTEGER DEFAULT 0,
    errors_count INTEGER DEFAULT 0,

    -- Timing
    started_at TIMESTAMPTZ DEFAULT now(),
    completed_at TIMESTAMPTZ,
    duration_seconds INTEGER
  );
  CREATE INDEX idx_library_scans_library ON library_scans(library_id, started_at DESC);
  CREATE INDEX idx_library_scans_status ON library_scans(status);
  ```
module_structure: |
  ```
  internal/libraries/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ types.go                     # Domain types
  â”œâ”€â”€ repository.go                # Database operations (sqlc)
  â”œâ”€â”€ service.go                   # Library management
  â”œâ”€â”€ scanner.go                   # File system scanner
  â”œâ”€â”€ watcher.go                   # Realtime FS monitoring
  â”œâ”€â”€ handler.go                   # HTTP API handlers
  â””â”€â”€ libraries_test.go
  ```
key_interfaces: |
  ```go
  type LibraryService interface {
    CreateLibrary(ctx context.Context, req CreateLibraryRequest) (*Library, error)
    ListLibraries(ctx context.Context) ([]Library, error)
    GetLibrary(ctx context.Context, libraryID uuid.UUID) (*Library, error)
    UpdateLibrary(ctx context.Context, libraryID uuid.UUID, update LibraryUpdate) (*Library, error)
    DeleteLibrary(ctx context.Context, libraryID uuid.UUID) error
    ScanLibrary(ctx context.Context, libraryID uuid.UUID, scanType string) (*LibraryScan, error)
  }

  type Library struct {
    ID                uuid.UUID `db:"id" json:"id"`
    Name              string    `db:"name" json:"name"`
    Type              string    `db:"type" json:"type"`
    Paths             []string  `db:"paths" json:"paths"`
    Enabled           bool      `db:"enabled" json:"enabled"`
    MetadataProvider  string    `db:"metadata_provider" json:"metadata_provider"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/google/uuid`
  - `github.com/jackc/pgx/v5`
  - `github.com/fsnotify/fsnotify` - FS monitoring
  - `github.com/riverqueue/river` - Background scan jobs
  - `go.uber.org/fx`
env_vars: |
  ```bash
  LIBRARIES_AUTO_SCAN_INTERVAL=6h
  ```
config_keys: |
  ```yaml
  libraries:
    auto_scan_interval: 6h
    realtime_monitoring_enabled: true
  ```
component_interaction: |
  **Library Creation**:
  1. Admin creates library via POST /api/v1/libraries
  2. Service validates paths exist
  3. Create libraries record
  4. Trigger initial scan (background job)

  **File Scanning**:
  1. River job starts library scan
  2. Walk file system paths recursively
  3. For each media file found:
     - Extract metadata from filename/path
     - Query metadata provider (TMDb, TVDB, etc.)
     - Create content record in appropriate table
  4. Update library_scans progress
  5. Notify completion

  **Realtime Monitoring**:
  1. fsnotify watches library paths
  2. On file added/modified/deleted
  3. Queue incremental scan for changed files
  4. Update content records
api_endpoints: |
  ```
  POST   /api/v1/libraries          # Create library
  GET    /api/v1/libraries          # List libraries
  GET    /api/v1/libraries/:id      # Get library
  PUT    /api/v1/libraries/:id      # Update library
  DELETE /api/v1/libraries/:id      # Delete library
  POST   /api/v1/libraries/:id/scan # Trigger scan
  ```
unit_tests: |
  ```go
  func TestLibraryService_CreateLibrary(t *testing.T) {
    // Test library creation with valid paths
  }
  ```
integration_tests: |
  ```go
  func TestLibraries_Scanning(t *testing.T) {
    // Test full library scan workflow
  }
  ```
