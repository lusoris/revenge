doc_title: Revenge - External Scrobbling & Sync
doc_category: feature
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Sync playback data to external services like Trakt, Last.fm, ListenBrainz, etc.'
wiki_tagline: '> Track what you watch and listen to across services'
wiki_overview: Scrobble your viewing and listening history to external services. Connect Trakt to track movies and TV shows.
  Link Last.fm or ListenBrainz for music listening history. Sync watch status to Simkl, Letterboxd, or AniList. Two-way sync
  imports existing history and exports new plays automatically. Per-user configuration for each connected service.
sources:
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: Last.fm API
  url: https://www.last.fm/api/intro
  note: Auto-resolved from lastfm-api
- name: ogen OpenAPI Generator
  url: https://pkg.go.dev/github.com/ogen-go/ogen
  note: Auto-resolved from ogen
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: sqlc
  url: https://docs.sqlc.dev/en/stable/
  note: Auto-resolved from sqlc
- name: sqlc Configuration
  url: https://docs.sqlc.dev/en/stable/reference/config.html
  note: Auto-resolved from sqlc-config
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
feature_name: Revenge - External Scrobbling & Sync
module_name: revenge___external_scrobbling_&_sync
schema_name: public
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1([Client<br/>[Web/App]])
      node2[[API Handler<br/>[ogen]]]
      node3[[Service<br/>[Logic]]]
      node4["Repository<br/>[sqlc]"]
      node5[[Metadata<br/>Service]]
      node6[(Cache<br/>[otter])]
      node7[(PostgreSQL<br/>[pgx])]
      node8([External<br/>APIs])
      node1 --> node2
      node2 --> node3
      node4 --> node5
      node5 --> node6
      node7 --> node8
      node3 --> node4
      node6 --> node7
  ```
database_schema: |
  **Schema**: `public`

  ```sql
  -- User connections to external scrobbling services
  CREATE TABLE scrobble_connections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Service details
    service VARCHAR(50) NOT NULL,                 -- 'trakt', 'lastfm', 'listenbrainz', 'simkl', 'letterboxd', 'anilist'
    enabled BOOLEAN DEFAULT true,

    -- OAuth credentials (encrypted)
    access_token TEXT,
    refresh_token TEXT,
    token_expires_at TIMESTAMPTZ,

    -- Service-specific settings
    scrobble_threshold_percent INTEGER DEFAULT 80,  -- Scrobble after X% watched
    sync_watch_status BOOLEAN DEFAULT true,         -- Two-way sync of watch status
    sync_ratings BOOLEAN DEFAULT true,              -- Two-way sync of ratings

    -- Sync state
    last_sync_at TIMESTAMPTZ,
    last_sync_status VARCHAR(20),                   -- 'success', 'failed', 'partial'
    last_sync_error TEXT,

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_scrobble_connections_user ON scrobble_connections(user_id);
  CREATE INDEX idx_scrobble_connections_service ON scrobble_connections(service);
  CREATE UNIQUE INDEX idx_scrobble_connections_unique ON scrobble_connections(user_id, service);

  -- Scrobble queue (items pending submission to external services)
  CREATE TABLE scrobble_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    connection_id UUID NOT NULL REFERENCES scrobble_connections(id) ON DELETE CASCADE,

    -- Content reference
    content_type VARCHAR(50) NOT NULL,              -- 'movie', 'episode', 'track'
    content_id UUID NOT NULL,

    -- Scrobble metadata
    action VARCHAR(20) NOT NULL,                    -- 'scrobble', 'watching', 'rating', 'collection'
    watched_at TIMESTAMPTZ,
    progress_percent INTEGER,
    rating DECIMAL(3,1),

    -- External IDs (for mapping to service)
    external_ids JSONB,                             -- {\"trakt_id\": 123, \"imdb_id\": \"tt123\"}

    -- Status
    status VARCHAR(20) DEFAULT 'pending',           -- 'pending', 'submitted', 'failed'
    attempts INTEGER DEFAULT 0,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,

    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_scrobble_queue_connection ON scrobble_queue(connection_id, status);
  CREATE INDEX idx_scrobble_queue_status ON scrobble_queue(status) WHERE status = 'pending';
  CREATE INDEX idx_scrobble_queue_content ON scrobble_queue(content_type, content_id);

  -- Scrobble history (successful submissions)
  CREATE TABLE scrobble_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    connection_id UUID NOT NULL REFERENCES scrobble_connections(id) ON DELETE CASCADE,

    -- Content reference
    content_type VARCHAR(50) NOT NULL,
    content_id UUID NOT NULL,

    -- Scrobble details
    action VARCHAR(20) NOT NULL,
    watched_at TIMESTAMPTZ,
    rating DECIMAL(3,1),

    -- External response
    external_id VARCHAR(255),                       -- ID returned by service
    submitted_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_scrobble_history_connection ON scrobble_history(connection_id, submitted_at DESC);
  CREATE INDEX idx_scrobble_history_content ON scrobble_history(content_type, content_id);

  -- Imported watch history (from external services)
  CREATE TABLE imported_watch_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    connection_id UUID NOT NULL REFERENCES scrobble_connections(id) ON DELETE CASCADE,

    -- External item details
    external_type VARCHAR(50) NOT NULL,             -- 'movie', 'show', 'episode', 'track'
    external_id VARCHAR(255) NOT NULL,
    external_title TEXT,

    -- Watch details
    watched_at TIMESTAMPTZ NOT NULL,
    rating DECIMAL(3,1),

    -- Mapping status
    matched BOOLEAN DEFAULT false,
    matched_content_type VARCHAR(50),
    matched_content_id UUID,

    imported_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_imported_watch_history_connection ON imported_watch_history(connection_id);
  CREATE INDEX idx_imported_watch_history_matched ON imported_watch_history(matched) WHERE matched = false;
  ```
module_structure: |
  ```
  internal/scrobble/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ types.go                     # Domain types
  â”œâ”€â”€ repository.go                # Database operations (sqlc)
  â”œâ”€â”€ service.go                   # Scrobbling logic
  â”œâ”€â”€ worker.go                    # Background worker for queue processing
  â”œâ”€â”€ clients/
  â”‚   â”œâ”€â”€ trakt.go                 # Trakt.tv API client
  â”‚   â”œâ”€â”€ lastfm.go                # Last.fm API client
  â”‚   â”œâ”€â”€ listenbrainz.go          # ListenBrainz API client
  â”‚   â”œâ”€â”€ simkl.go                 # Simkl API client
  â”‚   â”œâ”€â”€ letterboxd.go            # Letterboxd API client (if available)
  â”‚   â””â”€â”€ anilist.go               # AniList API client
  â”œâ”€â”€ mapper.go                    # Map internal IDs to external IDs
  â”œâ”€â”€ handler.go                   # HTTP API handlers
  â””â”€â”€ scrobble_test.go

  web/src/routes/(app)/settings/scrobbling/
  â”œâ”€â”€ +page.svelte                 # Scrobbling settings
  â”œâ”€â”€ +page.ts                     # Data loading
  â””â”€â”€ components/
      â”œâ”€â”€ ServiceCard.svelte       # Service connection card
      â”œâ”€â”€ ConnectButton.svelte     # OAuth connect button
      â”œâ”€â”€ SyncHistory.svelte       # Sync history display
      â””â”€â”€ ImportHistory.svelte     # Import external history
  ```
key_interfaces: |
  ```go
  type ScrobbleService interface {
    ConnectService(ctx context.Context, userID uuid.UUID, service string, oauthCode string) (*ScrobbleConnection, error)
    DisconnectService(ctx context.Context, connectionID uuid.UUID) error
    ListConnections(ctx context.Context, userID uuid.UUID) ([]ScrobbleConnection, error)
    UpdateConnection(ctx context.Context, connectionID uuid.UUID, settings ConnectionSettings) error

    QueueScrobble(ctx context.Context, connectionID uuid.UUID, scrobble ScrobbleRequest) error
    ProcessQueue(ctx context.Context) (int, error)

    ImportHistory(ctx context.Context, connectionID uuid.UUID) (int, error)
    GetHistory(ctx context.Context, connectionID uuid.UUID, limit int) ([]ScrobbleHistoryItem, error)
  }

  type ScrobbleConnection struct {
    ID                      uuid.UUID  `db:"id" json:"id"`
    UserID                  uuid.UUID  `db:"user_id" json:"user_id"`
    Service                 string     `db:"service" json:"service"`
    Enabled                 bool       `db:"enabled" json:"enabled"`
    ScrobbleThresholdPercent int       `db:"scrobble_threshold_percent" json:"scrobble_threshold_percent"`
    SyncWatchStatus         bool       `db:"sync_watch_status" json:"sync_watch_status"`
    SyncRatings             bool       `db:"sync_ratings" json:"sync_ratings"`
    LastSyncAt              *time.Time `db:"last_sync_at" json:"last_sync_at,omitempty"`
    LastSyncStatus          string     `db:"last_sync_status" json:"last_sync_status"`
  }

  type ScrobbleRequest struct {
    ContentType    string                 `json:"content_type"`
    ContentID      uuid.UUID              `json:"content_id"`
    Action         string                 `json:"action"`
    WatchedAt      time.Time              `json:"watched_at"`
    ProgressPercent int                   `json:"progress_percent,omitempty"`
    Rating         *float64               `json:"rating,omitempty"`
    ExternalIDs    map[string]interface{} `json:"external_ids"`
  }

  type ScrobbleClient interface {
    Scrobble(ctx context.Context, req ScrobbleRequest) error
    ImportHistory(ctx context.Context, since time.Time) ([]ExternalHistoryItem, error)
    GetExternalIDs(ctx context.Context, contentType string, contentID uuid.UUID) (map[string]string, error)
  }

  type TraktClient interface {
    ScrobbleClient
    OAuth(code string) (*OAuthTokens, error)
    RefreshToken(refreshToken string) (*OAuthTokens, error)
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/google/uuid`
  - `github.com/jackc/pgx/v5`
  - `github.com/riverqueue/river` - Background job queue for scrobble processing
  - `golang.org/x/oauth2` - OAuth2 client
  - `go.uber.org/fx`

  **External APIs**:
  - Trakt.tv API v2
  - Last.fm API
  - ListenBrainz API
  - Simkl API
  - AniList GraphQL API
env_vars: |
  ```bash
  TRAKT_CLIENT_ID=your_client_id
  TRAKT_CLIENT_SECRET=your_client_secret
  TRAKT_REDIRECT_URI=http://localhost:8080/api/v1/scrobble/trakt/callback

  LASTFM_API_KEY=your_api_key
  LASTFM_API_SECRET=your_secret

  LISTENBRAINZ_TOKEN=your_token

  SIMKL_CLIENT_ID=your_client_id
  SIMKL_CLIENT_SECRET=your_client_secret

  ANILIST_CLIENT_ID=your_client_id
  ANILIST_CLIENT_SECRET=your_client_secret
  ```
config_keys: |
  ```yaml
  scrobble:
    enabled: true
    queue_process_interval: 5m
    max_retries: 3
    retry_backoff: 5m

    services:
      trakt:
        enabled: true
        client_id: ${TRAKT_CLIENT_ID}
        client_secret: ${TRAKT_CLIENT_SECRET}
      lastfm:
        enabled: true
        api_key: ${LASTFM_API_KEY}
        api_secret: ${LASTFM_API_SECRET}
      listenbrainz:
        enabled: true
      simkl:
        enabled: true
        client_id: ${SIMKL_CLIENT_ID}
      anilist:
        enabled: true
        client_id: ${ANILIST_CLIENT_ID}
  ```
component_interaction: |
  **OAuth Connection Flow**:
  1. User clicks "Connect Trakt" button
  2. Frontend redirects to Trakt OAuth authorize URL
  3. User authorizes, Trakt redirects back with code
  4. Backend exchanges code for access/refresh tokens
  5. Tokens stored encrypted in scrobble_connections

  **Scrobble Flow**:
  1. User watches content, playback session tracked
  2. When progress >= threshold (default 80%), scrobble triggered
  3. Service queues scrobble in scrobble_queue
  4. Background worker (River job) processes queue every 5 minutes
  5. Worker fetches external IDs (Trakt ID, IMDb ID, etc.)
  6. Worker calls external API to submit scrobble
  7. On success, move to scrobble_history; on failure, increment attempts

  **Import History Flow**:
  1. User requests import from connected service
  2. Service calls external API to fetch watch history
  3. For each external item, attempt to match to local content
  4. Store in imported_watch_history with matched flag
  5. If matched, create/update local watch history
  6. If unmatched, display to user for manual matching

  **Two-Way Sync**:
  1. Periodic job fetches updates from external service
  2. Compare external watch status with local
  3. Sync changes in both directions (configurable)
  4. Handle conflicts (local vs external)
api_endpoints: |
  ```
  GET  /api/v1/scrobble/connections              # List user's connections
  POST /api/v1/scrobble/connect/{service}        # Initiate OAuth flow
  GET  /api/v1/scrobble/{service}/callback       # OAuth callback
  DELETE /api/v1/scrobble/connections/{id}       # Disconnect service
  PUT  /api/v1/scrobble/connections/{id}         # Update connection settings

  POST /api/v1/scrobble/queue                    # Manually queue scrobble
  GET  /api/v1/scrobble/history                  # Get scrobble history

  POST /api/v1/scrobble/import/{service}         # Import history from service
  GET  /api/v1/scrobble/imported                 # List imported items
  ```
unit_tests: |
  ```go
  func TestScrobbleService_QueueScrobble(t *testing.T) {
    // Test queueing scrobbles
    // Test threshold logic
  }

  func TestScrobbleWorker_ProcessQueue(t *testing.T) {
    tests := []struct {
      name       string
      queueItems []ScrobbleQueueItem
      wantErr    bool
    }{
      {
        name: "successful scrobble",
        queueItems: []ScrobbleQueueItem{
          {ContentType: "movie", Action: "scrobble"},
        },
        wantErr: false,
      },
      {
        name: "retry on failure",
        queueItems: []ScrobbleQueueItem{
          {ContentType: "movie", Attempts: 2},
        },
        wantErr: false,
      },
    }
    for _, tt := range tests {
      t.Run(tt.name, func(t *testing.T) {
        // Test implementation
      })
    }
  }

  func TestTraktClient_Scrobble(t *testing.T) {
    // Test Trakt API scrobble
    // Mock HTTP responses
  }

  func TestScrobbleMapper_GetExternalIDs(t *testing.T) {
    // Test mapping internal IDs to Trakt/IMDb/etc.
  }
  ```
integration_tests: |
  ```go
  func TestScrobble_EndToEnd(t *testing.T) {
    // 1. Connect to Trakt (mock OAuth)
    // 2. Queue a scrobble
    // 3. Process queue
    // 4. Verify scrobble submitted to Trakt
    // 5. Verify moved to history
  }

  func TestScrobble_Import(t *testing.T) {
    // 1. Mock Trakt history API
    // 2. Import history
    // 3. Verify items stored in imported_watch_history
    // 4. Verify matched items create local watch history
  }

  func TestScrobble_TwoWaySync(t *testing.T) {
    // Test syncing watch status and ratings bidirectionally
  }
  ```
