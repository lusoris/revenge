doc_title: Content Rating System
doc_category: feature
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: ðŸŸ¡
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Universal age restriction and content rating system for revenge.'
wiki_tagline: '> Age ratings and content restrictions across all media'
wiki_overview: Unified content rating system covering movies, TV shows, music, and games. Supports multiple rating systems
  (MPAA, PEGI, TV Parental Guidelines, ESRB). Set maximum allowed ratings per user profile - perfect for kid accounts. Content
  warnings for mature themes are displayed before playback. Ratings are pulled automatically from metadata providers.
sources:
- name: Casbin
  url: https://pkg.go.dev/github.com/casbin/casbin/v2
  note: Auto-resolved from casbin
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: rueidis
  url: https://pkg.go.dev/github.com/redis/rueidis
  note: Auto-resolved from rueidis
- name: rueidis GitHub README
  url: https://github.com/redis/rueidis
  note: Auto-resolved from rueidis-docs
- name: sqlc
  url: https://docs.sqlc.dev/en/stable/
  note: Auto-resolved from sqlc
- name: sqlc Configuration
  url: https://docs.sqlc.dev/en/stable/reference/config.html
  note: Auto-resolved from sqlc-config
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
feature_name: Content Rating System
module_name: content_rating_system
schema_name: public
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1["Client<br/>(Web/App)"]
      node2["API Handler<br/>(ogen)"]
      node3["Service<br/>(Logic)"]
      node4["itory<br/>Metadata<br/>Cac"]
      node5["PostgreSQL<br/>(pgx)"]
      node6["External<br/>APIs"]
      node1 --> node2
      node2 --> node3
      node5 --> node6
      node3 --> node4
      node4 --> node5
  ```
database_schema: |
  **Schema**: `public`

  ```sql
  -- Content ratings (from metadata providers)
  CREATE TABLE content_ratings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Content reference
    content_type VARCHAR(50) NOT NULL,             -- 'movie', 'tvshow', 'episode', 'album'
    content_id UUID NOT NULL,

    -- Rating details
    rating_system VARCHAR(50) NOT NULL,            -- 'MPAA', 'TV', 'PEGI', 'ESRB', 'BBFC', etc.
    rating_value VARCHAR(20) NOT NULL,             -- 'PG-13', 'TV-MA', 'PEGI-16', 'M', etc.
    country VARCHAR(2),                            -- ISO 3166-1 alpha-2 for regional ratings

    -- Content descriptors/warnings
    descriptors TEXT[] DEFAULT '{}',               -- ['Violence', 'Strong Language', 'Sexual Content']

    -- Source
    source VARCHAR(50),                            -- 'tmdb', 'tvdb', 'manual'

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE UNIQUE INDEX idx_content_ratings_unique ON content_ratings(content_type, content_id, rating_system, country);
  CREATE INDEX idx_content_ratings_content ON content_ratings(content_type, content_id);
  CREATE INDEX idx_content_ratings_system ON content_ratings(rating_system);

  -- User rating restrictions
  CREATE TABLE user_rating_restrictions (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

    -- Maximum allowed ratings per system
    mpaa_max VARCHAR(20),                          -- 'G', 'PG', 'PG-13', 'R', 'NC-17'
    tv_max VARCHAR(20),                            -- 'TV-Y', 'TV-Y7', 'TV-G', 'TV-PG', 'TV-14', 'TV-MA'
    pegi_max VARCHAR(20),                          -- 'PEGI-3', 'PEGI-7', 'PEGI-12', 'PEGI-16', 'PEGI-18'
    esrb_max VARCHAR(20),                          -- 'E', 'E10+', 'T', 'M', 'AO'

    -- Block unrated content
    block_unrated BOOLEAN DEFAULT false,

    -- Allowed descriptors (if empty, all allowed)
    blocked_descriptors TEXT[] DEFAULT '{}',       -- ['Violence', 'Nudity']

    updated_at TIMESTAMPTZ DEFAULT now()
  );

  -- Rating system definitions
  CREATE TABLE rating_systems (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) NOT NULL UNIQUE,              -- 'MPAA', 'TV', 'PEGI', etc.
    display_name TEXT NOT NULL,
    description TEXT,
    country VARCHAR(2),                            -- Primary country

    -- Ordered rating values (lowest to highest maturity)
    rating_values JSONB NOT NULL,                  -- [{"value": "G", "age": 0}, {"value": "PG", "age": 0}, ...]

    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_rating_systems_name ON rating_systems(name);

  -- Rating value mappings (for cross-system comparisons)
  CREATE TABLE rating_value_mappings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    from_system VARCHAR(50) NOT NULL,
    from_value VARCHAR(20) NOT NULL,
    to_system VARCHAR(50) NOT NULL,
    to_value VARCHAR(20) NOT NULL,

    -- Approximate age equivalence
    min_age INTEGER,

    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_rating_mappings_from ON rating_value_mappings(from_system, from_value);
  CREATE INDEX idx_rating_mappings_to ON rating_value_mappings(to_system, to_value);
  ```
module_structure: |
  ```
  internal/ratings/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ types.go                     # Domain types
  â”œâ”€â”€ repository.go                # Database operations (sqlc)
  â”œâ”€â”€ service.go                   # Rating logic
  â”œâ”€â”€ enforcer.go                  # Rating restriction enforcement
  â”œâ”€â”€ mapper.go                    # Cross-system rating mappings
  â”œâ”€â”€ handler.go                   # HTTP API handlers
  â””â”€â”€ ratings_test.go

  config/ratings/
  â””â”€â”€ systems.json                 # Rating system definitions

  web/src/routes/(app)/settings/ratings/
  â”œâ”€â”€ +page.svelte                 # Rating restrictions settings
  â”œâ”€â”€ +page.ts                     # Data loading
  â””â”€â”€ components/
      â”œâ”€â”€ RatingSelector.svelte    # Select max allowed rating
      â””â”€â”€ DescriptorFilter.svelte  # Block specific content descriptors
  ```
key_interfaces: |
  ```go
  type RatingService interface {
    GetContentRating(ctx context.Context, contentType string, contentID uuid.UUID) ([]ContentRating, error)
    AddContentRating(ctx context.Context, rating ContentRating) error

    GetUserRestrictions(ctx context.Context, userID uuid.UUID) (*UserRatingRestriction, error)
    UpdateUserRestrictions(ctx context.Context, userID uuid.UUID, restrictions UserRatingRestriction) error

    CheckRatingAllowed(ctx context.Context, userID uuid.UUID, rating ContentRating) (bool, string, error)
    GetRatingSystems(ctx context.Context) ([]RatingSystem, error)
    MapRating(ctx context.Context, fromSystem, fromValue, toSystem string) (string, error)
  }

  type ContentRating struct {
    ID            uuid.UUID `db:"id" json:"id"`
    ContentType   string    `db:"content_type" json:"content_type"`
    ContentID     uuid.UUID `db:"content_id" json:"content_id"`
    RatingSystem  string    `db:"rating_system" json:"rating_system"`
    RatingValue   string    `db:"rating_value" json:"rating_value"`
    Country       *string   `db:"country" json:"country,omitempty"`
    Descriptors   []string  `db:"descriptors" json:"descriptors"`
    Source        string    `db:"source" json:"source"`
  }

  type UserRatingRestriction struct {
    UserID             uuid.UUID `db:"user_id" json:"user_id"`
    MPAAMax            *string   `db:"mpaa_max" json:"mpaa_max,omitempty"`
    TVMax              *string   `db:"tv_max" json:"tv_max,omitempty"`
    PEGIMax            *string   `db:"pegi_max" json:"pegi_max,omitempty"`
    ESRBMax            *string   `db:"esrb_max" json:"esrb_max,omitempty"`
    BlockUnrated       bool      `db:"block_unrated" json:"block_unrated"`
    BlockedDescriptors []string  `db:"blocked_descriptors" json:"blocked_descriptors"`
  }

  type RatingSystem struct {
    ID           uuid.UUID              `db:"id" json:"id"`
    Name         string                 `db:"name" json:"name"`
    DisplayName  string                 `db:"display_name" json:"display_name"`
    Description  string                 `db:"description" json:"description"`
    Country      *string                `db:"country" json:"country,omitempty"`
    RatingValues []map[string]interface{} `db:"rating_values" json:"rating_values"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/google/uuid`
  - `github.com/jackc/pgx/v5`
  - `github.com/jackc/pgx/v5/pgtype` - JSONB handling
  - `go.uber.org/fx`
env_vars: |
  ```bash
  RATINGS_ENFORCE=true
  ```
config_keys: |
  ```yaml
  ratings:
    enforce_restrictions: true
    default_block_unrated: false
    systems:
      - MPAA
      - TV
      - PEGI
      - ESRB
      - BBFC
  ```
component_interaction: |
  **Rating Retrieval Flow**:
  1. User requests content (movie, TV show, etc.)
  2. Service fetches content_ratings for that content
  3. If user has restrictions, filter by user_rating_restrictions
  4. Return allowed ratings or block content

  **Restriction Enforcement Flow**:
  1. User attempts to play content
  2. Middleware calls RatingService.CheckRatingAllowed()
  3. Service compares content rating vs user's max allowed
  4. Map between rating systems if needed (MPAA â†” PEGI)
  5. Check for blocked descriptors
  6. Return allow/deny with reason

  **Rating Mapping Flow**:
  1. Content has MPAA rating but user has PEGI restriction
  2. Service queries rating_value_mappings for conversion
  3. Compare mapped values
  4. Use approximate age equivalence if direct mapping unavailable
api_endpoints: |
  ```
  GET  /api/v1/ratings/content/:type/:id       # Get content ratings
  GET  /api/v1/ratings/systems                 # List rating systems

  GET  /api/v1/users/:id/ratings/restrictions  # Get user restrictions
  PUT  /api/v1/users/:id/ratings/restrictions  # Update restrictions

  GET  /api/v1/ratings/check?content=:id       # Check if content allowed for user
  ```
unit_tests: |
  ```go
  func TestRatingService_CheckRatingAllowed(t *testing.T) {
    tests := []struct {
      name         string
      userMax      string
      contentRating string
      wantAllowed  bool
    }{
      {
        name:         "PG content allowed for PG-13 user",
        userMax:      "PG-13",
        contentRating: "PG",
        wantAllowed:  true,
      },
      {
        name:         "R content blocked for PG-13 user",
        userMax:      "PG-13",
        contentRating: "R",
        wantAllowed:  false,
      },
    }
    for _, tt := range tests {
      t.Run(tt.name, func(t *testing.T) {
        // Test implementation
      })
    }
  }

  func TestRatingService_MapRating(t *testing.T) {
    // Test cross-system rating mappings
    // MPAA PG-13 â†’ PEGI 12
  }
  ```
integration_tests: |
  ```go
  func TestRatings_EndToEnd(t *testing.T) {
    // 1. Set user rating restriction to PG-13
    // 2. Attempt to access R-rated movie
    // 3. Verify access denied
    // 4. Attempt to access PG movie
    // 5. Verify access allowed
  }

  func TestRatings_CrossSystem(t *testing.T) {
    // Test MPAA â†” PEGI â†” BBFC mappings
  }
  ```
