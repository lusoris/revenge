doc_title: Collections & Playlists
doc_category: feature
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: Generated from design
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: |
  > User-created collections and playlists for organizing media across content types

  Collections allow users to group media items together:
  - **Manual Collections**: User-curated lists (e.g., "Best Sci-Fi Movies")
  - **Smart Collections**: Filter-based dynamic lists (e.g., "All 4K Movies")
  - **Cross-Type Collections**: Mix movies, TV shows, music in one collection
  - **User-Specific**: Each user can create their own collections
  - **Shared Collections**: Optional sharing between users
wiki_tagline: |
  > Organize your media with custom collections and playlists
wiki_overview: |
  The Collections system lets you group any media into custom collections. Create manual collections by hand-picking items, or smart collections that automatically update based on filters. Mix and match movies, TV shows, albums, and more in a single collection. Share collections publicly or collaborate with other users. Perfect for creating themed collections like "Best of 2023", "Oscar Winners", or "Workout Music".
sources:
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: ogen OpenAPI Generator
  url: https://pkg.go.dev/github.com/ogen-go/ogen
  note: Auto-resolved from ogen
design_refs:
- title: features/shared
  path: INDEX.md
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: LIBRARY_TYPES
  path: ../../features/shared/LIBRARY_TYPES.md
feature_name: Collections & Playlists
module_name: collections
schema_name: public
content_types:
- Movies
- TV Shows
- Music
- All media types
collection_types:
  manual:
    name: Manual Collections
    description: User-curated lists of specific items
    use_cases:
    - Best Sci-Fi Movies
    - Family Movie Night Picks
    - Workout Music
  smart:
    name: Smart Collections
    description: Dynamic collections based on filters
    use_cases:
    - All 4K Movies
    - Recently Added (Last 30 Days)
    - Unwatched TV Shows
    - 5-Star Rated Content
    filters:
    - Resolution (4K, 1080p, 720p)
    - Rating (user rating, content rating)
    - Genre
    - Release year
    - Date added
    - Watch status
database_schema: |
  **Schema**: `public`

  ```sql
  -- Collections (manual or smart)
  CREATE TABLE collections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    type VARCHAR(20) NOT NULL DEFAULT 'manual',  -- 'manual', 'smart'
    is_public BOOLEAN DEFAULT false,

    -- Smart collection filters (JSONB for flexibility)
    filters JSONB,                                -- Smart collection filter rules

    -- Metadata
    poster_url TEXT,
    backdrop_url TEXT,
    sort_order INTEGER DEFAULT 0,                 -- User-defined sort order

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_collections_user ON collections(user_id, created_at DESC);
  CREATE INDEX idx_collections_public ON collections(is_public) WHERE is_public = true;
  CREATE INDEX idx_collections_type ON collections(type);
  CREATE INDEX idx_collections_filters ON collections USING gin(filters) WHERE type = 'smart';

  -- Collection items (polymorphic references)
  CREATE TABLE collection_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    collection_id UUID NOT NULL REFERENCES collections(id) ON DELETE CASCADE,

    -- Polymorphic reference to any content type
    item_type VARCHAR(50) NOT NULL,              -- 'movie', 'tvshow', 'episode', 'album', 'track', 'scene', 'gallery'
    item_id UUID NOT NULL,                       -- References movies.id, tvshows.id, etc.

    -- Ordering within collection
    position INTEGER NOT NULL DEFAULT 0,

    added_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_collection_items_collection ON collection_items(collection_id, position);
  CREATE INDEX idx_collection_items_item ON collection_items(item_type, item_id);
  CREATE UNIQUE INDEX idx_collection_items_unique ON collection_items(collection_id, item_type, item_id);

  -- Collection sharing (collaborate with other users)
  CREATE TABLE collection_shares (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    collection_id UUID NOT NULL REFERENCES collections(id) ON DELETE CASCADE,
    shared_with_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(20) DEFAULT 'read',       -- 'read', 'write', 'admin'

    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_collection_shares_collection ON collection_shares(collection_id);
  CREATE INDEX idx_collection_shares_user ON collection_shares(shared_with_user_id);
  CREATE UNIQUE INDEX idx_collection_shares_unique ON collection_shares(collection_id, shared_with_user_id);
  ```
api_endpoints:
- method: POST
  path: /api/v1/collections
  description: Create a new collection
  auth_required: true
  request_example: |
    {
      "name": "Best Sci-Fi",
      "description": "My favorite science fiction movies",
      "type": "manual",
      "is_public": false
    }
  response_example: |
    {
      "id": "uuid-123",
      "name": "Best Sci-Fi",
      "type": "manual",
      "is_public": false,
      "created_at": "2026-01-31T12:00:00Z"
    }
- method: GET
  path: /api/v1/collections
  description: List user's collections
  auth_required: true
  query_params:
  - type (optional): Filter by manual/smart
  - public (optional): Show only public collections
  request_example: '{}'
  response_example: |
    {
      "collections": [
        {"id": "uuid-123", "name": "Best Sci-Fi", "type": "manual", "item_count": 12}
      ]
    }
- method: GET
  path: /api/v1/collections/{id}
  description: Get collection details with items
  auth_required: true
  request_example: '{}'
  response_example: |
    {
      "id": "uuid-123",
      "name": "Best Sci-Fi",
      "items": [
        {"type": "movie", "id": "uuid-456", "title": "Inception"}
      ]
    }
- method: PUT
  path: /api/v1/collections/{id}
  description: Update collection metadata
  auth_required: true
  request_example: |
    {
      "name": "Updated Name",
      "description": "New description"
    }
  response_example: |
    {
      "id": "uuid-123",
      "name": "Updated Name",
      "updated_at": "2026-01-31T13:00:00Z"
    }
- method: DELETE
  path: /api/v1/collections/{id}
  description: Delete collection
  auth_required: true
  request_example: '{}'
  response_example: 204 No Content
- method: POST
  path: /api/v1/collections/{id}/items
  description: Add items to collection
  auth_required: true
  request_example: |
    {
      "items": [
        {"type": "movie", "id": "uuid-123"},
        {"type": "tvshow", "id": "uuid-456"}
      ]
    }
  response_example: |
    {
      "added": 2,
      "item_count": 14
    }
- method: DELETE
  path: /api/v1/collections/{id}/items/{item_id}
  description: Remove item from collection
  auth_required: true
  request_example: '{}'
  response_example: 204 No Content
implementation_notes: |
  **Service Layer** (`internal/service/collections`):
  - `CreateCollection(ctx, userID, name, type, filters)`
  - `ListCollections(ctx, userID, filters)`
  - `GetCollection(ctx, collectionID)`
  - `AddItems(ctx, collectionID, items)`
  - `RemoveItem(ctx, collectionID, itemID)`
  - `GetCollectionItems(ctx, collectionID)` - resolve polymorphic refs

  **Smart Collection Evaluation**:
  - Filters stored as JSONB
  - Evaluated at query time (no pre-materialization)
  - Cache results for 5 minutes (otter L1)

  **Permissions**:
  - Users can only CRUD their own collections
  - Public collections readable by all authenticated users
  - Admin can view/delete any collection
smart_collection_filter_examples: |
  ```json
  // All 4K movies
  {
    "item_type": "movie",
    "filters": {
      "resolution": "4K",
      "video_codec": "HEVC"
    }
  }

  // Recently added (last 30 days)
  {
    "filters": {
      "added_after": "2026-01-01T00:00:00Z"
    }
  }

  // Unwatched high-rated movies
  {
    "item_type": "movie",
    "filters": {
      "watched": false,
      "user_rating_min": 4.0
    }
  }
  ```
frontend_integration: |
  - Collections page: `/collections`
  - Create collection modal
  - Drag-and-drop to reorder items
  - Filter builder UI for smart collections
  - Share collection URL: `/collections/{id}/share`
architecture_diagram: |-
  ```mermaid
  flowchart TD
      subgraph row1[ ]
          direction LR
          node1(["Client<br/>(Web/App)"])
          node2[["API Handler<br/>(ogen)"]]
          node3[["Service<br/>(Logic)"]]
      end
      subgraph row2[ ]
          direction LR
          node4["Repository<br/>(sqlc)"]
          node5[["Metadata<br/>Service"]]
          node6[("Cache<br/>(otter)")]
      end
      subgraph row3[ ]
          direction LR
          node7[("PostgreSQL<br/>(pgx)")]
          node8(["External<br/>APIs"])
      end
      node1 --> node2
      node2 --> node3
      node4 --> node5
      node5 --> node6
      node7 --> node8
      node3 --> node4
      node6 --> node7

      %% Hide row subgraph borders
      style row1 fill:transparent,stroke:transparent
      style row2 fill:transparent,stroke:transparent
      style row3 fill:transparent,stroke:transparent
  ```
module_structure: |
  ```
  internal/collections/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ types.go                     # Domain types
  â”œâ”€â”€ repository.go                # Database operations (sqlc)
  â”œâ”€â”€ service.go                   # Collection logic
  â”œâ”€â”€ evaluator.go                 # Smart collection filter evaluator
  â”œâ”€â”€ handler.go                   # HTTP API handlers
  â””â”€â”€ collections_test.go

  web/src/routes/(app)/collections/
  â”œâ”€â”€ +page.svelte                 # Collections list
  â”œâ”€â”€ +page.ts                     # Data loading
  â”œâ”€â”€ [id]/
  â”‚   â”œâ”€â”€ +page.svelte             # Collection detail
  â”‚   â”œâ”€â”€ +page.ts                 # Data loading
  â”‚   â””â”€â”€ edit/
  â”‚       â””â”€â”€ +page.svelte         # Edit collection
  â””â”€â”€ components/
      â”œâ”€â”€ CollectionCard.svelte    # Collection card
      â”œâ”€â”€ CollectionGrid.svelte    # Grid of collections
      â”œâ”€â”€ FilterBuilder.svelte     # Smart collection filter builder
      â””â”€â”€ ItemPicker.svelte        # Add items to collection
  ```
key_interfaces: |
  ```go
  type CollectionService interface {
    CreateCollection(ctx context.Context, userID uuid.UUID, req CreateCollectionRequest) (*Collection, error)
    ListCollections(ctx context.Context, userID uuid.UUID, filters CollectionFilters) ([]Collection, error)
    GetCollection(ctx context.Context, collectionID uuid.UUID) (*CollectionDetail, error)
    UpdateCollection(ctx context.Context, collectionID uuid.UUID, req UpdateCollectionRequest) (*Collection, error)
    DeleteCollection(ctx context.Context, collectionID uuid.UUID) error

    AddItems(ctx context.Context, collectionID uuid.UUID, items []CollectionItemRef) (int, error)
    RemoveItem(ctx context.Context, collectionID uuid.UUID, itemID uuid.UUID) error
    ReorderItems(ctx context.Context, collectionID uuid.UUID, itemPositions map[uuid.UUID]int) error

    GetCollectionItems(ctx context.Context, collectionID uuid.UUID) ([]CollectionItem, error)
    EvaluateSmartCollection(ctx context.Context, collectionID uuid.UUID) ([]CollectionItem, error)

    ShareCollection(ctx context.Context, collectionID uuid.UUID, shareWith uuid.UUID, permission string) error
  }

  type Collection struct {
    ID          uuid.UUID              `db:"id" json:"id"`
    UserID      uuid.UUID              `db:"user_id" json:"user_id"`
    Name        string                 `db:"name" json:"name"`
    Description string                 `db:"description" json:"description"`
    Type        string                 `db:"type" json:"type"`
    IsPublic    bool                   `db:"is_public" json:"is_public"`
    Filters     map[string]interface{} `db:"filters" json:"filters,omitempty"`
    ItemCount   int                    `json:"item_count"`
    CreatedAt   time.Time              `db:"created_at" json:"created_at"`
    UpdatedAt   time.Time              `db:"updated_at" json:"updated_at"`
  }

  type CollectionItem struct {
    ID         uuid.UUID `db:"id" json:"id"`
    ItemType   string    `db:"item_type" json:"item_type"`
    ItemID     uuid.UUID `db:"item_id" json:"item_id"`
    Position   int       `db:"position" json:"position"`

    // Polymorphic data (joined from item tables)
    Title      string    `json:"title"`
    PosterURL  string    `json:"poster_url,omitempty"`
  }

  type SmartCollectionEvaluator interface {
    Evaluate(ctx context.Context, filters map[string]interface{}) ([]uuid.UUID, error)
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/google/uuid`
  - `github.com/jackc/pgx/v5`
  - `github.com/jackc/pgx/v5/pgtype` - JSONB handling
  - `go.uber.org/fx`
env_vars: |
  ```bash
  # No specific env vars required
  ```
config_keys: |
  ```yaml
  collections:
    max_items_per_collection: 5000
    smart_collection_cache_ttl: 5m
  ```
component_interaction: |
  **Manual Collection Flow**:
  1. User creates collection via POST /api/v1/collections
  2. Service validates and creates collection record
  3. User adds items via POST /api/v1/collections/{id}/items
  4. Service validates item references and inserts into collection_items
  5. Items cached in otter for 5 minutes

  **Smart Collection Flow**:
  1. User creates smart collection with filters (JSONB)
  2. On GET /api/v1/collections/{id}, service evaluates filters
  3. Evaluator builds SQL query from filter JSONB
  4. Results cached for configured TTL
  5. Background job re-evaluates periodically

  **Sharing Flow**:
  1. Owner shares collection with user
  2. Recipient sees collection in shared collections list
  3. Permission enforced at service layer (read/write/admin)
unit_tests: |
  ```go
  func TestCollectionService_CreateCollection(t *testing.T) {
    tests := []struct {
      name    string
      req     CreateCollectionRequest
      wantErr bool
    }{
      {
        name: "create manual collection",
        req: CreateCollectionRequest{
          Name: "Best Sci-Fi",
          Type: "manual",
        },
        wantErr: false,
      },
      {
        name: "create smart collection",
        req: CreateCollectionRequest{
          Name: "4K Movies",
          Type: "smart",
          Filters: map[string]interface{}{
            "resolution": "4K",
          },
        },
        wantErr: false,
      },
    }
    for _, tt := range tests {
      t.Run(tt.name, func(t *testing.T) {
        // Test implementation
      })
    }
  }

  func TestSmartCollectionEvaluator_Evaluate(t *testing.T) {
    // Test filter evaluation logic
  }

  func TestCollectionService_ShareCollection(t *testing.T) {
    // Test collection sharing permissions
  }
  ```
integration_tests: |
  ```go
  func TestCollections_EndToEnd(t *testing.T) {
    // 1. Create manual collection
    // 2. Add items to collection
    // 3. Retrieve collection with items
    // 4. Share collection
    // 5. Verify shared user can access
    // 6. Create smart collection
    // 7. Verify items auto-populate
  }

  func TestSmartCollections_FilterEvaluation(t *testing.T) {
    // Test various filter combinations
    // Verify SQL generation is correct
    // Check cache invalidation
  }
  ```
