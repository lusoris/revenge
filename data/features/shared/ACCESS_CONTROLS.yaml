doc_title: Time-Based Access Controls
doc_category: feature
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: ðŸŸ¡
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> User access restrictions based on time, limits, and schedules'
wiki_tagline: '> Control when and how users can access your media'
wiki_overview: Set rules for when users can access content. Limit viewing to certain hours (kids only watch TV after homework).
  Set daily or weekly limits on screen time. Block access during bedtimes or school hours. Create schedules per user or user
  group. Perfect for family media servers where parents want to control viewing habits.
sources:
- name: Casbin
  url: https://pkg.go.dev/github.com/casbin/casbin/v2
  note: Auto-resolved from casbin
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: rueidis
  url: https://pkg.go.dev/github.com/redis/rueidis
  note: Auto-resolved from rueidis
- name: rueidis GitHub README
  url: https://github.com/redis/rueidis
  note: Auto-resolved from rueidis-docs
- name: sqlc
  url: https://docs.sqlc.dev/en/stable/
  note: Auto-resolved from sqlc
- name: sqlc Configuration
  url: https://docs.sqlc.dev/en/stable/reference/config.html
  note: Auto-resolved from sqlc-config
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
feature_name: Time-Based Access Controls
module_name: time_based_access_controls
schema_name: public
architecture_diagram: |-
  ```mermaid
  flowchart LR
      subgraph Layer1["Layer 1"]
          node1(["Client<br/>(Web/App)"])
          node2[["API Handler<br/>(ogen)"]]
          node3[["Service<br/>(Logic)"]]
      end

      subgraph Layer2["Layer 2"]
          node4["Repository<br/>(sqlc)"]
          node5[["Metadata<br/>Service"]]
          node6[("Cache<br/>(otter)")]
      end

      subgraph Layer3["Layer 3"]
          node7[("PostgreSQL<br/>(pgx)")]
          node8(["External<br/>APIs"])
      end

      %% Connections
      node3 --> node4
      node6 --> node7

      %% Styling
      style Layer1 fill:#1976D2,stroke:#1976D2,color:#fff
      style Layer2 fill:#388E3C,stroke:#388E3C,color:#fff
      style Layer3 fill:#7B1FA2,stroke:#7B1FA2,color:#fff
  ```
database_schema: |
  **Schema**: `public`

  ```sql
  CREATE TABLE access_schedules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    enabled BOOLEAN DEFAULT true,
    days_of_week INTEGER[] DEFAULT '{0,1,2,3,4,5,6}',  -- 0=Sunday, 6=Saturday
    start_time TIME,                                    -- Daily start time
    end_time TIME,                                      -- Daily end time
    daily_limit_minutes INTEGER,                       -- Max minutes per day
    weekly_limit_minutes INTEGER,                      -- Max minutes per week
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_access_schedules_user ON access_schedules(user_id);
  CREATE INDEX idx_access_schedules_enabled ON access_schedules(enabled) WHERE enabled = true;

  CREATE TABLE access_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content_type VARCHAR(20),
    content_id UUID,
    started_at TIMESTAMPTZ DEFAULT now(),
    ended_at TIMESTAMPTZ,
    duration_minutes INTEGER,
    blocked BOOLEAN DEFAULT false,
    block_reason TEXT
  );
  CREATE INDEX idx_access_logs_user ON access_logs(user_id, started_at DESC);
  CREATE INDEX idx_access_logs_date ON access_logs(DATE(started_at));
  ```
module_structure: |
  ```
  internal/access/
  â”œâ”€â”€ module.go
  â”œâ”€â”€ types.go
  â”œâ”€â”€ repository.go
  â”œâ”€â”€ service.go
  â”œâ”€â”€ middleware.go          # Auth middleware
  â””â”€â”€ handler.go
  ```
key_interfaces: |
  ```go
  type AccessService interface {
    CheckAccess(ctx context.Context, userID uuid.UUID) (bool, string, error)
    CreateSchedule(ctx context.Context, schedule AccessSchedule) error
    GetUsageToday(ctx context.Context, userID uuid.UUID) (int, error)
  }
  ```
dependencies: |
  - `github.com/google/uuid`
  - `github.com/jackc/pgx/v5`
  - `github.com/casbin/casbin/v2` - Policy enforcement
env_vars: |
  ```bash
  ACCESS_CONTROLS_ENABLED=true
  ```
config_keys: |
  ```yaml
  access:
    enabled: true
    default_daily_limit_minutes: 120
  ```
component_interaction: |
  1. Middleware checks access_schedules for user
  2. Verify current time against allowed times
  3. Check daily/weekly usage limits
  4. Block or allow access
  5. Log access attempt
api_endpoints: |
  ```
  GET  /api/v1/access/schedules/:userId
  POST /api/v1/access/schedules
  GET  /api/v1/access/usage/:userId
  ```
unit_tests: |
  ```go
  func TestAccessService_CheckAccess(t *testing.T) {
    // Test time-based restrictions
  }
  ```
integration_tests: |
  ```go
  func TestAccess_EndToEnd(t *testing.T) {
    // Test full access control workflow
  }
  ```
