doc_title: Music Module
doc_category: feature
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: Complete music module design
status_sources: âœ…
status_sources_notes: All music APIs documented
status_instructions: âœ…
status_instructions_notes: Generated from design
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: |-
  > Music content management with metadata enrichment from MusicBrainz and Last.fm

  Complete music library management:
  - **Lidarr Integration**: Two-way sync for music library automation
  - **Metadata Sources**: MusicBrainz (primary), Last.fm (scrobbling, tags)
  - **Supported Formats**: MP3, FLAC, AAC, OGG, ALAC, Opus
  - **Playback**: HLS adaptive streaming with gapless playback
  - **Features**: Playlists, smart collections, album art, lyrics
wiki_tagline: '> Your complete music library with beautiful album art and metadata'
wiki_overview: The Music Module provides a complete music library experience with support for artists, albums, and tracks.
  It uses Lidarr as the PRIMARY metadata source (aggregates from MusicBrainz locally), with direct MusicBrainz/Last.fm APIs
  as supplementary enrichment. Lidarr integration provides both metadata caching and download automation. Stream your music
  in high quality with gapless playback, create playlists, and discover new music through smart collections.
sources:
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: Last.fm API
  url: https://www.last.fm/api/intro
  note: Auto-resolved from lastfm-api
- name: ogen OpenAPI Generator
  url: https://pkg.go.dev/github.com/ogen-go/ogen
  note: Auto-resolved from ogen
- name: pgx PostgreSQL Driver
  url: https://pkg.go.dev/github.com/jackc/pgx/v5
  note: Auto-resolved from pgx
- name: PostgreSQL Arrays
  url: https://www.postgresql.org/docs/current/arrays.html
  note: Auto-resolved from postgresql-arrays
- name: PostgreSQL JSON Functions
  url: https://www.postgresql.org/docs/current/functions-json.html
  note: Auto-resolved from postgresql-json
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: sqlc
  url: https://docs.sqlc.dev/en/stable/
  note: Auto-resolved from sqlc
- name: sqlc Configuration
  url: https://docs.sqlc.dev/en/stable/reference/config.html
  note: Auto-resolved from sqlc-config
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
- title: LIDARR (PRIMARY metadata + downloads)
  path: ../../integrations/servarr/LIDARR.md
- title: MUSICBRAINZ (supplementary metadata)
  path: ../../integrations/metadata/MUSICBRAINZ.md
- title: LASTFM (scrobbling + enrichment)
  path: ../../integrations/metadata/LASTFM.md
- title: LISTENBRAINZ (open-source scrobbling)
  path: ../../integrations/scrobbling/LISTENBRAINZ.md
- title: DISCOGS (vinyl/CD metadata)
  path: ../../integrations/metadata/DISCOGS.md
- title: SPOTIFY (streaming metadata)
  path: ../../integrations/metadata/SPOTIFY.md
feature_name: Music Module
module_name: music
schema_name: public
content_types:
- Artists
- Albums
- Tracks
lidarr_integration:
  sync_direction: two-way
  metadata_priority:
    1: Lidarr (cached metadata from MusicBrainz)
    2: MusicBrainz (direct API)
    3: Last.fm (tags, scrobbles, similar artists)
  webhook_events:
  - AlbumDownload
  - AlbumUpgrade
  - TrackRetag
  - ArtistDelete
  notes: Lidarr provides pre-fetched MusicBrainz metadata, reducing API calls
supported_formats:
- format: MP3
  codec: MPEG-1/2 Audio Layer III
  streaming: Direct playback or HLS transcode
- format: FLAC
  codec: Free Lossless Audio Codec
  streaming: Transcode to AAC/Opus for bandwidth savings
- format: AAC
  codec: Advanced Audio Coding
  streaming: Direct playback via HLS
- format: OGG
  codec: Vorbis/Opus
  streaming: Direct playback or transcode
- format: ALAC
  codec: Apple Lossless
  streaming: Transcode to AAC for web playback
- format: Opus
  codec: Opus
  streaming: Direct playback (best quality/bandwidth ratio)
metadata_sources:
- name: Lidarr
  purpose: Primary metadata source (cached from MusicBrainz)
  priority: 1
  fields: Artist, album, track, release date, genres, album art
- name: MusicBrainz
  purpose: Fallback for missing metadata
  priority: 2
  fields: Complete discography, relationships, ISRCs
  api_url: https://musicbrainz.org/ws/2/
- name: Last.fm
  purpose: User scrobbles, tags, similar artists
  priority: 3
  fields: Play counts, user tags, artist bio, similar artists
  api_url: https://www.last.fm/api
database_schema: |
  **Schema**: `public`

  **Tables**:
  - `artists`: Artist/band metadata
  - `artist_images`: Artist photos and promotional images
  - `albums`: Album metadata
  - `album_images`: Album cover art
  - `tracks`: Individual track metadata
  - `track_files`: Physical audio files
  - `track_lyrics`: Synced and unsynced lyrics
  - `artist_genres`: Genre associations for artists
  - `album_genres`: Genre associations for albums
  - `scrobbles`: Play history for Last.fm/ListenBrainz
  - `music_metadata_cache`: Cached metadata from providers

  **Key Columns** (`artists`):
  - `id` (UUID): Primary key
  - `musicbrainz_id` (UUID): MusicBrainz artist ID
  - `name` (TEXT): Artist/band name
  - `sort_name` (TEXT): Name for alphabetical sorting
  - `disambiguation` (TEXT): Disambiguation comment
  - `type` (TEXT): Artist type (person, group, orchestra, etc.)
  - `country` (TEXT): Country of origin
  - `begin_date` (DATE): Formation/birth date
  - `end_date` (DATE): Dissolution/death date
  - `biography` (TEXT): Artist biography (from Last.fm)
  - `image_path` (TEXT): Primary artist image
  - `lidarr_id` (INTEGER): Lidarr artist ID
  - `created_at` (TIMESTAMPTZ): Record creation time
  - `updated_at` (TIMESTAMPTZ): Last update time

  **Key Columns** (`albums`):
  - `id` (UUID): Primary key
  - `musicbrainz_id` (UUID): MusicBrainz release ID
  - `artist_id` (UUID): Artist foreign key
  - `title` (TEXT): Album title
  - `release_date` (DATE): Original release date
  - `release_type` (TEXT): Album, EP, Single, Compilation, etc.
  - `release_status` (TEXT): Official, Promotion, Bootleg, etc.
  - `country` (TEXT): Release country
  - `barcode` (TEXT): Album barcode
  - `label` (TEXT): Record label
  - `cover_path` (TEXT): Album cover image
  - `disc_count` (INTEGER): Number of discs
  - `track_count` (INTEGER): Total tracks
  - `duration` (INTEGER): Total duration in seconds
  - `lidarr_id` (INTEGER): Lidarr album ID
  - `created_at` (TIMESTAMPTZ): Record creation time
  - `updated_at` (TIMESTAMPTZ): Last update time

  **Key Columns** (`tracks`):
  - `id` (UUID): Primary key
  - `musicbrainz_id` (UUID): MusicBrainz recording ID
  - `album_id` (UUID): Album foreign key
  - `title` (TEXT): Track title
  - `track_number` (INTEGER): Track position on disc
  - `disc_number` (INTEGER): Disc number
  - `duration` (INTEGER): Duration in milliseconds
  - `isrc` (TEXT): International Standard Recording Code
  - `artist_credit` (TEXT): Artist credits (may differ from album artist)
  - `created_at` (TIMESTAMPTZ): Record creation time
  - `updated_at` (TIMESTAMPTZ): Last update time

  **Key Columns** (`track_files`):
  - `id` (UUID): Primary key
  - `track_id` (UUID): Track foreign key
  - `file_path` (TEXT): Absolute file path
  - `file_size` (BIGINT): Size in bytes
  - `format` (TEXT): Audio format (MP3, FLAC, etc.)
  - `codec` (TEXT): Audio codec
  - `bitrate` (INTEGER): Bitrate in kbps
  - `sample_rate` (INTEGER): Sample rate in Hz
  - `channels` (INTEGER): Channel count (1=mono, 2=stereo, etc.)
  - `bit_depth` (INTEGER): Bit depth (16, 24, etc.)
  - `replay_gain` (DECIMAL): ReplayGain adjustment in dB
  - `checksum` (TEXT): File checksum (SHA256)
  - `created_at` (TIMESTAMPTZ): Record creation time
  - `updated_at` (TIMESTAMPTZ): Last update time

  **Indexes**:
  - `idx_artists_musicbrainz_id` on `musicbrainz_id`
  - `idx_artists_lidarr_id` on `lidarr_id`
  - `idx_artists_name_trgm` (GIN trigram) for fuzzy search
  - `idx_albums_artist_id` on `artist_id`
  - `idx_albums_musicbrainz_id` on `musicbrainz_id`
  - `idx_albums_release_date` on `release_date`
  - `idx_tracks_album_id` on `album_id`
  - `idx_tracks_musicbrainz_id` on `musicbrainz_id`
  - `idx_track_files_track_id` on `track_id`
  - `idx_scrobbles_user_track` on (`user_id`, `track_id`)
  - `idx_scrobbles_timestamp` on `scrobbled_at`
playback_features:
  streaming_protocol: HLS (HTTP Live Streaming)
  gapless_playback: true
  crossfade: Configurable (0-12 seconds)
  audio_normalization: ReplayGain support
  lyrics_display: Synced lyrics (LRC format) if available
  queue_management: Add to queue, play next, shuffle, repeat
playlist_support:
  types:
  - Manual playlists (user-created)
  - Smart playlists (filter-based)
  features:
  - Collaborative playlists
  - Playlist sharing (public/private)
  - Import from M3U/PLS
  - Export to M3U/PLS
  database_table: playlists (shared with other modules)
scrobbling_integration:
  services:
  - Last.fm
  - ListenBrainz
  - Spotify (if configured)
  scrobble_trigger: 50% played or 4 minutes (whichever comes first)
  offline_queue: Queue scrobbles when offline, submit when online
api_endpoints:
- method: GET
  path: /api/v1/music/artists
  description: List all artists with pagination and filters
- method: GET
  path: /api/v1/music/artists/:id
  description: Get artist details by ID
- method: GET
  path: /api/v1/music/artists/:id/albums
  description: List all albums by an artist
- method: GET
  path: /api/v1/music/albums
  description: List all albums with pagination and filters
- method: GET
  path: /api/v1/music/albums/:id
  description: Get album details by ID
- method: GET
  path: /api/v1/music/albums/:id/tracks
  description: List all tracks on an album
- method: GET
  path: /api/v1/music/tracks
  description: List all tracks with pagination and filters
- method: GET
  path: /api/v1/music/tracks/:id
  description: Get track details by ID
- method: GET
  path: /api/v1/music/tracks/:id/stream
  description: Get audio streaming URL for a track
- method: POST
  path: /api/v1/music/playlists
  description: Create a new playlist
- method: GET
  path: /api/v1/music/genres
  description: List all music genres
architecture_diagram: |-
  ```mermaid
  flowchart LR
      subgraph Layer1["Layer 1"]
          node1(["Client<br/>(Web/App)"])
          node2[["API Handler<br/>(ogen)"]]
          node3[["Service<br/>(Logic)"]]
      end

      subgraph Layer2["Layer 2"]
          node4["Repository<br/>(sqlc)"]
          node5[["Metadata<br/>Service"]]
          node6[("Cache<br/>(otter)")]
      end

      subgraph Layer3["Layer 3"]
          node7[("PostgreSQL<br/>(pgx)")]
          node8(["External<br/>APIs"])
      end

      %% Connections
      node3 --> node4
      node6 --> node7

      %% Styling
      style Layer1 fill:#1976D2,stroke:#1976D2,color:#fff
      style Layer2 fill:#388E3C,stroke:#388E3C,color:#fff
      style Layer3 fill:#7B1FA2,stroke:#7B1FA2,color:#fff
  ```
module_structure: |-
  ```
    internal/content/music/
    â”œâ”€â”€ module.go              # fx module definition
    â”œâ”€â”€ repository.go          # Database operations (sqlc)
    â”œâ”€â”€ service.go             # Business logic
    â”œâ”€â”€ handler.go             # HTTP handlers (ogen)
    â”œâ”€â”€ types.go               # Domain types
    â””â”€â”€ cache.go               # Caching layer (otter)
    ```
component_interaction: |
  1. **Request Flow**:
     - Client sends HTTP request to `/api/v1/music/*`
     - API handler (ogen) validates request and calls service
     - Service checks cache for existing data
     - If cache miss, service calls repository for database query
     - Repository executes SQL via sqlc-generated code
     - Results flow back through service â†’ handler â†’ client

  2. **Metadata Enrichment**:
     - Lidarr webhook triggers on new album download
     - Service fetches metadata from Lidarr API (includes MusicBrainz data)
     - Service stores artist, album, and track data
     - Background job fetches additional metadata from Last.fm (bio, similar artists)
     - Service updates database and invalidates cache

  3. **Audio Streaming**:
     - Client requests track stream via `/api/v1/music/tracks/{id}/stream`
     - Service checks user permissions and track availability
     - Service determines optimal format based on client capabilities
     - If transcoding needed, FFmpeg worker job is created
     - HLS manifest and segments are generated/served
     - Client plays audio with gapless playback support

  4. **Scrobbling Flow**:
     - Client reports playback progress via websocket
     - When scrobble threshold reached (50% or 4 min), event triggered
     - Background job submits scrobble to Last.fm/ListenBrainz
     - Scrobble stored locally for play count statistics
     - If submission fails, queued for retry
file_structure: |
  ```
  internal/content/music/
  â”œâ”€â”€ module.go              # fx.Module with all providers
  â”œâ”€â”€ repository.go          # Database layer
  â”œâ”€â”€ repository_test.go     # Repository tests (testcontainers)
  â”œâ”€â”€ service.go             # Business logic
  â”œâ”€â”€ service_test.go        # Service tests (mocks)
  â”œâ”€â”€ handler.go             # HTTP handlers
  â”œâ”€â”€ handler_test.go        # Handler tests (httptest)
  â”œâ”€â”€ types.go               # Domain types
  â”œâ”€â”€ cache.go               # Caching logic
  â”œâ”€â”€ cache_test.go          # Cache tests
  â”œâ”€â”€ streaming/
  â”‚   â”œâ”€â”€ transcoder.go      # FFmpeg transcoding logic
  â”‚   â”œâ”€â”€ transcoder_test.go # Transcoding tests
  â”‚   â”œâ”€â”€ hls.go             # HLS manifest generation
  â”‚   â””â”€â”€ gapless.go         # Gapless playback handling
  â”œâ”€â”€ metadata/
  â”‚   â”œâ”€â”€ provider.go        # Interface: MetadataProvider
  â”‚   â”œâ”€â”€ lidarr.go          # Lidarr API integration
  â”‚   â”œâ”€â”€ musicbrainz.go     # MusicBrainz API integration
  â”‚   â”œâ”€â”€ lastfm.go          # Last.fm API integration
  â”‚   â”œâ”€â”€ lastfm_test.go     # Last.fm integration tests
  â”‚   â””â”€â”€ enricher.go        # Enrichment orchestration
  â””â”€â”€ scrobbling/
      â”œâ”€â”€ scrobbler.go       # Scrobble submission logic
      â”œâ”€â”€ queue.go           # Offline scrobble queue
      â””â”€â”€ scrobbler_test.go  # Scrobbling tests

  migrations/
  â””â”€â”€ music/
      â”œâ”€â”€ 001_artists.sql    # Artists schema
      â”œâ”€â”€ 002_albums.sql     # Albums schema
      â”œâ”€â”€ 003_tracks.sql     # Tracks schema
      â””â”€â”€ 004_scrobbles.sql  # Scrobbling schema

  api/
  â””â”€â”€ openapi.yaml           # OpenAPI spec (music/* endpoints)
  ```
key_interfaces: |
  ```go
  // Repository defines database operations for music content
  type Repository interface {
      // Artist CRUD
      GetArtist(ctx context.Context, id uuid.UUID) (*Artist, error)
      ListArtists(ctx context.Context, filters ListFilters) ([]Artist, error)
      CreateArtist(ctx context.Context, artist *Artist) error
      UpdateArtist(ctx context.Context, artist *Artist) error
      DeleteArtist(ctx context.Context, id uuid.UUID) error

      // Album CRUD
      GetAlbum(ctx context.Context, id uuid.UUID) (*Album, error)
      ListAlbums(ctx context.Context, filters ListFilters) ([]Album, error)
      ListAlbumsByArtist(ctx context.Context, artistID uuid.UUID) ([]Album, error)
      CreateAlbum(ctx context.Context, album *Album) error
      UpdateAlbum(ctx context.Context, album *Album) error
      DeleteAlbum(ctx context.Context, id uuid.UUID) error

      // Track CRUD
      GetTrack(ctx context.Context, id uuid.UUID) (*Track, error)
      ListTracks(ctx context.Context, filters ListFilters) ([]Track, error)
      ListTracksByAlbum(ctx context.Context, albumID uuid.UUID) ([]Track, error)
      CreateTrack(ctx context.Context, track *Track) error
      UpdateTrack(ctx context.Context, track *Track) error
      DeleteTrack(ctx context.Context, id uuid.UUID) error

      // Scrobbling
      RecordScrobble(ctx context.Context, userID, trackID uuid.UUID, timestamp time.Time) error
      GetRecentScrobbles(ctx context.Context, userID uuid.UUID, limit int) ([]Scrobble, error)
      GetPlayCount(ctx context.Context, userID, trackID uuid.UUID) (int, error)
  }

  // Service defines business logic for music
  type Service interface {
      // Artist operations
      GetArtist(ctx context.Context, id uuid.UUID) (*Artist, error)
      SearchArtists(ctx context.Context, query string, filters SearchFilters) ([]Artist, error)
      EnrichArtist(ctx context.Context, id uuid.UUID) error

      // Album operations
      GetAlbum(ctx context.Context, id uuid.UUID) (*Album, error)
      SearchAlbums(ctx context.Context, query string, filters SearchFilters) ([]Album, error)
      EnrichAlbum(ctx context.Context, id uuid.UUID) error

      // Track operations
      GetTrack(ctx context.Context, id uuid.UUID) (*Track, error)
      GetStreamURL(ctx context.Context, trackID uuid.UUID, format string) (string, error)

      // Scrobbling
      SubmitScrobble(ctx context.Context, userID, trackID uuid.UUID) error
  }

  // MetadataProvider fetches music metadata from external sources
  type MetadataProvider interface {
      GetArtistByMBID(ctx context.Context, mbid string) (*ArtistMetadata, error)
      GetAlbumByMBID(ctx context.Context, mbid string) (*AlbumMetadata, error)
      GetTrackByMBID(ctx context.Context, mbid string) (*TrackMetadata, error)
      SearchArtists(ctx context.Context, query string) ([]ArtistMetadata, error)
      SearchAlbums(ctx context.Context, query string) ([]AlbumMetadata, error)
  }

  // Transcoder handles audio format conversion
  type Transcoder interface {
      // TranscodeToHLS creates HLS manifest and segments
      TranscodeToHLS(ctx context.Context, inputPath string, opts TranscodeOptions) (*HLSManifest, error)

      // SupportedFormats returns formats this transcoder can handle
      SupportedFormats() []string

      // GetCodecForFormat returns optimal codec for target format
      GetCodecForFormat(format string) (string, error)
  }

  // Scrobbler submits playback events to external services
  type Scrobbler interface {
      // Scrobble submits a scrobble event
      Scrobble(ctx context.Context, track *Track, timestamp time.Time) error

      // UpdateNowPlaying updates "now playing" status
      UpdateNowPlaying(ctx context.Context, track *Track) error

      // QueueOffline queues scrobble for later submission
      QueueOffline(track *Track, timestamp time.Time) error
  }
  ```
dependencies: |
  **Go Dependencies**:
  - `github.com/jackc/pgx/v5/pgxpool` - PostgreSQL connection pool
  - `github.com/google/uuid` - UUID generation
  - `github.com/maypok86/otter` - In-memory cache
  - `github.com/asticode/go-astiav` - FFmpeg bindings for transcoding
  - `github.com/go-resty/resty/v2` - HTTP client for external APIs
  - `go.uber.org/fx` - Dependency injection
  - `github.com/riverqueue/river` - Background job queue
  - `golang.org/x/net/proxy` - SOCKS5 proxy support for external metadata calls

  **External APIs** (priority order):
  - **Lidarr API v1** - PRIMARY metadata source (local MusicBrainz cache) + download automation
  - **MusicBrainz API v2** - Supplementary metadata (via proxy/VPN when Lidarr lacks data)
  - **Last.fm API v2.0** - Supplementary enrichment (via proxy/VPN): scrobbling, tags, similar artists
  - **ListenBrainz API** - Open scrobbling alternative (via proxy/VPN)

  **External Tools**:
  - FFmpeg 7.0+ - Audio transcoding and format conversion

  **Database**:
  - PostgreSQL 18+ with trigram extension for fuzzy search
env_vars: |
  **Environment Variables**:
  - `REVENGE_MUSIC_CACHE_TTL` - Cache TTL duration (default: 15m)
  - `REVENGE_MUSIC_CACHE_SIZE` - Cache size in MB (default: 150)
  - `REVENGE_LIDARR_URL` - Lidarr instance URL (required)
  - `REVENGE_LIDARR_API_KEY` - Lidarr API key (required)
  - `REVENGE_METADATA_MUSICBRAINZ_RATE_LIMIT` - Rate limit per second (default: 1)
  - `REVENGE_METADATA_LASTFM_API_KEY` - Last.fm API key (optional)
  - `REVENGE_METADATA_LASTFM_API_SECRET` - Last.fm API secret (optional)
  - `REVENGE_METADATA_LISTENBRAINZ_TOKEN` - ListenBrainz user token (optional)
  - `REVENGE_MUSIC_TRANSCODE_ENABLED` - Enable audio transcoding (default: true)
  - `REVENGE_MUSIC_TRANSCODE_QUALITY` - Transcode quality preset (low, medium, high, lossless)
  - `REVENGE_MUSIC_GAPLESS_ENABLED` - Enable gapless playback (default: true)
config_keys: |
  **config.yaml keys**:
  ```yaml
  music:
    cache:
      ttl: 15m
      size_mb: 150

    metadata:
      lidarr:
        url: ${REVENGE_LIDARR_URL}
        api_key: ${REVENGE_LIDARR_API_KEY}
        sync_interval: 30m

      musicbrainz:
        rate_limit: 1  # Requests per second
        user_agent: "Revenge/1.0 (your-email@example.com)"

      lastfm:
        api_key: ${REVENGE_METADATA_LASTFM_API_KEY}
        api_secret: ${REVENGE_METADATA_LASTFM_API_SECRET}
        scrobbling_enabled: true

      listenbrainz:
        token: ${REVENGE_METADATA_LISTENBRAINZ_TOKEN}
        enabled: false

      priority:
        - lidarr        # PRIMARY: Local MusicBrainz cache
        - musicbrainz   # Supplementary: Direct API (via proxy/VPN)
        - lastfm        # Enrichment (via proxy/VPN)

      musicbrainz:
        proxy: tor  # Route through proxy/VPN (see HTTP_CLIENT service)

      lastfm:
        proxy: tor  # Route through proxy/VPN

    streaming:
      transcoding:
        enabled: true
        quality: high  # low, medium, high, lossless
        formats:
          - mp3: {bitrate: 320, codec: libmp3lame}
          - aac: {bitrate: 256, codec: aac}
          - opus: {bitrate: 128, codec: libopus}
        cache_segments: true
        segment_duration: 6  # seconds

      gapless:
        enabled: true
        prebuffer_next_track: true

      replaygain:
        enabled: true
        fallback_level: -18  # LUFS

    scrobbling:
      threshold_percent: 50
      threshold_duration: 240  # seconds
      services:
        - lastfm
        - listenbrainz
      offline_queue_size: 1000
  ```
defaults: |
  - Cache TTL: 15 minutes
  - Cache size: 150 MB
  - Lidarr sync interval: 30 minutes
  - MusicBrainz rate limit: 1 request/second
  - Transcoding quality: high
  - Gapless playback: enabled
  - Scrobble threshold: 50% or 4 minutes
  - HLS segment duration: 6 seconds
  - ReplayGain: enabled (-18 LUFS fallback)
request_examples: |
  **List artists with filters**:
  ```http
  GET /api/v1/music/artists?genre=rock&country=US&limit=20&offset=0
  Authorization: Bearer {token}
  ```

  **Get artist with albums**:
  ```http
  GET /api/v1/music/artists/550e8400-e29b-41d4-a716-446655440000?include=albums
  Authorization: Bearer {token}
  ```

  **Get album with tracks**:
  ```http
  GET /api/v1/music/albums/650e8400-e29b-41d4-a716-446655440000?include=tracks
  Authorization: Bearer {token}
  ```

  **Stream a track**:
  ```http
  GET /api/v1/music/tracks/750e8400-e29b-41d4-a716-446655440000/stream?format=opus&quality=high
  Authorization: Bearer {token}
  ```

  **Submit scrobble**:
  ```http
  POST /api/v1/music/scrobbles
  Authorization: Bearer {token}
  Content-Type: application/json

  {
    "track_id": "750e8400-e29b-41d4-a716-446655440000",
    "timestamp": "2024-01-15T20:30:00Z"
  }
  ```
response_examples: |
  **Artist details response**:
  ```json
  {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "musicbrainz_id": "83d91898-7763-47d7-b03b-b92132375c47",
    "name": "Pink Floyd",
    "sort_name": "Pink Floyd",
    "type": "Group",
    "country": "GB",
    "begin_date": "1965-01-01",
    "biography": "British rock band formed in London...",
    "image_path": "/artists/images/pink-floyd.jpg",
    "genres": ["Progressive Rock", "Psychedelic Rock"],
    "album_count": 15,
    "track_count": 203,
    "created_at": "2024-01-01T00:00:00Z",
    "updated_at": "2024-01-15T20:30:00Z"
  }
  ```

  **Album details response**:
  ```json
  {
    "id": "650e8400-e29b-41d4-a716-446655440000",
    "musicbrainz_id": "b84ee12a-09ef-421b-82de-0441a926375b",
    "artist": {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "Pink Floyd"
    },
    "title": "The Dark Side of the Moon",
    "release_date": "1973-03-01",
    "release_type": "Album",
    "cover_path": "/albums/covers/dark-side-of-the-moon.jpg",
    "disc_count": 1,
    "track_count": 10,
    "duration": 2583,
    "genres": ["Progressive Rock"],
    "tracks": [
      {
        "id": "...",
        "title": "Speak to Me",
        "track_number": 1,
        "duration": 90000
      }
    ],
    "created_at": "2024-01-01T00:00:00Z",
    "updated_at": "2024-01-15T20:30:00Z"
  }
  ```

  **Stream URL response**:
  ```json
  {
    "stream_url": "https://revenge.example.com/stream/750e8400.../master.m3u8",
    "format": "hls",
    "codec": "opus",
    "bitrate": 128,
    "gapless_supported": true,
    "expires_at": "2024-01-15T21:30:00Z"
  }
  ```
unit_tests: |
  **Repository Tests** (with testcontainers):
  - Test CRUD operations for artists
  - Test CRUD operations for albums
  - Test CRUD operations for tracks
  - Test scrobble recording
  - Test play count aggregation
  - Test search with filters
  - Test concurrent access

  **Service Tests** (with mocks):
  - Test business logic with mocked repository
  - Test metadata enrichment flow (Lidarr â†’ MusicBrainz â†’ Last.fm)
  - Test cache hit/miss scenarios
  - Test error handling
  - Test rate limiting for MusicBrainz

  **Handler Tests** (with httptest):
  - Test HTTP request/response handling
  - Test authentication/authorization
  - Test request validation
  - Test error responses
  - Test pagination

  **Transcoding Tests**:
  - Test HLS manifest generation
  - Test audio format detection
  - Test codec selection
  - Test gapless playback metadata
  - Test ReplayGain application

  **Scrobbling Tests**:
  - Test scrobble threshold logic
  - Test offline queue behavior
  - Test retry logic for failed submissions
  - Test concurrent scrobbles
integration_tests: |
  **Full Stack Tests**:
  - Test complete request flow (client â†’ database)
  - Test metadata enrichment with real Lidarr API (mocked)
  - Test Last.fm scrobbling (mocked)
  - Test audio streaming end-to-end
  - Test gapless playback transitions
  - Test concurrent track streaming

  **Database Tests**:
  - Test migrations (up/down)
  - Test indexes performance
  - Test foreign key constraints
  - Test transaction isolation
  - Test trigram search performance

  **Streaming Tests**:
  - Test HLS playback with various formats
  - Test transcoding quality levels
  - Test segment caching
  - Test bandwidth adaptation
  - Test gapless transitions
test_coverage_target: |
  - **Overall**: 80% minimum
  - **Repository**: 90% (critical path)
  - **Service**: 85% (business logic)
  - **Handler**: 75% (integration layer)
  - **Metadata providers**: 70% (external dependency)
  - **Transcoding**: 80% (complex audio processing)
  - **Scrobbling**: 85% (important for user stats)
