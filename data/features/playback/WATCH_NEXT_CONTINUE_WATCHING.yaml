doc_title: Watch Next & Continue Watching System
doc_category: feature
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Intelligent playback continuation and recommendation system'
wiki_tagline: '> Intelligent playback continuation and recommendation system'
wiki_overview: Never lose your place. Continue Watching shows partially-watched content with progress bars. Watch Next suggests
  the next episode or related content based on your viewing history. Syncs across all your devices so you can start on your
  phone and finish on TV. Configurable per-user with options to hide content or reset progress.
sources:
- name: Jellyfin API
  url: https://api.jellyfin.org/
  note: Auto-resolved from jellyfin-api
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
feature_name: Watch Next & Continue Watching System
module_name: watch_next_&_continue_watching_system
schema_name: public
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1([Client<br/>(Web/App)])
      node2[[API Handler<br/>(ogen)]]
      node3[[Service<br/>(Logic)]]
      node4["Repository<br/>(sqlc)"]
      node5[[Metadata<br/>Service]]
      node6[(Cache<br/>(otter))]
      node7[(PostgreSQL<br/>(pgx))]
      node8([External<br/>APIs])
      node1 --> node2
      node2 --> node3
      node4 --> node5
      node5 --> node6
      node7 --> node8
      node3 --> node4
      node6 --> node7
  ```
database_schema: |
  **Schema**: `public`

  **Tables**:

  ```sql
  -- Playback progress tracking
  CREATE TABLE playback_progress (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

      -- Content reference (polymorphic)
      content_type TEXT NOT NULL,  -- 'movie', 'episode', 'audiobook_chapter', 'music_track'
      content_id UUID NOT NULL,

      -- Progress
      position_seconds INTEGER NOT NULL DEFAULT 0,
      duration_seconds INTEGER NOT NULL,
      progress_percent NUMERIC(5,2) GENERATED ALWAYS AS (
          CASE
              WHEN duration_seconds > 0 THEN (position_seconds::NUMERIC / duration_seconds * 100)
              ELSE 0
          END
      ) STORED,

      -- Completion tracking
      is_completed BOOLEAN DEFAULT false,
      completed_at TIMESTAMPTZ,

      -- Device tracking
      last_device_id TEXT,
      last_device_name TEXT,

      -- Metadata
      last_played_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

      UNIQUE(user_id, content_type, content_id),
      CONSTRAINT playback_progress_position_check CHECK (position_seconds >= 0),
      CONSTRAINT playback_progress_duration_check CHECK (duration_seconds > 0)
  );

  CREATE INDEX idx_playback_progress_user_id ON playback_progress(user_id);
  CREATE INDEX idx_playback_progress_last_played ON playback_progress(last_played_at DESC);
  CREATE INDEX idx_playback_progress_user_last_played ON playback_progress(user_id, last_played_at DESC);
  CREATE INDEX idx_playback_progress_content ON playback_progress(content_type, content_id);
  CREATE INDEX idx_playback_progress_incomplete ON playback_progress(user_id, is_completed)
      WHERE is_completed = false;

  -- Continue Watching list items
  -- This is a materialized view or computed on-the-fly from playback_progress
  -- For performance, we can cache it or use a view
  CREATE VIEW continue_watching_v AS
  SELECT
      pp.id,
      pp.user_id,
      pp.content_type,
      pp.content_id,
      pp.position_seconds,
      pp.duration_seconds,
      pp.progress_percent,
      pp.last_played_at,
      pp.last_device_name,

      -- Join with content tables based on type
      CASE pp.content_type
          WHEN 'movie' THEN m.title
          WHEN 'episode' THEN tv.title || ' - ' || e.title
          WHEN 'audiobook_chapter' THEN ab.title || ' - Chapter ' || ac.chapter_number
          ELSE NULL
      END AS display_title,

      CASE pp.content_type
          WHEN 'movie' THEN m.poster_path
          WHEN 'episode' THEN tv.poster_path
          WHEN 'audiobook_chapter' THEN ab.cover_path
          ELSE NULL
      END AS poster_url

  FROM playback_progress pp
  LEFT JOIN movies m ON pp.content_type = 'movie' AND pp.content_id = m.id
  LEFT JOIN tv_episodes e ON pp.content_type = 'episode' AND pp.content_id = e.id
  LEFT JOIN tv_shows tv ON e.show_id = tv.id
  LEFT JOIN audiobook_chapters ac ON pp.content_type = 'audiobook_chapter' AND pp.content_id = ac.id
  LEFT JOIN audiobooks ab ON ac.audiobook_id = ab.id

  WHERE pp.is_completed = false
    AND pp.progress_percent BETWEEN 5 AND 95  -- Not just started or almost finished
  ORDER BY pp.last_played_at DESC;

  -- Watch Next suggestions
  CREATE TABLE watch_next_suggestions (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

      -- Suggested content
      content_type TEXT NOT NULL,  -- 'episode', 'movie'
      content_id UUID NOT NULL,

      -- Reason for suggestion
      suggestion_type TEXT NOT NULL,  -- 'next_episode', 'similar_movie', 'continue_series', 'based_on_history'
      based_on_content_id UUID,  -- What triggered this suggestion

      -- Ranking
      score NUMERIC(5,2) DEFAULT 0,  -- Relevance score (0-100)

      -- Status
      is_dismissed BOOLEAN DEFAULT false,
      dismissed_at TIMESTAMPTZ,

      -- Metadata
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      expires_at TIMESTAMPTZ,  -- Auto-expire old suggestions

      UNIQUE(user_id, content_type, content_id, suggestion_type)
  );

  CREATE INDEX idx_watch_next_user_id ON watch_next_suggestions(user_id);
  CREATE INDEX idx_watch_next_user_active ON watch_next_suggestions(user_id, is_dismissed, score DESC)
      WHERE is_dismissed = false AND (expires_at IS NULL OR expires_at > NOW());
  CREATE INDEX idx_watch_next_based_on ON watch_next_suggestions(based_on_content_id);

  -- User preferences for Continue Watching
  CREATE TABLE continue_watching_preferences (
      user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

      -- Display settings
      show_continue_watching BOOLEAN DEFAULT true,
      show_watch_next BOOLEAN DEFAULT true,
      max_continue_watching_items INTEGER DEFAULT 20,
      max_watch_next_items INTEGER DEFAULT 10,

      -- Auto-hide settings
      auto_hide_after_days INTEGER DEFAULT 90,  -- Hide items not played in X days
      auto_mark_watched_percent INTEGER DEFAULT 90,  -- Auto-mark as watched at X%

      -- Device sync
      sync_across_devices BOOLEAN DEFAULT true,

      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
  );

  -- Hidden content (user manually hid from Continue Watching)
  CREATE TABLE continue_watching_hidden (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      content_type TEXT NOT NULL,
      content_id UUID NOT NULL,
      hidden_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

      UNIQUE(user_id, content_type, content_id)
  );

  CREATE INDEX idx_continue_watching_hidden_user ON continue_watching_hidden(user_id);
  ```

  **Indexes**: Optimized for:
  - User playback history lookups
  - Continue Watching list generation (incomplete progress, recent plays)
  - Watch Next suggestions by user and relevance
  - Content hiding and preference lookups
  - Device-specific filtering
file_structure: |
  ```
  internal/playback/
  â”œâ”€â”€ module.go                    # fx module registration
  â”œâ”€â”€ progress_repository.go       # Playback progress database ops (sqlc)
  â”œâ”€â”€ queries.sql                  # SQL queries for sqlc
  â”œâ”€â”€ progress_service.go          # Progress tracking service
  â”œâ”€â”€ continue_watching_service.go # Continue Watching logic
  â”œâ”€â”€ watch_next_service.go        # Watch Next suggestions
  â”œâ”€â”€ handler.go                   # HTTP handlers (ogen-generated)
  â”œâ”€â”€ types.go                     # Domain types
  â”œâ”€â”€ cache.go                     # Caching layer (otter)
  â”œâ”€â”€ suggestion_engine.go         # Recommendation algorithm
  â””â”€â”€ sync.go                      # Cross-device sync

  cmd/server/
  â””â”€â”€ main.go                      # Server entry point with fx

  migrations/
  â”œâ”€â”€ 030_playback_progress.up.sql # Playback tracking tables
  â””â”€â”€ 030_playback_progress.down.sql

  api/openapi/
  â””â”€â”€ playback.yaml                # OpenAPI spec for playback

  web/src/lib/components/playback/
  â”œâ”€â”€ ContinueWatchingRow.svelte   # Continue Watching carousel
  â”œâ”€â”€ WatchNextSection.svelte      # Watch Next suggestions
  â”œâ”€â”€ ProgressBar.svelte           # Progress indicator
  â””â”€â”€ PlaybackPreferences.svelte   # User preferences UI
  ```
key_interfaces: |
  ```go
  // ProgressRepository interface for playback progress database operations
  type ProgressRepository interface {
      // Progress tracking
      UpsertProgress(ctx context.Context, params UpsertProgressParams) (*PlaybackProgress, error)
      GetProgress(ctx context.Context, userID uuid.UUID, contentType string, contentID uuid.UUID) (*PlaybackProgress, error)
      GetUserProgress(ctx context.Context, userID uuid.UUID, contentType *string, limit, offset int) ([]*PlaybackProgress, error)
      DeleteProgress(ctx context.Context, userID uuid.UUID, contentType string, contentID uuid.UUID) error
      MarkCompleted(ctx context.Context, userID uuid.UUID, contentType string, contentID uuid.UUID) error

      // Continue Watching
      GetContinueWatching(ctx context.Context, userID uuid.UUID, limit int) ([]*ContinueWatchingItem, error)
      GetIncompleteProgress(ctx context.Context, userID uuid.UUID, minPercent, maxPercent int, limit int) ([]*PlaybackProgress, error)

      // Cleanup
      DeleteOldProgress(ctx context.Context, userID uuid.UUID, olderThan time.Time) (int64, error)
      AutoMarkWatched(ctx context.Context, userID uuid.UUID, minPercent int) (int64, error)

      // Hidden content
      HideContent(ctx context.Context, userID uuid.UUID, contentType string, contentID uuid.UUID) error
      UnhideContent(ctx context.Context, userID uuid.UUID, contentType string, contentID uuid.UUID) error
      GetHiddenContent(ctx context.Context, userID uuid.UUID) ([]*HiddenContent, error)
      IsContentHidden(ctx context.Context, userID uuid.UUID, contentType string, contentID uuid.UUID) (bool, error)

      // Preferences
      GetPreferences(ctx context.Context, userID uuid.UUID) (*ContinueWatchingPreferences, error)
      UpsertPreferences(ctx context.Context, userID uuid.UUID, prefs PreferencesParams) (*ContinueWatchingPreferences, error)
  }

  // WatchNextRepository interface for suggestion management
  type WatchNextRepository interface {
      CreateSuggestion(ctx context.Context, params CreateSuggestionParams) (*WatchNextSuggestion, error)
      GetSuggestions(ctx context.Context, userID uuid.UUID, limit int) ([]*WatchNextSuggestion, error)
      DismissSuggestion(ctx context.Context, userID uuid.UUID, suggestionID uuid.UUID) error
      DeleteExpiredSuggestions(ctx context.Context) (int64, error)
      ClearUserSuggestions(ctx context.Context, userID uuid.UUID) error
  }

  // ProgressService interface for progress tracking
  type ProgressService interface {
      // Update progress
      UpdateProgress(ctx context.Context, userID uuid.UUID, req UpdateProgressRequest) (*PlaybackProgress, error)
      GetProgress(ctx context.Context, userID uuid.UUID, contentType string, contentID uuid.UUID) (*PlaybackProgress, error)
      ResetProgress(ctx context.Context, userID uuid.UUID, contentType string, contentID uuid.UUID) error
      MarkWatched(ctx context.Context, userID uuid.UUID, contentType string, contentID uuid.UUID) error

      // Batch operations
      GetAllProgress(ctx context.Context, userID uuid.UUID, filters ProgressFilters) ([]*PlaybackProgress, error)
      BulkResetProgress(ctx context.Context, userID uuid.UUID, contentIDs []ContentReference) error
  }

  // ContinueWatchingService interface for Continue Watching list
  type ContinueWatchingService interface {
      GetContinueWatching(ctx context.Context, userID uuid.UUID) (*ContinueWatchingResponse, error)
      HideFromContinueWatching(ctx context.Context, userID uuid.UUID, contentType string, contentID uuid.UUID) error
      UnhideFromContinueWatching(ctx context.Context, userID uuid.UUID, contentType string, contentID uuid.UUID) error
      GetPreferences(ctx context.Context, userID uuid.UUID) (*ContinueWatchingPreferences, error)
      UpdatePreferences(ctx context.Context, userID uuid.UUID, updates PreferencesUpdate) (*ContinueWatchingPreferences, error)
  }

  // WatchNextService interface for Watch Next suggestions
  type WatchNextService interface {
      GetWatchNext(ctx context.Context, userID uuid.UUID) (*WatchNextResponse, error)
      DismissSuggestion(ctx context.Context, userID, suggestionID uuid.UUID) error
      RefreshSuggestions(ctx context.Context, userID uuid.UUID) error
  }

  // SuggestionEngine interface for recommendation logic
  type SuggestionEngine interface {
      GenerateNextEpisodeSuggestions(ctx context.Context, userID uuid.UUID) ([]*WatchNextSuggestion, error)
      GenerateSimilarMovieSuggestions(ctx context.Context, userID uuid.UUID, basedOnMovieID uuid.UUID) ([]*WatchNextSuggestion, error)
      GenerateContinueSeriesSuggestions(ctx context.Context, userID uuid.UUID) ([]*WatchNextSuggestion, error)
      GenerateHistoryBasedSuggestions(ctx context.Context, userID uuid.UUID) ([]*WatchNextSuggestion, error)
  }
  ```
dependencies: |
  **Go Packages**:
  ```go
  require (
      // Core
      github.com/google/uuid v1.6.0
      go.uber.org/fx v1.23.0

      // Database
      github.com/jackc/pgx/v5 v5.7.2
      github.com/sqlc-dev/sqlc v1.28.0

      // API
      github.com/ogen-go/ogen v1.7.0

      // Caching
      github.com/maypok86/otter v1.2.4
      github.com/redis/rueidis v1.0.50

      // Testing
      github.com/stretchr/testify v1.10.0
      github.com/testcontainers/testcontainers-go v0.35.0
  )
  ```

  **External Dependencies**:
  - **PostgreSQL 18+**: Database with views and generated columns
  - **Dragonfly**: Distributed cache (L2) for cross-device sync
env_vars: |
  ```bash
  # Continue Watching
  PLAYBACK_CONTINUE_WATCHING_ENABLED=true
  PLAYBACK_CONTINUE_WATCHING_DEFAULT_LIMIT=20
  PLAYBACK_CONTINUE_WATCHING_MIN_PERCENT=5    # Min progress % to show
  PLAYBACK_CONTINUE_WATCHING_MAX_PERCENT=95   # Max progress % to show
  PLAYBACK_AUTO_HIDE_DAYS=90                  # Auto-hide after X days

  # Watch Next
  PLAYBACK_WATCH_NEXT_ENABLED=true
  PLAYBACK_WATCH_NEXT_DEFAULT_LIMIT=10
  PLAYBACK_WATCH_NEXT_EXPIRY_DAYS=7           # Expire suggestions after X days

  # Progress tracking
  PLAYBACK_AUTO_MARK_WATCHED_PERCENT=90       # Auto-mark as watched at X%
  PLAYBACK_UPDATE_INTERVAL_SECONDS=10         # Min interval between progress updates
  PLAYBACK_SYNC_ACROSS_DEVICES=true           # Enable cross-device sync

  # Cleanup
  PLAYBACK_CLEANUP_INTERVAL_HOURS=24          # Run cleanup job every X hours
  PLAYBACK_CLEANUP_OLD_PROGRESS_DAYS=365      # Delete progress older than X days
  ```
config_keys: |
  ```yaml
  playback:
    # Continue Watching settings
    continue_watching:
      enabled: true
      default_limit: 20
      min_progress_percent: 5          # Don't show if < 5% watched
      max_progress_percent: 95         # Don't show if > 95% watched
      auto_hide_days: 90               # Auto-hide items not played in 90 days

    # Watch Next settings
    watch_next:
      enabled: true
      default_limit: 10
      expiry_days: 7                   # Expire old suggestions
      suggestion_types:
        - next_episode
        - similar_movie
        - continue_series
        - based_on_history

    # Progress tracking
    progress:
      auto_mark_watched_percent: 90    # Mark as watched at 90%
      update_interval_seconds: 10      # Rate-limit progress updates
      sync_across_devices: true

    # Cleanup
    cleanup:
      enabled: true
      interval_hours: 24
      delete_old_progress_days: 365
      delete_expired_suggestions: true

    # Caching
    cache:
      ttl_continue_watching: 5m
      ttl_watch_next: 10m
      ttl_user_progress: 1m
  ```
defaults: |
  - **Continue Watching Limit**: 20 items
  - **Progress Range**: Show items between 5% and 95% watched
  - **Auto-hide**: After 90 days of inactivity
  - **Watch Next Limit**: 10 suggestions
  - **Suggestion Expiry**: 7 days
  - **Auto-mark Watched**: At 90% progress
  - **Progress Update Interval**: 10 seconds (rate limiting)
  - **Cross-device Sync**: Enabled
  - **Cleanup**: Daily, delete progress older than 1 year
module_structure: |-
  ```
    internal/content/watch_next_&_continue_watching_system/
    â”œâ”€â”€ module.go              # fx module definition
    â”œâ”€â”€ repository.go          # Database operations (sqlc)
    â”œâ”€â”€ service.go             # Business logic
    â”œâ”€â”€ handler.go             # HTTP handlers (ogen)
    â”œâ”€â”€ types.go               # Domain types
    â””â”€â”€ cache.go               # Caching layer (otter)
    ```
request_examples: |
  **Update Playback Progress**:
  ```json
  POST /api/v1/playback/progress
  Content-Type: application/json
  Authorization: Bearer <token>

  {
    "content_type": "episode",
    "content_id": "123e4567-e89b-12d3-a456-426614174000",
    "position_seconds": 1250,
    "duration_seconds": 2400,
    "device_id": "web-chrome-12345",
    "device_name": "Chrome on MacBook"
  }
  ```

  **Mark as Watched**:
  ```json
  POST /api/v1/playback/progress/watched
  Content-Type: application/json
  Authorization: Bearer <token>

  {
    "content_type": "movie",
    "content_id": "550e8400-e29b-41d4-a716-446655440000"
  }
  ```

  **Reset Progress**:
  ```json
  DELETE /api/v1/playback/progress?content_type=episode&content_id=123e4567-e89b-12d3-a456-426614174000
  Authorization: Bearer <token>
  ```

  **Hide from Continue Watching**:
  ```json
  POST /api/v1/playback/continue-watching/hide
  Content-Type: application/json
  Authorization: Bearer <token>

  {
    "content_type": "episode",
    "content_id": "123e4567-e89b-12d3-a456-426614174000"
  }
  ```

  **Update Preferences**:
  ```json
  PUT /api/v1/playback/preferences
  Content-Type: application/json
  Authorization: Bearer <token>

  {
    "show_continue_watching": true,
    "show_watch_next": true,
    "max_continue_watching_items": 25,
    "max_watch_next_items": 12,
    "auto_hide_after_days": 60,
    "auto_mark_watched_percent": 85
  }
  ```

  **Dismiss Watch Next Suggestion**:
  ```json
  DELETE /api/v1/playback/watch-next/660e8400-e29b-41d4-a716-446655440000
  Authorization: Bearer <token>
  ```
response_examples: |
  **Progress Object**:
  ```json
  {
    "id": "770e8400-e29b-41d4-a716-446655440000",
    "user_id": "990e8400-e29b-41d4-a716-446655440000",
    "content_type": "episode",
    "content_id": "123e4567-e89b-12d3-a456-426614174000",
    "position_seconds": 1250,
    "duration_seconds": 2400,
    "progress_percent": 52.08,
    "is_completed": false,
    "last_device_name": "Chrome on MacBook",
    "last_played_at": "2024-06-15T19:45:00Z",
    "created_at": "2024-06-15T19:00:00Z",
    "updated_at": "2024-06-15T19:45:00Z"
  }
  ```

  **Continue Watching Response**:
  ```json
  {
    "items": [
      {
        "id": "770e8400-e29b-41d4-a716-446655440000",
        "content_type": "episode",
        "content_id": "123e4567-e89b-12d3-a456-426614174000",
        "display_title": "The Office - Dinner Party",
        "subtitle": "Season 4, Episode 13",
        "poster_url": "https://image.tmdb.org/t/p/w500/abcdef.jpg",
        "backdrop_url": "https://image.tmdb.org/t/p/w1280/xyz123.jpg",
        "position_seconds": 1250,
        "duration_seconds": 2400,
        "progress_percent": 52.08,
        "last_played_at": "2024-06-15T19:45:00Z",
        "last_device_name": "Chrome on MacBook"
      },
      {
        "id": "880e8400-e29b-41d4-a716-446655440000",
        "content_type": "movie",
        "content_id": "550e8400-e29b-41d4-a716-446655440000",
        "display_title": "Inception",
        "subtitle": null,
        "poster_url": "https://image.tmdb.org/t/p/w500/movie.jpg",
        "backdrop_url": "https://image.tmdb.org/t/p/w1280/backdrop.jpg",
        "position_seconds": 3600,
        "duration_seconds": 8880,
        "progress_percent": 40.54,
        "last_played_at": "2024-06-14T21:30:00Z",
        "last_device_name": "Roku TV"
      }
    ],
    "total": 15
  }
  ```

  **Watch Next Response**:
  ```json
  {
    "suggestions": [
      {
        "id": "aa0e8400-e29b-41d4-a716-446655440000",
        "content_type": "episode",
        "content_id": "bb0e8400-e29b-41d4-a716-446655440000",
        "suggestion_type": "next_episode",
        "display_title": "The Office - The Deposition",
        "subtitle": "Season 4, Episode 14",
        "description": "Michael is deposed in a lawsuit.",
        "poster_url": "https://image.tmdb.org/t/p/w500/next.jpg",
        "score": 95.0,
        "reason": "Next episode after 'Dinner Party'",
        "created_at": "2024-06-15T19:46:00Z"
      },
      {
        "id": "cc0e8400-e29b-41d4-a716-446655440000",
        "content_type": "episode",
        "content_id": "dd0e8400-e29b-41d4-a716-446655440000",
        "suggestion_type": "continue_series",
        "display_title": "Parks and Recreation - Pilot",
        "subtitle": "Season 1, Episode 1",
        "description": "Leslie Knope starts a new project.",
        "poster_url": "https://image.tmdb.org/t/p/w500/parks.jpg",
        "score": 85.0,
        "reason": "Similar to 'The Office'",
        "created_at": "2024-06-15T19:46:00Z"
      }
    ],
    "total": 8
  }
  ```

  **Preferences Object**:
  ```json
  {
    "user_id": "990e8400-e29b-41d4-a716-446655440000",
    "show_continue_watching": true,
    "show_watch_next": true,
    "max_continue_watching_items": 20,
    "max_watch_next_items": 10,
    "auto_hide_after_days": 90,
    "auto_mark_watched_percent": 90,
    "sync_across_devices": true,
    "created_at": "2024-01-01T00:00:00Z",
    "updated_at": "2024-06-15T10:00:00Z"
  }
  ```
unit_tests: |
  **ProgressRepository Layer**:
  - Test CRUD operations for playback progress
  - Test upsert behavior (create vs update)
  - Test progress calculation (percent from position/duration)
  - Test mark completed/incomplete
  - Test Continue Watching filtering (5-95% range)
  - Test old progress deletion
  - Test auto-mark watched by percentage
  - Test hidden content CRUD
  - Test preferences CRUD
  - Mock database with sqlc.Querier interface

  **WatchNextRepository Layer**:
  - Test suggestion CRUD operations
  - Test suggestion filtering (active, not dismissed, not expired)
  - Test scoring and ordering
  - Test expiry logic
  - Mock database with sqlc.Querier interface

  **ProgressService Layer**:
  - Test progress update with rate limiting
  - Test progress retrieval with caching
  - Test mark watched/unwatched
  - Test batch reset operations
  - Test device tracking
  - Mock repository

  **ContinueWatchingService Layer**:
  - Test Continue Watching list generation
  - Test filtering by preferences (min/max percent)
  - Test hiding/unhiding content
  - Test auto-hide by date
  - Test preference updates
  - Mock repository and cache

  **WatchNextService Layer**:
  - Test Watch Next list generation
  - Test suggestion dismissal
  - Test suggestion refresh
  - Mock repository and suggestion engine

  **SuggestionEngine**:
  - Test next episode detection (same series, next episode)
  - Test similar movie suggestions (genre/cast matching)
  - Test continue series suggestions (incomplete series)
  - Test history-based suggestions
  - Test scoring algorithm
  - Mock content repositories

  **Handler Layer**:
  - Test request validation (ogen schemas)
  - Test authentication and authorization
  - Test rate limiting on progress updates
  - Test error responses
  - Mock service layer

  **Coverage Target**: 85%+ for critical paths (progress tracking, suggestions)
integration_tests: |
  **Database Integration**:
  - Test full progress lifecycle with real PostgreSQL (testcontainers)
  - Test Continue Watching view with joins across content types
  - Test generated columns (progress_percent)
  - Test unique constraints (user_id + content_type + content_id)
  - Test cascade deletions
  - Test migration up/down

  **Progress Tracking Integration**:
  - Test end-to-end progress update flow
  - Test concurrent progress updates from multiple devices
  - Test auto-mark watched at threshold
  - Test progress cleanup job

  **Continue Watching Integration**:
  - Test Continue Watching list with real mixed content (movies, episodes, audiobooks)
  - Test hiding/unhiding flow
  - Test preference-based filtering
  - Test auto-hide by date

  **Watch Next Integration**:
  - Test next episode suggestion generation
  - Test similar content suggestions
  - Test suggestion expiry job
  - Test suggestion dismissal

  **Cross-device Sync**:
  - Test progress update on device A appears on device B (via cache invalidation)
  - Test device tracking
  - Test last_played_at ordering

  **Cache Integration**:
  - Test cache invalidation on progress update
  - Test cache TTL expiry
  - Test cache warming for Continue Watching

  **API Integration**:
  - Test full progress update flow (HTTP â†’ service â†’ database â†’ cache)
  - Test Continue Watching endpoint with authentication
  - Test Watch Next endpoint
  - Test preference updates

  **Performance Tests**:
  - Test Continue Watching query performance (user with 1000+ progress records)
  - Test concurrent progress updates (100+ simultaneous requests)
  - Test suggestion generation performance
test_coverage_target: 80%
api_endpoints:
- method: GET
  path: /api/v1/playback/continue-watching
  description: Get Continue Watching list
- method: POST
  path: /api/v1/playback/progress
  description: Update playback progress
- method: GET
  path: /api/v1/playback/progress
  description: Get playback progress for content
- method: DELETE
  path: /api/v1/playback/progress
  description: Reset playback progress
- method: POST
  path: /api/v1/playback/progress/watched
  description: Mark content as watched
- method: POST
  path: /api/v1/playback/continue-watching/hide
  description: Hide content from Continue Watching
- method: POST
  path: /api/v1/playback/continue-watching/unhide
  description: Unhide content from Continue Watching
- method: GET
  path: /api/v1/playback/watch-next
  description: Get Watch Next suggestions
- method: DELETE
  path: /api/v1/playback/watch-next/:id
  description: Dismiss a Watch Next suggestion
- method: POST
  path: /api/v1/playback/watch-next/refresh
  description: Refresh Watch Next suggestions
- method: GET
  path: /api/v1/playback/preferences
  description: Get user playback preferences
- method: PUT
  path: /api/v1/playback/preferences
  description: Update user playback preferences
component_interaction: |-
  1. Client requests resource via HTTP
    2. API handler validates and routes to service
    3. Service checks cache, queries repository if needed
    4. Repository executes SQL via sqlc
    5. Results return through layers to client
