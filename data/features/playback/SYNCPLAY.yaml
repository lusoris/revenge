doc_title: SyncPlay (Watch Together)
doc_category: feature
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Synchronized playback for multiple users watching together'
wiki_tagline: '> Synchronized playback for multiple users watching together'
wiki_overview: Watch movies and shows together with friends, even when apart. SyncPlay keeps everyone at the same playback
  position in real-time via WebSocket. Create a room, share the link, and playback syncs automatically. Pause/play/seek actions
  sync to all participants. Built-in chat for commentary during viewing.
sources:
- name: Go sync
  url: https://pkg.go.dev/sync
  note: Auto-resolved from go-sync
- name: Jellyfin SyncPlay
  url: https://jellyfin.org/docs/general/server/syncplay/
  note: Auto-resolved from jellyfin-syncplay
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
feature_name: SyncPlay (Watch Together)
module_name: syncplay_(watch_together)
schema_name: public
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1(["Client<br/>(Web/App)"])
      node2[["API Handler<br/>(ogen)"]]
      node3[["Service<br/>(Logic)"]]
      node4["Repository<br/>(sqlc)"]
      node5[["Metadata<br/>Service"]]
      node6[("Cache<br/>(otter)")]
      node7[("PostgreSQL<br/>(pgx)")]
      node8(["External<br/>APIs"])
      node1 --> node2
      node2 --> node3
      node4 --> node5
      node5 --> node6
      node7 --> node8
      node3 --> node4
      node6 --> node7
  ```
database_schema: |
  **Schema**: `public`

  **Tables**:

  ```sql
  -- SyncPlay rooms
  CREATE TABLE syncplay_rooms (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      name TEXT NOT NULL,
      owner_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

      -- Content being watched
      content_type TEXT NOT NULL,  -- 'movie', 'episode'
      content_id UUID NOT NULL,

      -- Room settings
      is_public BOOLEAN DEFAULT false,
      password_hash TEXT,  -- Bcrypt hash if password-protected
      max_participants INTEGER DEFAULT 50,

      -- Playback state
      current_position_seconds NUMERIC(10,3) DEFAULT 0,
      is_playing BOOLEAN DEFAULT false,
      playback_rate NUMERIC(3,2) DEFAULT 1.0,  -- 0.25x to 2.0x
      last_state_update_at TIMESTAMPTZ DEFAULT NOW(),
      last_state_update_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL,

      -- Leader settings
      leader_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
      leader_control_mode TEXT DEFAULT 'shared',  -- 'leader_only', 'shared'

      -- Chat settings
      chat_enabled BOOLEAN DEFAULT true,

      -- Status
      status TEXT NOT NULL DEFAULT 'active',  -- 'active', 'ended'
      ended_at TIMESTAMPTZ,

      -- Metadata
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

      CONSTRAINT syncplay_rooms_max_participants_check CHECK (max_participants BETWEEN 1 AND 1000),
      CONSTRAINT syncplay_rooms_playback_rate_check CHECK (playback_rate BETWEEN 0.25 AND 2.0)
  );

  CREATE INDEX idx_syncplay_rooms_owner ON syncplay_rooms(owner_user_id);
  CREATE INDEX idx_syncplay_rooms_status ON syncplay_rooms(status) WHERE status = 'active';
  CREATE INDEX idx_syncplay_rooms_public ON syncplay_rooms(is_public) WHERE is_public = true AND status = 'active';
  CREATE INDEX idx_syncplay_rooms_content ON syncplay_rooms(content_type, content_id);

  -- Room participants
  CREATE TABLE syncplay_participants (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      room_id UUID NOT NULL REFERENCES syncplay_rooms(id) ON DELETE CASCADE,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

      -- Connection state
      is_connected BOOLEAN DEFAULT true,
      connected_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      disconnected_at TIMESTAMPTZ,
      last_seen_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

      -- Client state
      client_position_seconds NUMERIC(10,3) DEFAULT 0,
      client_is_playing BOOLEAN DEFAULT false,
      client_is_buffering BOOLEAN DEFAULT false,
      ping_ms INTEGER,  -- Latency to server

      -- Permissions
      can_control BOOLEAN DEFAULT true,  -- Can play/pause/seek
      is_muted BOOLEAN DEFAULT false,  -- Muted in chat

      -- Metadata
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

      UNIQUE(room_id, user_id)
  );

  CREATE INDEX idx_syncplay_participants_room ON syncplay_participants(room_id);
  CREATE INDEX idx_syncplay_participants_user ON syncplay_participants(user_id);
  CREATE INDEX idx_syncplay_participants_connected ON syncplay_participants(room_id, is_connected)
      WHERE is_connected = true;

  -- Chat messages
  CREATE TABLE syncplay_chat_messages (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      room_id UUID NOT NULL REFERENCES syncplay_rooms(id) ON DELETE CASCADE,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      message TEXT NOT NULL,
      timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),

      CONSTRAINT syncplay_chat_message_length_check CHECK (char_length(message) BETWEEN 1 AND 1000)
  );

  CREATE INDEX idx_syncplay_chat_room ON syncplay_chat_messages(room_id, timestamp DESC);

  -- Playback events log (for debugging and replay)
  CREATE TABLE syncplay_events (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      room_id UUID NOT NULL REFERENCES syncplay_rooms(id) ON DELETE CASCADE,
      user_id UUID REFERENCES users(id) ON DELETE SET NULL,

      -- Event details
      event_type TEXT NOT NULL,  -- 'play', 'pause', 'seek', 'join', 'leave', 'buffer_start', 'buffer_end'
      event_data JSONB,

      -- Playback state at event time
      position_seconds NUMERIC(10,3),
      is_playing BOOLEAN,

      timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
  );

  CREATE INDEX idx_syncplay_events_room ON syncplay_events(room_id, timestamp DESC);
  CREATE INDEX idx_syncplay_events_type ON syncplay_events(event_type);

  -- Room invitations
  CREATE TABLE syncplay_invitations (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      room_id UUID NOT NULL REFERENCES syncplay_rooms(id) ON DELETE CASCADE,
      invited_by_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      invited_user_id UUID REFERENCES users(id) ON DELETE CASCADE,  -- NULL if invite link
      invite_code TEXT UNIQUE,  -- Random code for share links
      expires_at TIMESTAMPTZ,

      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
  );

  CREATE INDEX idx_syncplay_invitations_room ON syncplay_invitations(room_id);
  CREATE INDEX idx_syncplay_invitations_code ON syncplay_invitations(invite_code)
      WHERE invite_code IS NOT NULL AND (expires_at IS NULL OR expires_at > NOW());
  ```

  **Indexes**: Optimized for:
  - Room lookups by owner, content, status
  - Public room browsing
  - Participant room membership
  - Connected participant queries
  - Chat message retrieval
  - Event log queries
  - Invitation code lookups
file_structure: |
  ```
  internal/playback/syncplay/
  â”œâ”€â”€ module.go                    # fx module registration
  â”œâ”€â”€ repository.go                # Database operations (sqlc)
  â”œâ”€â”€ queries.sql                  # SQL queries for sqlc
  â”œâ”€â”€ service.go                   # Business logic
  â”œâ”€â”€ handler.go                   # HTTP/WebSocket handlers
  â”œâ”€â”€ types.go                     # Domain types
  â”œâ”€â”€ room_manager.go              # Room lifecycle management
  â”œâ”€â”€ sync_engine.go               # Playback synchronization logic
  â”œâ”€â”€ websocket.go                 # WebSocket connection handling
  â”œâ”€â”€ chat.go                      # Chat functionality
  â”œâ”€â”€ events.go                    # Event logging and broadcasting
  â””â”€â”€ cache.go                     # Caching layer (otter)

  cmd/server/
  â””â”€â”€ main.go                      # Server entry point with fx

  migrations/
  â”œâ”€â”€ 033_syncplay.up.sql          # SyncPlay tables
  â””â”€â”€ 033_syncplay.down.sql        # Rollback

  api/openapi/
  â””â”€â”€ syncplay.yaml                # OpenAPI spec (HTTP endpoints)

  web/src/lib/components/syncplay/
  â”œâ”€â”€ SyncPlayRoom.svelte          # Room UI
  â”œâ”€â”€ ParticipantsList.svelte      # Participants sidebar
  â”œâ”€â”€ SyncPlayChat.svelte          # Chat panel
  â”œâ”€â”€ SyncPlayControls.svelte      # Playback controls
  â””â”€â”€ SyncPlayInvite.svelte        # Invite dialog
  ```
key_interfaces: |
  ```go
  // Repository interface for syncplay database operations
  type Repository interface {
      // Rooms
      CreateRoom(ctx context.Context, params CreateRoomParams) (*SyncPlayRoom, error)
      GetRoom(ctx context.Context, id uuid.UUID) (*SyncPlayRoom, error)
      ListRooms(ctx context.Context, filters RoomFilters, limit, offset int) ([]*SyncPlayRoom, int64, error)
      UpdateRoom(ctx context.Context, id uuid.UUID, params UpdateRoomParams) (*SyncPlayRoom, error)
      UpdatePlaybackState(ctx context.Context, roomID uuid.UUID, position float64, isPlaying bool, userID uuid.UUID) error
      EndRoom(ctx context.Context, id uuid.UUID) error
      DeleteRoom(ctx context.Context, id uuid.UUID) error

      // Participants
      AddParticipant(ctx context.Context, roomID, userID uuid.UUID) (*SyncPlayParticipant, error)
      GetParticipant(ctx context.Context, roomID, userID uuid.UUID) (*SyncPlayParticipant, error)
      ListParticipants(ctx context.Context, roomID uuid.UUID, connectedOnly bool) ([]*SyncPlayParticipant, error)
      UpdateParticipantState(ctx context.Context, roomID, userID uuid.UUID, params UpdateParticipantParams) error
      RemoveParticipant(ctx context.Context, roomID, userID uuid.UUID) error
      UpdateParticipantConnection(ctx context.Context, roomID, userID uuid.UUID, isConnected bool) error

      // Chat
      CreateChatMessage(ctx context.Context, roomID, userID uuid.UUID, message string) (*SyncPlayChatMessage, error)
      GetChatMessages(ctx context.Context, roomID uuid.UUID, limit, offset int) ([]*SyncPlayChatMessage, error)
      DeleteChatMessage(ctx context.Context, id uuid.UUID) error

      // Events
      LogEvent(ctx context.Context, params LogEventParams) error
      GetEvents(ctx context.Context, roomID uuid.UUID, limit, offset int) ([]*SyncPlayEvent, error)

      // Invitations
      CreateInvitation(ctx context.Context, params CreateInvitationParams) (*SyncPlayInvitation, error)
      GetInvitationByCode(ctx context.Context, code string) (*SyncPlayInvitation, error)
      DeleteInvitation(ctx context.Context, id uuid.UUID) error
      CleanupExpiredInvitations(ctx context.Context) (int64, error)
  }

  // Service interface for syncplay operations
  type Service interface {
      // Room management
      CreateRoom(ctx context.Context, userID uuid.UUID, req CreateRoomRequest) (*SyncPlayRoom, error)
      GetRoom(ctx context.Context, roomID uuid.UUID) (*SyncPlayRoomDetail, error)
      ListRooms(ctx context.Context, filters RoomFilters) (*RoomListResponse, error)
      EndRoom(ctx context.Context, roomID, userID uuid.UUID) error
      UpdateRoomSettings(ctx context.Context, roomID, userID uuid.UUID, updates RoomSettingsUpdate) (*SyncPlayRoom, error)

      // Joining/leaving
      JoinRoom(ctx context.Context, userID uuid.UUID, req JoinRoomRequest) (*JoinRoomResponse, error)
      LeaveRoom(ctx context.Context, roomID, userID uuid.UUID) error

      // Invitations
      CreateInvitation(ctx context.Context, roomID, userID uuid.UUID, invitedUserID *uuid.UUID, expiresIn *time.Duration) (*SyncPlayInvitation, error)
      ValidateInvitation(ctx context.Context, code string) (*SyncPlayRoom, error)

      // Chat
      SendChatMessage(ctx context.Context, roomID, userID uuid.UUID, message string) error
      GetChatHistory(ctx context.Context, roomID uuid.UUID, pagination Pagination) (*ChatHistoryResponse, error)
  }

  // RoomManager interface for room lifecycle
  type RoomManager interface {
      CreateRoom(roomID uuid.UUID, contentType string, contentID uuid.UUID, ownerID uuid.UUID) error
      GetRoom(roomID uuid.UUID) (*Room, error)
      CloseRoom(roomID uuid.UUID) error
      BroadcastToRoom(roomID uuid.UUID, event RoomEvent) error
  }

  // SyncEngine interface for playback synchronization
  type SyncEngine interface {
      HandlePlaybackCommand(ctx context.Context, roomID, userID uuid.UUID, cmd PlaybackCommand) error
      SyncParticipant(ctx context.Context, roomID, userID uuid.UUID, clientState ClientState) (*SyncResponse, error)
      CalculateSyncOffset(roomState *RoomState, clientState *ClientState) (offset float64, shouldSync bool)
  }

  // WebSocketManager interface for WebSocket connections
  type WebSocketManager interface {
      HandleConnection(conn *websocket.Conn, userID uuid.UUID, roomID uuid.UUID) error
      SendToUser(roomID, userID uuid.UUID, message interface{}) error
      SendToRoom(roomID uuid.UUID, message interface{}, excludeUserID *uuid.UUID) error
      DisconnectUser(roomID, userID uuid.UUID) error
  }
  ```
dependencies: |
  **Go Packages**:
  ```go
  require (
      // Core
      github.com/google/uuid v1.6.0
      go.uber.org/fx v1.23.0

      // Database
      github.com/jackc/pgx/v5 v5.7.2
      github.com/sqlc-dev/sqlc v1.28.0

      // API
      github.com/ogen-go/ogen v1.7.0

      // WebSocket
      github.com/gorilla/websocket v1.5.3

      // Caching
      github.com/maypok86/otter v1.2.4

      // Password hashing
      golang.org/x/crypto v0.31.0

      // Testing
      github.com/stretchr/testify v1.10.0
      github.com/testcontainers/testcontainers-go v0.35.0
  )
  ```

  **External Dependencies**:
  - **PostgreSQL 18+**: Database
  - **WebSocket**: Real-time communication
env_vars: |
  ```bash
  # SyncPlay settings
  SYNCPLAY_ENABLED=true
  SYNCPLAY_DEFAULT_MAX_PARTICIPANTS=50
  SYNCPLAY_MAX_ROOM_AGE_HOURS=24         # Auto-end inactive rooms

  # Sync settings
  SYNCPLAY_SYNC_THRESHOLD_SECONDS=2      # Sync if offset > 2 seconds
  SYNCPLAY_HEARTBEAT_INTERVAL_SECONDS=5  # Client heartbeat interval
  SYNCPLAY_DISCONNECT_TIMEOUT_SECONDS=30 # Mark disconnected after X seconds

  # Chat settings
  SYNCPLAY_CHAT_ENABLED=true
  SYNCPLAY_CHAT_MAX_MESSAGE_LENGTH=1000
  SYNCPLAY_CHAT_HISTORY_LIMIT=100

  # Room settings
  SYNCPLAY_ALLOW_PUBLIC_ROOMS=true
  SYNCPLAY_ALLOW_PASSWORD_ROOMS=true
  SYNCPLAY_INVITE_EXPIRY_HOURS=24

  # WebSocket
  SYNCPLAY_WS_READ_BUFFER_SIZE=4096
  SYNCPLAY_WS_WRITE_BUFFER_SIZE=4096
  SYNCPLAY_WS_PING_INTERVAL_SECONDS=30
  SYNCPLAY_WS_PONG_TIMEOUT_SECONDS=60
  ```
config_keys: |
  ```yaml
  syncplay:
    # Feature toggle
    enabled: true

    # Room settings
    rooms:
      default_max_participants: 50
      max_room_age_hours: 24
      allow_public: true
      allow_password_protected: true

    # Synchronization
    sync:
      threshold_seconds: 2          # Sync if offset > 2 sec
      heartbeat_interval_seconds: 5
      disconnect_timeout_seconds: 30
      max_latency_ms: 500           # Warn if latency > 500ms

    # Chat
    chat:
      enabled: true
      max_message_length: 1000
      history_limit: 100
      rate_limit_messages_per_minute: 60

    # Invitations
    invitations:
      default_expiry_hours: 24
      code_length: 8

    # WebSocket
    websocket:
      read_buffer_size: 4096
      write_buffer_size: 4096
      ping_interval_seconds: 30
      pong_timeout_seconds: 60
      max_connections_per_user: 5

    # Cleanup
    cleanup:
      inactive_rooms_hours: 24
      expired_invitations_hours: 48
  ```
defaults: |
  - **Max Participants**: 50 per room
  - **Sync Threshold**: 2 seconds offset
  - **Heartbeat Interval**: 5 seconds
  - **Disconnect Timeout**: 30 seconds
  - **Chat Message Length**: 1000 characters
  - **Chat History**: 100 messages
  - **Invite Expiry**: 24 hours
  - **Room Auto-end**: 24 hours of inactivity
  - **WebSocket Ping**: Every 30 seconds
module_structure: |-
  ```
    internal/content/syncplay_(watch_together)/
    â”œâ”€â”€ module.go              # fx module definition
    â”œâ”€â”€ repository.go          # Database operations (sqlc)
    â”œâ”€â”€ service.go             # Business logic
    â”œâ”€â”€ handler.go             # HTTP handlers (ogen)
    â”œâ”€â”€ types.go               # Domain types
    â””â”€â”€ cache.go               # Caching layer (otter)
    ```
request_examples: |
  **Create Room**:
  ```json
  POST /api/v1/syncplay/rooms
  Content-Type: application/json
  Authorization: Bearer <token>

  {
    "name": "Movie Night with Friends",
    "content_type": "movie",
    "content_id": "123e4567-e89b-12d3-a456-426614174000",
    "is_public": false,
    "password": "secret123",
    "max_participants": 10,
    "chat_enabled": true,
    "leader_control_mode": "shared"
  }
  ```

  **Join Room**:
  ```json
  POST /api/v1/syncplay/rooms/550e8400-e29b-41d4-a716-446655440000/join
  Content-Type: application/json
  Authorization: Bearer <token>

  {
    "password": "secret123"
  }
  ```

  **Leave Room**:
  ```json
  POST /api/v1/syncplay/rooms/550e8400-e29b-41d4-a716-446655440000/leave
  Authorization: Bearer <token>
  ```

  **Create Invitation**:
  ```json
  POST /api/v1/syncplay/rooms/550e8400-e29b-41d4-a716-446655440000/invitations
  Content-Type: application/json
  Authorization: Bearer <token>

  {
    "invited_user_id": "660e8400-e29b-41d4-a716-446655440000",
    "expires_in_hours": 48
  }
  ```

  **Send Chat Message**:
  ```json
  POST /api/v1/syncplay/rooms/550e8400-e29b-41d4-a716-446655440000/chat
  Content-Type: application/json
  Authorization: Bearer <token>

  {
    "message": "This scene is amazing!"
  }
  ```

  **WebSocket Connection** (example):
  ```javascript
  // Connect to SyncPlay WebSocket
  const ws = new WebSocket('wss://revenge.local/api/v1/syncplay/ws?room_id=550e8400&token=<jwt>');

  // Send playback command
  ws.send(JSON.stringify({
    type: 'playback_command',
    command: 'play',
    position: 1234.5
  }));

  // Send client state (heartbeat)
  ws.send(JSON.stringify({
    type: 'client_state',
    position: 1245.8,
    is_playing: true,
    is_buffering: false,
    ping_ms: 45
  }));

  // Receive sync response
  ws.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    if (msg.type === 'sync_response') {
      // Sync to position: msg.target_position
      // Set playing: msg.should_be_playing
    }
  };
  ```
response_examples: |
  **Room Object**:
  ```json
  {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "Movie Night with Friends",
    "owner_user_id": "770e8400-e29b-41d4-a716-446655440000",
    "content_type": "movie",
    "content_id": "123e4567-e89b-12d3-a456-426614174000",
    "content_title": "Inception",
    "content_poster_url": "https://image.tmdb.org/t/p/w500/inception.jpg",
    "is_public": false,
    "has_password": true,
    "max_participants": 10,
    "participant_count": 4,
    "current_position_seconds": 1234.5,
    "is_playing": true,
    "playback_rate": 1.0,
    "leader_user_id": "770e8400-e29b-41d4-a716-446655440000",
    "leader_control_mode": "shared",
    "chat_enabled": true,
    "status": "active",
    "created_at": "2024-06-15T19:00:00Z",
    "updated_at": "2024-06-15T19:30:00Z"
  }
  ```

  **Join Room Response**:
  ```json
  {
    "room": {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "Movie Night with Friends",
      "content_type": "movie",
      "content_id": "123e4567-e89b-12d3-a456-426614174000",
      "current_position_seconds": 1234.5,
      "is_playing": true
    },
    "websocket_url": "wss://revenge.local/api/v1/syncplay/ws?room_id=550e8400&token=<jwt>",
    "participants": [
      {
        "user_id": "770e8400-e29b-41d4-a716-446655440000",
        "username": "alice",
        "is_connected": true,
        "is_leader": true
      },
      {
        "user_id": "880e8400-e29b-41d4-a716-446655440000",
        "username": "bob",
        "is_connected": true,
        "is_leader": false
      }
    ]
  }
  ```

  **Participant Object**:
  ```json
  {
    "id": "aa0e8400-e29b-41d4-a716-446655440000",
    "user_id": "770e8400-e29b-41d4-a716-446655440000",
    "username": "alice",
    "is_connected": true,
    "connected_at": "2024-06-15T19:00:00Z",
    "client_position_seconds": 1234.8,
    "client_is_playing": true,
    "client_is_buffering": false,
    "ping_ms": 45,
    "can_control": true,
    "is_muted": false
  }
  ```

  **Chat Message Object**:
  ```json
  {
    "id": "bb0e8400-e29b-41d4-a716-446655440000",
    "user_id": "770e8400-e29b-41d4-a716-446655440000",
    "username": "alice",
    "message": "This scene is amazing!",
    "timestamp": "2024-06-15T19:25:30Z"
  }
  ```

  **WebSocket Message Types**:
  ```json
  // Playback state update (broadcast to all)
  {
    "type": "playback_state",
    "position": 1234.5,
    "is_playing": true,
    "playback_rate": 1.0,
    "updated_by_user_id": "770e8400-e29b-41d4-a716-446655440000",
    "timestamp": "2024-06-15T19:25:30Z"
  }

  // Sync response (to specific client)
  {
    "type": "sync_response",
    "target_position": 1235.0,
    "should_be_playing": true,
    "offset_seconds": 0.5,
    "should_sync": true
  }

  // Participant joined (broadcast)
  {
    "type": "participant_joined",
    "user_id": "990e8400-e29b-41d4-a716-446655440000",
    "username": "charlie"
  }

  // Participant left (broadcast)
  {
    "type": "participant_left",
    "user_id": "990e8400-e29b-41d4-a716-446655440000",
    "username": "charlie"
  }

  // Chat message (broadcast)
  {
    "type": "chat_message",
    "message_id": "bb0e8400-e29b-41d4-a716-446655440000",
    "user_id": "770e8400-e29b-41d4-a716-446655440000",
    "username": "alice",
    "message": "This scene is amazing!",
    "timestamp": "2024-06-15T19:25:30Z"
  }
  ```

  **Invitation Object**:
  ```json
  {
    "id": "cc0e8400-e29b-41d4-a716-446655440000",
    "room_id": "550e8400-e29b-41d4-a716-446655440000",
    "invite_code": "ABC123XY",
    "invite_url": "https://revenge.local/syncplay/join/ABC123XY",
    "expires_at": "2024-06-16T19:00:00Z",
    "created_at": "2024-06-15T19:00:00Z"
  }
  ```
unit_tests: |
  **Repository Layer**:
  - Test CRUD operations for rooms
  - Test playback state updates
  - Test participant add/remove
  - Test participant connection state updates
  - Test chat message storage
  - Test event logging
  - Test invitation CRUD
  - Mock database with sqlc.Querier interface

  **Service Layer**:
  - Test room creation with validation
  - Test join room (password verification, capacity limits)
  - Test leave room
  - Test invitation creation and validation
  - Test chat message sending
  - Mock repository

  **RoomManager**:
  - Test room lifecycle (create, get, close)
  - Test broadcasting to room participants
  - Test concurrent room access
  - Mock WebSocket manager

  **SyncEngine**:
  - Test playback command handling (play, pause, seek)
  - Test sync offset calculation
  - Test leader control modes
  - Test playback rate sync
  - Test buffering handling
  - Mock room state

  **WebSocketManager**:
  - Test WebSocket connection handling
  - Test message broadcasting to room
  - Test message sending to specific user
  - Test connection cleanup on disconnect
  - Test ping/pong heartbeat
  - Mock WebSocket connections

  **Handler Layer**:
  - Test HTTP request validation (ogen schemas)
  - Test WebSocket upgrade
  - Test authentication and authorization
  - Test error responses
  - Mock service layer

  **Coverage Target**: 85%+ for critical paths (sync, WebSocket)
integration_tests: |
  **Database Integration**:
  - Test full room lifecycle with real PostgreSQL (testcontainers)
  - Test concurrent participant updates
  - Test playback state consistency
  - Test chat message ordering
  - Test event log queries
  - Test migration up/down

  **WebSocket Integration**:
  - Test real WebSocket connections
  - Test multi-client synchronization
  - Test connection recovery
  - Test message broadcasting
  - Test ping/pong heartbeat

  **Synchronization Integration**:
  - Test play/pause sync across clients
  - Test seek sync across clients
  - Test playback rate sync
  - Test buffering handling
  - Test latency compensation

  **Room Integration**:
  - Test room creation and joining
  - Test participant limit enforcement
  - Test password verification
  - Test leader control modes
  - Test room cleanup

  **Chat Integration**:
  - Test chat message delivery
  - Test chat history retrieval
  - Test message rate limiting
  - Test message length validation

  **API Integration**:
  - Test full flow (HTTP â†’ WebSocket â†’ sync â†’ broadcast)
  - Test authentication for WebSocket upgrade
  - Test room invitation flow
  - Test concurrent room operations

  **Performance Tests**:
  - Test synchronization with 50 participants
  - Test message broadcasting latency
  - Test concurrent room creation (100 rooms)
  - Test WebSocket connection limits

  **Stress Tests**:
  - Test rapid playback commands
  - Test high-frequency position updates
  - Test chat message flood
  - Test participant churn (join/leave)
test_coverage_target: 80%
api_endpoints:
- method: GET
  path: /api/v1/syncplay/rooms
  description: List SyncPlay rooms
- method: POST
  path: /api/v1/syncplay/rooms
  description: Create a new room
- method: GET
  path: /api/v1/syncplay/rooms/:id
  description: Get room details
- method: PUT
  path: /api/v1/syncplay/rooms/:id
  description: Update room settings
- method: DELETE
  path: /api/v1/syncplay/rooms/:id
  description: End/delete room
- method: POST
  path: /api/v1/syncplay/rooms/:id/join
  description: Join a room
- method: POST
  path: /api/v1/syncplay/rooms/:id/leave
  description: Leave a room
- method: GET
  path: /api/v1/syncplay/rooms/:id/participants
  description: List room participants
- method: POST
  path: /api/v1/syncplay/rooms/:id/chat
  description: Send chat message
- method: GET
  path: /api/v1/syncplay/rooms/:id/chat
  description: Get chat history
- method: POST
  path: /api/v1/syncplay/rooms/:id/invitations
  description: Create invitation
- method: GET
  path: /api/v1/syncplay/invitations/:code
  description: Get invitation details
- method: WS
  path: /api/v1/syncplay/ws
  description: WebSocket connection for real-time sync
component_interaction: |-
  1. Client requests resource via HTTP
    2. API handler validates and routes to service
    3. Service checks cache, queries repository if needed
    4. Repository executes SQL via sqlc
    5. Results return through layers to client
