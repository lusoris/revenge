doc_title: Podcasts
doc_category: feature
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: |-
  > RSS podcast subscription and playback

  Complete podcast experience:
  - **RSS Feed Support**: Subscribe to any podcast via RSS/Atom feeds
  - **Automatic Updates**: Background jobs refresh feeds and download new episodes
  - **Playback Features**: Variable speed, chapter navigation, sleep timer
  - **Offline Support**: Download episodes for offline listening
  - **Discovery**: Search and browse podcasts via Podcast Index API
wiki_tagline: '> Your podcast library with automatic updates and offline downloads'
wiki_overview: The Podcasts Module provides a complete podcast listening experience with RSS feed subscriptions, automatic
  episode updates, and offline downloads. Subscribe to your favorite podcasts, get notified of new episodes, and listen with
  variable speed playback and chapter navigation. All episodes are automatically organized and ready to play across all your
  devices.
sources:
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: ogen OpenAPI Generator
  url: https://pkg.go.dev/github.com/ogen-go/ogen
  note: Auto-resolved from ogen
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: sqlc
  url: https://docs.sqlc.dev/en/stable/
  note: Auto-resolved from sqlc
- name: sqlc Configuration
  url: https://docs.sqlc.dev/en/stable/reference/config.html
  note: Auto-resolved from sqlc-config
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
feature_name: Podcasts
module_name: podcasts
schema_name: public
content_types:
- Podcasts
- Episodes
rss_feed_support:
  formats:
  - RSS 2.0
  - Atom
  - Podcast RSS (with iTunes extensions)
  discovery:
  - Podcast Index API (search and discovery)
  - Manual RSS URL subscription
  - Import OPML feed lists
  metadata_extraction:
  - Title, description, author
  - Artwork (feed and episode level)
  - Categories and keywords
  - Episode duration and file size
  - Publication dates
  - Chapter markers (if present)
automatic_updates:
  refresh_strategy:
    method: Background jobs via River
    frequency: Every 1-6 hours (configurable per podcast)
    checks: Check RSS feed for new episodes
  download_behavior:
    automatic: Download latest N episodes automatically (configurable)
    manual: User-triggered downloads
    storage: Local file storage with cleanup policies
  notifications:
    new_episodes: Push notifications for subscribed podcasts
    download_complete: Notify when episode download finishes
database_schema: |
  **Schema**: `public`

  **Tables**:
  - `podcasts`: Podcast feed metadata
  - `podcast_episodes`: Individual episode metadata
  - `podcast_episode_files`: Downloaded episode files
  - `podcast_subscriptions`: User subscriptions to podcasts
  - `podcast_playback_progress`: Per-user episode progress
  - `podcast_categories`: Podcast categories/genres
  - `podcast_feed_cache`: Cached RSS feed data
  - `podcast_downloads`: Download queue and status

  **Key Columns** (`podcasts`):
  - `id` (UUID): Primary key
  - `title` (TEXT): Podcast title
  - `description` (TEXT): Podcast description
  - `author` (TEXT): Podcast author/creator
  - `rss_url` (TEXT): RSS feed URL (unique)
  - `website_url` (TEXT): Podcast website
  - `image_url` (TEXT): Podcast artwork URL
  - `image_path` (TEXT): Cached artwork path
  - `language` (TEXT): Language code (ISO 639-1)
  - `categories` (TEXT[]): Category tags
  - `explicit` (BOOLEAN): Explicit content flag
  - `last_fetched_at` (TIMESTAMPTZ): Last RSS fetch time
  - `last_published_at` (TIMESTAMPTZ): Last episode publish time
  - `refresh_interval` (INTEGER): Refresh frequency in seconds
  - `podcast_index_id` (BIGINT): Podcast Index ID
  - `created_at` (TIMESTAMPTZ): Record creation time
  - `updated_at` (TIMESTAMPTZ): Last update time

  **Key Columns** (`podcast_episodes`):
  - `id` (UUID): Primary key
  - `podcast_id` (UUID): Podcast foreign key
  - `title` (TEXT): Episode title
  - `description` (TEXT): Episode description
  - `guid` (TEXT): Episode GUID (unique)
  - `episode_number` (INTEGER): Episode number (nullable)
  - `season_number` (INTEGER): Season number (nullable)
  - `episode_type` (TEXT): full, trailer, bonus
  - `published_at` (TIMESTAMPTZ): Publication timestamp
  - `duration` (INTEGER): Duration in seconds
  - `file_url` (TEXT): Audio file URL
  - `file_size` (BIGINT): File size in bytes
  - `file_type` (TEXT): MIME type
  - `image_url` (TEXT): Episode-specific artwork URL
  - `image_path` (TEXT): Cached episode artwork path
  - `chapters` (JSONB): Chapter markers (Podcasting 2.0)
  - `transcript_url` (TEXT): Transcript URL (if available)
  - `created_at` (TIMESTAMPTZ): Record creation time

  **Key Columns** (`podcast_subscriptions`):
  - `id` (UUID): Primary key
  - `user_id` (UUID): User foreign key
  - `podcast_id` (UUID): Podcast foreign key
  - `auto_download` (BOOLEAN): Auto-download new episodes
  - `download_limit` (INTEGER): Max episodes to auto-download
  - `notifications_enabled` (BOOLEAN): Notify on new episodes
  - `subscribed_at` (TIMESTAMPTZ): Subscription timestamp

  **Key Columns** (`podcast_playback_progress`):
  - `id` (UUID): Primary key
  - `user_id` (UUID): User foreign key
  - `episode_id` (UUID): Episode foreign key
  - `current_time` (INTEGER): Current playback position in seconds
  - `progress_percent` (DECIMAL): Completion percentage (0-100)
  - `playback_speed` (DECIMAL): Playback speed
  - `completed` (BOOLEAN): Episode fully listened
  - `last_played_at` (TIMESTAMPTZ): Last playback timestamp

  **Indexes**:
  - `idx_podcasts_rss_url` (unique) on `rss_url`
  - `idx_podcasts_podcast_index_id` on `podcast_index_id`
  - `idx_podcasts_title_trgm` (GIN trigram) for fuzzy search
  - `idx_podcast_episodes_podcast_id` on `podcast_id`
  - `idx_podcast_episodes_guid` (unique) on `guid`
  - `idx_podcast_episodes_published_at` on `published_at`
  - `idx_podcast_subscriptions_user_podcast` (unique) on (`user_id`, `podcast_id`)
  - `idx_podcast_playback_user_episode` (unique) on (`user_id`, `episode_id`)
playback_features:
  streaming: Direct streaming or HLS transcode
  variable_speed: 0.5x, 0.75x, 1.0x, 1.25x, 1.5x, 1.75x, 2.0x, 2.5x, 3.0x
  chapter_navigation: Jump between chapters (Podcasting 2.0 support)
  sleep_timer: 5, 10, 15, 30, 45, 60 minutes, end of episode
  skip_controls: Skip forward/back 15/30/60 seconds (configurable)
  queue_management: Play queue, up next, shuffle
  offline_playback: Download episodes for offline listening
discovery_features:
  podcast_index_api: Search 4M+ podcasts via Podcast Index
  categories: Browse by category (Comedy, News, Technology, etc.)
  trending: Popular podcasts across all users
  recommendations: Based on listening history and subscriptions
  import_export: Import/export OPML feed lists
background_jobs:
- job: Feed Refresh
  frequency: Every 1-6 hours per podcast
  action: Check RSS feed for new episodes
- job: Auto Download
  trigger: New episode detected + auto_download enabled
  action: Download latest N episodes
- job: Cleanup
  frequency: Daily
  action: Remove old downloaded episodes per retention policy
- job: Image Cache
  trigger: New podcast/episode added
  action: Download and cache artwork
api_endpoints:
- method: GET
  path: /api/v1/podcasts
  description: List all subscribed podcasts
- method: POST
  path: /api/v1/podcasts
  description: Subscribe to a podcast by RSS URL
- method: GET
  path: /api/v1/podcasts/:id
  description: Get podcast details by ID
- method: DELETE
  path: /api/v1/podcasts/:id
  description: Unsubscribe from a podcast
- method: GET
  path: /api/v1/podcasts/:id/episodes
  description: List all episodes for a podcast
- method: GET
  path: /api/v1/podcasts/episodes/:id
  description: Get episode details by ID
- method: GET
  path: /api/v1/podcasts/episodes/:id/stream
  description: Get streaming URL for an episode
- method: POST
  path: /api/v1/podcasts/episodes/:id/download
  description: Download an episode for offline listening
- method: GET
  path: /api/v1/podcasts/episodes/:id/progress
  description: Get user playback progress for an episode
- method: PUT
  path: /api/v1/podcasts/episodes/:id/progress
  description: Update user playback progress for an episode
- method: GET
  path: /api/v1/podcasts/search
  description: Search podcasts via Podcast Index API
- method: POST
  path: /api/v1/podcasts/import-opml
  description: Import podcast subscriptions from OPML file
- method: GET
  path: /api/v1/podcasts/export-opml
  description: Export podcast subscriptions as OPML file
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1["Client<br/>(Web/App)"]
      node2["API Handler<br/>(ogen)"]
      node3["Service<br/>(Logic)"]
      node4["itory<br/>Metadata<br/>Cac"]
      node5["PostgreSQL<br/>(pgx)"]
      node6["External<br/>APIs"]
      node1 --> node2
      node2 --> node3
      node5 --> node6
      node3 --> node4
      node4 --> node5
  ```
module_structure: |-
  ```
    internal/content/podcasts/
    â”œâ”€â”€ module.go              # fx module definition
    â”œâ”€â”€ repository.go          # Database operations (sqlc)
    â”œâ”€â”€ service.go             # Business logic
    â”œâ”€â”€ handler.go             # HTTP handlers (ogen)
    â”œâ”€â”€ types.go               # Domain types
    â””â”€â”€ cache.go               # Caching layer (otter)
    ```
component_interaction: |
  1. **Request Flow**:
     - Client sends HTTP request to `/api/v1/podcasts/*`
     - API handler (ogen) validates request and calls service
     - Service checks cache for existing data
     - If cache miss, service calls repository for database query
     - Repository executes SQL via sqlc-generated code
     - Results flow back through service â†’ handler â†’ client

  2. **RSS Feed Subscription**:
     - Client submits RSS URL via `/api/v1/podcasts` POST
     - Service validates RSS feed and fetches initial data
     - Service extracts podcast metadata and episodes
     - Service downloads and caches podcast artwork
     - Podcast and episodes stored in database
     - Background job scheduled for periodic feed refresh

  3. **Automatic Updates**:
     - River background job triggers feed refresh (every 1-6 hours)
     - Service fetches RSS feed and parses for new episodes
     - New episodes compared with existing episodes by GUID
     - New episodes added to database
     - If auto_download enabled, download job queued
     - Push notifications sent to subscribed users

  4. **Episode Streaming/Download**:
     - Client requests stream or download
     - Service checks episode file availability (downloaded vs. remote)
     - For streaming: HLS manifest generated or direct URL returned
     - For download: Episode downloaded to local storage
     - Progress updates sent via WebSocket
file_structure: |
  ```
  internal/content/podcasts/
  â”œâ”€â”€ module.go              # fx.Module with all providers
  â”œâ”€â”€ repository.go          # Database layer
  â”œâ”€â”€ repository_test.go     # Repository tests (testcontainers)
  â”œâ”€â”€ service.go             # Business logic
  â”œâ”€â”€ service_test.go        # Service tests (mocks)
  â”œâ”€â”€ handler.go             # HTTP handlers
  â”œâ”€â”€ handler_test.go        # Handler tests (httptest)
  â”œâ”€â”€ types.go               # Domain types
  â”œâ”€â”€ cache.go               # Caching logic
  â”œâ”€â”€ cache_test.go          # Cache tests
  â”œâ”€â”€ rss/
  â”‚   â”œâ”€â”€ parser.go          # RSS/Atom feed parsing
  â”‚   â”œâ”€â”€ parser_test.go     # RSS parsing tests
  â”‚   â””â”€â”€ fetcher.go         # HTTP feed fetching with caching
  â”œâ”€â”€ discovery/
  â”‚   â”œâ”€â”€ podcast_index.go   # Podcast Index API integration
  â”‚   â”œâ”€â”€ opml.go            # OPML import/export
  â”‚   â””â”€â”€ opml_test.go       # OPML tests
  â”œâ”€â”€ downloads/
  â”‚   â”œâ”€â”€ downloader.go      # Episode download manager
  â”‚   â”œâ”€â”€ queue.go           # Download queue management
  â”‚   â””â”€â”€ cleanup.go         # Storage cleanup policies
  â”œâ”€â”€ jobs/
  â”‚   â”œâ”€â”€ feed_refresh.go    # Feed refresh River job
  â”‚   â”œâ”€â”€ auto_download.go   # Auto-download River job
  â”‚   â””â”€â”€ cleanup.go         # Cleanup River job
  â””â”€â”€ progress/
      â”œâ”€â”€ tracker.go         # Playback progress tracking
      â””â”€â”€ sync.go            # Multi-device sync logic

  migrations/
  â””â”€â”€ podcasts/
      â”œâ”€â”€ 001_podcasts.sql   # Podcasts schema
      â”œâ”€â”€ 002_episodes.sql   # Episodes schema
      â””â”€â”€ 003_progress.sql   # Progress tracking schema

  api/
  â””â”€â”€ openapi.yaml           # OpenAPI spec (podcasts/* endpoints)
  ```
key_interfaces: |
  ```go
  // Repository defines database operations for podcasts
  type Repository interface {
      // Podcast CRUD
      GetPodcast(ctx context.Context, id uuid.UUID) (*Podcast, error)
      GetPodcastByRSSURL(ctx context.Context, rssURL string) (*Podcast, error)
      ListPodcasts(ctx context.Context, filters ListFilters) ([]Podcast, error)
      CreatePodcast(ctx context.Context, podcast *Podcast) error
      UpdatePodcast(ctx context.Context, podcast *Podcast) error
      DeletePodcast(ctx context.Context, id uuid.UUID) error

      // Episode CRUD
      GetEpisode(ctx context.Context, id uuid.UUID) (*Episode, error)
      GetEpisodeByGUID(ctx context.Context, guid string) (*Episode, error)
      ListEpisodes(ctx context.Context, podcastID uuid.UUID, filters ListFilters) ([]Episode, error)
      CreateEpisode(ctx context.Context, episode *Episode) error
      UpdateEpisode(ctx context.Context, episode *Episode) error

      // Subscription management
      Subscribe(ctx context.Context, userID, podcastID uuid.UUID, opts SubscriptionOptions) error
      Unsubscribe(ctx context.Context, userID, podcastID uuid.UUID) error
      GetSubscription(ctx context.Context, userID, podcastID uuid.UUID) (*Subscription, error)
      ListSubscriptions(ctx context.Context, userID uuid.UUID) ([]Subscription, error)

      // Progress tracking
      GetProgress(ctx context.Context, userID, episodeID uuid.UUID) (*PlaybackProgress, error)
      UpdateProgress(ctx context.Context, progress *PlaybackProgress) error
  }

  // Service defines business logic for podcasts
  type Service interface {
      // Podcast operations
      SubscribeToPodcast(ctx context.Context, userID uuid.UUID, rssURL string) (*Podcast, error)
      UnsubscribeFromPodcast(ctx context.Context, userID, podcastID uuid.UUID) error
      RefreshPodcast(ctx context.Context, podcastID uuid.UUID) error

      // Episode operations
      GetEpisode(ctx context.Context, id uuid.UUID) (*Episode, error)
      ListNewEpisodes(ctx context.Context, userID uuid.UUID, limit int) ([]Episode, error)
      DownloadEpisode(ctx context.Context, episodeID uuid.UUID) error
      DeleteDownload(ctx context.Context, episodeID uuid.UUID) error

      // Discovery
      SearchPodcasts(ctx context.Context, query string) ([]PodcastSearchResult, error)
      ImportOPML(ctx context.Context, userID uuid.UUID, opmlData []byte) error
      ExportOPML(ctx context.Context, userID uuid.UUID) ([]byte, error)

      // Progress
      UpdateProgress(ctx context.Context, userID, episodeID uuid.UUID, progress ProgressUpdate) error
  }

  // RSSParser parses podcast RSS feeds
  type RSSParser interface {
      // ParseFeed parses an RSS/Atom feed into structured data
      ParseFeed(data []byte) (*PodcastFeed, error)

      // ExtractEpisodes extracts episode list from feed
      ExtractEpisodes(feed *PodcastFeed) ([]Episode, error)

      // ValidateFeed validates RSS feed format
      ValidateFeed(data []byte) error
  }

  // PodcastIndexClient interfaces with Podcast Index API
  type PodcastIndexClient interface {
      // Search searches for podcasts by query
      Search(ctx context.Context, query string) ([]PodcastSearchResult, error)

      // GetPodcastByFeedURL retrieves podcast details by RSS URL
      GetPodcastByFeedURL(ctx context.Context, feedURL string) (*PodcastIndexPodcast, error)

      // GetTrending retrieves trending podcasts
      GetTrending(ctx context.Context, limit int) ([]PodcastIndexPodcast, error)
  }

  // DownloadManager manages episode downloads
  type DownloadManager interface {
      // QueueDownload adds episode to download queue
      QueueDownload(ctx context.Context, episodeID uuid.UUID) error

      // GetDownloadStatus retrieves current download status
      GetDownloadStatus(ctx context.Context, episodeID uuid.UUID) (*DownloadStatus, error)

      // CancelDownload cancels an in-progress download
      CancelDownload(ctx context.Context, episodeID uuid.UUID) error

      // CleanupOldDownloads removes old downloads per retention policy
      CleanupOldDownloads(ctx context.Context, retentionDays int) error
  }
  ```
dependencies: |
  **Go Dependencies**:
  - `github.com/jackc/pgx/v5/pgxpool` - PostgreSQL connection pool
  - `github.com/google/uuid` - UUID generation
  - `github.com/maypok86/otter` - In-memory cache
  - `github.com/mmcdole/gofeed` - RSS/Atom feed parsing
  - `github.com/go-resty/resty/v2` - HTTP client for feed fetching
  - `go.uber.org/fx` - Dependency injection
  - `github.com/riverqueue/river` - Background job queue
  - `github.com/gilliek/go-opml` - OPML parsing and generation

  **External APIs**:
  - Podcast Index API - Podcast search and discovery
  - RSS/Atom feeds - Episode metadata and updates

  **Database**:
  - PostgreSQL 18+ with trigram extension for fuzzy search
env_vars: |
  **Environment Variables**:
  - `REVENGE_PODCAST_CACHE_TTL` - Cache TTL duration (default: 15m)
  - `REVENGE_PODCAST_CACHE_SIZE` - Cache size in MB (default: 100)
  - `REVENGE_PODCAST_REFRESH_INTERVAL` - Default refresh interval in seconds (default: 3600)
  - `REVENGE_PODCAST_INDEX_API_KEY` - Podcast Index API key (required for search)
  - `REVENGE_PODCAST_INDEX_API_SECRET` - Podcast Index API secret (required for search)
  - `REVENGE_PODCAST_AUTO_DOWNLOAD_LIMIT` - Default auto-download limit (default: 3)
  - `REVENGE_PODCAST_DOWNLOAD_PATH` - Path for downloaded episodes
  - `REVENGE_PODCAST_RETENTION_DAYS` - Episode retention in days (default: 30)
config_keys: |
  **config.yaml keys**:
  ```yaml
  podcast:
    cache:
      ttl: 15m
      size_mb: 100

    feeds:
      refresh_interval: 3600  # seconds (1 hour)
      timeout: 30s
      user_agent: "Revenge Podcast Client/1.0"
      max_episodes_per_fetch: 100

    discovery:
      podcast_index:
        api_key: ${REVENGE_PODCAST_INDEX_API_KEY}
        api_secret: ${REVENGE_PODCAST_INDEX_API_SECRET}
        enabled: true

    downloads:
      enabled: true
      path: ${REVENGE_PODCAST_DOWNLOAD_PATH}
      auto_download_limit: 3  # Latest N episodes
      retention_days: 30
      max_concurrent: 3
      bandwidth_limit: 0  # 0 = unlimited, bytes/sec

    playback:
      speed_options: [0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.5, 3.0]
      skip_forward: 30  # seconds
      skip_backward: 15  # seconds
      sleep_timer_options: [5, 10, 15, 30, 45, 60, "end_of_episode"]

    notifications:
      new_episodes_enabled: true
      download_complete_enabled: true
  ```
defaults: |
  - Cache TTL: 15 minutes
  - Cache size: 100 MB
  - Feed refresh interval: 1 hour
  - Auto-download limit: 3 latest episodes
  - Download retention: 30 days
  - Max concurrent downloads: 3
  - Skip forward: 30 seconds
  - Skip backward: 15 seconds
  - Playback speed: 0.5x to 3.0x
request_examples: |
  **Subscribe to podcast**:
  ```http
  POST /api/v1/podcasts
  Authorization: Bearer {token}
  Content-Type: application/json

  {
    "rss_url": "https://feeds.example.com/podcast.xml",
    "auto_download": true,
    "download_limit": 3,
    "notifications_enabled": true
  }
  ```

  **Search podcasts**:
  ```http
  GET /api/v1/podcasts/search?q=technology&limit=20
  Authorization: Bearer {token}
  ```

  **List episodes for podcast**:
  ```http
  GET /api/v1/podcasts/550e8400-e29b-41d4-a716-446655440000/episodes?limit=20&offset=0
  Authorization: Bearer {token}
  ```

  **Download episode**:
  ```http
  POST /api/v1/podcasts/episodes/650e8400-e29b-41d4-a716-446655440000/download
  Authorization: Bearer {token}
  ```

  **Update playback progress**:
  ```http
  PUT /api/v1/podcasts/episodes/650e8400-e29b-41d4-a716-446655440000/progress
  Authorization: Bearer {token}
  Content-Type: application/json

  {
    "current_time": 1250,
    "playback_speed": 1.5,
    "completed": false
  }
  ```
response_examples: |
  **Podcast details response**:
  ```json
  {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "title": "The Daily Tech Podcast",
    "description": "Your daily dose of technology news...",
    "author": "Tech News Network",
    "rss_url": "https://feeds.example.com/daily-tech.xml",
    "website_url": "https://dailytech.example.com",
    "image_path": "/podcasts/images/daily-tech.jpg",
    "language": "en",
    "categories": ["Technology", "News"],
    "explicit": false,
    "episode_count": 523,
    "last_published_at": "2024-01-15T06:00:00Z",
    "subscription": {
      "subscribed": true,
      "auto_download": true,
      "download_limit": 3,
      "notifications_enabled": true,
      "subscribed_at": "2024-01-01T00:00:00Z"
    },
    "created_at": "2024-01-01T00:00:00Z"
  }
  ```

  **Episode details response**:
  ```json
  {
    "id": "650e8400-e29b-41d4-a716-446655440000",
    "podcast_id": "550e8400-e29b-41d4-a716-446655440000",
    "title": "AI Breakthroughs in 2024",
    "description": "Discussing the latest AI developments...",
    "episode_number": 523,
    "published_at": "2024-01-15T06:00:00Z",
    "duration": 2456,
    "file_size": 58720256,
    "file_type": "audio/mpeg",
    "image_path": "/podcasts/episodes/ai-breakthroughs.jpg",
    "chapters": [
      {
        "title": "Introduction",
        "start_time": 0,
        "end_time": 120
      },
      {
        "title": "GPT-5 Release",
        "start_time": 120,
        "end_time": 780
      }
    ],
    "downloaded": true,
    "user_progress": {
      "current_time": 1250,
      "progress_percent": 50.9,
      "playback_speed": 1.5,
      "completed": false,
      "last_played_at": "2024-01-15T20:30:00Z"
    }
  }
  ```

  **Search results response**:
  ```json
  {
    "results": [
      {
        "id": 123456,
        "title": "The Daily Tech Podcast",
        "description": "Your daily dose...",
        "author": "Tech News Network",
        "rss_url": "https://feeds.example.com/daily-tech.xml",
        "image_url": "https://example.com/artwork.jpg",
        "categories": ["Technology", "News"],
        "subscribed": true
      }
    ],
    "total": 42
  }
  ```
unit_tests: |
  **Repository Tests** (with testcontainers):
  - Test CRUD operations for podcasts
  - Test CRUD operations for episodes
  - Test subscription management
  - Test progress tracking
  - Test search with filters
  - Test concurrent access

  **Service Tests** (with mocks):
  - Test business logic with mocked repository
  - Test RSS feed subscription flow
  - Test feed refresh logic
  - Test cache hit/miss scenarios
  - Test error handling
  - Test rate limiting

  **Handler Tests** (with httptest):
  - Test HTTP request/response handling
  - Test authentication/authorization
  - Test request validation
  - Test error responses
  - Test pagination

  **RSS Parser Tests**:
  - Test RSS 2.0 parsing
  - Test Atom feed parsing
  - Test iTunes extension parsing
  - Test Podcasting 2.0 chapter parsing
  - Test malformed feed handling

  **OPML Tests**:
  - Test OPML import
  - Test OPML export
  - Test malformed OPML handling
integration_tests: |
  **Full Stack Tests**:
  - Test complete request flow (client â†’ database)
  - Test RSS feed subscription with real feeds (mocked HTTP)
  - Test Podcast Index search (mocked)
  - Test episode download end-to-end
  - Test progress sync across simulated devices
  - Test OPML import/export

  **Database Tests**:
  - Test migrations (up/down)
  - Test indexes performance
  - Test foreign key constraints
  - Test transaction isolation
  - Test trigram search performance

  **Background Job Tests**:
  - Test feed refresh job execution
  - Test auto-download job execution
  - Test cleanup job execution
  - Test job failure and retry logic
test_coverage_target: |
  - **Overall**: 80% minimum
  - **Repository**: 90% (critical path)
  - **Service**: 85% (business logic)
  - **Handler**: 75% (integration layer)
  - **RSS parser**: 90% (critical functionality)
  - **Download manager**: 85% (important for offline)
  - **Progress tracking**: 85% (user experience)
