doc_title: Email System
doc_category: technical
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: Complete email system design
status_sources: âœ…
status_sources_notes: go-mail documentation included
status_instructions: âœ…
status_instructions_notes: Generated from design
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> SMTP email system with go-mail, TLS/STARTTLS, templates, async
  delivery


  Complete email infrastructure:

  - **Library**: go-mail (wneessen/go-mail) with connection pooling

  - **Security**: TLS/STARTTLS support, SMTP auth (PLAIN, LOGIN, CRAM-MD5)

  - **Templates**: HTML with text fallback using Go templates

  - **Delivery**: Async via River job queue with retry logic

  - **Features**: Bounce handling, unsubscribe links, rate limiting'
wiki_tagline: '> Reliable email delivery for notifications, alerts, and user communications'
wiki_overview: The Email System provides reliable SMTP email delivery with support
  for HTML templates, TLS encryption, and async sending. Built on go-mail library
  with connection pooling and automatic retries. All emails are queued via River for
  resilient delivery, with bounce detection and unsubscribe management built-in.
sources:
- name: go-mail GitHub README
  url: https://github.com/wneessen/go-mail
  note: Auto-resolved from go-mail-docs
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
design_refs:
- title: technical
  path: technical.md
- title: 01_ARCHITECTURE
  path: ../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../architecture/02_DESIGN_PRINCIPLES.md
- title: NOTIFICATIONS
  path: ../technical/NOTIFICATIONS.md
smtp_configuration:
  library: go-mail (github.com/wneessen/go-mail)
  version: v0.5.x
  features:
  - Connection pooling
  - TLS/STARTTLS support
  - Multiple auth methods
  - Attachment support
  - HTML and plain text
  - Custom headers
  config_keys:
    smtp.host: SMTP server hostname
    smtp.port: SMTP server port (25, 465, 587)
    smtp.username: SMTP auth username
    smtp.password: SMTP auth password
    smtp.from_address: Default sender email
    smtp.from_name: Default sender name
    smtp.tls: Enable TLS (true/false)
    smtp.skip_verify: Skip TLS cert verification (dev only)
    smtp.timeout: Connection timeout (default 10s)
  example_config: "```yaml\nsmtp:\n  host: smtp.gmail.com\n  port: 587\n  username:\
    \ noreply@revenge.example.com\n  password: ${SMTP_PASSWORD}\n  from_address: noreply@revenge.example.com\n\
    \  from_name: Revenge Media Server\n  tls: true\n  skip_verify: false\n  timeout:\
    \ 10s\n```\n"
authentication_methods:
- method: PLAIN
  description: Simple username/password (requires TLS)
  recommended: true
  security: Must use TLS to protect credentials
- method: LOGIN
  description: Base64 encoded username/password
  recommended: true
  security: Similar to PLAIN, requires TLS
- method: CRAM-MD5
  description: Challenge-response authentication
  recommended: false
  security: Considered weak, prefer PLAIN over TLS
- method: None
  description: No authentication (local relay only)
  recommended: false
  security: Only for trusted local SMTP relay
tls_security:
  starttls:
    description: Upgrade plain connection to TLS
    port: 587 (submission port)
    recommended: true
  tls_wrapper:
    description: TLS from connection start
    port: 465 (SMTPS)
    legacy: true
    notes: Deprecated but still widely supported
  plain_smtp:
    description: No encryption
    port: 25
    recommended: false
    use_case: Local relay only, never over public internet
email_templates:
  template_engine: Go html/template
  template_location: internal/email/templates/
  structure:
  - base.html (base layout with header/footer)
  - welcome.html (user registration)
  - password_reset.html (password reset link)
  - new_content.html (new movies/albums notification)
  - server_alert.html (server issues)
  - invitation.html (invite user to server)
  template_example: "```html\n<!-- templates/welcome.html -->\n{{template \"base\"\
    \ .}}\n\n{{define \"content\"}}\n<h1>Welcome to {{.ServerName}}!</h1>\n<p>Hi {{.UserName}},</p>\n\
    <p>Your account has been created successfully.</p>\n<p>\n  <a href=\"{{.LoginURL}}\"\
    \ style=\"background: #007bff; color: white; padding: 10px 20px; text-decoration:\
    \ none;\">\n    Log In to Revenge\n  </a>\n</p>\n{{end}}\n```\n"
  text_fallback:
    description: Plain text version for email clients that don't support HTML
    generation: Auto-generate from HTML or manual template
    example: '```

      Welcome to Revenge!


      Hi {{.UserName}},


      Your account has been created successfully.


      Log in here: {{.LoginURL}}


      --

      Revenge Media Server

      ```

      '
async_email_sending:
  method: River background jobs
  advantages:
  - Non-blocking API responses
  - Automatic retry on failure
  - Rate limiting
  - Delivery tracking
  job_definition: "```go\ntype SendEmailArgs struct {\n    To          []string  \
    \        `json:\"to\"`\n    Subject     string            `json:\"subject\"`\n\
    \    TemplateID  string            `json:\"template_id\"`\n    TemplateData map[string]any\
    \   `json:\"template_data\"`\n    Priority    int               `json:\"priority\"\
    ` // 1=high, 2=normal, 3=low\n}\n\ntype SendEmailWorker struct {\n    river.WorkerDefaults[SendEmailArgs]\n\
    \    mailer *email.Mailer\n}\n\nfunc (w *SendEmailWorker) Work(ctx context.Context,\
    \ job *river.Job[SendEmailArgs]) error {\n    msg := w.mailer.NewMessage()\n \
    \   msg.To(job.Args.To...)\n    msg.Subject(job.Args.Subject)\n\n    // Render\
    \ template\n    html, text, err := w.mailer.RenderTemplate(job.Args.TemplateID,\
    \ job.Args.TemplateData)\n    if err != nil {\n        return fmt.Errorf(\"render\
    \ template: %w\", err)\n    }\n\n    msg.SetBodyString(mail.TypeTextHTML, html)\n\
    \    msg.AddAlternativeString(mail.TypeTextPlain, text)\n\n    // Send with retries\n\
    \    return w.mailer.Send(ctx, msg)\n}\n```\n"
  queue_example: "```go\n// Queue email for sending\n_, err := riverClient.Insert(ctx,\
    \ &SendEmailArgs{\n    To:          []string{\"user@example.com\"},\n    Subject:\
    \     \"Welcome to Revenge!\",\n    TemplateID:  \"welcome\",\n    TemplateData:\
    \ map[string]any{\n        \"UserName\":   user.Name,\n        \"ServerName\"\
    : cfg.ServerName,\n        \"LoginURL\":   cfg.BaseURL + \"/login\",\n    },\n\
    \    Priority: 2, // Normal priority\n}, nil)\n```\n"
retry_logic:
  max_attempts: 5
  backoff_strategy: Exponential with jitter
  delays:
  - attempt: 1
    delay: 1 minute
  - attempt: 2
    delay: 5 minutes
  - attempt: 3
    delay: 15 minutes
  - attempt: 4
    delay: 1 hour
  - attempt: 5
    delay: 4 hours
  permanent_failures:
  - Invalid recipient email
  - Mailbox does not exist
  - Domain does not exist
  - Message rejected by recipient server
  transient_failures:
  - Connection timeout
  - SMTP server temporarily unavailable
  - Greylisting (try again later)
  - Rate limit exceeded
notification_types:
  user_notifications:
  - type: Welcome Email
    template: welcome
    trigger: User registration
    priority: high
  - type: Password Reset
    template: password_reset
    trigger: User requests password reset
    priority: high
  - type: Email Verification
    template: email_verification
    trigger: Email change or new account
    priority: high
  - type: New Content Alert
    template: new_content
    trigger: New movies/albums match user preferences
    priority: normal
  - type: Invitation
    template: invitation
    trigger: Admin invites new user
    priority: normal
  server_notifications:
  - type: Server Error Alert
    template: server_alert
    trigger: Critical error or service down
    priority: high
    recipients: Admin emails
  - type: Backup Completion
    template: backup_complete
    trigger: Database backup finishes
    priority: low
  - type: Storage Warning
    template: storage_warning
    trigger: Disk space below threshold
    priority: high
unsubscribe_handling:
  method: List-Unsubscribe header + web link
  headers:
    List-Unsubscribe: <https://revenge.example.com/unsubscribe?token=xyz>
    List-Unsubscribe-Post: List-Unsubscribe=One-Click
  implementation: "```go\n// Add unsubscribe headers\nunsubscribeURL := fmt.Sprintf(\"\
    %s/unsubscribe?token=%s\", cfg.BaseURL, token)\nmsg.SetGenHeader(\"List-Unsubscribe\"\
    , fmt.Sprintf(\"<%s>\", unsubscribeURL))\nmsg.SetGenHeader(\"List-Unsubscribe-Post\"\
    , \"List-Unsubscribe=One-Click\")\n\n// Add footer link in template\n<p style=\"\
    color: #666; font-size: 12px;\">\n  Don't want these emails? <a href=\"{{.UnsubscribeURL}}\"\
    >Unsubscribe</a>\n</p>\n```\n"
  per_notification_type:
    description: Users can unsubscribe from specific notification types
    categories:
    - New content alerts
    - Server announcements
    - Weekly digest
    critical_emails:
    - Password reset (always sent)
    - Security alerts (always sent)
    - Account verification (always sent)
bounce_handling:
  detection_methods:
  - SMTP error codes (5xx permanent, 4xx temporary)
  - Bounce webhook (if using email service provider)
  - Parsing NDR (Non-Delivery Report) emails
  bounce_types:
    hard_bounce:
      description: Permanent delivery failure
      action: Mark email as invalid, disable future sends
      examples:
      - User does not exist
      - Domain does not exist
      - Email rejected
    soft_bounce:
      description: Temporary delivery failure
      action: Retry with backoff
      examples:
      - Mailbox full
      - Server temporarily unavailable
      - Message too large
  tracking:
    table: email_bounce_log
    fields:
    - user_email
    - bounce_type (hard/soft)
    - bounce_reason
    - bounced_at
    - retry_count
rate_limiting:
  per_user:
    limit: 10 emails per hour
    purpose: Prevent abuse and spam
  per_server:
    limit: 100 emails per minute
    purpose: Respect SMTP provider limits
  smtp_provider_limits:
    gmail_smtp:
      limit: 500 emails per day (free)
      notes: Use Google Workspace for higher limits
    aws_ses:
      limit: Varies by account (request increase)
      notes: Pay per email sent
    sendgrid:
      limit: 100 emails per day (free tier)
      notes: Upgrade for higher limits
connection_pooling:
  library: go-mail built-in pool
  configuration:
    pool_size: 5 connections
    idle_timeout: 5 minutes
    max_lifetime: 30 minutes
  benefits:
  - Reuse SMTP connections for multiple emails
  - Reduce connection overhead
  - Better throughput for bulk sends
  example: "```go\n// Create SMTP client with connection pool\nclient, err := mail.NewClient(\n\
    \    cfg.SMTPHost,\n    mail.WithPort(cfg.SMTPPort),\n    mail.WithUsername(cfg.SMTPUsername),\n\
    \    mail.WithPassword(cfg.SMTPPassword),\n    mail.WithTLSPolicy(mail.TLSMandatory),\n\
    \    mail.WithSMTPAuth(mail.SMTPAuthPlain),\n)\n\n// Connection pool is managed\
    \ internally by go-mail\n```\n"
testing:
  unit_tests:
  - Test template rendering
  - Test email validation
  - Mock SMTP client
  integration_tests:
  - Use mailhog or mailpit for local testing
  - Verify email delivery
  - Check HTML rendering
  test_tools:
  - mailhog: Local SMTP server with web UI
  - mailpit: Modern alternative to mailhog
  - mailtrap: Cloud-based email testing
api_endpoints:
- method: POST
  path: /api/v1/admin/email/send
  description: Send test email (admin only)
- method: GET
  path: /api/v1/user/email/preferences
  description: Get email notification preferences
- method: PUT
  path: /api/v1/user/email/preferences
  description: Update email notification preferences
- method: GET
  path: /unsubscribe
  description: Unsubscribe from emails (public, no auth)
best_practices:
- practice: Always use TLS for SMTP connections
  reason: Protect credentials and email content
- practice: Implement unsubscribe links
  reason: Legal requirement (GDPR, CAN-SPAM) and user experience
- practice: Use async sending via background jobs
  reason: Don't block API requests waiting for SMTP
- practice: Track bounces and mark invalid emails
  reason: Maintain sender reputation
- practice: Rate limit email sending
  reason: Prevent abuse and respect provider limits
- practice: Provide plain text fallback
  reason: Compatibility with text-only email clients
- practice: Use connection pooling for bulk sends
  reason: Better performance and lower latency
- practice: Test emails in development
  reason: Use mailhog/mailpit to verify rendering
