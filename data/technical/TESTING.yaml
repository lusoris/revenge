doc_title: Testing Patterns and Practices
doc_category: technical
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: Complete testing patterns documentation
status_sources: âœ…
status_sources_notes: All testing tools documented
status_instructions: âœ…
status_instructions_notes: Generated from design
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Comprehensive testing strategy with unit, integration, and end-to-end
  tests


  Testing approach:

  - **Unit Tests**: Fast, isolated tests with mocks (testify + mockery)

  - **Integration Tests**: Real dependencies via testcontainers

  - **Table-Driven Tests**: Go testing pattern for multiple scenarios

  - **Coverage**: Minimum 80% code coverage required

  - **CI/CD**: Automated testing on every PR and commit

  - **Best Practices**: Test-driven development, clear test names, arrange-act-assert'
wiki_tagline: '> Ensure code quality with comprehensive automated testing'
wiki_overview: The Testing Strategy ensures code quality through multiple test layers.
  Unit tests run fast with mocked dependencies using testify and mockery. Integration
  tests use testcontainers to spin up real PostgreSQL, Dragonfly, and Typesense instances.
  Table-driven tests cover multiple scenarios efficiently. Code coverage tracked automatically
  with minimum 80% threshold. Tests run in CI/CD on every commit. Follow best practices
  like arrange-act-assert pattern, clear test names, and test-driven development.
sources:
- name: Go Testing Package
  url: https://pkg.go.dev/testing
  note: Standard library testing
- name: testify
  url: https://pkg.go.dev/github.com/stretchr/testify
  note: Assertion and mocking toolkit
- name: mockery
  url: https://vektra.github.io/mockery/
  note: Mock generation from interfaces
- name: testcontainers-go
  url: https://pkg.go.dev/github.com/testcontainers/testcontainers-go
  note: Docker containers for integration tests
- name: embedded-postgres
  url: https://pkg.go.dev/github.com/fergusstrange/embedded-postgres
  note: Embedded PostgreSQL for testing
design_refs:
- title: technical
  path: technical.md
- title: 01_ARCHITECTURE
  path: ../architecture/01_ARCHITECTURE.md
- title: BEST_PRACTICES
  path: ../operations/BEST_PRACTICES.md
testing_pyramid:
  unit_tests:
    percentage: 70%
    speed: Very fast (milliseconds)
    scope: Individual functions and methods
    dependencies: Mocked
    tools: testing, testify, mockery
    when_to_write: For all business logic and service layer
  integration_tests:
    percentage: 20%
    speed: Moderate (seconds)
    scope: Multiple components working together
    dependencies: Real (PostgreSQL, Dragonfly, Typesense)
    tools: testcontainers-go, embedded-postgres
    when_to_write: For repository layer, API endpoints, external integrations
  e2e_tests:
    percentage: 10%
    speed: Slow (minutes)
    scope: Complete user workflows
    dependencies: Full stack
    tools: Playwright, Cypress
    when_to_write: For critical user journeys
unit_testing:
  table_driven_tests: "```go\npackage service_test\n\nimport (\n    \"context\"\n\
    \    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/mock\"\
    \n    \"revenge/internal/service/movie\"\n    \"revenge/internal/repository/mocks\"\
    \n)\n\nfunc TestMovieService_GetByID(t *testing.T) {\n    tests := []struct {\n\
    \        name          string\n        movieID       uuid.UUID\n        mockSetup\
    \     func(*mocks.MovieRepository)\n        expectedMovie *movie.Movie\n     \
    \   expectedError error\n    }{\n        {\n            name:    \"successful\
    \ retrieval\",\n            movieID: uuid.MustParse(\"550e8400-e29b-41d4-a716-446655440000\"\
    ),\n            mockSetup: func(repo *mocks.MovieRepository) {\n             \
    \   repo.On(\"GetByID\", mock.Anything, uuid.MustParse(\"550e8400-e29b-41d4-a716-446655440000\"\
    )).\n                    Return(&movie.Movie{\n                        ID:   \
    \ uuid.MustParse(\"550e8400-e29b-41d4-a716-446655440000\"),\n                \
    \        Title: \"Inception\",\n                        Year:  2010,\n       \
    \             }, nil)\n            },\n            expectedMovie: &movie.Movie{\n\
    \                ID:    uuid.MustParse(\"550e8400-e29b-41d4-a716-446655440000\"\
    ),\n                Title: \"Inception\",\n                Year:  2010,\n    \
    \        },\n            expectedError: nil,\n        },\n        {\n        \
    \    name:    \"movie not found\",\n            movieID: uuid.MustParse(\"550e8400-e29b-41d4-a716-446655440001\"\
    ),\n            mockSetup: func(repo *mocks.MovieRepository) {\n             \
    \   repo.On(\"GetByID\", mock.Anything, uuid.MustParse(\"550e8400-e29b-41d4-a716-446655440001\"\
    )).\n                    Return(nil, movie.ErrMovieNotFound)\n            },\n\
    \            expectedMovie: nil,\n            expectedError: movie.ErrMovieNotFound,\n\
    \        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t\
    \ *testing.T) {\n            // Arrange\n            mockRepo := mocks.NewMovieRepository(t)\n\
    \            tt.mockSetup(mockRepo)\n            svc := movie.NewService(mockRepo)\n\
    \n            // Act\n            result, err := svc.GetByID(context.Background(),\
    \ tt.movieID)\n\n            // Assert\n            assert.Equal(t, tt.expectedError,\
    \ err)\n            assert.Equal(t, tt.expectedMovie, result)\n            mockRepo.AssertExpectations(t)\n\
    \        })\n    }\n}\n```"
  testify_assertions: "```go\nfunc TestMovieValidation(t *testing.T) {\n    movie\
    \ := &Movie{\n        Title: \"Inception\",\n        Year:  2010,\n    }\n\n \
    \   // Basic assertions\n    assert.NotNil(t, movie)\n    assert.Equal(t, \"Inception\"\
    , movie.Title)\n    assert.Equal(t, 2010, movie.Year)\n    assert.True(t, movie.Year\
    \ > 2000)\n    assert.Contains(t, movie.Title, \"Inc\")\n\n    // Error assertions\n\
    \    err := movie.Validate()\n    assert.NoError(t, err)\n\n    // Collection\
    \ assertions\n    genres := []string{\"Sci-Fi\", \"Action\", \"Thriller\"}\n \
    \   assert.Len(t, genres, 3)\n    assert.ElementsMatch(t, genres, []string{\"\
    Action\", \"Sci-Fi\", \"Thriller\"})\n}\n```"
  mock_generation: "```go\n// Repository interface\npackage repository\n\ntype MovieRepository\
    \ interface {\n    GetByID(ctx context.Context, id uuid.UUID) (*Movie, error)\n\
    \    Insert(ctx context.Context, movie *Movie) error\n    Update(ctx context.Context,\
    \ movie *Movie) error\n    Delete(ctx context.Context, id uuid.UUID) error\n \
    \   List(ctx context.Context, filters Filters) ([]Movie, error)\n}\n\n// Generate\
    \ mocks with mockery\n// Command: mockery --name=MovieRepository --output=mocks\
    \ --outpkg=mocks\n\n// Use in tests\nfunc TestMovieService_Create(t *testing.T)\
    \ {\n    // Arrange\n    mockRepo := mocks.NewMovieRepository(t)\n    mockRepo.On(\"\
    Insert\", mock.Anything, mock.AnythingOfType(\"*repository.Movie\")).\n      \
    \  Return(nil)\n\n    svc := service.NewMovieService(mockRepo)\n\n    // Act\n\
    \    err := svc.Create(context.Background(), &CreateMovieRequest{\n        Title:\
    \ \"Inception\",\n        Year:  2010,\n    })\n\n    // Assert\n    assert.NoError(t,\
    \ err)\n    mockRepo.AssertExpectations(t)\n}\n```"
  test_helpers: "```go\npackage testutil\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/require\"\
    \n)\n\n// Helper to create test movie\nfunc NewTestMovie(t *testing.T, overrides\
    \ ...func(*Movie)) *Movie {\n    t.Helper()\n    \n    movie := &Movie{\n    \
    \    ID:    uuid.New(),\n        Title: \"Test Movie\",\n        Year:  2024,\n\
    \    }\n\n    for _, override := range overrides {\n        override(movie)\n\
    \    }\n\n    return movie\n}\n\n// Usage\nfunc TestSomething(t *testing.T) {\n\
    \    movie := NewTestMovie(t, func(m *Movie) {\n        m.Title = \"Custom Title\"\
    \n        m.Year = 2010\n    })\n\n    assert.Equal(t, \"Custom Title\", movie.Title)\n\
    }\n```"
integration_testing:
  testcontainers_postgres: "```go\npackage repository_test\n\nimport (\n    \"context\"\
    \n    \"testing\"\n    \"github.com/jackc/pgx/v5/pgxpool\"\n    \"github.com/testcontainers/testcontainers-go\"\
    \n    \"github.com/testcontainers/testcontainers-go/wait\"\n)\n\nfunc setupPostgres(t\
    \ *testing.T) (*pgxpool.Pool, func()) {\n    t.Helper()\n\n    ctx := context.Background()\n\
    \n    // Start PostgreSQL container\n    req := testcontainers.ContainerRequest{\n\
    \        Image:        \"postgres:18-alpine\",\n        ExposedPorts: []string{\"\
    5432/tcp\"},\n        Env: map[string]string{\n            \"POSTGRES_USER\":\
    \     \"test\",\n            \"POSTGRES_PASSWORD\": \"test\",\n            \"\
    POSTGRES_DB\":       \"testdb\",\n        },\n        WaitingFor: wait.ForLog(\"\
    database system is ready to accept connections\"),\n    }\n\n    container, err\
    \ := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{\n\
    \        ContainerRequest: req,\n        Started:          true,\n    })\n   \
    \ if err != nil {\n        t.Fatalf(\"failed to start postgres container: %v\"\
    , err)\n    }\n\n    // Get connection string\n    host, _ := container.Host(ctx)\n\
    \    port, _ := container.MappedPort(ctx, \"5432\")\n    connStr := fmt.Sprintf(\"\
    postgres://test:test@%s:%s/testdb\", host, port.Port())\n\n    // Connect to database\n\
    \    pool, err := pgxpool.New(ctx, connStr)\n    if err != nil {\n        container.Terminate(ctx)\n\
    \        t.Fatalf(\"failed to connect to postgres: %v\", err)\n    }\n\n    //\
    \ Run migrations\n    runMigrations(t, pool)\n\n    // Return cleanup function\n\
    \    cleanup := func() {\n        pool.Close()\n        container.Terminate(ctx)\n\
    \    }\n\n    return pool, cleanup\n}\n\nfunc TestMovieRepository_Integration(t\
    \ *testing.T) {\n    pool, cleanup := setupPostgres(t)\n    defer cleanup()\n\n\
    \    repo := repository.NewMovieRepository(pool)\n\n    t.Run(\"insert and retrieve\"\
    , func(t *testing.T) {\n        movie := &repository.Movie{\n            ID: \
    \   uuid.New(),\n            Title: \"Inception\",\n            Year:  2010,\n\
    \        }\n\n        err := repo.Insert(context.Background(), movie)\n      \
    \  assert.NoError(t, err)\n\n        retrieved, err := repo.GetByID(context.Background(),\
    \ movie.ID)\n        assert.NoError(t, err)\n        assert.Equal(t, movie.Title,\
    \ retrieved.Title)\n        assert.Equal(t, movie.Year, retrieved.Year)\n    })\n\
    }\n```"
  testcontainers_dragonfly: "```go\nfunc setupDragonfly(t *testing.T) (rueidis.Client,\
    \ func()) {\n    t.Helper()\n\n    ctx := context.Background()\n\n    req := testcontainers.ContainerRequest{\n\
    \        Image:        \"docker.dragonflydb.io/dragonflydb/dragonfly:latest\"\
    ,\n        ExposedPorts: []string{\"6379/tcp\"},\n        WaitingFor:   wait.ForLog(\"\
    accepting connections\"),\n    }\n\n    container, err := testcontainers.GenericContainer(ctx,\
    \ testcontainers.GenericContainerRequest{\n        ContainerRequest: req,\n  \
    \      Started:          true,\n    })\n    if err != nil {\n        t.Fatalf(\"\
    failed to start dragonfly: %v\", err)\n    }\n\n    host, _ := container.Host(ctx)\n\
    \    port, _ := container.MappedPort(ctx, \"6379\")\n\n    client, err := rueidis.NewClient(rueidis.ClientOption{\n\
    \        InitAddress: []string{fmt.Sprintf(\"%s:%s\", host, port.Port())},\n \
    \   })\n    if err != nil {\n        container.Terminate(ctx)\n        t.Fatalf(\"\
    failed to connect to dragonfly: %v\", err)\n    }\n\n    cleanup := func() {\n\
    \        client.Close()\n        container.Terminate(ctx)\n    }\n\n    return\
    \ client, cleanup\n}\n```"
  embedded_postgres: "```go\npackage repository_test\n\nimport (\n    \"testing\"\n\
    \    embeddedpostgres \"github.com/fergusstrange/embedded-postgres\"\n)\n\nfunc\
    \ setupEmbeddedPostgres(t *testing.T) (*pgxpool.Pool, func()) {\n    t.Helper()\n\
    \n    // Start embedded PostgreSQL\n    postgres := embeddedpostgres.NewDatabase(embeddedpostgres.DefaultConfig().\n\
    \        Port(5433).\n        Username(\"test\").\n        Password(\"test\").\n\
    \        Database(\"testdb\"))\n\n    if err := postgres.Start(); err != nil {\n\
    \        t.Fatalf(\"failed to start embedded postgres: %v\", err)\n    }\n\n \
    \   // Connect\n    pool, err := pgxpool.New(context.Background(), \"postgres://test:test@localhost:5433/testdb\"\
    )\n    if err != nil {\n        postgres.Stop()\n        t.Fatalf(\"failed to\
    \ connect: %v\", err)\n    }\n\n    cleanup := func() {\n        pool.Close()\n\
    \        postgres.Stop()\n    }\n\n    return pool, cleanup\n}\n```"
test_coverage:
  running_coverage: '```bash

    # Run tests with coverage

    go test -coverprofile=coverage.out ./...


    # View coverage in terminal

    go tool cover -func=coverage.out


    # Generate HTML coverage report

    go tool cover -html=coverage.out -o coverage.html


    # Check coverage threshold (80%)

    go test -coverprofile=coverage.out ./... && \

    go tool cover -func=coverage.out | grep total | awk ''{print $3}'' | sed ''s/%//''
    | \

    awk ''{if ($1 < 80) exit 1}''

    ```'
  coverage_reports: '```go

    // Example output

    revenge/internal/service/movie/service.go:23:    GetByID       95.0%

    revenge/internal/service/movie/service.go:45:    Create        88.9%

    revenge/internal/service/movie/service.go:67:    Update        92.3%

    revenge/internal/service/movie/service.go:89:    Delete        100.0%

    total:                                           (statements)  91.5%

    ```'
  ci_integration: "```yaml\n# .github/workflows/test.yml\nname: Tests\n\non: [push,\
    \ pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n  \
    \    - uses: actions/checkout@v4\n      \n      - name: Set up Go\n        uses:\
    \ actions/setup-go@v5\n        with:\n          go-version: '1.25'\n      \n \
    \     - name: Run tests with coverage\n        run: go test -race -coverprofile=coverage.out\
    \ -covermode=atomic ./...\n      \n      - name: Check coverage threshold\n  \
    \      run: |\n          coverage=$(go tool cover -func=coverage.out | grep total\
    \ | awk '{print $3}' | sed 's/%//')\n          if (( $(echo \"$coverage < 80\"\
    \ | bc -l) )); then\n            echo \"Coverage $coverage% is below 80% threshold\"\
    \n            exit 1\n          fi\n      \n      - name: Upload coverage to Codecov\n\
    \        uses: codecov/codecov-action@v4\n        with:\n          file: ./coverage.out\n\
    ```"
test_organization:
  file_structure: "```\ninternal/\n  service/\n    movie/\n      service.go      \
    \     # Implementation\n      service_test.go      # Unit tests\n  repository/\n\
    \    movie.go              # Repository implementation\n    movie_test.go    \
    \     # Integration tests\n    mocks/                # Generated mocks\n     \
    \ movie_repository.go\n  testutil/               # Test helpers\n    fixtures.go\n\
    \    helpers.go\n```"
  naming_conventions:
  - pattern: TestFunctionName
    description: Test for specific function
    example: TestMovieService_GetByID
  - pattern: TestFunctionName_Scenario
    description: Specific scenario
    example: TestMovieService_GetByID_NotFound
  - pattern: TestFunctionName_StateUnderTest_ExpectedBehavior
    description: Detailed test name
    example: TestMovieService_Create_WithInvalidYear_ReturnsError
best_practices:
- practice: Follow arrange-act-assert pattern
  reason: Clear test structure
  example: "```go\nfunc TestExample(t *testing.T) {\n    // Arrange\n    input :=\
    \ \"test\"\n    expected := \"TEST\"\n    \n    // Act\n    result := ToUpper(input)\n\
    \    \n    // Assert\n    assert.Equal(t, expected, result)\n}\n```"
- practice: Use table-driven tests
  reason: Test multiple scenarios efficiently
  benefit: Reduces duplication, easy to add cases
- practice: Test behavior, not implementation
  reason: Tests should survive refactoring
  example: Test public API, not internal state
- practice: Use descriptive test names
  reason: Failing tests should explain what broke
  example: TestMovieService_Create_WithDuplicateTitle_ReturnsError
- practice: Mock external dependencies
  reason: Fast, isolated unit tests
  tools: mockery, testify/mock
- practice: Use real dependencies for integration tests
  reason: Catch real-world issues
  tools: testcontainers-go
- practice: Avoid test interdependence
  reason: Tests should run in any order
  implementation: Use t.Parallel() where possible
- practice: Clean up resources in tests
  reason: Prevent resource leaks
  example: Use defer cleanup()
- practice: Use test helpers
  reason: Reduce test boilerplate
  benefit: More readable tests
- practice: Test error paths
  reason: Errors are part of behavior
  coverage: Aim for 100% error path coverage
- practice: Use sub-tests for grouping
  reason: Better organization and isolation
  example: "```go\nfunc TestMovieService(t *testing.T) {\n    t.Run(\"GetByID\", func(t\
    \ *testing.T) {\n        // Tests for GetByID\n    })\n    t.Run(\"Create\", func(t\
    \ *testing.T) {\n        // Tests for Create\n    })\n}\n```"
- practice: Maintain 80% minimum coverage
  reason: Ensures code is well-tested
  enforcement: CI/CD fails below threshold
common_patterns:
  testing_http_handlers: "```go\nfunc TestMovieHandler_Get(t *testing.T) {\n    mockService\
    \ := mocks.NewMovieService(t)\n    mockService.On(\"GetByID\", mock.Anything,\
    \ uuid.MustParse(\"123\")).\n        Return(&movie.Movie{Title: \"Inception\"\
    }, nil)\n\n    handler := NewMovieHandler(mockService)\n\n    req := httptest.NewRequest(\"\
    GET\", \"/api/v1/movies/123\", nil)\n    w := httptest.NewRecorder()\n\n    handler.Get(w,\
    \ req)\n\n    assert.Equal(t, http.StatusOK, w.Code)\n    assert.Contains(t, w.Body.String(),\
    \ \"Inception\")\n}\n```"
  testing_database_transactions: "```go\nfunc TestMovieRepository_Transaction(t *testing.T)\
    \ {\n    pool, cleanup := setupPostgres(t)\n    defer cleanup()\n\n    repo :=\
    \ repository.NewMovieRepository(pool)\n\n    t.Run(\"rollback on error\", func(t\
    \ *testing.T) {\n        tx, _ := pool.Begin(context.Background())\n        defer\
    \ tx.Rollback(context.Background())\n\n        movie := &repository.Movie{ID:\
    \ uuid.New(), Title: \"Test\"}\n        repo.Insert(context.Background(), tx,\
    \ movie)\n\n        // Trigger error (duplicate insert)\n        err := repo.Insert(context.Background(),\
    \ tx, movie)\n        assert.Error(t, err)\n\n        tx.Rollback(context.Background())\n\
    \n        // Verify movie was not inserted\n        _, err = repo.GetByID(context.Background(),\
    \ movie.ID)\n        assert.Error(t, err)\n    })\n}\n```"
  testing_concurrent_code: "```go\nfunc TestCacheService_Concurrent(t *testing.T)\
    \ {\n    cache := NewCacheService()\n\n    var wg sync.WaitGroup\n    for i :=\
    \ 0; i < 100; i++ {\n        wg.Add(1)\n        go func(n int) {\n           \
    \ defer wg.Done()\n            key := fmt.Sprintf(\"key-%d\", n)\n           \
    \ cache.Set(key, fmt.Sprintf(\"value-%d\", n))\n            value, _ := cache.Get(key)\n\
    \            assert.Equal(t, fmt.Sprintf(\"value-%d\", n), value)\n        }(i)\n\
    \    }\n    wg.Wait()\n}\n```"
