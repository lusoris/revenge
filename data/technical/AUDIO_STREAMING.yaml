doc_title: Audio Streaming & Progress Tracking
doc_category: technical
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: Complete audio streaming design
status_sources: âœ…
status_sources_notes: All streaming tools documented
status_instructions: âœ…
status_instructions_notes: Generated from design
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: |-
  > HLS audio streaming with adaptive bitrate and progress tracking

  Audio streaming architecture:
  - **Protocol**: HLS (HTTP Live Streaming) via gohlslib
  - **Codecs**: AAC, MP3, FLAC, Opus (transcode on-demand)
  - **Adaptive Bitrate**: Multiple quality streams (64k, 128k, 256k, 320k)
  - **Progress Tracking**: Per-second accuracy with real-time sync
  - **Session Management**: Resume playback across devices

wiki_tagline: |-
  > Stream your music with adaptive quality and seamless progress sync

wiki_overview: |-
  The Audio Streaming system delivers high-quality music playback using HLS (HTTP Live Streaming) with adaptive bitrate selection. Your progress is tracked per-second and synced in real-time across all devices, so you can start listening on your phone and continue on your computer exactly where you left off.
sources:
  - name: gohlslib (HLS)
    url: https://pkg.go.dev/github.com/bluenviron/gohlslib/v2
    note: HLS server implementation
  - name: go-astiav (FFmpeg)
    url: https://pkg.go.dev/github.com/asticode/go-astiav
    note: Audio transcoding
  - name: Dragonfly
    url: https://www.dragonflydb.io/docs
    note: Progress tracking cache

design_refs:
- title: technical
  path: technical.md
- title: 01_ARCHITECTURE
  path: architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: architecture/03_METADATA_SYSTEM.md

streaming_protocol: HLS (HTTP Live Streaming)
streaming_library: gohlslib v2

supported_codecs:
  input:
    - format: MP3
      codec: MPEG-1/2 Audio Layer III
      action: Direct stream or transcode
    - format: FLAC
      codec: Free Lossless Audio Codec
      action: Transcode to AAC/Opus
    - format: AAC
      codec: Advanced Audio Coding
      action: Direct stream
    - format: OGG
      codec: Vorbis/Opus
      action: Direct stream or transcode
    - format: ALAC
      codec: Apple Lossless
      action: Transcode to AAC
    - format: Opus
      codec: Opus
      action: Direct stream (best quality/bandwidth)

  output:
    - format: AAC
      bitrates: [64k, 128k, 256k, 320k]
      container: M4A (HLS compatible)
      preferred: true
    - format: MP3
      bitrates: [128k, 192k, 256k, 320k]
      container: MP3
    - format: Opus
      bitrates: [64k, 96k, 128k, 160k]
      container: OGG/WebM

adaptive_bitrate:
  strategy: Client-driven based on bandwidth
  quality_levels:
    - name: Low
      bitrate: 64kbps
      codec: AAC
      use_case: Mobile data, slow connection
    - name: Normal
      bitrate: 128kbps
      codec: AAC
      use_case: Standard streaming
    - name: High
      bitrate: 256kbps
      codec: AAC
      use_case: Wi-Fi, good connection
    - name: Lossless
      bitrate: 320kbps+
      codec: FLAC/ALAC (if source is lossless)
      use_case: Audiophile quality

  switching:
    method: Seamless switching between quality levels
    buffer: 3-5 seconds of audio buffer
    algorithm: Monitor network speed, adjust bitrate accordingly

hls_implementation:
  segment_duration: 6 seconds
  playlist_type: Live (continuous streaming)
  segments_per_playlist: 5-10 segments

  manifest_example: |
    ```m3u8
    #EXTM3U
    #EXT-X-VERSION:3
    #EXT-X-TARGETDURATION:6
    #EXT-X-MEDIA-SEQUENCE:0
    #EXTINF:6.0,
    segment0.ts
    #EXTINF:6.0,
    segment1.ts
    #EXTINF:6.0,
    segment2.ts
    #EXT-X-ENDLIST
    ```

  url_pattern: /api/v1/stream/:track_id/playlist.m3u8
  segment_url_pattern: /api/v1/stream/:track_id/segment:N.ts

transcoding:
  library: go-astiav (FFmpeg bindings)
  on_demand: true
  cache_transcoded: true
  cache_ttl: 24 hours

  transcode_pipeline: |
    ```go
    func TranscodeToAAC(inputPath string, bitrate int) (io.ReadCloser, error) {
        // Open input file
        inputCtx, err := astiav.OpenInput(inputPath)
        if err != nil {
            return nil, err
        }

        // Find audio stream
        audioStream := inputCtx.FindBestStream(astiav.MediaTypeAudio)

        // Create encoder
        encoder := astiav.FindEncoderByName("aac")
        encoderCtx := astiav.AllocCodecContext(encoder)
        encoderCtx.SetBitRate(int64(bitrate * 1000))
        encoderCtx.SetSampleRate(44100)
        encoderCtx.SetChannelLayout(astiav.ChannelLayoutStereo)

        // Transcode loop
        // ... (read frames, encode, write to output)

        return outputReader, nil
    }
    ```

progress_tracking:
  granularity: Per-second accuracy
  update_interval: 10 seconds
  storage: Dragonfly (Redis-compatible)
  persistence: PostgreSQL (backup every 60 seconds)

  database_schema: |
    ```sql
    CREATE TABLE playback_progress (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID NOT NULL,
      track_id UUID REFERENCES tracks(id) ON DELETE CASCADE,
      position_seconds NUMERIC NOT NULL DEFAULT 0,
      duration_seconds NUMERIC NOT NULL,
      playback_rate NUMERIC DEFAULT 1.0,
      last_updated TIMESTAMPTZ DEFAULT NOW(),
      completed BOOLEAN DEFAULT FALSE,
      created_at TIMESTAMPTZ DEFAULT NOW(),
      updated_at TIMESTAMPTZ DEFAULT NOW(),
      UNIQUE(user_id, track_id)
    );

    CREATE INDEX idx_playback_progress_user ON playback_progress(user_id);
    CREATE INDEX idx_playback_progress_updated ON playback_progress(user_id, last_updated DESC);
    ```

  update_pattern: |
    ```go
    func UpdateProgress(ctx context.Context, userID, trackID uuid.UUID, position float64) error {
        // Update in cache (fast)
        key := fmt.Sprintf("progress:%s:%s", userID, trackID)
        err := cache.Set(ctx, key, position, 5*time.Minute).Err()
        if err != nil {
            return err
        }

        // Async update to database (every 60s or on completion)
        if shouldPersist(position) {
            go func() {
                repo.UpdateProgress(ctx, userID, trackID, position)
            }()
        }

        return nil
    }
    ```

session_management:
  resume_playback: Automatic resume from last position
  cross_device_sync: Real-time sync via Dragonfly
  offline_mode: Queue progress updates, sync when online

  scrobbling_integration:
    trigger_at: 50% played or 4 minutes (whichever first)
    services: Last.fm, ListenBrainz
    deduplication: Prevent multiple scrobbles for same track

gapless_playback:
  supported: true
  method: Preload next track when 80% through current
  buffer_overlap: 2 seconds
  implementation: Client-side crossfade

api_endpoints:
  - method: GET
    path: /api/v1/stream/:track_id/playlist.m3u8
    description: HLS master playlist
  - method: GET
    path: /api/v1/stream/:track_id/segment:N.ts
    description: HLS segment
  - method: GET
    path: /api/v1/playback/progress/:track_id
    description: Get current progress
  - method: PUT
    path: /api/v1/playback/progress/:track_id
    description: Update progress
    request_example: '{"position_seconds": 123.45, "duration_seconds": 245.0}'
  - method: POST
    path: /api/v1/playback/scrobble
    description: Submit scrobble

best_practices:
  - practice: Use HLS for adaptive streaming
    reason: Industry standard, works everywhere
  - practice: Transcode on-demand
    reason: Saves storage, serves all quality levels
  - practice: Cache transcoded segments
    reason: Reduces CPU load on repeat playback
  - practice: Update progress every 10 seconds
    reason: Balance between accuracy and API load
  - practice: Store progress in cache first
    reason: Fast updates, async DB persistence
  - practice: Preload next track at 80%
    reason: Enables gapless playback
