doc_title: WebSockets
doc_category: technical
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: Complete WebSocket system design
status_sources: âœ…
status_sources_notes: coder/websocket documentation included
status_instructions: âœ…
status_instructions_notes: Generated from design
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Real-time bidirectional communication via WebSockets


  Complete WebSocket infrastructure:

  - **Library**: nhooyr.io/websocket (coder/websocket)

  - **Channels**: Playback sync, notifications, live updates, transcoding progress

  - **Authentication**: JWT token validation on connect

  - **Protocol**: JSON message format with type-based routing

  - **Features**: Automatic reconnection, heartbeat/ping, message acknowledgment'
wiki_tagline: '> Real-time updates for playback, notifications, and live server events'
wiki_overview: The WebSocket System enables real-time bidirectional communication
  between the server and clients. Receive instant notifications, sync playback state
  across devices, monitor transcoding progress, and get live server updates. Built
  on the high-performance nhooyr.io/websocket library with automatic reconnection
  and heartbeat support for reliable connections.
sources:
- name: coder/websocket GitHub README
  url: https://github.com/coder/websocket
  note: Auto-resolved from coder-websocket-docs
- name: nhooyr.io/websocket
  url: https://pkg.go.dev/nhooyr.io/websocket
  note: WebSocket library (coder/websocket)
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
design_refs:
- title: technical
  path: INDEX.md
- title: 01_ARCHITECTURE
  path: ../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../architecture/02_DESIGN_PRINCIPLES.md
- title: WEBSOCKETS (Syncplay)
  path: ../features/playback/SYNCPLAY.md
websocket_library:
  name: nhooyr.io/websocket
  repository: https://github.com/coder/websocket
  advantages:
  - Pure Go implementation
  - High performance (no cgo)
  - Context-aware APIs
  - Automatic compression
  - Proper backpressure handling
  - Clean, modern API
  standards_compliance: RFC 6455 (WebSocket Protocol)
websocket_endpoints:
- endpoint: GET /api/v1/ws
  description: Main WebSocket connection for all real-time events
  authentication: JWT token (via query param or cookie)
  protocol: JSON messages with type field
- endpoint: GET /api/v1/ws/playback/:session_id
  description: Syncplay session for synchronized playback
  authentication: Session invite token or user JWT
  protocol: Syncplay-specific message format
- endpoint: GET /api/v1/ws/transcode/:job_id
  description: Live transcoding progress updates
  authentication: User JWT
  protocol: Progress percentage and status updates
websocket_authentication:
  methods:
  - method: JWT Query Parameter
    usage: wss://revenge.example.com/api/v1/ws?token=eyJhbG...
    recommended: For web clients
  - method: JWT Cookie
    usage: wss://revenge.example.com/api/v1/ws (cookie sent automatically)
    recommended: For browser-based clients
  - method: Authorization Header
    usage: Not supported by WebSocket standard
    alternative: Use query param or cookie
  validation: "```go\nfunc (h *WebSocketHandler) HandleConnection(w http.ResponseWriter,\
    \ r *http.Request) {\n    // Extract token from query or cookie\n    token :=\
    \ r.URL.Query().Get(\"token\")\n    if token == \"\" {\n        cookie, err :=\
    \ r.Cookie(\"auth_token\")\n        if err == nil {\n            token = cookie.Value\n\
    \        }\n    }\n\n    // Validate JWT\n    claims, err := h.jwtService.ValidateToken(token)\n\
    \    if err != nil {\n        http.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\
    \        return\n    }\n\n    // Upgrade to WebSocket\n    conn, err := websocket.Accept(w,\
    \ r, &websocket.AcceptOptions{\n        CompressionMode: websocket.CompressionContextTakeover,\n\
    \    })\n    if err != nil {\n        return\n    }\n\n    // Handle connection\
    \ with user context\n    h.handleWebSocket(r.Context(), conn, claims.UserID)\n\
    }\n```\n"
message_protocol:
  format: JSON
  structure: "{\n  \"type\": \"message_type\",\n  \"id\": \"unique-message-id\",\n\
    \  \"timestamp\": \"2026-01-31T12:00:00Z\",\n  \"data\": { ... }\n}\n"
  message_types:
    client_to_server:
    - type: subscribe
      description: Subscribe to event channels
      data:
        channels:
        - notifications
        - playback
        - transcoding
      example: "{\n  \"type\": \"subscribe\",\n  \"id\": \"msg-123\",\n  \"data\"\
        : {\n    \"channels\": [\"notifications\", \"playback\"]\n  }\n}\n"
    - type: unsubscribe
      description: Unsubscribe from channels
      data:
        channels:
        - notifications
    - type: ping
      description: Heartbeat to keep connection alive
      data: {}
    - type: playback.update
      description: Update playback state (for Syncplay)
      data:
        position: 123.45
        state: playing
        timestamp: '2026-01-31T12:00:00Z'
    server_to_client:
    - type: pong
      description: Response to ping
      data: {}
    - type: notification
      description: Push notification
      data:
        notification_type: content.new_episode
        title: New episode available
        body: Breaking Bad S05E14
        content_id: uuid-here
    - type: playback.sync
      description: Sync playback state (Syncplay)
      data:
        position: 123.45
        state: playing
        leader_id: user-uuid
    - type: transcode.progress
      description: Transcoding job progress
      data:
        job_id: uuid-here
        progress: 45.5
        status: encoding
        eta_seconds: 120
    - type: server.event
      description: Live server events
      data:
        event_type: library.scan.started
        message: Scanning Movies library
    - type: error
      description: Error message
      data:
        code: INVALID_MESSAGE
        message: Unknown message type
connection_management:
  connection_lifecycle: "```go\ntype WebSocketConnection struct {\n    conn      \
    \ *websocket.Conn\n    userID     uuid.UUID\n    channels   map[string]bool\n\
    \    sendChan   chan Message\n    closeChan  chan struct{}\n    ctx        context.Context\n\
    \    cancel     context.CancelFunc\n}\n\nfunc (h *WebSocketHandler) handleWebSocket(ctx\
    \ context.Context, conn *websocket.Conn, userID uuid.UUID) {\n    wsConn := &WebSocketConnection{\n\
    \        conn:      conn,\n        userID:    userID,\n        channels:  make(map[string]bool),\n\
    \        sendChan:  make(chan Message, 100),\n        closeChan: make(chan struct{}),\n\
    \    }\n    wsConn.ctx, wsConn.cancel = context.WithCancel(ctx)\n    defer wsConn.cancel()\n\
    \n    // Register connection\n    h.registerConnection(wsConn)\n    defer h.unregisterConnection(wsConn)\n\
    \n    // Start goroutines\n    go wsConn.writePump()\n    go wsConn.readPump()\n\
    \n    // Wait for close\n    <-wsConn.closeChan\n}\n\nfunc (c *WebSocketConnection)\
    \ readPump() {\n    defer close(c.closeChan)\n\n    for {\n        var msg Message\n\
    \        err := wsjson.Read(c.ctx, c.conn, &msg)\n        if err != nil {\n  \
    \          return\n        }\n\n        // Handle message\n        c.handleMessage(msg)\n\
    \    }\n}\n\nfunc (c *WebSocketConnection) writePump() {\n    ticker := time.NewTicker(30\
    \ * time.Second)\n    defer ticker.Stop()\n\n    for {\n        select {\n   \
    \     case msg := <-c.sendChan:\n            err := wsjson.Write(c.ctx, c.conn,\
    \ msg)\n            if err != nil {\n                return\n            }\n\n\
    \        case <-ticker.C:\n            // Send ping\n            c.sendChan <-\
    \ Message{Type: \"ping\"}\n\n        case <-c.ctx.Done():\n            return\n\
    \        }\n    }\n}\n```\n"
  heartbeat:
    interval: 30 seconds
    timeout: 90 seconds
    mechanism: Client sends ping, server responds with pong
  reconnection:
    client_responsibility: true
    exponential_backoff: 1s, 2s, 4s, 8s, 16s, 30s (max)
    resume_subscriptions: Client resubscribes to channels on reconnect
  connection_limits:
    per_user: 10 concurrent connections
    global: 10000 concurrent connections
    idle_timeout: 5 minutes
channels:
  notifications:
    description: Receive push notifications in real-time
    messages:
    - notification (new content, server alerts, etc.)
    subscription: Auto-subscribe on connect
  playback:
    description: Syncplay synchronized playback
    messages:
    - playback.sync
    - playback.pause
    - playback.seek
    subscription: Manual subscribe with session ID
  transcoding:
    description: Live transcoding progress
    messages:
    - transcode.progress
    - transcode.complete
    - transcode.error
    subscription: Auto-subscribe when user starts transcode job
  server:
    description: Server events and status updates
    messages:
    - server.event
    - library.scan.progress
    - library.scan.complete
    subscription: Admin users only
  activity:
    description: User activity feed
    messages:
    - activity.user_watching
    - activity.friend_online
    subscription: Manual subscribe
broadcasting:
  user_broadcast:
    description: Send message to specific user
    implementation: "```go\nfunc (h *WebSocketHandler) BroadcastToUser(userID uuid.UUID,\
      \ msg Message) {\n    h.mu.RLock()\n    defer h.mu.RUnlock()\n\n    conns :=\
      \ h.userConnections[userID]\n    for _, conn := range conns {\n        select\
      \ {\n        case conn.sendChan <- msg:\n        default:\n            // Buffer\
      \ full, drop message\n            slog.Warn(\"websocket send buffer full\",\
      \ \"user_id\", userID)\n        }\n    }\n}\n```\n"
  channel_broadcast:
    description: Send message to all subscribed to channel
    implementation: "```go\nfunc (h *WebSocketHandler) BroadcastToChannel(channel\
      \ string, msg Message) {\n    h.mu.RLock()\n    defer h.mu.RUnlock()\n\n   \
      \ for _, conn := range h.connections {\n        if conn.channels[channel] {\n\
      \            select {\n            case conn.sendChan <- msg:\n            default:\n\
      \                // Buffer full, drop message\n            }\n        }\n  \
      \  }\n}\n```\n"
  global_broadcast:
    description: Send message to all connected clients
    use_case: Server shutdown announcement
use_cases:
  playback_sync:
    description: Synchronized playback across multiple devices (Syncplay)
    messages:
    - Client sends playback.update when playing/pausing
    - Server broadcasts playback.sync to all session participants
    - Automatic leader election (first to join)
    example_flow: '1. User creates Syncplay session

      2. Friend joins session via invite link

      3. User presses play â†’ sends playback.update

      4. Server broadcasts playback.sync to friend

      5. Friend''s player syncs to same position

      '
  live_notifications:
    description: Real-time push notifications
    messages:
    - Server sends notification when new content added
    - Client displays toast/banner
    example: 'New episode: Breaking Bad S05E14'
  transcoding_progress:
    description: Live progress for transcoding jobs
    messages:
    - Server sends transcode.progress every 2 seconds
    - Client updates progress bar
    example: 'Transcoding: 45% complete (2 minutes remaining)'
  live_updates:
    description: Real-time UI updates
    messages:
    - Library scan progress
    - Download status
    - Server health
    example: 'Scanning Movies: 1234 / 5000 files processed'
error_handling:
  connection_errors:
  - error: Authentication failed
    status: 401 Unauthorized
    action: Reject WebSocket upgrade
  - error: Rate limit exceeded
    status: 429 Too Many Requests
    action: Reject WebSocket upgrade
  - error: Connection closed by client
    action: Cleanup resources, unregister connection
  - error: Send buffer full
    action: Drop message, log warning
  message_errors:
  - error: Invalid JSON
    response:
      type: error
      data:
        code: INVALID_JSON
  - error: Unknown message type
    response:
      type: error
      data:
        code: UNKNOWN_TYPE
  - error: Unauthorized channel
    response:
      type: error
      data:
        code: UNAUTHORIZED
client_example:
  javascript: "```javascript\nclass RevengeWebSocket {\n  constructor(token) {\n \
    \   this.token = token;\n    this.ws = null;\n    this.reconnectDelay = 1000;\n\
    \    this.connect();\n  }\n\n  connect() {\n    const url = `wss://revenge.example.com/api/v1/ws?token=${this.token}`;\n\
    \    this.ws = new WebSocket(url);\n\n    this.ws.onopen = () => {\n      console.log('WebSocket\
    \ connected');\n      this.reconnectDelay = 1000;\n\n      // Subscribe to channels\n\
    \      this.send({\n        type: 'subscribe',\n        data: { channels: ['notifications',\
    \ 'playback'] }\n      });\n    };\n\n    this.ws.onmessage = (event) => {\n \
    \     const msg = JSON.parse(event.data);\n      this.handleMessage(msg);\n  \
    \  };\n\n    this.ws.onerror = (error) => {\n      console.error('WebSocket error:',\
    \ error);\n    };\n\n    this.ws.onclose = () => {\n      console.log('WebSocket\
    \ closed, reconnecting...');\n      setTimeout(() => this.connect(), this.reconnectDelay);\n\
    \      this.reconnectDelay = Math.min(this.reconnectDelay * 2, 30000);\n    };\n\
    \n    // Heartbeat\n    setInterval(() => {\n      if (this.ws.readyState ===\
    \ WebSocket.OPEN) {\n        this.send({ type: 'ping' });\n      }\n    }, 30000);\n\
    \  }\n\n  send(message) {\n    message.id = crypto.randomUUID();\n    message.timestamp\
    \ = new Date().toISOString();\n    this.ws.send(JSON.stringify(message));\n  }\n\
    \n  handleMessage(msg) {\n    switch (msg.type) {\n      case 'pong':\n      \
    \  // Heartbeat response\n        break;\n      case 'notification':\n       \
    \ this.showNotification(msg.data);\n        break;\n      case 'playback.sync':\n\
    \        this.syncPlayback(msg.data);\n        break;\n      default:\n      \
    \  console.log('Unknown message:', msg);\n    }\n  }\n}\n```\n"
best_practices:
- practice: Authenticate on connection
  reason: Verify user identity before accepting WebSocket
- practice: Use compression
  reason: Reduce bandwidth for JSON messages
- practice: Implement heartbeat/ping
  reason: Detect dead connections early
- practice: Buffer outgoing messages
  reason: Handle slow clients gracefully
- practice: Limit message size
  reason: Prevent memory exhaustion attacks
- practice: Rate limit connections
  reason: Prevent DoS attacks
- practice: Clean up resources on disconnect
  reason: Avoid memory leaks
- practice: Use channels for broadcasting
  reason: Efficient message routing
- practice: Handle reconnection on client
  reason: Resilient real-time experience
- practice: Log connection events
  reason: Debugging and monitoring
