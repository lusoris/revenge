doc_title: Revenge - Architecture v2
doc_category: architecture
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âšª
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: Generated from design
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: |
  > Modern media server architecture with Go backend, SvelteKit frontend, PostgreSQL database

  Core components:
  - **Backend**: Go with fx dependency injection, ogen OpenAPI generation
  - **Frontend**: SvelteKit 2, Svelte 5, Tailwind CSS 4, shadcn-svelte
  - **Database**: PostgreSQL 18 with pgx driver (no SQLite)
  - **Cache**: Dragonfly (Redis-compatible) via rueidis + otter L1 cache
  - **Search**: Typesense for full-text search
  - **Jobs**: River queue for background processing
wiki_tagline: '> How Revenge is built - the technical foundation'
wiki_overview: Revenge is built with a Go backend and SvelteKit frontend. PostgreSQL stores all data (no SQLite), with Dragonfly
  providing fast caching and Typesense powering search. Background jobs run through River queue. The backend uses fx for dependency
  injection and ogen for type-safe API generation. The frontend uses Svelte 5 with shadcn-svelte components. All components
  are designed for self-hosting with Docker or bare metal deployment.
sources:
- name: Dragonfly Documentation
  url: https://www.dragonflydb.io/docs
  note: Auto-resolved from dragonfly
- name: FFmpeg Documentation
  url: https://ffmpeg.org/ffmpeg.html
  note: Auto-resolved from ffmpeg
- name: FFmpeg Codecs
  url: https://ffmpeg.org/ffmpeg-codecs.html
  note: Auto-resolved from ffmpeg-codecs
- name: FFmpeg Formats
  url: https://ffmpeg.org/ffmpeg-formats.html
  note: Auto-resolved from ffmpeg-formats
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: go-astiav (FFmpeg bindings)
  url: https://pkg.go.dev/github.com/asticode/go-astiav
  note: Auto-resolved from go-astiav
- name: go-astiav GitHub README
  url: https://github.com/asticode/go-astiav
  note: Auto-resolved from go-astiav-docs
- name: go-blurhash
  url: https://pkg.go.dev/github.com/bbrks/go-blurhash
  note: Auto-resolved from go-blurhash
- name: gohlslib (HLS)
  url: https://pkg.go.dev/github.com/bluenviron/gohlslib/v2
  note: Auto-resolved from gohlslib
- name: koanf
  url: https://pkg.go.dev/github.com/knadh/koanf/v2
  note: Auto-resolved from koanf
- name: Last.fm API
  url: https://www.last.fm/api/intro
  note: Auto-resolved from lastfm-api
- name: M3U8 Extended Format
  url: https://datatracker.ietf.org/doc/html/rfc8216
  note: Auto-resolved from m3u8
- name: ogen OpenAPI Generator
  url: https://pkg.go.dev/github.com/ogen-go/ogen
  note: Auto-resolved from ogen
- name: pgx PostgreSQL Driver
  url: https://pkg.go.dev/github.com/jackc/pgx/v5
  note: Auto-resolved from pgx
- name: PostgreSQL Arrays
  url: https://www.postgresql.org/docs/current/arrays.html
  note: Auto-resolved from postgresql-arrays
- name: PostgreSQL JSON Functions
  url: https://www.postgresql.org/docs/current/functions-json.html
  note: Auto-resolved from postgresql-json
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: rueidis
  url: https://pkg.go.dev/github.com/redis/rueidis
  note: Auto-resolved from rueidis
- name: rueidis GitHub README
  url: https://github.com/redis/rueidis
  note: Auto-resolved from rueidis-docs
- name: shadcn-svelte
  url: https://www.shadcn-svelte.com/docs
  note: Auto-resolved from shadcn-svelte
- name: sqlc
  url: https://docs.sqlc.dev/en/stable/
  note: Auto-resolved from sqlc
- name: sqlc Configuration
  url: https://docs.sqlc.dev/en/stable/reference/config.html
  note: Auto-resolved from sqlc-config
- name: Svelte 5 Runes
  url: https://svelte.dev/docs/svelte/$state
  note: Auto-resolved from svelte-runes
- name: Svelte 5 Documentation
  url: https://svelte.dev/docs/svelte/overview
  note: Auto-resolved from svelte5
- name: SvelteKit Documentation
  url: https://svelte.dev/docs/kit/introduction
  note: Auto-resolved from sveltekit
- name: TanStack Query
  url: https://tanstack.com/query/latest/docs/framework/svelte/overview
  note: Auto-resolved from tanstack-query
- name: Typesense API
  url: https://typesense.org/docs/latest/api/
  note: Auto-resolved from typesense
- name: Typesense Go Client
  url: https://github.com/typesense/typesense-go
  note: Auto-resolved from typesense-go
design_refs:
- title: architecture
  path: INDEX.md
- title: 03_METADATA_SYSTEM
  path: 03_METADATA_SYSTEM.md
- title: METADATA (service)
  path: ../services/METADATA.md
- title: DRAGONFLY (integration)
  path: ../integrations/infrastructure/DRAGONFLY.md
- title: HTTP_CLIENT (service)
  path: ../services/HTTP_CLIENT.md
- title: RADARR (PRIMARY metadata + downloads)
  path: ../integrations/servarr/RADARR.md
- title: SONARR (PRIMARY metadata + downloads)
  path: ../integrations/servarr/SONARR.md
- title: LIDARR (PRIMARY metadata + downloads)
  path: ../integrations/servarr/LIDARR.md
- title: CHAPTARR (PRIMARY metadata + downloads)
  path: ../integrations/servarr/CHAPTARR.md
- title: WHISPARR (PRIMARY metadata + downloads)
  path: ../integrations/servarr/WHISPARR.md
- title: TMDB (SUPPLEMENTARY metadata)
  path: ../integrations/metadata/video/TMDB.md
- title: THETVDB (SUPPLEMENTARY metadata)
  path: ../integrations/metadata/video/THETVDB.md
- title: ADULT_CONTENT_SYSTEM
  path: ../features/adult/ADULT_CONTENT_SYSTEM.md
- title: ADULT_METADATA
  path: ../features/adult/ADULT_METADATA.md
- title: DATA_RECONCILIATION
  path: ../features/adult/DATA_RECONCILIATION.md
architecture_diagram: |-
  Revenge follows a **layered architecture** with clear separation of concerns:

  ```mermaid
  flowchart LR
      subgraph Client["Client Layer"]
          node1[" "]
      end

      subgraph API["API Layer"]
          node2[" "]
      end

      subgraph Service["Service Layer"]
          node3[" "]
      end

      subgraph Layer4["Layer 4"]
          node4[["Content<br/>Services"]]
          node5[["Metadata<br/>Services"]]
          node6[["Auth<br/>Services"]]
          node7["Media<br/>Processing"]
      end

      subgraph Layer5["Layer 5"]
          node8["Repository<br/>Layer<br/>(sqlc + pgx)"]
          node9["Metadata Priority<br/>Chain"]
      end

      subgraph Layer6["Layer 6"]
          node10[("PostgreSQL<br/>Database<br/>(pgx pool)")]
          node11[("L1 Cache L2 Cache<br/>Arr Services External<br/>(otter Dragonfly")]
      end

      %% Connections
      node1 --> node2
      node2 --> node3
      node3 --> node4
      node7 --> node8
      node9 --> node10

      %% Styling
      style Client fill:#1976D2,stroke:#1976D2,color:#fff
      style API fill:#388E3C,stroke:#388E3C,color:#fff
      style Service fill:#7B1FA2,stroke:#7B1FA2,color:#fff
      style Layer4 fill:#F57C00,stroke:#F57C00,color:#fff
      style Layer5 fill:#C2185B,stroke:#C2185B,color:#fff
      style Layer6 fill:#00796B,stroke:#00796B,color:#fff
  ```
system_components: |
  **1. Client Layer (Frontend)**
  - **Technology**: SvelteKit 2, Svelte 5, Tailwind CSS 4
  - **Purpose**: User interface for web, mobile, TV platforms
  - **State Management**: TanStack Query for server state, Svelte stores for UI state
  - **Components**: shadcn-svelte for UI primitives
  - **Communication**: REST API, Server-Sent Events (SSE), WebSocket for real-time

  **2. API Layer (HTTP Handlers)**
  - **Technology**: ogen (OpenAPI code generation)
  - **Purpose**: HTTP request handling, validation, serialization
  - **OpenAPI Spec**: Single source of truth for API contracts
  - **Validation**: Automatic request/response validation via ogen
  - **Routing**: Generated from OpenAPI paths

  **3. Service Layer (Business Logic)**
  - **Technology**: Go with fx dependency injection
  - **Purpose**: Business logic, orchestration, caching coordination
  - **Key Services**:
    - Content services (movies, TV, music, books, etc.)
    - Metadata aggregation and enrichment
    - Authentication and authorization
    - Media transcoding and processing
    - Background job scheduling

  **4. Repository Layer (Data Access)**
  - **Technology**: sqlc (type-safe SQL), pgx (PostgreSQL driver)
  - **Purpose**: Database operations, query execution
  - **Pattern**: Repository pattern with interfaces for testability
  - **Transactions**: pgx transaction support for atomic operations

  **5. Metadata Priority Chain**
  **CRITICAL**: Metadata flows through a priority chain from fastest (cache) to slowest (external APIs):

  ```
  Request â†’ L1 Cache (otter) â†’ L2 Cache (Dragonfly) â†’
           PRIMARY (Arr Services) â†’ SUPPLEMENTARY (External APIs)
  ```

  - **L1 Cache (otter)**: In-memory, sub-millisecond, per-instance
  - **L2 Cache (Dragonfly)**: Distributed, multi-millisecond, shared across instances
  - **PRIMARY (Arr Services)**: Local metadata aggregators (Radarr, Sonarr, Lidarr, Chaptarr, Whisparr)
    - Serve DUAL purposes: (1) PRIMARY metadata cache, (2) Download automation
    - Cache metadata from external sources locally (e.g., Radarr caches TMDb)
    - Preferred over direct external API calls for performance and reliability
  - **SUPPLEMENTARY (External APIs)**: Direct API calls when Arr unavailable or for enrichment
    - **Fallback**: Used when Arr not setup/unreachable OR lacks specific metadata
    - **Enrichment**: Additional data beyond what Arr provides
    - **Proxy/VPN**: OPTIONAL routing through HTTP proxy, SOCKS5 (Tor), or VPN (disabled by default)

  **See**: [03_METADATA_SYSTEM](03_METADATA_SYSTEM.md) for complete metadata architecture

  **6. Database (PostgreSQL)**
  - **Version**: PostgreSQL 18+
  - **Driver**: pgx with connection pooling (pgxpool)
  - **Features**:
    - UUID primary keys (no auto-increment)
    - TIMESTAMPTZ for all timestamps
    - Trigram indexes for fuzzy search (pg_trgm)
    - JSON columns for flexible metadata
    - Full-text search with tsvector

  **7. Cache Layer**
  Two-tier caching: L1 (otter) + L2 (Dragonfly via rueidis).
  See data/integrations/infrastructure/DRAGONFLY.yaml for complete cache architecture details.

  **8. Search (Typesense)**
  - **Purpose**: Full-text search across all content
  - **Indexes**: Per content type (movies, TV shows, music, etc.)
  - **Features**: Typo tolerance, faceting, geo-search

  **9. Background Jobs (River)**
  - **Purpose**: Async task processing
  - **Workers**: Metadata enrichment, transcoding, cleanup
  - **Queue**: PostgreSQL-backed (pgx integration)

  **10. Arr Services Integration (Dual-Role)**
  Arr services (Radarr, Sonarr, Lidarr, Chaptarr, Whisparr) serve dual purposes as both
  PRIMARY metadata aggregators (local cache of external APIs) and download automation managers.

  See [03_METADATA_SYSTEM](03_METADATA_SYSTEM.md#arr_services_dual_role) for complete architecture explanation.

  **Arr Services**:
  - **Radarr**: Movies (aggregates TMDb locally)
  - **Sonarr**: TV Shows (aggregates TheTVDB locally)
  - **Lidarr**: Music (aggregates MusicBrainz locally)
  - **Chaptarr**: Books & Audiobooks (aggregates OpenLibrary/Audnexus locally)
  - **Whisparr**: Adult Content (aggregates StashDB locally)

  **11. Proxy/VPN Support (Optional)**
  **OPTIONAL** routing for external metadata API calls (NOT for Arr services):

  - **HTTP/HTTPS Proxy**: Via HTTP_PROXY environment variable
  - **SOCKS5 Proxy**: Via golang.org/x/net/proxy (e.g., Tor)
  - **VPN Binding**: Route traffic through specific network interface (e.g., tun0, wg0)

  **Configuration**: Disabled by default, must be explicitly enabled per provider

  **See**: [HTTP_CLIENT](../services/HTTP_CLIENT.md) for proxy/VPN implementation
file_structure: |
  ```
  revenge/
  â”œâ”€â”€ cmd/
  â”‚   â””â”€â”€ revenge/                  # Main application entrypoint
  â”‚       â””â”€â”€ main.go
  â”œâ”€â”€ internal/
  â”‚   â”œâ”€â”€ api/                      # ogen-generated API handlers
  â”‚   â”‚   â”œâ”€â”€ handler.go
  â”‚   â”‚   â””â”€â”€ types.go
  â”‚   â”œâ”€â”€ content/                  # Content modules (movies, TV, music, etc.)
  â”‚   â”‚   â”œâ”€â”€ movie/
  â”‚   â”‚   â”‚   â”œâ”€â”€ module.go         # fx module definition
  â”‚   â”‚   â”‚   â”œâ”€â”€ repository.go     # sqlc-generated repository
  â”‚   â”‚   â”‚   â”œâ”€â”€ service.go        # Business logic
  â”‚   â”‚   â”‚   â”œâ”€â”€ handler.go        # API handlers
  â”‚   â”‚   â”‚   â”œâ”€â”€ cache.go          # Caching layer
  â”‚   â”‚   â”‚   â””â”€â”€ types.go          # Domain types
  â”‚   â”‚   â”œâ”€â”€ tvshow/
  â”‚   â”‚   â”œâ”€â”€ music/
  â”‚   â”‚   â”œâ”€â”€ book/
  â”‚   â”‚   â”œâ”€â”€ audiobook/
  â”‚   â”‚   â””â”€â”€ qar/                  # Adult content (obfuscated)
  â”‚   â”œâ”€â”€ service/                  # Shared services
  â”‚   â”‚   â”œâ”€â”€ metadata/             # Metadata aggregation
  â”‚   â”‚   â”‚   â”œâ”€â”€ priority_chain.go # L1â†’L2â†’Arrâ†’External
  â”‚   â”‚   â”‚   â”œâ”€â”€ arr/              # Arr service providers
  â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ radarr.go
  â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ sonarr.go
  â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ lidarr.go
  â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ chaptarr.go
  â”‚   â”‚   â”‚   â”‚   â””â”€â”€ whisparr.go
  â”‚   â”‚   â”‚   â””â”€â”€ external/         # External API providers
  â”‚   â”‚   â”‚       â”œâ”€â”€ tmdb.go
  â”‚   â”‚   â”‚       â”œâ”€â”€ thetvdb.go
  â”‚   â”‚   â”‚       â”œâ”€â”€ musicbrainz.go
  â”‚   â”‚   â”‚       â””â”€â”€ openlibrary.go
  â”‚   â”‚   â”œâ”€â”€ auth/                 # Authentication & authorization
  â”‚   â”‚   â”œâ”€â”€ cache/                # Cache management (L1 + L2)
  â”‚   â”‚   â”œâ”€â”€ search/               # Typesense integration
  â”‚   â”‚   â”œâ”€â”€ jobs/                 # River background jobs
  â”‚   â”‚   â”œâ”€â”€ http_client/          # Proxy/VPN-aware HTTP client factory
  â”‚   â”‚   â””â”€â”€ media/                # Media processing (transcoding)
  â”‚   â”œâ”€â”€ repository/               # sqlc-generated repositories
  â”‚   â””â”€â”€ config/                   # Configuration (koanf)
  â”œâ”€â”€ migrations/                   # SQL migrations
  â”‚   â”œâ”€â”€ 001_initial.sql
  â”‚   â”œâ”€â”€ 002_movies.sql
  â”‚   â””â”€â”€ ...
  â”œâ”€â”€ api/                          # OpenAPI specifications
  â”‚   â””â”€â”€ openapi.yaml
  â”œâ”€â”€ web/                          # SvelteKit frontend
  â”‚   â”œâ”€â”€ src/
  â”‚   â”‚   â”œâ”€â”€ routes/
  â”‚   â”‚   â”œâ”€â”€ lib/
  â”‚   â”‚   â””â”€â”€ app.html
  â”‚   â””â”€â”€ package.json
  â”œâ”€â”€ scripts/                      # Automation scripts
  â”œâ”€â”€ docs/                         # Documentation
  â””â”€â”€ go.mod
  ```
key_interfaces: |
  **Repository Pattern**:
  ```go
  // Repository defines database operations for a content type
  type Repository interface {
      Get(ctx context.Context, id uuid.UUID) (*Entity, error)
      List(ctx context.Context, filters Filters) ([]Entity, error)
      Create(ctx context.Context, entity *Entity) error
      Update(ctx context.Context, entity *Entity) error
      Delete(ctx context.Context, id uuid.UUID) error
  }
  ```

  **Service Pattern**:
  ```go
  // Service defines business logic for a content type
  type Service interface {
      Get(ctx context.Context, id uuid.UUID) (*Entity, error)
      Search(ctx context.Context, query string, filters Filters) ([]Entity, error)
      Enrich(ctx context.Context, id uuid.UUID) error
  }
  ```

  **Metadata Provider (Priority Chain)**:
  ```go
  // MetadataProvider fetches metadata from a specific source
  type MetadataProvider interface {
      GetMovie(ctx context.Context, externalID string) (*MovieMetadata, error)
      GetTVShow(ctx context.Context, externalID string) (*TVShowMetadata, error)
      GetMusic(ctx context.Context, externalID string) (*MusicMetadata, error)
      Priority() int  // Lower = higher priority (L1=0, L2=1, Arr=2, External=3)
  }

  // PriorityChainResolver orchestrates metadata fetching
  type PriorityChainResolver interface {
      FetchMetadata(ctx context.Context, contentType, externalID string) (*Metadata, error)
  }
  ```

  **HTTP Client Factory (Proxy/VPN)**:
  ```go
  // ClientFactory creates HTTP clients with optional proxy/VPN routing
  type ClientFactory interface {
      GetClient(service string) *http.Client
      GetClientWithProxy(proxyURL string) *http.Client
      GetClientWithVPN(interfaceName string) (*http.Client, error)
      CheckProxyHealth(ctx context.Context, proxyURL string) error
  }
  ```
dependencies: |
  **Core**:
  - `go.uber.org/fx` - Dependency injection
  - `github.com/jackc/pgx/v5` - PostgreSQL driver
  - `github.com/maypok86/otter` - L1 cache
  - `github.com/redis/rueidis` - L2 cache (Dragonfly client)
  - `github.com/riverqueue/river` - Background jobs

  **API & Web**:
  - `github.com/ogen-go/ogen` - OpenAPI code generation
  - SvelteKit 2, Svelte 5, Tailwind CSS 4

  **Metadata & Integration**:
  - `github.com/go-resty/resty/v2` - HTTP client for external APIs
  - `golang.org/x/net/proxy` - SOCKS5 proxy support (Tor)
  - All Arr services: Radarr, Sonarr, Lidarr, Chaptarr, Whisparr

  **Search**:
  - `github.com/typesense/typesense-go` - Typesense client

  **Media Processing**:
  - `github.com/asticode/go-astiav` - FFmpeg bindings

  **See**: [00_SOURCE_OF_TRUTH](../00_SOURCE_OF_TRUTH.md) for complete dependency list with versions
env_vars: |
  **Core**:
  - `REVENGE_DB_URL` - PostgreSQL connection string (required)
  - `REVENGE_CACHE_L2_ADDR` - Dragonfly/Redis address (optional, default: localhost:6379)
  - `REVENGE_ENV` - Environment (development, staging, production)

  **Metadata & Arr Services**:
  - `REVENGE_RADARR_URL` - Radarr instance URL (optional)
  - `REVENGE_RADARR_API_KEY` - Radarr API key (optional)
  - `REVENGE_SONARR_URL` - Sonarr instance URL (optional)
  - `REVENGE_SONARR_API_KEY` - Sonarr API key (optional)
  - `REVENGE_LIDARR_URL` - Lidarr instance URL (optional)
  - `REVENGE_LIDARR_API_KEY` - Lidarr API key (optional)
  - `REVENGE_CHAPTARR_URL` - Chaptarr instance URL (optional)
  - `REVENGE_CHAPTARR_API_KEY` - Chaptarr API key (optional)
  - `REVENGE_WHISPARR_URL` - Whisparr instance URL (optional)
  - `REVENGE_WHISPARR_API_KEY` - Whisparr API key (optional)

  **External Metadata Providers** (SUPPLEMENTARY):
  - `REVENGE_METADATA_TMDB_API_KEY` - TMDb API key (optional)
  - `REVENGE_METADATA_THETVDB_API_KEY` - TheTVDB API key (optional)
  - `REVENGE_METADATA_MUSICBRAINZ_APP` - MusicBrainz app identifier (optional)

  **Proxy/VPN** (OPTIONAL):
  - `HTTP_PROXY` - HTTP proxy URL (optional)
  - `HTTPS_PROXY` - HTTPS proxy URL (optional)
  - `SOCKS5_PROXY` - SOCKS5 proxy URL (optional, e.g., socks5://127.0.0.1:9050 for Tor)

  **Search**:
  - `REVENGE_TYPESENSE_URL` - Typesense server URL (optional)
  - `REVENGE_TYPESENSE_API_KEY` - Typesense API key (optional)

  **Media Processing**:
  - `REVENGE_FFMPEG_PATH` - FFmpeg binary path (optional, default: ffmpeg)
  - `REVENGE_TRANSCODE_THREADS` - Transcoding thread count (optional, default: CPU cores)
config_keys: |
  **config.yaml structure**:
  ```yaml
  database:
    url: ${REVENGE_DB_URL}
    max_connections: 25
    min_connections: 5

  cache:
    l1:
      size_mb: 256
      ttl: 5m
    l2:
      addr: ${REVENGE_CACHE_L2_ADDR}
      ttl: 1h

  metadata:
    # Priority chain: L1 â†’ L2 â†’ Arr (PRIMARY) â†’ External (SUPPLEMENTARY)
    priority:
      - l1_cache      # otter (in-memory)
      - l2_cache      # Dragonfly (distributed)
      - arr_services  # Radarr, Sonarr, Lidarr, Chaptarr, Whisparr
      - external_apis # TMDb, TheTVDB, MusicBrainz, etc.

    # Arr services (PRIMARY metadata + downloads)
    arr:
      radarr:
        enabled: true
        url: ${REVENGE_RADARR_URL}
        api_key: ${REVENGE_RADARR_API_KEY}
        sync_interval: 15m
      sonarr:
        enabled: true
        url: ${REVENGE_SONARR_URL}
        api_key: ${REVENGE_SONARR_API_KEY}
        sync_interval: 15m
      lidarr:
        enabled: true
        url: ${REVENGE_LIDARR_URL}
        api_key: ${REVENGE_LIDARR_API_KEY}
        sync_interval: 15m
      chaptarr:
        enabled: true
        url: ${REVENGE_CHAPTARR_URL}
        api_key: ${REVENGE_CHAPTARR_API_KEY}
        sync_interval: 15m
      whisparr:
        enabled: true
        url: ${REVENGE_WHISPARR_URL}
        api_key: ${REVENGE_WHISPARR_API_KEY}
        sync_interval: 15m

    # External providers (SUPPLEMENTARY - fallback + enrichment)
    providers:
      tmdb:
        role: supplementary
        api_key: ${REVENGE_METADATA_TMDB_API_KEY}
        rate_limit: 40
        proxy:
          enabled: false  # Must explicitly enable
          type: tor       # http, socks5, vpn
          url: socks5://127.0.0.1:9050
      thetvdb:
        role: supplementary
        api_key: ${REVENGE_METADATA_THETVDB_API_KEY}
        rate_limit: 30
        proxy:
          enabled: false
      musicbrainz:
        role: supplementary
        app_identifier: ${REVENGE_METADATA_MUSICBRAINZ_APP}
        rate_limit: 1
        proxy:
          enabled: false

  search:
    typesense:
      url: ${REVENGE_TYPESENSE_URL}
      api_key: ${REVENGE_TYPESENSE_API_KEY}
      collections:
        - movies
        - tvshows
        - music
        - books

  jobs:
    river:
      workers: 10
      max_attempts: 3
      queues:
        - metadata_enrichment
        - transcoding
        - cleanup
  ```
unit_tests: |
  **Framework**: Go testing with testify/assert and mockery

  **Scope**: Individual functions and methods in isolation

  **Mocking**:
  - Repository layer mocked for service tests
  - External API clients mocked for metadata provider tests
  - HTTP clients mocked for integration tests

  **Coverage Target**: 85% minimum for service layer

  **Example**:
  ```go
  func TestMovieService_GetMovie(t *testing.T) {
      tests := []struct {
          name    string
          id      uuid.UUID
          want    *Movie
          wantErr error
      }{
          {
              name: "success",
              id:   uuid.New(),
              want: &Movie{Title: "Fight Club"},
          },
      }
      for _, tt := range tests {
          t.Run(tt.name, func(t *testing.T) {
              mockRepo := NewMockRepository(t)
              mockRepo.On("Get", mock.Anything, tt.id).Return(tt.want, tt.wantErr)

              svc := NewService(mockRepo)
              got, err := svc.GetMovie(context.Background(), tt.id)

              assert.Equal(t, tt.wantErr, err)
              assert.Equal(t, tt.want, got)
          })
      }
  }
  ```
integration_tests: |
  **Framework**: testcontainers-go for PostgreSQL, Dragonfly, Typesense

  **Scope**: Full stack tests (API â†’ database)

  **Database**: PostgreSQL container with migrations applied

  **Cache**: Dragonfly container for L2 cache tests

  **Coverage Target**: 70% minimum for integration layer

  **Example**:
  ```go
  func TestMovieHandler_GetMovie(t *testing.T) {
      ctx := context.Background()

      // Start PostgreSQL container
      pgContainer, err := postgres.RunContainer(ctx)
      require.NoError(t, err)
      defer pgContainer.Terminate(ctx)

      // Run migrations
      connStr := pgContainer.ConnectionString(ctx)
      runMigrations(t, connStr)

      // Create app with test dependencies
      app := setupTestApp(t, connStr)

      // Test API endpoint
      req := httptest.NewRequest("GET", "/api/v1/movies/550e8400-e29b-41d4-a716-446655440000", nil)
      rec := httptest.NewRecorder()

      app.ServeHTTP(rec, req)

      assert.Equal(t, http.StatusOK, rec.Code)
  }
  ```
test_coverage_target: |
  **Overall Target**: **80% minimum**

  **Per Layer**:
  - Repository: 90% (critical path)
  - Service: 85% (business logic)
  - Handler: 75% (integration layer)
  - Metadata providers: 70% (external dependency)

  **Excluded**:
  - Generated code (ogen, sqlc)
  - Main entrypoint (cmd/revenge/main.go)
  - Trivial getters/setters

  **Verification**:
  ```bash
  go test -coverprofile=coverage.out ./...
  go tool cover -html=coverage.out
  ```
