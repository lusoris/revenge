doc_title: Revenge - Player Architecture
doc_category: architecture
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âšª
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: Generated from design
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: |
  > Media playback system with HLS streaming and Vidstack player

  Player components:
  - **Backend**: gohlslib for HLS manifest generation, FFmpeg for transcoding
  - **Frontend**: Vidstack player with HLS.js for adaptive streaming
  - **Features**: Skip intro, trickplay thumbnails, chapter markers, subtitles
  - **Casting**: Chromecast and DLNA support
  - **Sync**: SyncPlay for watching together remotely
wiki_tagline: '> How Revenge plays your media across all devices'
wiki_overview: The player architecture handles media playback across web, mobile, and TV clients. Videos stream via HLS for
  adaptive quality based on your connection. The backend generates HLS manifests and handles transcoding when needed (using
  FFmpeg). The web player (Vidstack) supports chapters, subtitles, skip intro, and trickplay thumbnails. Chromecast lets you
  cast to TV, and SyncPlay lets multiple users watch together in sync.
sources:
- name: FFmpeg Documentation
  url: https://ffmpeg.org/ffmpeg.html
  note: Auto-resolved from ffmpeg
- name: FFmpeg Codecs
  url: https://ffmpeg.org/ffmpeg-codecs.html
  note: Auto-resolved from ffmpeg-codecs
- name: FFmpeg Formats
  url: https://ffmpeg.org/ffmpeg-formats.html
  note: Auto-resolved from ffmpeg-formats
- name: go-astiav (FFmpeg bindings)
  url: https://pkg.go.dev/github.com/asticode/go-astiav
  note: Auto-resolved from go-astiav
- name: go-astiav GitHub README
  url: https://github.com/asticode/go-astiav
  note: Auto-resolved from go-astiav-docs
- name: gohlslib (HLS)
  url: https://pkg.go.dev/github.com/bluenviron/gohlslib/v2
  note: Auto-resolved from gohlslib
- name: M3U8 Extended Format
  url: https://datatracker.ietf.org/doc/html/rfc8216
  note: Auto-resolved from m3u8
- name: Svelte 5 Runes
  url: https://svelte.dev/docs/svelte/$state
  note: Auto-resolved from svelte-runes
- name: Svelte 5 Documentation
  url: https://svelte.dev/docs/svelte/overview
  note: Auto-resolved from svelte5
- name: SvelteKit Documentation
  url: https://svelte.dev/docs/kit/introduction
  note: Auto-resolved from sveltekit
design_refs:
- title: architecture
  path: INDEX.md
- title: ADULT_CONTENT_SYSTEM
  path: ../features/adult/ADULT_CONTENT_SYSTEM.md
- title: ADULT_METADATA
  path: ../features/adult/ADULT_METADATA.md
- title: DATA_RECONCILIATION
  path: ../features/adult/DATA_RECONCILIATION.md
architecture_diagram: |-
  # Player Architecture

  ```mermaid
  flowchart LR
      subgraph Clients["CLIENT LAYER"]
          Web["Web Player<br/>(Vidstack)"]
          Mobile(["Mobile App<br/>(React Native)"])
          TV(["TV App<br/>(Android TV)"])
      end

      subgraph Streaming["STREAMING LAYER"]
          HLS[["HLS Generator<br/>(gohlslib)"]]
          Trans[["Transcoder<br/>(FFmpeg)"]]
      end

      subgraph Features["FEATURE LAYER"]
          Skip["Skip Intro"]
          Trick["Trickplay"]
          Chap["Chapters"]
          Sync(["SyncPlay"])
          Cast["Casting"]
          Subs(["Subtitles"])
      end

      subgraph Storage["STORAGE LAYER"]
          Media["Media Files"]
          MetaDB[("Metadata DB")]
          Cache[("Cache")]
      end

      Web --> HLS
      Mobile --> HLS
      TV --> HLS
      HLS --> Trans
      Trans --> Skip
      Trans --> Trick
      Trans --> Chap
      Skip --> Sync
      Trick --> Cast
      Chap --> Subs
      Sync --> Media
      Cast --> MetaDB
      Subs --> Cache

      style Clients fill:#1976D2,stroke:#1976D2,color:#fff
      style Streaming fill:#388E3C,stroke:#388E3C,color:#fff
      style Features fill:#7B1FA2,stroke:#7B1FA2,color:#fff
      style Storage fill:#F57C00,stroke:#F57C00,color:#fff
  ```
system_components:
- name: Web Player (Vidstack)
  description: |
    Modern web video player built on Vidstack framework with HLS.js for adaptive streaming.

    **Features**:
    - Adaptive bitrate streaming (HLS)
    - Custom UI with shadcn-svelte components
    - Chapter markers and navigation
    - Skip intro/outro detection and UI
    - Trickplay thumbnail scrubbing
    - Multiple audio tracks and subtitle selection
    - Keyboard shortcuts and accessibility
    - Picture-in-Picture support
    - Fullscreen with native browser API

    **State Management**:
    - Svelte 5 runes for reactive state
    - TanStack Query for server state (playback position, watch history)
    - Local storage for user preferences (volume, quality)

    **Performance**:
    - Lazy load player bundle (code splitting)
    - Preload next episode metadata
    - Progressive Web App capabilities
- name: Mobile Apps
  description: |
    Native mobile applications for iOS and Android using React Native or native SDKs.

    **iOS**:
    - AVPlayer for native HLS playback
    - Native controls with custom overlays
    - AirPlay support for Apple TV
    - Background audio playback
    - PiP on iPad

    **Android**:
    - ExoPlayer for HLS streaming
    - Material Design 3 UI
    - Cast Connect for Chromecast
    - Background playback service
    - PiP on Android 8+

    **Shared Features**:
    - Offline download support (future)
    - Playback state sync via WebSocket
    - SyncPlay participation
- name: TV Apps
  description: |
    Television applications for Android TV, Apple TV, and Roku.

    **Android TV**:
    - Leanback UI framework
    - D-pad navigation
    - Voice search integration
    - Recommendations API

    **Apple TV**:
    - tvOS native app
    - Siri integration
    - Top Shelf support
    - Focus engine navigation

    **Roku**:
    - BrightScript or SceneGraph
    - Standard Roku controls
    - Channel store distribution
- name: HLS Manifest Generator
  description: |
    Generates HTTP Live Streaming (HLS) manifests using gohlslib.

    **Master Playlist**:
    ```m3u8
    #EXTM3U
    #EXT-X-VERSION:6
    #EXT-X-STREAM-INF:BANDWIDTH=5000000,RESOLUTION=1920x1080,CODECS="avc1.640028,mp4a.40.2"
    1080p.m3u8
    #EXT-X-STREAM-INF:BANDWIDTH=2500000,RESOLUTION=1280x720,CODECS="avc1.64001f,mp4a.40.2"
    720p.m3u8
    #EXT-X-STREAM-INF:BANDWIDTH=1000000,RESOLUTION=854x480,CODECS="avc1.64001e,mp4a.40.2"
    480p.m3u8
    ```

    **Media Playlist**:
    - Segment duration (6-10 seconds)
    - Discontinuities for codec changes
    - Byte ranges for optimized delivery
    - Encryption keys (AES-128 for DRM future)

    **Adaptive Logic**:
    - Bandwidth estimation from client
    - Resolution switching based on viewport
    - Audio track selection by language
    - Subtitle track availability
- name: Transcoding Engine
  description: |
    Real-time and offline transcoding using FFmpeg via go-astiav bindings.

    **Real-Time Transcoding**:
    - On-demand transcoding for unsupported codecs
    - Hardware acceleration (VAAPI, NVENC, QuickSync, VideoToolbox)
    - Low latency mode for live streaming
    - Segment-based processing (parallel)

    **Offline Transcoding**:
    - Batch processing via River job queue
    - Multiple quality profiles (1080p, 720p, 480p)
    - Audio normalization (EBU R128)
    - Subtitle extraction to WebVTT

    **Codec Support**:
    - **Video**: H.264 (baseline, main, high), H.265, AV1, VP9
    - **Audio**: AAC, Opus, MP3, FLAC
    - **Containers**: MP4, MKV, WebM

    **Hardware Acceleration**:
    ```go
    type HWAccelConfig struct {
        Type       HWAccelType  // vaapi, nvenc, qsv, videotoolbox
        Device     string       // /dev/dri/renderD128, cuda:0
        Priority   int          // Fallback order
        MaxStreams int          // Concurrent limit
    }
    ```
- name: Skip Intro
  description: |
    Automatic intro/outro detection and skip functionality.

    **Detection Methods**:
    1. **Audio Fingerprinting**: Match intro audio across episodes
    2. **Black Frame Detection**: Identify fade-to-black transitions
    3. **Duration Heuristics**: Common intro lengths (60-90s)
    4. **Community Data**: Shared intro timestamps

    **Storage**:
    ```sql
    CREATE TABLE intro_markers (
        episode_id UUID PRIMARY KEY,
        intro_start INTERVAL NOT NULL,
        intro_end INTERVAL NOT NULL,
        confidence FLOAT NOT NULL,
        detection_method TEXT NOT NULL,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    ```

    **Client Integration**:
    - "Skip Intro" button appears during intro
    - Auto-skip preference (per-user)
    - Timeline marker visualization
    - Outro detection for auto-play next episode
- name: Trickplay Thumbnails
  description: |
    Thumbnail generation for timeline scrubbing.

    **Generation**:
    - Extract frame every N seconds (configurable, default 10s)
    - Resize to 320x180 or 640x360
    - Composite into sprite sheets (10x10 grid)
    - Store metadata in .vtt file

    **WebVTT Format**:
    ```vtt
    WEBVTT

    00:00:00.000 --> 00:00:10.000
    thumbnails/sprite-01.jpg#xywh=0,0,320,180

    00:00:10.000 --> 00:00:20.000
    thumbnails/sprite-01.jpg#xywh=320,0,320,180
    ```

    **Caching**:
    - Store in object storage (S3, MinIO)
    - CDN distribution for faster load
    - Lazy generation (on first playback)
    - Cleanup old thumbnails (TTL 30 days)
- name: Chapter Markers
  description: |
    Chapter navigation within media files.

    **Sources**:
    1. **Embedded Chapters**: Extract from MKV/MP4 metadata
    2. **Manual Chapters**: User-created via admin UI
    3. **Community Chapters**: Shared chapter databases

    **Format**:
    ```json
    {
      "chapters": [
        {
          "id": "ch-001",
          "title": "Cold Open",
          "start": "00:00:00",
          "end": "00:02:30"
        },
        {
          "id": "ch-002",
          "title": "Opening Credits",
          "start": "00:02:30",
          "end": "00:04:00"
        }
      ]
    }
    ```

    **Player Integration**:
    - Chapter menu in player UI
    - Timeline markers
    - Skip to next/previous chapter hotkeys
- name: SyncPlay
  description: |
    Synchronized playback for watching together remotely.

    **Architecture**:
    - WebSocket for real-time state sync
    - Room-based sessions with leader election
    - Playback commands (play, pause, seek, speed)
    - Latency compensation

    **State Machine**:
    ```go
    type SyncPlayState struct {
        RoomID       string
        Leader       UserID
        Members      []UserID
        MediaID      string
        Position     time.Duration
        PlaybackRate float64
        State        PlaybackState  // playing, paused, buffering
        UpdatedAt    time.Time
    }
    ```

    **Commands**:
    - `SYNC_PLAY`: Start playing at position
    - `SYNC_PAUSE`: Pause all clients
    - `SYNC_SEEK`: Seek to timestamp
    - `SYNC_SPEED`: Change playback rate

    **Permissions**:
    - Only leader can issue commands (default: room creator)
    - Transfer leadership
    - Kick members (leader only)
- name: Casting (Chromecast/DLNA)
  description: |
    Cast media to external devices.

    **Chromecast**:
    - Google Cast SDK integration
    - Custom receiver app
    - Media session management
    - Queue management for playlists

    **DLNA**:
    - UPnP/DLNA discovery (SSDP)
    - SOAP control protocol
    - MediaServer and MediaRenderer roles
    - Transcoding for incompatible formats

    **Fallback Chain**:
    1. Direct play (compatible codec)
    2. Remux (change container only)
    3. Transcode (change codec)
- name: Subtitle System
  description: |
    Multi-format subtitle support with rendering.

    **Supported Formats**:
    - **SSA/ASS**: Advanced SubStation Alpha (styling, positioning, animations)
    - **WebVTT**: Web Video Text Tracks (HLS standard)
    - **SRT**: SubRip (basic text)
    - **PGS**: Presentation Graphic Stream (Blu-ray image subs)

    **Conversion Pipeline**:
    ```
    PGS â†’ OCR â†’ SRT â†’ WebVTT
    SSA/ASS â†’ WebVTT (preserve styles)
    ```

    **Rendering**:
    - Browser-native WebVTT rendering (web)
    - Custom renderer for ASS styling (canvas overlay)
    - Burned-in subtitles for unsupported clients
file_structure: |
  ```
  internal/
    playback/
      player/
        service.go           # Player service
        repository.go        # Playback state persistence
        repository_test.go
      hls/
        manifest.go          # HLS manifest generator
        segmenter.go         # Video segmentation
        segmenter_test.go
      transcode/
        engine.go            # FFmpeg wrapper
        profiles.go          # Quality profiles
        hwaccel.go           # Hardware acceleration
        queue.go             # River job integration
        engine_test.go
      features/
        skipintro/
          detector.go        # Intro detection
          fingerprint.go     # Audio fingerprinting
          detector_test.go
        trickplay/
          generator.go       # Thumbnail generation
          sprites.go         # Sprite sheet creation
          generator_test.go
        chapters/
          extractor.go       # Chapter metadata extraction
          service.go         # Chapter management
        syncplay/
          room.go            # SyncPlay room management
          state.go           # State synchronization
          websocket.go       # WebSocket handler
          room_test.go
        casting/
          chromecast.go      # Chromecast integration
          dlna.go            # DLNA/UPnP support
        subtitles/
          converter.go       # Format conversion
          renderer.go        # Subtitle rendering
          ocr.go             # PGS OCR

  web/
    src/
      lib/
        player/
          Player.svelte      # Main player component
          controls/
            Controls.svelte  # Player controls
            Timeline.svelte  # Scrub bar with trickplay
            Volume.svelte
            Settings.svelte
          overlays/
            SkipIntro.svelte # Skip intro button
            Chapters.svelte  # Chapter menu
            Subtitles.svelte # Subtitle selector
          hooks/
            usePlayback.ts   # Playback state management
            useHLS.ts        # HLS.js integration
            useSyncPlay.ts   # SyncPlay client

  migrations/
    playback/
      001_playback_state.sql    # User playback progress
      002_intro_markers.sql     # Skip intro data
      003_trickplay.sql          # Thumbnail metadata
      004_chapters.sql           # Chapter markers
      005_syncplay.sql           # SyncPlay sessions
  ```
key_interfaces: |
  ```go
  // Player Service Interface
  type PlayerService interface {
      // Start a playback session
      StartSession(ctx context.Context, req *StartSessionRequest) (*Session, error)

      // Get HLS manifest for media
      GetHLSManifest(ctx context.Context, mediaID string, profile QualityProfile) (*HLSManifest, error)

      // Update playback position
      UpdatePosition(ctx context.Context, sessionID string, position time.Duration) error

      // Get playback state
      GetState(ctx context.Context, sessionID string) (*PlaybackState, error)

      // Stop session
      StopSession(ctx context.Context, sessionID string) error
  }

  type StartSessionRequest struct {
      MediaID      string
      UserID       string
      QualityProfile QualityProfile
      StartPosition  time.Duration
      AudioTrack     int
      SubtitleTrack  *int
  }

  type Session struct {
      ID            string
      MediaID       string
      UserID        string
      HLSManifestURL string
      Created       time.Time
      ExpiresAt     time.Time
  }

  type PlaybackState struct {
      SessionID     string
      Position      time.Duration
      Duration      time.Duration
      State         string  // playing, paused, buffering
      QualityProfile QualityProfile
      UpdatedAt     time.Time
  }

  // HLS Manifest Generator Interface
  type HLSGenerator interface {
      // Generate master playlist
      GenerateMasterPlaylist(ctx context.Context, mediaID string, profiles []QualityProfile) (*MasterPlaylist, error)

      // Generate media playlist for specific quality
      GenerateMediaPlaylist(ctx context.Context, mediaID string, profile QualityProfile) (*MediaPlaylist, error)

      // Get segment URL
      GetSegmentURL(ctx context.Context, mediaID string, profile QualityProfile, segmentIndex int) (string, error)
  }

  type QualityProfile struct {
      Name       string
      Resolution Resolution
      Bitrate    int
      VideoCodec string
      AudioCodec string
  }

  type Resolution struct {
      Width  int
      Height int
  }

  type MasterPlaylist struct {
      Variants []Variant
      AudioGroups []AudioGroup
      SubtitleGroups []SubtitleGroup
  }

  // Transcoding Engine Interface
  type TranscodeEngine interface {
      // Start real-time transcode
      StartTranscode(ctx context.Context, req *TranscodeRequest) (*TranscodeSession, error)

      // Stop transcode
      StopTranscode(ctx context.Context, sessionID string) error

      // Queue offline transcode job
      QueueTranscode(ctx context.Context, mediaID string, profiles []QualityProfile) ([]string, error)

      // Get transcode progress
      GetProgress(ctx context.Context, jobID string) (*TranscodeProgress, error)
  }

  type TranscodeRequest struct {
      MediaID    string
      Profile    QualityProfile
      StartTime  time.Duration
      HWAccel    *HWAccelConfig
      Priority   int
  }

  type TranscodeSession struct {
      ID         string
      MediaID    string
      Profile    QualityProfile
      OutputURL  string
      Created    time.Time
  }

  type HWAccelConfig struct {
      Type       HWAccelType  // vaapi, nvenc, qsv, videotoolbox
      Device     string
      MaxStreams int
  }

  type HWAccelType string

  const (
      HWAccelVAAPI        HWAccelType = "vaapi"
      HWAccelNVENC        HWAccelType = "nvenc"
      HWAccelQSV          HWAccelType = "qsv"
      HWAccelVideoToolbox HWAccelType = "videotoolbox"
  )

  // Skip Intro Detection Interface
  type SkipIntroDetector interface {
      // Detect intro in episode
      DetectIntro(ctx context.Context, episodeID string) (*IntroMarker, error)

      // Batch detect intros for series
      BatchDetect(ctx context.Context, seriesID string) ([]IntroMarker, error)

      // Get intro marker
      GetIntroMarker(ctx context.Context, episodeID string) (*IntroMarker, error)
  }

  type IntroMarker struct {
      EpisodeID        string
      IntroStart       time.Duration
      IntroEnd         time.Duration
      Confidence       float64
      DetectionMethod  string
      CreatedAt        time.Time
  }

  // Trickplay Generator Interface
  type TrickplayGenerator interface {
      // Generate thumbnails for media
      Generate(ctx context.Context, mediaID string, opts *TrickplayOptions) (*TrickplayMetadata, error)

      // Get trickplay metadata
      GetMetadata(ctx context.Context, mediaID string) (*TrickplayMetadata, error)
  }

  type TrickplayOptions struct {
      Interval   time.Duration  // Thumbnail every N seconds
      Width      int
      Height     int
      TileWidth  int  // Sprites per row
      TileHeight int  // Sprites per column
  }

  type TrickplayMetadata struct {
      MediaID       string
      VTTFile       string
      SpriteSheets  []string
      Interval      time.Duration
      ThumbnailSize Resolution
      GeneratedAt   time.Time
  }

  // SyncPlay Room Manager Interface
  type SyncPlayManager interface {
      // Create room
      CreateRoom(ctx context.Context, req *CreateRoomRequest) (*Room, error)

      // Join room
      JoinRoom(ctx context.Context, roomID string, userID string) error

      // Leave room
      LeaveRoom(ctx context.Context, roomID string, userID string) error

      // Sync playback command
      SyncCommand(ctx context.Context, roomID string, cmd *PlaybackCommand) error

      // Get room state
      GetRoomState(ctx context.Context, roomID string) (*SyncPlayState, error)
  }

  type CreateRoomRequest struct {
      Name     string
      MediaID  string
      LeaderID string
      Password *string
  }

  type Room struct {
      ID        string
      Name      string
      MediaID   string
      LeaderID  string
      Members   []string
      CreatedAt time.Time
  }

  type PlaybackCommand struct {
      Type      CommandType
      Position  *time.Duration
      Rate      *float64
      Timestamp time.Time
  }

  type CommandType string

  const (
      CmdPlay  CommandType = "play"
      CmdPause CommandType = "pause"
      CmdSeek  CommandType = "seek"
      CmdSpeed CommandType = "speed"
  )

  // Subtitle Converter Interface
  type SubtitleConverter interface {
      // Convert subtitle to WebVTT
      ConvertToWebVTT(ctx context.Context, input io.Reader, format SubtitleFormat) (io.Reader, error)

      // Extract PGS subtitles via OCR
      ExtractPGS(ctx context.Context, videoFile string, trackIndex int) (io.Reader, error)
  }

  type SubtitleFormat string

  const (
      FormatSSA    SubtitleFormat = "ssa"
      FormatASS    SubtitleFormat = "ass"
      FormatSRT    SubtitleFormat = "srt"
      FormatWebVTT SubtitleFormat = "vtt"
      FormatPGS    SubtitleFormat = "pgs"
  )
  ```
dependencies:
  backend:
  - name: github.com/bluenviron/gohlslib/v2
    version: v2.0.0
    purpose: HLS manifest generation and serving
  - name: github.com/asticode/go-astiav
    version: v0.20.0
    purpose: FFmpeg bindings for transcoding
  - name: github.com/riverqueue/river
    version: v0.14.2
    purpose: Transcode job queue
  - name: github.com/gorilla/websocket
    version: v1.5.3
    purpose: WebSocket for SyncPlay
  - name: github.com/pion/webrtc/v4
    version: v4.0.5
    purpose: WebRTC for future P2P streaming
  frontend:
  - name: vidstack
    version: ^1.12.0
    purpose: Web video player framework
  - name: hls.js
    version: ^1.5.0
    purpose: HLS adaptive streaming
  - name: '@vidstack/react'
    version: ^1.12.0
    purpose: React bindings for Vidstack (mobile)
config_keys:
  playback:
  - key: playback.hls.segment_duration
    type: int
    default: 6
    description: HLS segment duration in seconds
  - key: playback.hls.playlist_size
    type: int
    default: 5
    description: Number of segments in media playlist
  - key: playback.transcode.enabled
    type: bool
    default: true
    description: Enable transcoding for unsupported formats
  - key: playback.transcode.hw_accel
    type: string
    default: auto
    description: Hardware acceleration (auto, vaapi, nvenc, qsv, videotoolbox, none)
  - key: playback.transcode.max_concurrent
    type: int
    default: 3
    description: Maximum concurrent transcode sessions
  - key: playback.transcode.profiles
    type: string[]
    default:
    - 1080p
    - 720p
    - 480p
    description: Quality profiles for transcoding
  - key: playback.skip_intro.enabled
    type: bool
    default: true
    description: Enable skip intro detection
  - key: playback.skip_intro.auto_skip
    type: bool
    default: false
    description: Automatically skip intros (user preference)
  - key: playback.trickplay.enabled
    type: bool
    default: true
    description: Enable trickplay thumbnail generation
  - key: playback.trickplay.interval
    type: int
    default: 10
    description: Thumbnail interval in seconds
  - key: playback.syncplay.enabled
    type: bool
    default: true
    description: Enable SyncPlay feature
  - key: playback.casting.chromecast_enabled
    type: bool
    default: true
    description: Enable Chromecast support
  - key: playback.casting.dlna_enabled
    type: bool
    default: true
    description: Enable DLNA support
testing_strategy:
  unit_tests: |
    **Target Coverage**: 85%

    **Test Structure**:
    - Table-driven tests for HLS manifest generation
    - Mock FFmpeg calls for transcode engine tests
    - In-memory WebSocket for SyncPlay tests

    **Example**:
    ```go
    func TestHLSGenerator_GenerateMasterPlaylist(t *testing.T) {
        tests := []struct {
            name     string
            mediaID  string
            profiles []QualityProfile
            want     *MasterPlaylist
            wantErr  bool
        }{
            {
                name:    "multiple profiles",
                mediaID: "movie-123",
                profiles: []QualityProfile{
                    {Name: "1080p", Resolution: Resolution{1920, 1080}, Bitrate: 5000000},
                    {Name: "720p", Resolution: Resolution{1280, 720}, Bitrate: 2500000},
                },
                want: &MasterPlaylist{
                    Variants: []Variant{
                        {Bandwidth: 5000000, Resolution: "1920x1080"},
                        {Bandwidth: 2500000, Resolution: "1280x720"},
                    },
                },
            },
        }

        for _, tt := range tests {
            t.Run(tt.name, func(t *testing.T) {
                gen := NewHLSGenerator()
                got, err := gen.GenerateMasterPlaylist(context.Background(), tt.mediaID, tt.profiles)
                if tt.wantErr {
                    require.Error(t, err)
                    return
                }
                require.NoError(t, err)
                assert.Equal(t, tt.want, got)
            })
        }
    }
    ```
  integration_tests: |
    **Target Coverage**: 75%

    **Test Scenarios**:
    - End-to-end playback flow (session creation â†’ HLS manifest â†’ segment delivery)
    - Transcode pipeline with real FFmpeg (small test files)
    - SyncPlay room synchronization across multiple clients
    - Skip intro detection accuracy

    **Example**:
    ```go
    func TestPlaybackIntegration(t *testing.T) {
        // Setup test media file
        mediaFile := createTestVideo(t, 60*time.Second)
        defer os.Remove(mediaFile)

        // Start playback session
        session, err := playerService.StartSession(ctx, &StartSessionRequest{
            MediaID: "test-media",
            UserID:  "user-123",
            QualityProfile: QualityProfile{Name: "720p"},
        })
        require.NoError(t, err)

        // Fetch HLS manifest
        resp, err := http.Get(session.HLSManifestURL)
        require.NoError(t, err)
        defer resp.Body.Close()

        // Verify manifest content
        body, _ := io.ReadAll(resp.Body)
        assert.Contains(t, string(body), "#EXTM3U")
        assert.Contains(t, string(body), "#EXT-X-VERSION")
    }
    ```
  e2e_tests: |
    **Frontend E2E** (Playwright):
    - Load player page
    - Click play button
    - Verify video playback starts
    - Seek to middle of video
    - Verify position updates
    - Test skip intro button
    - Test chapter navigation

    **Mobile E2E** (Detox/Appium):
    - Launch app
    - Navigate to video
    - Start playback
    - Test casting to Chromecast
    - Test background playback
  performance_tests: |
    **Benchmarks**:
    - HLS manifest generation time
    - Transcode startup latency
    - Segment delivery throughput
    - SyncPlay sync latency

    **Load Tests**:
    - 100 concurrent playback sessions
    - 10 concurrent transcode sessions
    - 50 users in SyncPlay room
