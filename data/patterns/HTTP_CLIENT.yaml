doc_title: HTTP Client with Proxy/VPN Pattern
doc_category: pattern
created_date: '2026-02-02'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: Complete HTTP client pattern with proxy/VPN support
status_sources: âœ…
status_sources_notes: All proxy types documented
status_instructions: âœ…
status_instructions_notes: Implementation examples provided
status_code: ðŸ”´
status_code_notes: To be implemented
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: |
  > Reusable HTTP client factory with optional proxy/VPN routing for external API calls

  Provides HTTP clients with configurable proxy/VPN routing:
  - **HTTP/HTTPS Proxy**: Standard proxy with authentication
  - **SOCKS5 Proxy**: Tor and commercial VPN support
  - **VPN Binding**: Route through specific network interface
  - **Tor Support**: Convenience alias for SOCKS5 (127.0.0.1:9050)

  **CRITICAL**: Proxy/VPN is **OPTIONAL** - must be explicitly enabled
wiki_tagline: |
  > HTTP client factory with optional proxy/VPN routing for external API calls
wiki_overview: |
  The HTTP Client pattern provides a centralized factory for creating HTTP clients with
  optional proxy/VPN routing. This enables external API calls (TMDb, TheTVDB, etc.) to be
  routed through privacy-preserving proxies or VPN tunnels when needed.

  Key features:
  - Service-specific client configuration
  - Multiple proxy types (HTTP, SOCKS5, Tor)
  - VPN interface binding
  - Connection pooling and timeout management
  - Optional by default - must be explicitly enabled
design_refs: []

rationale: |
  **Why HTTP Client Factory?**

  1. **Privacy**: Hide metadata queries from ISP and external services
  2. **Geolocation**: Access region-restricted metadata APIs
  3. **Rate Limiting**: Rotate IPs to avoid rate limits
  4. **Security**: Isolate external API traffic from main network
  5. **Flexibility**: Per-service proxy configuration

  **Why Optional?**
  - Most users don't need proxy/VPN
  - Adds complexity and potential failure points
  - Can impact performance
  - Configuration overhead

scope: |
  **IN SCOPE**: ONLY for EXTERNAL API calls
  - TMDb, TheTVDB, MusicBrainz, Last.fm, Discogs, etc.
  - Any public internet metadata provider
  - Rate-limited or geo-restricted APIs

  **OUT OF SCOPE**: NOT used for
  - Arr services (Radarr, Sonarr, etc.) - local network
  - Internal services (Stash, local database)
  - Inter-service communication
  - Frontend requests

proxy_types: |
  **Supported Proxy Types**:

  **1. HTTP/HTTPS Proxy** (Preferred for simplicity)
  - Standard HTTP CONNECT proxy
  - Supports authentication (username/password)
  - Compatible with most corporate proxies
  - Example: `http://proxy.example.com:8080`

  **2. SOCKS5 Proxy** (Preferred for Tor/VPN)
  - Lower-level protocol, more flexible
  - Tor Browser default: `socks5://127.0.0.1:9050`
  - Most VPN software supports SOCKS5
  - Can handle UDP traffic

  **3. Tor Routing** (Convenience alias)
  - Just `type: tor` in config
  - Automatically uses `socks5://127.0.0.1:9050`
  - Requires Tor service running locally
  - Slowest but highest privacy

  **4. VPN Interface Binding** (Advanced)
  - Bind to specific network interface (tun0, wg0, etc.)
  - Requires VPN already configured at OS level
  - Best for wireguard/OpenVPN setups
  - Example: `interface: tun0`

configuration: |
  **Per-Service Configuration**:

  ```yaml
  http_client:
    services:
      tmdb:
        proxy:
          enabled: true              # Must explicitly enable
          type: tor                  # http, socks5, tor, vpn
          url: socks5://127.0.0.1:9050  # For http/socks5/tor
          username: ""               # Optional for http/socks5
          password: ""               # Optional for http/socks5
          interface: tun0            # For vpn type
        timeout: 30s                 # Request timeout
        max_idle_conns: 10           # Connection pooling

      thetvdb:
        proxy:
          enabled: true
          type: vpn
          interface: wg0
        timeout: 45s

      # Default for all others (no proxy)
      default:
        proxy:
          enabled: false
        timeout: 30s
        max_idle_conns: 100
  ```

  **Global Proxy** (applies to all unless overridden):

  ```yaml
  http_client:
    global_proxy:
      enabled: true
      type: socks5
      url: socks5://127.0.0.1:1080
    services:
      tmdb:
        # Inherits global_proxy
        timeout: 30s
  ```

implementation_http_proxy: |
  **Option 1: HTTP/HTTPS Proxy**

  ```go
  package httpclient

  import (
    "net/http"
    "net/url"
    "time"
  )

  type HTTPProxyConfig struct {
    Enabled   bool
    ProxyURL  string  // "http://proxy.example.com:8080"
    Username  string
    Password  string
  }

  func NewHTTPClientWithProxy(cfg HTTPProxyConfig) *http.Client {
    if !cfg.Enabled {
      return http.DefaultClient
    }

    proxyURL, _ := url.Parse(cfg.ProxyURL)
    if cfg.Username != "" {
      proxyURL.User = url.UserPassword(cfg.Username, cfg.Password)
    }

    transport := &http.Transport{
      Proxy:               http.ProxyURL(proxyURL),
      MaxIdleConns:        100,
      MaxIdleConnsPerHost: 10,
      IdleConnTimeout:     90 * time.Second,
    }

    return &http.Client{
      Transport: transport,
      Timeout:   30 * time.Second,
    }
  }
  ```

implementation_socks5: |
  **Option 2: SOCKS5 Proxy (Tor, VPNs)**

  ```go
  package httpclient

  import (
    "net/http"
    "golang.org/x/net/proxy"
  )

  type SOCKS5Config struct {
    Enabled   bool
    ProxyAddr string  // "127.0.0.1:9050" for Tor
    Username  string  // Optional
    Password  string  // Optional
  }

  func NewHTTPClientWithSOCKS5(cfg SOCKS5Config) (*http.Client, error) {
    if !cfg.Enabled {
      return http.DefaultClient, nil
    }

    var auth *proxy.Auth
    if cfg.Username != "" {
      auth = &proxy.Auth{
        User:     cfg.Username,
        Password: cfg.Password,
      }
    }

    dialer, err := proxy.SOCKS5("tcp", cfg.ProxyAddr, auth, proxy.Direct)
    if err != nil {
      return nil, fmt.Errorf("failed to create SOCKS5 dialer: %w", err)
    }

    transport := &http.Transport{
      Dial: dialer.Dial,
    }

    return &http.Client{
      Transport: transport,
      Timeout:   30 * time.Second,
    }, nil
  }
  ```

  **Tor Convenience**:
  ```go
  func NewHTTPClientWithTor() (*http.Client, error) {
    return NewHTTPClientWithSOCKS5(SOCKS5Config{
      Enabled:   true,
      ProxyAddr: "127.0.0.1:9050",
    })
  }
  ```

implementation_vpn: |
  **Option 3: VPN Interface Binding**

  ```go
  package httpclient

  import (
    "net"
    "net/http"
  )

  type VPNConfig struct {
    Enabled       bool
    InterfaceName string  // "tun0", "wg0", "utun3", etc.
  }

  func NewHTTPClientWithVPN(cfg VPNConfig) (*http.Client, error) {
    if !cfg.Enabled {
      return http.DefaultClient, nil
    }

    iface, err := net.InterfaceByName(cfg.InterfaceName)
    if err != nil {
      return nil, fmt.Errorf("interface %s not found: %w", cfg.InterfaceName, err)
    }

    addrs, err := iface.Addrs()
    if err != nil || len(addrs) == 0 {
      return nil, fmt.Errorf("no addresses on interface %s: %w", cfg.InterfaceName, err)
    }

    localAddr := addrs[0].(*net.IPNet).IP

    dialer := &net.Dialer{
      LocalAddr: &net.TCPAddr{IP: localAddr},
      Timeout:   10 * time.Second,
    }

    transport := &http.Transport{
      DialContext:         dialer.DialContext,
      MaxIdleConns:        100,
      MaxIdleConnsPerHost: 10,
      IdleConnTimeout:     90 * time.Second,
    }

    return &http.Client{
      Transport: transport,
      Timeout:   30 * time.Second,
    }, nil
  }
  ```

factory_pattern: |
  **Centralized HTTP Client Factory**

  ```go
  package httpclient

  import (
    "context"
    "fmt"
    "sync"
  )

  type ClientFactory struct {
    config  *Config
    clients map[string]*http.Client
    mu      sync.RWMutex
  }

  func NewClientFactory(cfg *Config) *ClientFactory {
    return &ClientFactory{
      config:  cfg,
      clients: make(map[string]*http.Client),
    }
  }

  // GetClientForService returns HTTP client configured for specific service
  func (f *ClientFactory) GetClientForService(ctx context.Context, service string) (*http.Client, error) {
    f.mu.RLock()
    if client, exists := f.clients[service]; exists {
      f.mu.RUnlock()
      return client, nil
    }
    f.mu.RUnlock()

    f.mu.Lock()
    defer f.mu.Unlock()

    // Double-check after acquiring write lock
    if client, exists := f.clients[service]; exists {
      return client, nil
    }

    // Get service-specific config or default
    serviceCfg := f.config.GetServiceConfig(service)

    // Create client based on proxy type
    var client *http.Client
    var err error

    if !serviceCfg.Proxy.Enabled {
      client = http.DefaultClient
    } else {
      switch serviceCfg.Proxy.Type {
      case "http", "https":
        client = NewHTTPClientWithProxy(HTTPProxyConfig{
          Enabled:  true,
          ProxyURL: serviceCfg.Proxy.URL,
          Username: serviceCfg.Proxy.Username,
          Password: serviceCfg.Proxy.Password,
        })
      case "socks5":
        client, err = NewHTTPClientWithSOCKS5(SOCKS5Config{
          Enabled:   true,
          ProxyAddr: serviceCfg.Proxy.URL,
          Username:  serviceCfg.Proxy.Username,
          Password:  serviceCfg.Proxy.Password,
        })
      case "tor":
        client, err = NewHTTPClientWithTor()
      case "vpn":
        client, err = NewHTTPClientWithVPN(VPNConfig{
          Enabled:       true,
          InterfaceName: serviceCfg.Proxy.Interface,
        })
      default:
        return nil, fmt.Errorf("unsupported proxy type: %s", serviceCfg.Proxy.Type)
      }
    }

    if err != nil {
      return nil, fmt.Errorf("failed to create HTTP client for %s: %w", service, err)
    }

    // Apply timeout
    client.Timeout = serviceCfg.Timeout

    // Cache the client
    f.clients[service] = client

    return client, nil
  }
  ```

usage_example: |
  **Using HTTP Client in Metadata Providers**:

  ```go
  package tmdb

  import (
    "context"
    "internal/service/httpclient"
  )

  type Provider struct {
    httpFactory *httpclient.ClientFactory
    apiKey      string
  }

  func (p *Provider) GetMovie(ctx context.Context, id int) (*Movie, error) {
    // Get HTTP client with proxy support
    client, err := p.httpFactory.GetClientForService(ctx, "tmdb")
    if err != nil {
      return nil, fmt.Errorf("failed to get HTTP client: %w", err)
    }

    // Build request
    url := fmt.Sprintf("https://api.themoviedb.org/3/movie/%d?api_key=%s", id, p.apiKey)
    req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)

    // Execute request (automatically uses proxy if configured)
    resp, err := client.Do(req)
    if err != nil {
      return nil, fmt.Errorf("TMDb API request failed: %w", err)
    }
    defer resp.Body.Close()

    // Parse response...
    var movie Movie
    json.NewDecoder(resp.Body).Decode(&movie)

    return &movie, nil
  }
  ```

testing: |
  **Testing with Mock Proxy**:

  ```go
  package httpclient_test

  import (
    "testing"
    "net/http/httptest"
  )

  func TestHTTPClientWithProxy(t *testing.T) {
    // Start test proxy server
    proxy := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
      // Verify proxy is being used
      if r.Method == "CONNECT" {
        w.WriteHeader(http.StatusOK)
        return
      }
      // Forward request
      // ...
    }))
    defer proxy.Close()

    // Create client with test proxy
    client := NewHTTPClientWithProxy(HTTPProxyConfig{
      Enabled:  true,
      ProxyURL: proxy.URL,
    })

    // Test request
    resp, err := client.Get("https://api.themoviedb.org/3/movie/550")
    if err != nil {
      t.Fatalf("Request failed: %v", err)
    }
    defer resp.Body.Close()

    // Verify response
    if resp.StatusCode != http.StatusOK {
      t.Errorf("Expected 200, got %d", resp.StatusCode)
    }
  }
  ```

security: |
  **Security Considerations**:

  1. **Credential Storage**: Store proxy credentials in secrets management, not config files
  2. **TLS Verification**: Always verify TLS certificates, even through proxy
  3. **Timeout Enforcement**: Set reasonable timeouts to prevent hanging
  4. **Connection Pooling**: Limit connections to prevent resource exhaustion
  5. **Tor Anonymity**: Don't send identifying headers when using Tor

  **Example: Secure Credential Handling**:
  ```go
  func (f *ClientFactory) GetClientForService(ctx context.Context, service string) (*http.Client, error) {
    serviceCfg := f.config.GetServiceConfig(service)

    // Load credentials from secrets manager
    if serviceCfg.Proxy.Enabled && serviceCfg.Proxy.CredentialsSecret != "" {
      creds, err := f.secretsManager.GetSecret(ctx, serviceCfg.Proxy.CredentialsSecret)
      if err != nil {
        return nil, fmt.Errorf("failed to load proxy credentials: %w", err)
      }
      serviceCfg.Proxy.Username = creds["username"]
      serviceCfg.Proxy.Password = creds["password"]
    }

    // Create client...
  }
  ```

performance: |
  **Performance Implications**:

  - **HTTP Proxy**: Minimal overhead (~5-10ms latency)
  - **SOCKS5 Proxy**: Similar to HTTP, ~5-10ms
  - **Tor**: Significant overhead (100-500ms or more)
  - **VPN Binding**: Minimal overhead if VPN is fast

  **Optimization Tips**:
  - Use connection pooling (MaxIdleConns)
  - Cache DNS lookups
  - Set appropriate timeouts
  - Use Keep-Alive connections
  - Consider per-service proxy configuration

  **Benchmarks**:
  ```
  Direct connection:        10ms
  HTTP Proxy:               15ms (+50%)
  SOCKS5 Proxy:             17ms (+70%)
  Tor:                     250ms (+2400%)
  VPN (WireGuard):          12ms (+20%)
  ```

sources:
  - name: Go net/http Package
    url: https://pkg.go.dev/net/http
    note: Standard library HTTP client
  - name: Go net/url Package
    url: https://pkg.go.dev/net/url
    note: URL parsing for proxy configuration
  - name: golang.org/x/net/proxy
    url: https://pkg.go.dev/golang.org/x/net/proxy
    note: SOCKS5 proxy support
  - name: Tor Project
    url: https://www.torproject.org/
    note: Tor SOCKS5 proxy documentation
  - name: HTTP Proxy RFC
    url: https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.6
    note: HTTP CONNECT method specification
  - name: SOCKS5 RFC
    url: https://datatracker.ietf.org/doc/html/rfc1928
    note: SOCKS5 protocol specification

sources_additional: []

design_refs:
  - file: data/architecture/03_METADATA_SYSTEM.yaml
    note: Metadata system uses HTTP client for external APIs
  - file: data/services/METADATA.yaml
    note: Metadata service implements HTTP client factory
  - file: data/integrations/metadata/video/TMDB.yaml
    note: TMDb integration uses HTTP client
  - file: data/integrations/metadata/video/THETVDB.yaml
    note: TheTVDB integration uses HTTP client
