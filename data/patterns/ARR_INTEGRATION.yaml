doc_title: Arr Integration Pattern
doc_category: pattern
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: Complete Arr integration pattern
status_sources: âœ…
status_sources_notes: All Arr tools documented
status_instructions: âœ…
status_instructions_notes: Generated from design
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Webhook-based integration pattern with Radarr, Sonarr, Lidarr,
  and Whisparr


  Standard pattern for Arr stack integration:

  - **Webhook Handlers**: Process Download, Upgrade, Rename, Delete events

  - **Metadata Sync**: Two-way sync with conflict resolution

  - **Priority Chain**: Arr metadata > Internal > External APIs

  - **Background Jobs**: Async enrichment and validation

  - **Error Handling**: Retry logic with exponential backoff'
wiki_tagline: '> Seamless integration with your Arr stack for automated media management'
wiki_overview: The Arr Integration Pattern provides a consistent approach for integrating
  with Radarr, Sonarr, Lidarr, and Whisparr. Webhook events automatically sync new
  downloads, metadata updates, and deletions. The system prioritizes Arr metadata
  (which is already cached from upstream sources) to minimize external API calls,
  while background jobs enrich content with additional metadata when needed.
sources:
- name: Radarr API Docs
  url: https://radarr.video/docs/api/
  note: Radarr webhook events
- name: Sonarr API Docs
  url: https://sonarr.tv/docs/api/
  note: Sonarr webhook events
- name: Lidarr API Docs
  url: https://lidarr.audio/docs/api/
  note: Lidarr webhook events
- name: Servarr Wiki
  url: https://wiki.servarr.com/
  note: Shared Arr stack documentation
design_refs:
- title: patterns
  path: INDEX.md
- title: 01_ARCHITECTURE
  path: ../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../architecture/03_METADATA_SYSTEM.md
pattern_name: Arr Integration Pattern
webhook_events:
  radarr:
  - event: Download
    trigger: Movie file downloaded
    payload_fields: movie, movieFile, release, downloadClient
    action: Create/update movie record, trigger metadata enrichment
  - event: Upgrade
    trigger: Better quality file downloaded
    payload_fields: movie, movieFile, deletedFiles
    action: Update movie file path, remove old file reference
  - event: Rename
    trigger: File renamed by Radarr
    payload_fields: movie, movieFile
    action: Update file path in database
  - event: MovieDelete
    trigger: Movie deleted from Radarr
    payload_fields: movie, deletedFiles
    action: Mark as unavailable or delete from Revenge
  sonarr:
  - event: Download
    trigger: Episode file downloaded
    payload_fields: series, episodes, episodeFile, release
    action: Create/update episode records
  - event: Upgrade
    trigger: Better quality file downloaded
    payload_fields: series, episodes, episodeFile, deletedFiles
    action: Update episode file path
  - event: Rename
    trigger: File renamed by Sonarr
    payload_fields: series, episodeFile
    action: Update file path in database
  - event: SeriesDelete
    trigger: Series deleted from Sonarr
    payload_fields: series, deletedFiles
    action: Mark series as unavailable
  lidarr:
  - event: AlbumDownload
    trigger: Album downloaded
    payload_fields: artist, album, tracks, release
    action: Create/update album and track records
  - event: AlbumUpgrade
    trigger: Better quality album downloaded
    payload_fields: artist, album, deletedFiles
    action: Update album files
  - event: TrackRetag
    trigger: Metadata tags updated
    payload_fields: artist, album, trackFile
    action: Re-extract metadata from file
  - event: ArtistDelete
    trigger: Artist deleted from Lidarr
    payload_fields: artist, deletedFiles
    action: Mark artist as unavailable
  whisparr:
  - event: Download
    trigger: Scene downloaded
    payload_fields: movie, movieFile, release
    action: Create/update QAR record (legacy module)
  - event: Upgrade
    trigger: Better quality file downloaded
    payload_fields: movie, movieFile, deletedFiles
    action: Update file path
  - event: MovieDelete
    trigger: Scene deleted from Whisparr
    payload_fields: movie, deletedFiles
    action: Mark as unavailable
webhook_handler_pattern: "**Standard Webhook Handler Implementation**:\n\n```go\n\
  // Webhook handler receives events from Arr services\nfunc (h *ArrWebhookHandler)\
  \ HandleRadarrEvent(ctx context.Context, event *RadarrEvent) error {\n    switch\
  \ event.EventType {\n    case \"Download\":\n        return h.handleMovieDownload(ctx,\
  \ event)\n    case \"Upgrade\":\n        return h.handleMovieUpgrade(ctx, event)\n\
  \    case \"Rename\":\n        return h.handleMovieRename(ctx, event)\n    case\
  \ \"MovieDelete\":\n        return h.handleMovieDelete(ctx, event)\n    default:\n\
  \        return fmt.Errorf(\"unknown event type: %s\", event.EventType)\n    }\n\
  }\n\nfunc (h *ArrWebhookHandler) handleMovieDownload(ctx context.Context, event\
  \ *RadarrEvent) error {\n    // 1. Extract metadata from webhook payload\n    movie\
  \ := event.Movie\n\n    // 2. Check if movie already exists\n    existing, err :=\
  \ h.repo.GetByRadarrID(ctx, movie.ID)\n    if err != nil && !errors.Is(err, ErrNotFound)\
  \ {\n        return fmt.Errorf(\"failed to check existing: %w\", err)\n    }\n\n\
  \    // 3. Use Arr metadata (already enriched from TMDb)\n    movieRecord := &Movie{\n\
  \        RadarrID: movie.ID,\n        Title: movie.Title,\n        Year: movie.Year,\n\
  \        TMDbID: movie.TmdbId,\n        FilePath: event.MovieFile.RelativePath,\n\
  \        // Use metadata from Radarr (already fetched from TMDb)\n        Overview:\
  \ movie.Overview,\n        PosterURL: movie.Images.FindPoster(),\n        Genres:\
  \ movie.Genres,\n    }\n\n    // 4. Save or update\n    if existing != nil {\n \
  \       return h.repo.Update(ctx, movieRecord)\n    }\n    return h.repo.Insert(ctx,\
  \ movieRecord)\n}\n```\n"
metadata_sync_strategy:
  priority_order:
    1: Arr Service Metadata (Radarr, Sonarr, Lidarr, Whisparr)
    2: Internal Metadata (Stash-App for adult content)
    3: External API Direct (TMDb, MusicBrainz, StashDB)
    4: Background Enrichment Jobs
  rationale: 'Arr services already fetch and cache metadata from upstream sources
    (TMDb, MusicBrainz, etc.).

    Re-fetching the same data from external APIs wastes API quota and adds latency.

    Use Arr metadata first, only enrich with additional details not provided by Arr.'
  conflict_resolution:
    strategy: Arr metadata wins by default
    user_override: Configurable per-library
    example: 'If Radarr provides a movie title "The Matrix (1999)" but TMDb returns
      "The Matrix",

      use Radarr''s title since it includes the year for disambiguation.


      User can configure library to prefer TMDb metadata over Radarr if desired.'
background_enrichment:
  trigger: After initial webhook processing
  method: River background jobs
  jobs:
  - job: EnrichMovieMetadata
    input: movie_id
    actions:
    - Fetch additional metadata not provided by Radarr (cast, crew, reviews)
    - Download high-resolution poster/backdrop images
    - Extract video codec and quality information
    - Generate video preview thumbnails
  - job: EnrichAlbumMetadata
    input: album_id
    actions:
    - Fetch artist biography from Last.fm
    - Get album reviews from external sources
    - Download high-resolution album art
    - Extract audio fingerprints for track matching
validation_and_reconciliation:
  validation_checks:
  - File exists at provided path
  - File is readable and not corrupted
  - Metadata IDs are valid (TMDb ID, MusicBrainz ID, etc.)
  - No duplicate entries created
  reconciliation:
    frequency: Daily background job
    actions:
    - Check Arr API for deleted items not reflected via webhooks
    - Verify file paths still exist
    - Update metadata for items modified in Arr
    - Remove orphaned records
error_handling:
  retry_strategy:
    method: Exponential backoff
    max_retries: 5
    initial_delay: 1s
    max_delay: 60s
  failure_scenarios:
  - scenario: Webhook payload malformed
    action: Log error, return 400 Bad Request
  - scenario: Database connection failed
    action: Retry with backoff, queue for later processing
  - scenario: File path doesn't exist
    action: Log warning, mark as unavailable, retry later
  - scenario: External API rate limited
    action: Skip external enrichment, use Arr metadata only
implementation_example: "**Complete Integration Example**:\n\n```go\n// Module registration\
  \ with fx\nvar Module = fx.Module(\n    \"arr_integration\",\n    fx.Provide(\n\
  \        NewRadarrWebhookHandler,\n        NewSonarrWebhookHandler,\n        NewLidarrWebhookHandler,\n\
  \        NewWhisparrWebhookHandler,\n    ),\n)\n\n// Webhook endpoint registration\
  \ (ogen)\nfunc (h *Handler) PostArrWebhook(ctx context.Context, req *ArrWebhookRequest)\
  \ (*ArrWebhookResponse, error) {\n    // Validate webhook signature (if configured)\n\
  \    if err := h.validateWebhookSignature(req); err != nil {\n        return nil,\
  \ ErrUnauthorized\n    }\n\n    // Route to appropriate handler based on source\n\
  \    switch req.Source {\n    case \"radarr\":\n        err = h.radarrHandler.HandleEvent(ctx,\
  \ req.Payload)\n    case \"sonarr\":\n        err = h.sonarrHandler.HandleEvent(ctx,\
  \ req.Payload)\n    case \"lidarr\":\n        err = h.lidarrHandler.HandleEvent(ctx,\
  \ req.Payload)\n    case \"whisparr\":\n        err = h.whisparrHandler.HandleEvent(ctx,\
  \ req.Payload)\n    default:\n        return nil, fmt.Errorf(\"unknown source: %s\"\
  , req.Source)\n    }\n\n    if err != nil {\n        // Log error but return 200\
  \ to prevent Arr from retrying\n        slog.Error(\"webhook processing failed\"\
  , \"error\", err, \"source\", req.Source)\n    }\n\n    return &ArrWebhookResponse{Success:\
  \ true}, nil\n}\n```\n"
best_practices:
- practice: Always return 200 OK to webhooks
  reason: Prevents Arr services from retrying on transient errors
- practice: Process webhooks asynchronously
  reason: Fast response time, avoid timeout issues
- practice: Use Arr metadata as source of truth
  reason: Avoids duplicate API calls and quota waste
- practice: Validate file existence before updating database
  reason: Prevents broken file path references
- practice: Implement idempotency
  reason: Handle duplicate webhook deliveries gracefully
- practice: Log all webhook events
  reason: Debugging and auditing
