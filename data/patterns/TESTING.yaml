doc_title: Testing Patterns
doc_category: pattern
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: Generated from design
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Table-driven tests, mocking patterns, and integration testing
  with testcontainers


  Standard testing approach for Revenge project:

  - **Table-Driven Tests**: All logic tests use table-driven pattern

  - **Testify**: Assertions and test suites

  - **Mockery**: Auto-generated mocks from interfaces

  - **Embedded Postgres**: Fast unit tests without containers

  - **Testcontainers**: Integration tests with real PostgreSQL, Dragonfly

  '
wiki_tagline: '> Testing standards and patterns for code quality

  '
wiki_overview: 'Revenge maintains high code quality through comprehensive testing. All new code requires 80% test coverage minimum. Unit tests use table-driven patterns for clarity and completeness, with mocks generated automatically via Mockery. Integration tests run against real PostgreSQL using embedded-postgres for speed or testcontainers for full fidelity. The CI pipeline runs all tests on every pull request, blocking merges that reduce coverage or introduce failing tests.

  '
sources:
- name: Go Testing
  url: https://pkg.go.dev/testing
  note: Standard library testing
- name: Testify
  url: https://github.com/stretchr/testify
  note: Assertions and test suites
- name: Mockery
  url: https://vektra.github.io/mockery/
  note: Mock generation
- name: Testcontainers Go
  url: https://golang.testcontainers.org/
  note: Integration testing with containers
- name: Embedded Postgres
  url: https://github.com/fergusstrange/embedded-postgres
  note: Fast PostgreSQL for unit tests
design_refs:
- title: patterns
  path: patterns/INDEX.md
- title: BEST_PRACTICES
  path: operations/BEST_PRACTICES.md
- title: 02_DESIGN_PRINCIPLES
  path: architecture/02_DESIGN_PRINCIPLES.md
pattern_name: Testing Patterns
test_coverage_requirements:
  minimum: 80%
  enforcement: CI blocks PRs below 80%
  exceptions: Generated code (mocks, ogen handlers)
  critical_paths_100:
  - Authentication (login, logout, token validation)
  - Authorization (RBAC, permission checks)
  - Payment processing (if applicable)
  - Data migrations
table_driven_tests:
  description: Standard pattern for all logic tests
  example: "```go\nfunc TestMovieService_GetByID(t *testing.T) {\n  tests := []struct\
    \ {\n    name      string\n    movieID   uuid.UUID\n    mockSetup func(*mocks.MovieRepository)\n\
    \    want      *Movie\n    wantErr   error\n  }{\n    {\n      name:    \"success\
    \ - movie found\",\n      movieID: uuid.MustParse(\"123e4567-e89b-12d3-a456-426614174000\"\
    ),\n      mockSetup: func(repo *mocks.MovieRepository) {\n        repo.On(\"GetByID\"\
    , mock.Anything, uuid.MustParse(\"123e4567-e89b-12d3-a456-426614174000\")).\n\
    \          Return(&Movie{\n            ID:    uuid.MustParse(\"123e4567-e89b-12d3-a456-426614174000\"\
    ),\n            Title: \"Inception\",\n          }, nil)\n      },\n      want:\
    \ &Movie{\n        ID:    uuid.MustParse(\"123e4567-e89b-12d3-a456-426614174000\"\
    ),\n        Title: \"Inception\",\n      },\n      wantErr: nil,\n    },\n   \
    \ {\n      name:    \"error - movie not found\",\n      movieID: uuid.MustParse(\"\
    123e4567-e89b-12d3-a456-426614174001\"),\n      mockSetup: func(repo *mocks.MovieRepository)\
    \ {\n        repo.On(\"GetByID\", mock.Anything, uuid.MustParse(\"123e4567-e89b-12d3-a456-426614174001\"\
    )).\n          Return(nil, ErrMovieNotFound)\n      },\n      want:    nil,\n\
    \      wantErr: ErrMovieNotFound,\n    },\n  }\n\n  for _, tt := range tests {\n\
    \    t.Run(tt.name, func(t *testing.T) {\n      // Setup mocks\n      mockRepo\
    \ := mocks.NewMovieRepository(t)\n      if tt.mockSetup != nil {\n        tt.mockSetup(mockRepo)\n\
    \      }\n\n      // Create service\n      svc := NewMovieService(mockRepo)\n\n\
    \      // Execute\n      got, err := svc.GetByID(context.Background(), tt.movieID)\n\
    \n      // Assert\n      if tt.wantErr != nil {\n        require.ErrorIs(t, err,\
    \ tt.wantErr)\n        require.Nil(t, got)\n      } else {\n        require.NoError(t,\
    \ err)\n        require.Equal(t, tt.want, got)\n      }\n    })\n  }\n}\n```\n"
  benefits:
  - Readable: Each test case is a row in the table
  - Comprehensive: Easy to add new cases
  - Maintainable: Common setup/teardown logic
  - Parallel-friendly: t.Run() enables parallel execution
unit_tests:
  description: Fast tests with mocked dependencies
  file_naming: '*_test.go (same package)'
  mocking_strategy:
    tool: Mockery v3
    generation: Automatic from interfaces
    config_file: .mockery.yaml
  mockery_config: "```yaml\n# .mockery.yaml\nwith-expecter: true\ndir: \"internal/mocks\"\
    \noutpkg: mocks\npackages:\n  github.com/yourorg/revenge/internal/content/movie:\n\
    \    interfaces:\n      Repository:\n```\n"
  generate_mocks: '```bash

    # Generate all mocks

    mockery


    # Generated file: internal/mocks/Repository.go

    ```

    '
  testify_assertions: "```go\nimport (\n  \"testing\"\n  \"github.com/stretchr/testify/assert\"\
    \n  \"github.com/stretchr/testify/require\"\n)\n\nfunc TestSomething(t *testing.T)\
    \ {\n  // require: Fails immediately if false\n  require.NotNil(t, obj)\n  require.NoError(t,\
    \ err)\n\n  // assert: Continues running tests even if false\n  assert.Equal(t,\
    \ expected, actual)\n  assert.True(t, condition)\n  assert.Contains(t, slice,\
    \ element)\n}\n```\n"
integration_tests:
  description: Tests with real database and services
  file_naming: '*_integration_test.go'
  build_tag: //go:build integration
  embedded_postgres_example: "```go\n//go:build integration\npackage movie_test\n\n\
    import (\n  \"context\"\n  \"testing\"\n  embeddedpostgres \"github.com/fergusstrange/embedded-postgres\"\
    \n  \"github.com/stretchr/testify/require\"\n)\n\nfunc TestMovieRepository_Integration(t\
    \ *testing.T) {\n  // Start embedded PostgreSQL\n  postgres := embeddedpostgres.NewDatabase(\n\
    \    embeddedpostgres.DefaultConfig().\n      Port(5433).\n      Database(\"revenge_test\"\
    ),\n  )\n  require.NoError(t, postgres.Start())\n  defer postgres.Stop()\n\n \
    \ // Connect to database\n  db, err := sql.Open(\"postgres\", \"postgres://postgres:postgres@localhost:5433/revenge_test?sslmode=disable\"\
    )\n  require.NoError(t, err)\n  defer db.Close()\n\n  // Run migrations\n  err\
    \ = runMigrations(db)\n  require.NoError(t, err)\n\n  // Create repository\n \
    \ repo := NewMovieRepository(db)\n\n  // Test Insert\n  movie := &Movie{Title:\
    \ \"Inception\", Year: 2010}\n  err = repo.Insert(context.Background(), movie)\n\
    \  require.NoError(t, err)\n  require.NotEqual(t, uuid.Nil, movie.ID)\n\n  //\
    \ Test GetByID\n  found, err := repo.GetByID(context.Background(), movie.ID)\n\
    \  require.NoError(t, err)\n  require.Equal(t, \"Inception\", found.Title)\n}\n\
    ```\n"
  testcontainers_example: "```go\n//go:build integration\npackage movie_test\n\nimport\
    \ (\n  \"context\"\n  \"testing\"\n  \"github.com/testcontainers/testcontainers-go\"\
    \n  \"github.com/testcontainers/testcontainers-go/modules/postgres\"\n)\n\nfunc\
    \ TestMovieRepository_Testcontainers(t *testing.T) {\n  ctx := context.Background()\n\
    \n  // Start PostgreSQL container\n  pgContainer, err := postgres.RunContainer(ctx,\n\
    \    testcontainers.WithImage(\"postgres:18-alpine\"),\n    postgres.WithDatabase(\"\
    revenge_test\"),\n    postgres.WithUsername(\"postgres\"),\n    postgres.WithPassword(\"\
    postgres\"),\n  )\n  require.NoError(t, err)\n  defer pgContainer.Terminate(ctx)\n\
    \n  // Get connection string\n  connStr, err := pgContainer.ConnectionString(ctx)\n\
    \  require.NoError(t, err)\n\n  // Connect and test\n  db, err := sql.Open(\"\
    postgres\", connStr)\n  require.NoError(t, err)\n\n  // Run tests...\n}\n```\n"
  run_integration_tests: '# Run integration tests only

    go test -tags=integration ./...


    # Run all tests (unit + integration)

    go test -tags=integration ./...


    # Skip integration tests in CI (default)

    go test ./...

    '
test_suites:
  description: Group related tests with setup/teardown
  example: "```go\nimport \"github.com/stretchr/testify/suite\"\n\ntype MovieServiceTestSuite\
    \ struct {\n  suite.Suite\n  db   *sql.DB\n  repo *MovieRepository\n  svc  *MovieService\n\
    }\n\nfunc (s *MovieServiceTestSuite) SetupSuite() {\n  // One-time setup for entire\
    \ suite\n  s.db = setupTestDB()\n}\n\nfunc (s *MovieServiceTestSuite) TearDownSuite()\
    \ {\n  // One-time teardown\n  s.db.Close()\n}\n\nfunc (s *MovieServiceTestSuite)\
    \ SetupTest() {\n  // Before each test\n  s.repo = NewMovieRepository(s.db)\n\
    \  s.svc = NewMovieService(s.repo)\n}\n\nfunc (s *MovieServiceTestSuite) TearDownTest()\
    \ {\n  // After each test\n  s.db.Exec(\"TRUNCATE TABLE movies CASCADE\")\n}\n\
    \nfunc (s *MovieServiceTestSuite) TestGetByID() {\n  // Test implementation\n\
    \  movie := &Movie{Title: \"Inception\"}\n  err := s.repo.Insert(context.Background(),\
    \ movie)\n  s.NoError(err)\n\n  found, err := s.svc.GetByID(context.Background(),\
    \ movie.ID)\n  s.NoError(err)\n  s.Equal(\"Inception\", found.Title)\n}\n\n//\
    \ Run suite\nfunc TestMovieServiceSuite(t *testing.T) {\n  suite.Run(t, new(MovieServiceTestSuite))\n\
    }\n```\n"
benchmarking:
  description: Performance testing with `go test -bench`
  example: "```go\nfunc BenchmarkMovieRepository_GetByID(b *testing.B) {\n  repo :=\
    \ setupRepo(b)\n  movie := insertTestMovie(b, repo)\n\n  b.ResetTimer()\n\n  for\
    \ i := 0; i < b.N; i++ {\n    _, err := repo.GetByID(context.Background(), movie.ID)\n\
    \    if err != nil {\n      b.Fatal(err)\n    }\n  }\n}\n\n// Run benchmarks\n\
    // go test -bench=. -benchmem\n```\n"
test_helpers:
  description: Common test utilities
  location: internal/testutil/
  helpers:
  - name: NewTestDB
    description: Create test database connection
  - name: RunMigrations
    description: Apply migrations to test DB
  - name: TruncateTables
    description: Clean test data between tests
  - name: FixtureLoader
    description: Load test fixtures from YAML/JSON
  - name: AssertJSONEqual
    description: Compare JSON responses
ci_integration:
  description: GitHub Actions configuration for running tests in CI
  workflow_file: .github/workflows/tests.yml
  notes: Example configuration showing unit tests, integration tests, and coverage
    checking
best_practices:
- name: Test one thing per test
  description: Each test should validate a single behavior
- name: Use descriptive test names
  description: 'Name pattern: TestFunction_Scenario_ExpectedBehavior'
- name: Arrange-Act-Assert
  description: Clear separation of setup, execution, and assertions
- name: Avoid test interdependence
  description: Tests should run independently in any order
- name: Use table-driven tests
  description: Prefer tables over duplicate test functions
- name: Mock external dependencies
  description: Unit tests should not hit real databases/APIs
- name: Test error cases
  description: Test both happy path and error scenarios
- name: Keep tests fast
  description: Unit tests <100ms, integration tests <1s
