doc_title: ListenBrainz Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: ðŸŸ¡
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Open-source music listening history tracking (MusicBrainz project)'
wiki_tagline: '> Open-source music scrobbling with ListenBrainz'
wiki_overview: ListenBrainz is an open-source alternative to Last.fm for tracking music listening. Part of the MusicBrainz
  project. Scrobble your plays and build a listening history. Import your Last.fm history to start. Discover music through
  community playlists. Your data is open and exportable.
sources:
- name: Last.fm API
  url: https://www.last.fm/api/intro
  note: Auto-resolved from lastfm-api
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
integration_name: ListenBrainz
integration_id: listenbrainz
external_service: ListenBrainz
api_base_url: https://api.listenbrainz.org/1
auth_method: token
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1["Revenge<br/>Playback<br/>Events"]
      node2["ListenBrainz<br/>Integration"]
      node3[[ListenBrainz<br/>API]]
      node4["Listen<br/>Queue [River]"]
      node1 --> node2
      node2 --> node3
      node3 --> node4
  ```
api_details: |
  **API Version**: v1
  **Base URL**: `https://api.listenbrainz.org/1`
  **Authentication**: User token (no OAuth required)
  **Rate Limit**: None (open-source, community-driven)

  **Key Endpoints**:
  - `/submit-listens` - Submit listening history
  - `/user/{username}/listens` - Get user's listen history
  - `/user/{username}/listen-count` - Get total listen count
  - `/user/{username}/playing-now` - Get currently playing track
  - `/latest-import` - Get timestamp of last import
  - `/stats/user/{username}/artists` - Get top artists
  - `/stats/user/{username}/recordings` - Get top tracks

  **Required Headers**:
  - `Content-Type: application/json`
  - `Authorization: Token {user_token}`
database_schema: |
  **Schema**: `public`

  ```sql
  -- ListenBrainz user connections
  CREATE TABLE listenbrainz_connections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    user_token TEXT NOT NULL,
    lb_username VARCHAR(255) NOT NULL,

    auto_submit BOOLEAN DEFAULT true,
    last_sync_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),

    UNIQUE(user_id)
  );

  -- Listen submission queue (River jobs)
  CREATE TABLE listenbrainz_listen_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    connection_id UUID NOT NULL REFERENCES listenbrainz_connections(id) ON DELETE CASCADE,

    track_id UUID NOT NULL,
    listened_at TIMESTAMPTZ NOT NULL,

    track_name VARCHAR(500) NOT NULL,
    artist_name VARCHAR(500) NOT NULL,
    release_name VARCHAR(500),
    recording_mbid UUID,                        -- MusicBrainz Recording ID

    submitted_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT
  );
  CREATE INDEX idx_lb_queue_user ON listenbrainz_listen_queue(user_id);
  CREATE INDEX idx_lb_queue_pending ON listenbrainz_listen_queue(listened_at) WHERE submitted_at IS NULL;

  -- Imported listens from ListenBrainz
  CREATE TABLE listenbrainz_imported_listens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    connection_id UUID NOT NULL REFERENCES listenbrainz_connections(id) ON DELETE CASCADE,

    track_id UUID,                              -- NULL if track not in library
    listened_at TIMESTAMPTZ NOT NULL,

    track_name VARCHAR(500) NOT NULL,
    artist_name VARCHAR(500) NOT NULL,
    release_name VARCHAR(500),
    recording_mbid UUID,

    imported_at TIMESTAMPTZ DEFAULT now(),

    UNIQUE(connection_id, listened_at, recording_mbid)
  );
  CREATE INDEX idx_lb_imported_connection ON listenbrainz_imported_listens(connection_id);
  ```
module_structure: |
  ```
  internal/integrations/listenbrainz/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ client.go                    # ListenBrainz API client
  â”œâ”€â”€ submit.go                    # Listen submission
  â”œâ”€â”€ import.go                    # Import history
  â”œâ”€â”€ jobs.go                      # River jobs
  â”œâ”€â”€ types.go                     # ListenBrainz API types
  â””â”€â”€ listenbrainz_test.go
  ```
key_interfaces: |
  ```go
  // ListenBrainz integration service
  type ListenBrainzService interface {
    // Connection
    ConnectUser(ctx context.Context, userID uuid.UUID, userToken string) (*LBConnection, error)
    ValidateToken(ctx context.Context, userToken string) (string, error)  // Returns username

    // Submission
    SubmitListen(ctx context.Context, userID uuid.UUID, trackID uuid.UUID, listenedAt time.Time) error
    SubmitPlayingNow(ctx context.Context, userID uuid.UUID, trackID uuid.UUID) error

    // Import
    ImportHistory(ctx context.Context, connectionID uuid.UUID, minTimestamp *time.Time) error
    GetUserStats(ctx context.Context, connectionID uuid.UUID) (*LBStats, error)
  }

  // Listen payload for submission
  type ListenPayload struct {
    ListenType string   `json:"listen_type"`  // "single", "playing_now", "import"
    Payload    []Listen `json:"payload"`
  }

  type Listen struct {
    ListenedAt    int64         `json:"listened_at,omitempty"`
    TrackMetadata TrackMetadata `json:"track_metadata"`
  }

  type TrackMetadata struct {
    ArtistName      string                 `json:"artist_name"`
    TrackName       string                 `json:"track_name"`
    ReleaseName     string                 `json:"release_name,omitempty"`
    AdditionalInfo  map[string]interface{} `json:"additional_info,omitempty"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client
  - `github.com/google/uuid` - UUID support (for MBIDs)
  - `github.com/jackc/pgx/v5` - PostgreSQL driver
  - `github.com/riverqueue/river` - Background jobs
  - `go.uber.org/fx` - Dependency injection

  **External Services**:
  - ListenBrainz account (free, open-source)
env_vars: |
  ```bash
  # No global config needed - users provide their own tokens
  LISTENBRAINZ_AUTO_SUBMIT=true
  LISTENBRAINZ_IMPORT_ON_CONNECT=true
  ```
config_keys: |
  ```yaml
  integrations:
    listenbrainz:
      auto_submit: true              # Auto-submit listens as user plays tracks
      import_on_connect: true        # Import existing history when user connects
      max_import_age_days: 365       # Only import listens from last year
  ```
component_interaction: |
  **User Connection Flow**:
  1. User goes to ListenBrainz settings in Revenge
  2. User obtains user token from https://listenbrainz.org/profile/
  3. Enter token in Revenge
  4. Validate token via GET /1/validate-token
  5. Store token and username in listenbrainz_connections

  **Listen Submission** (real-time):
  1. User plays track in Revenge
  2. Playback event triggers SubmitListen()
  3. Queue listen in listenbrainz_listen_queue
  4. River job submits to POST /1/submit-listens
  5. Payload includes track_name, artist_name, release_name, recording_mbid, listened_at

  **Playing Now**:
  1. Track starts playing
  2. POST /1/submit-listens with listen_type: "playing_now"
  3. No listened_at timestamp (indicates "now playing")

  **Import History**:
  1. User connects ListenBrainz account
  2. GET /1/user/{username}/listens with pagination
  3. Import all listens (up to max_import_age_days)
  4. Match tracks by recording_mbid (MusicBrainz ID)
  5. Store in listenbrainz_imported_listens
  6. Mark tracks as "played" in Revenge
api_request_examples: |
  **Submit Single Listen**:
  ```
  POST https://api.listenbrainz.org/1/submit-listens
  Authorization: Token {user_token}
  Content-Type: application/json

  {
    "listen_type": "single",
    "payload": [
      {
        "listened_at": 1706745600,
        "track_metadata": {
          "artist_name": "Radiohead",
          "track_name": "Paranoid Android",
          "release_name": "OK Computer",
          "additional_info": {
            "recording_mbid": "8cc3c0c0-d11c-4d90-b674-49f993d8e4d7",
            "artist_mbids": ["a74b1b7f-71a5-4011-9441-d0b5e4122711"],
            "release_mbid": "b1392450-e666-3926-a536-22c65f834433",
            "duration_ms": 383000
          }
        }
      }
    ]
  }
  ```

  **Response**:
  ```json
  {
    "status": "ok"
  }
  ```

  **Submit Playing Now**:
  ```
  POST https://api.listenbrainz.org/1/submit-listens
  Authorization: Token {user_token}
  Content-Type: application/json

  {
    "listen_type": "playing_now",
    "payload": [
      {
        "track_metadata": {
          "artist_name": "Pink Floyd",
          "track_name": "Time",
          "release_name": "The Dark Side of the Moon"
        }
      }
    ]
  }
  ```

  **Get User Listens**:
  ```
  GET https://api.listenbrainz.org/1/user/johndoe/listens?
    min_ts=1704067200&
    max_ts=1706745600&
    count=100
  ```

  **Response**:
  ```json
  {
    "payload": {
      "count": 100,
      "latest_listen_ts": 1706745600,
      "oldest_listen_ts": 1706659200,
      "listens": [
        {
          "listened_at": 1706745600,
          "track_metadata": {
            "artist_name": "Radiohead",
            "track_name": "Paranoid Android",
            "release_name": "OK Computer",
            "additional_info": {
              "recording_mbid": "8cc3c0c0-d11c-4d90-b674-49f993d8e4d7"
            }
          }
        }
      ]
    }
  }
  ```
listen_submission: |
  **Listen Types**:
  - **single**: Submit a completed listen (requires listened_at timestamp)
  - **playing_now**: Submit currently playing track (no timestamp)
  - **import**: Batch import historical listens (multiple listens)

  **Timestamp Format**:
  - Unix timestamp (seconds since epoch)
  - Must be in the past for "single" type
  - Must be within last 1 hour for accuracy

  **MusicBrainz Integration**:
  - Include recording_mbid when available (preferred)
  - Include artist_mbids, release_mbid for better matching
  - ListenBrainz uses MBIDs to link listens to MusicBrainz database

  **Batch Submission**:
  - Can submit up to 100 listens per request
  - Use for importing historical data
  - Listens must be in chronological order
musicbrainz_integration: |
  **Recording MBID Matching**:
  - Query MusicBrainz for recording_mbid during track scan
  - Store mbid in tracks table as UUID
  - Include in ListenBrainz submissions for accurate matching

  **Benefits of MBIDs**:
  - Canonical track identification across services
  - Links listens to MusicBrainz knowledge base
  - Enables better statistics and recommendations

  **Fallback Without MBID**:
  - ListenBrainz accepts listens without MBIDs
  - Uses fuzzy matching on artist_name + track_name
  - Less accurate but still functional
import_workflow: |
  **Initial Import**:
  1. User connects ListenBrainz account
  2. Calculate min_ts (now - max_import_age_days)
  3. GET /1/user/{username}/listens with pagination (100 per page)
  4. For each listen:
     - Try to match recording_mbid to local track
     - If matched, mark track as played in Revenge
     - Store in listenbrainz_imported_listens
  5. Continue until all pages fetched or min_ts reached

  **Incremental Import**:
  - Store latest_listen_ts from last import
  - On next sync, use as min_ts
  - Only fetch new listens since last sync

  **Conflict Handling**:
  - If listen already exists in local playback history, skip
  - Use (connection_id, listened_at, recording_mbid) as unique key
statistics_sync: |
  **User Statistics**:
  - GET /1/stats/user/{username}/artists - Top artists (all time, year, month)
  - GET /1/stats/user/{username}/recordings - Top tracks
  - GET /1/stats/user/{username}/releases - Top albums

  **Listen Count**:
  - GET /1/user/{username}/listen-count
  - Returns total number of listens submitted

  **Use Cases**:
  - Display user's top artists/tracks in Revenge UI
  - Compare local playback stats with ListenBrainz stats
  - Verify sync completeness
unit_tests: |
  ```go
  func TestListenBrainzService_SubmitListen(t *testing.T) {
    // Test single listen submission
    // Test playing_now submission
    // Test batch import
  }

  func TestListenBrainzService_ImportHistory(t *testing.T) {
    // Test pagination
    // Test MBID matching
    // Test duplicate detection
  }

  func TestListenBrainzService_ValidateToken(t *testing.T) {
    // Test token validation
    // Test invalid token handling
  }
  ```
integration_tests: |
  ```go
  func TestListenBrainz_FullWorkflow(t *testing.T) {
    // Use test ListenBrainz account
    // Test connect â†’ import â†’ submit listen
    // Verify listen appears in ListenBrainz history
  }
  ```
