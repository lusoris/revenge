doc_title: Chaptarr Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: ðŸŸ¡
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Book & audiobook management automation (uses Readarr API)'
wiki_tagline: '> Automatic book and audiobook downloads with Chaptarr'
wiki_overview: Chaptarr manages book and audiobook downloads using the Readarr API. Add authors and their works download automatically.
  Monitors for new releases. Supports both ebook and audiobook formats. Webhooks notify Revenge when books are imported. Connect
  with your Chaptarr/Readarr URL and API key.
sources:
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: pgx PostgreSQL Driver
  url: https://pkg.go.dev/github.com/jackc/pgx/v5
  note: Auto-resolved from pgx
- name: PostgreSQL Arrays
  url: https://www.postgresql.org/docs/current/arrays.html
  note: Auto-resolved from postgresql-arrays
- name: PostgreSQL JSON Functions
  url: https://www.postgresql.org/docs/current/functions-json.html
  note: Auto-resolved from postgresql-json
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: Servarr Wiki
  url: https://wiki.servarr.com/
  note: Auto-resolved from servarr-wiki
- name: Typesense API
  url: https://typesense.org/docs/latest/api/
  note: Auto-resolved from typesense
- name: Typesense Go Client
  url: https://github.com/typesense/typesense-go
  note: Auto-resolved from typesense-go
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
integration_name: Chaptarr
integration_id: chaptarr
external_service: Chaptarr
auth_method: api_key
api_base_url: http://localhost:8787/api/v1
dual_role_metadata_and_downloads: |
  **CRITICAL: Chaptarr serves DUAL purposes in the Revenge architecture**:

  **1. PRIMARY Metadata Aggregator**:
  - Chaptarr is the PRIMARY source for book and audiobook metadata in Revenge
  - It aggregates metadata from GoodReads and OpenLibrary
  - Maintains local cache of author/book information (ISBN, publication dates, descriptions, cover art)
  - Revenge queries Chaptarr API for book metadata BEFORE falling back to direct GoodReads/OpenLibrary APIs
  - Provides unified, consistent metadata interface for BOTH ebooks AND audiobooks
  - Reduces direct API calls to external services (rate limiting, availability)

  **2. Download Automation Manager**:
  - Handles book/audiobook acquisition through configured indexers and download clients
  - Monitors authors for new releases and automatically downloads
  - Supports dual-format: ebooks (EPUB, MOBI, PDF) and audiobooks (M4B, MP3)
  - Manages author/book file organization
  - Webhooks notify Revenge when books/audiobooks are ready

  **Metadata Flow**:
  ```
  External (GoodReads/OpenLibrary) â†’ Chaptarr (local aggregation) â†’ Revenge
                                          â†“
                        (optional direct GoodReads/OpenLibrary for enrichment)
  ```

  **Why This Matters**:
  - Chaptarr is NOT just a download tool - it's the metadata backbone for books AND audiobooks
  - Direct GoodReads/OpenLibrary/Audible integrations are SUPPLEMENTARY for enrichment
  - This dual-role pattern is consistent across ALL Arr services
  - Chaptarr uniquely handles BOTH ebook and audiobook formats with same metadata source
architecture_diagram: |-
  ```mermaid
  flowchart TD
      subgraph row1[ ]
          direction LR
          node1["Revenge<br/>Request<br/>System"]
          node2["Chaptarr<br/>Integration"]
          node3["Chaptarr<br/>(Readarr)"]
      end
      node4(["Webhook<br/>Handler"])
      node1 --> node2
      node2 --> node3
      node3 --> node4

      %% Hide row subgraph borders
      style row1 fill:transparent,stroke:transparent
  ```
api_details: |
  **API Version**: v1 (Readarr-compatible API)
  **Base URL**: `http://localhost:8787/api/v1` (configurable)
  **Authentication**: X-Api-Key header
  **Rate Limit**: None (local service)

  **Key Endpoints**:
  - `/author` - List/add/delete authors
  - `/author/{id}` - Get/update author details
  - `/author/lookup` - Search authors (GoodReads, OpenLibrary)
  - `/book` - Get books
  - `/command` - Trigger commands
  - `/calendar` - Get upcoming releases

  **Note**: Chaptarr uses Readarr API for book/audiobook management
database_schema: |
  **Schema**: `public`

  ```sql
  -- Chaptarr instance configuration
  CREATE TABLE chaptarr_instances (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    name VARCHAR(255) NOT NULL,
    base_url TEXT NOT NULL,
    api_key TEXT NOT NULL,

    enabled BOOLEAN DEFAULT true,
    auto_sync BOOLEAN DEFAULT true,
    sync_interval INTEGER DEFAULT 300,

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
  );

  -- Author to Chaptarr mapping
  CREATE TABLE chaptarr_authors (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    author_id UUID NOT NULL REFERENCES authors(id) ON DELETE CASCADE,
    chaptarr_instance_id UUID NOT NULL REFERENCES chaptarr_instances(id) ON DELETE CASCADE,

    chaptarr_author_id INTEGER NOT NULL,
    monitored BOOLEAN DEFAULT true,
    quality_profile_id INTEGER,
    metadata_profile_id INTEGER,

    last_synced_at TIMESTAMPTZ,
    UNIQUE(author_id, chaptarr_instance_id)
  );

  -- Book tracking
  CREATE TABLE chaptarr_books (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    book_id UUID NOT NULL REFERENCES books(id) ON DELETE CASCADE,
    chaptarr_author_id UUID NOT NULL REFERENCES chaptarr_authors(id) ON DELETE CASCADE,

    chaptarr_book_id INTEGER NOT NULL,
    has_file BOOLEAN DEFAULT false,
    file_path TEXT,
    book_type VARCHAR(50),                    -- 'ebook', 'audiobook'

    UNIQUE(book_id)
  );
  ```
module_structure: |
  ```
  internal/integrations/chaptarr/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ client.go                    # Chaptarr API client
  â”œâ”€â”€ service.go                   # Integration service
  â”œâ”€â”€ sync.go                      # Library sync (River job)
  â”œâ”€â”€ webhook.go                   # Webhook handler
  â”œâ”€â”€ types.go                     # Chaptarr API types
  â””â”€â”€ chaptarr_test.go
  ```
key_interfaces: |
  ```go
  // Chaptarr integration service
  type ChaptarrService interface {
    // Author management
    AddAuthor(ctx context.Context, goodreadsID string, qualityProfileID int, rootFolder string) (*ChaptarrAuthor, error)
    DeleteAuthor(ctx context.Context, chaptarrID int, deleteFiles bool) error
    SearchAuthor(ctx context.Context, authorID int) error  // Trigger download

    // Book management
    GetBooks(ctx context.Context, authorID int) ([]ChaptarrBook, error)
    GetCalendar(ctx context.Context, start, end time.Time) ([]CalendarBook, error)

    // Sync
    SyncLibrary(ctx context.Context, instanceID uuid.UUID) error
  }

  // Chaptarr author structure
  type ChaptarrAuthor struct {
    ID              int      `json:"id"`
    AuthorName      string   `json:"authorName"`
    ForeignAuthorID string   `json:"foreignAuthorId"`  // GoodReads ID
    QualityProfile  int      `json:"qualityProfileId"`
    MetadataProfile int      `json:"metadataProfileId"`
    Monitored       bool     `json:"monitored"`
    RootFolderPath  string   `json:"rootFolderPath"`
    Path            string   `json:"path"`
  }

  // Chaptarr book structure
  type ChaptarrBook struct {
    ID              int      `json:"id"`
    Title           string   `json:"title"`
    AuthorID        int      `json:"authorId"`
    ForeignBookID   string   `json:"foreignBookId"`
    ISBN            string   `json:"isbn"`
    ReleaseDate     string   `json:"releaseDate"`
    PageCount       int      `json:"pageCount"`
    Monitored       bool     `json:"monitored"`
    HasFile         bool     `json:"hasFile"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client
  - `github.com/google/uuid` - UUID support
  - `github.com/jackc/pgx/v5` - PostgreSQL driver
  - `github.com/riverqueue/river` - Background sync jobs
  - `go.uber.org/fx` - Dependency injection

  **External Services**:
  - Chaptarr/Readarr v1+ (self-hosted)
env_vars: |
  ```bash
  # Chaptarr instance
  CHAPTARR_URL=http://localhost:8787
  CHAPTARR_API_KEY=your_api_key_here

  # Sync settings
  CHAPTARR_AUTO_SYNC=true
  CHAPTARR_SYNC_INTERVAL=300  # 5 minutes
  ```
config_keys: |
  ```yaml
  integrations:
    chaptarr:
      instances:
        - name: Main Chaptarr
          base_url: http://localhost:8787
          api_key: ${CHAPTARR_API_KEY}
          enabled: true
          auto_sync: true
          sync_interval: 300
  ```
component_interaction: |
  **Add Author to Chaptarr** (from Revenge request):
  1. User requests author in Revenge
  2. Request system calls ChaptarrService.AddAuthor(goodreadsID, profileID, rootFolder)
  3. POST to /api/v1/author with author details
  4. Chaptarr adds author and starts monitoring
  5. Store chaptarr_author_id in chaptarr_authors table
  6. Chaptarr searches for author's books automatically
  7. When downloaded, Chaptarr sends webhook to Revenge

  **Webhook Processing** (on book download):
  1. Chaptarr sends POST to /api/v1/webhooks/chaptarr
  2. Payload includes eventType: "BookDownload", bookId, filePath, bookType
  3. Webhook handler extracts data
  4. Update chaptarr_books: has_file=true, file_path=..., book_type=ebook/audiobook
  5. Trigger library scan to import book file
  6. Book becomes available in Revenge library

  **Library Sync** (background):
  1. River job runs every 5 minutes
  2. GET /api/v1/author from Chaptarr
  3. GET /api/v1/book for each author
  4. Compare with chaptarr_books table
  5. Update monitored status, has_file, file_path
  6. Create/update books in Revenge library
api_request_examples: |
  **Add Author**:
  ```
  POST http://localhost:8787/api/v1/author
  X-Api-Key: your_api_key

  {
    "authorName": "Brandon Sanderson",
    "foreignAuthorId": "38550",
    "qualityProfileId": 1,
    "metadataProfileId": 1,
    "rootFolderPath": "/books",
    "monitored": true,
    "addOptions": {
      "searchForMissingBooks": true
    }
  }
  ```

  **Get Books by Author**:
  ```
  GET http://localhost:8787/api/v1/book?authorId=1
  X-Api-Key: your_api_key
  ```

  **Trigger Author Search**:
  ```
  POST http://localhost:8787/api/v1/command
  X-Api-Key: your_api_key

  {
    "name": "AuthorSearch",
    "authorId": 1
  }
  ```
webhook_handling: |
  **Supported Events**:
  - **BookDownload**: Book downloaded and imported
  - **BookDelete**: Book deleted from Chaptarr
  - **Rename**: Book file renamed
  - **Health**: Health check event

  **Webhook Payload** (BookDownload event):
  ```json
  {
    "eventType": "Download",
    "author": {
      "id": 1,
      "name": "Brandon Sanderson",
      "foreignAuthorId": "38550"
    },
    "book": {
      "id": 10,
      "title": "The Way of Kings",
      "isbn": "9780765326355",
      "releaseDate": "2010-08-31"
    },
    "bookFile": {
      "id": 100,
      "path": "/books/Brandon Sanderson/The Way of Kings/The Way of Kings.epub",
      "quality": "EPUB",
      "size": 5242880
    },
    "isAudiobook": false
  }
  ```

  **Handler Logic**:
  1. Verify webhook signature (if configured)
  2. Parse event type
  3. Determine if ebook or audiobook based on file extension or isAudiobook flag
  4. Update chaptarr_books table with file info
  5. Trigger library rescan to import book
quality_profiles: |
  **Book Quality Profiles**:
  - EPUB Only
  - MOBI/AZW3 (Kindle)
  - PDF Preferred
  - Any eBook Format

  **Audiobook Quality Profiles**:
  - M4B (Audiobook format with chapters)
  - MP3 (audiobook)
  - Any
metadata_profiles: |
  **Metadata Profiles**:
  - Standard: Novels and novellas only
  - Everything: All book types (short stories, collections, comics)
  - Audiobooks Only: Filter for audiobook editions
book_vs_audiobook: |
  **Dual Format Support**:
  - Chaptarr can monitor for both ebook and audiobook editions
  - Quality profiles determine preferred format
  - Store book_type in chaptarr_books (ebook/audiobook)
  - Link to separate tables in Revenge (books vs audiobooks)

  **File Extensions**:
  - eBooks: .epub, .mobi, .azw3, .pdf
  - Audiobooks: .m4b, .mp3 (in folders with multiple tracks)
unit_tests: |
  ```go
  func TestChaptarrService_AddAuthor(t *testing.T) {
    // Test adding author to Chaptarr
  }

  func TestChaptarrWebhook_BookDownload(t *testing.T) {
    // Test book download webhook
  }

  func TestChaptarrService_DualFormat(t *testing.T) {
    // Test handling both ebook and audiobook downloads
  }
  ```
integration_tests: |
  ```go
  func TestChaptarr_FullWorkflow(t *testing.T) {
    // Use testcontainers for Chaptarr/Readarr (if available)
    // Test add, sync, webhook for both ebooks and audiobooks
  }
  ```
