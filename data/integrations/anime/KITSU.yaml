doc_title: Kitsu Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: ‚úÖ Complete
status_design: ‚úÖ
status_design_notes: '-'
status_sources: ‚úÖ
status_sources_notes: '-'
status_instructions: ‚úÖ
status_instructions_notes: '-'
status_code: üî¥
status_code_notes: '-'
status_linting: üî¥
status_linting_notes: '-'
status_unit_testing: üî¥
status_unit_testing_notes: '-'
status_integration_testing: üî¥
status_integration_testing_notes: '-'
technical_summary: '> Modern anime tracking platform with social features'
wiki_tagline: '> Sync anime progress with Kitsu'
wiki_overview: Link your Kitsu account to track anime watching. Kitsu provides metadata, community ratings, and social features.
  Episodes watched in Revenge sync to your Kitsu library. Import your existing Kitsu list to see what you have already watched.
  Compare ratings and discover new anime through Kitsu social features.
sources:
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
integration_name: Kitsu
integration_id: kitsu
external_service: Kitsu
api_base_url: https://kitsu.io/api/edge
auth_method: oauth
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1([Revenge<br/>Web Player])
      node2["Anime Item<br/>[TV Show]<br/>River Queue"]
      node3[[Scrobbling<br/>Service]]
      node4["River Queue<br/>[Background]"]
      node5["Kitsu<br/>Scrobbler"]
      node6[(Database<br/>[history])]
      node7[[Kitsu API<br/>[REST]]]
      node8["Kitsu<br/>User Library"]
      node1 --> node2
      node3 --> node4
      node6 --> node7
      node2 --> node3
      node4 --> node5
      node5 --> node6
      node7 --> node8
  ```
protocol_details: |
  **JSON:API Specification**:

  **Base URL**: `https://kitsu.io/api/edge`
  **Format**: JSON:API v1.0
  **Authentication**: OAuth 2.0 (Resource Owner Password Credentials)

  **JSON:API Structure**:
  - Resources have `type`, `id`, `attributes`, `relationships`
  - Pagination via `links` (first, next, last)
  - Include related resources: `?include=categories,mediaRelationships`
  - Filtering: `?filter[text]=demon slayer`
  - Sorting: `?sort=-user_count` (descending)
  - Sparse fieldsets: `?fields[anime]=slug,canonicalTitle`

  **OAuth 2.0 Flow** (Password Grant):
  1. POST to `/oauth/token` with username + password
  2. Receive access token (valid 30 days) + refresh token
  3. Use `Authorization: Bearer {token}` in requests
  4. Refresh before expiry with refresh token

  **Rate Limiting**:
  - No documented hard limit
  - Respect retry-after header if present
  - Recommend: 2-3 requests/second max

  **Key Endpoints**:
  - `GET /anime` - Search/browse anime
  - `GET /anime/{id}` - Get anime details
  - `GET /library-entries` - Get user's library
  - `POST /library-entries` - Add to library
  - `PATCH /library-entries/{id}` - Update progress
  - `DELETE /library-entries/{id}` - Remove from library
  - `GET /users` - Search users
  - `GET /users/{id}` - Get user profile
module_structure: |
  ```
  internal/
    scrobbling/
      kitsu/
        client.go         # JSON:API client
        auth.go           # OAuth 2.0 password grant
        scrobbler.go      # Scrobbling implementation
        metadata.go       # Metadata fetching
        library.go        # Library operations
        types.go          # Response types
        module.go         # fx module
        client_test.go
        scrobbler_test.go

  config/
    scrobbling/
      kitsu.yaml          # Kitsu configuration example
  ```
key_interfaces: |
  ```go
  // KitsuClient manages Kitsu JSON:API
  type KitsuClient interface {
      // Search for anime
      SearchAnime(ctx context.Context, query string) ([]AnimeResult, error)

      // Get anime by ID
      GetAnime(ctx context.Context, kitsuID string) (*AnimeDetails, error)

      // Get user's library
      GetLibrary(ctx context.Context, userID string, status LibraryStatus) (*LibraryEntryCollection, error)

      // Update library entry progress
      UpdateProgress(ctx context.Context, entryID string, progress int, status LibraryStatus) error

      // Add anime to library
      AddToLibrary(ctx context.Context, animeID string, status LibraryStatus) (*LibraryEntry, error)

      // Remove from library
      RemoveFromLibrary(ctx context.Context, entryID string) error

      // Get current user
      GetCurrentUser(ctx context.Context) (*User, error)
  }

  // KitsuScrobbler implements scrobbling to Kitsu
  type KitsuScrobbler struct {
      client *KitsuClient
      config *KitsuConfig
  }

  type KitsuConfig struct {
      Email        string        // User email for OAuth
      Password     string        // User password for OAuth
      ClientID     string        // OAuth client ID
      ClientSecret string        // OAuth client secret
      Enabled      bool
      SyncInterval time.Duration
  }

  type JSONAPIResource struct {
      Type          string                    `json:"type"`
      ID            string                    `json:"id"`
      Attributes    map[string]interface{}    `json:"attributes,omitempty"`
      Relationships map[string]JSONAPIRelationship `json:"relationships,omitempty"`
      Links         map[string]string         `json:"links,omitempty"`
  }

  type JSONAPIRelationship struct {
      Data  interface{}       `json:"data,omitempty"`   // Single or array of {type, id}
      Links map[string]string `json:"links,omitempty"`
  }

  type JSONAPIResponse struct {
      Data     interface{}              `json:"data"`     // Single resource or array
      Included []JSONAPIResource        `json:"included,omitempty"`
      Links    map[string]string        `json:"links,omitempty"`
      Meta     map[string]interface{}   `json:"meta,omitempty"`
  }

  type AnimeResult struct {
      ID            string
      Slug          string
      Titles        Titles
      Synopsis      string
      PosterImage   PosterImage
      CoverImage    CoverImage
      EpisodeCount  int
      EpisodeLength int  // Minutes
      Status        AnimeStatus
      AgeRating     string
      AverageRating string  // "75.32"
      UserCount     int
      StartDate     string
      EndDate       string
  }

  type AnimeDetails struct {
      ID            string
      Slug          string
      Titles        Titles
      Synopsis      string
      Description   string
      PosterImage   PosterImage
      CoverImage    CoverImage
      EpisodeCount  int
      EpisodeLength int
      Status        AnimeStatus
      Subtype       AnimeSubtype  // TV, movie, ONA, OVA, special, music
      AgeRating     string        // G, PG, R, R18
      AverageRating string
      UserCount     int
      FavoritesCount int
      StartDate     string
      EndDate       string
      NSFW          bool
      Categories    []Category    // From included resources
      MediaRelationships []MediaRelationship
  }

  type Titles struct {
      En      string `json:"en"`
      EnJp    string `json:"en_jp"`  // Romaji
      JaJp    string `json:"ja_jp"`  // Native
  }

  type PosterImage struct {
      Tiny     string
      Small    string
      Medium   string
      Large    string
      Original string
  }

  type CoverImage struct {
      Tiny     string
      Small    string
      Large    string
      Original string
  }

  type AnimeStatus string

  const (
      StatusCurrent   AnimeStatus = "current"    // Airing
      StatusFinished  AnimeStatus = "finished"   // Completed
      StatusTBA       AnimeStatus = "tba"        // Announced
      StatusUnreleased AnimeStatus = "unreleased"
      StatusUpcoming  AnimeStatus = "upcoming"
  )

  type AnimeSubtype string

  const (
      SubtypeTV      AnimeSubtype = "TV"
      SubtypeMovie   AnimeSubtype = "movie"
      SubtypeONA     AnimeSubtype = "ONA"
      SubtypeOVA     AnimeSubtype = "OVA"
      SubtypeSpecial AnimeSubtype = "special"
      SubtypeMusic   AnimeSubtype = "music"
  )

  type LibraryStatus string

  const (
      LibStatusCurrent   LibraryStatus = "current"    // Watching
      LibStatusPlanned   LibraryStatus = "planned"    // Plan to watch
      LibStatusCompleted LibraryStatus = "completed"  // Finished
      LibStatusOnHold    LibraryStatus = "on_hold"    // Paused
      LibStatusDropped   LibraryStatus = "dropped"    // Abandoned
  )

  type LibraryEntry struct {
      ID           string
      AnimeID      string
      Status       LibraryStatus
      Progress     int           // Episodes watched
      Rating       float64       // 0-20 (Kitsu uses 20-point scale)
      Notes        string
      Private      bool
      ProgressedAt time.Time
      StartedAt    string        // YYYY-MM-DD
      FinishedAt   string        // YYYY-MM-DD
      UpdatedAt    time.Time
      Anime        *AnimeDetails // From included resources
  }

  type LibraryEntryCollection struct {
      Entries []LibraryEntry
      Links   map[string]string  // Pagination links
      Meta    PaginationMeta
  }

  type PaginationMeta struct {
      Count int `json:"count"`
  }

  type User struct {
      ID       string
      Name     string
      Slug     string
      Avatar   Image
      CoverImage Image
      About    string
      Location string
      Waifus   int
      LifeSpentOnAnime int  // Minutes
  }

  type Image struct {
      Tiny     string
      Small    string
      Medium   string
      Large    string
      Original string
  }

  type Category struct {
      ID          string
      Title       string
      Description string
      Slug        string
  }

  type OAuthTokenResponse struct {
      AccessToken  string `json:"access_token"`
      TokenType    string `json:"token_type"`
      ExpiresIn    int    `json:"expires_in"`
      RefreshToken string `json:"refresh_token"`
      Scope        string `json:"scope"`
      CreatedAt    int64  `json:"created_at"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/riverqueue/river` - Background job queue
  - `golang.org/x/oauth2` - OAuth 2.0 client
  - `encoding/json` - JSON encoding
  - `net/http` - HTTP client

  **External Services**:
  - Kitsu API (https://kitsu.io)
env_vars: |
  ```bash
  # Kitsu OAuth configuration (per-user)
  # Users configure via web UI, not environment variables

  # Global settings
  REVENGE_KITSU_ENABLED=true
  REVENGE_KITSU_CLIENT_ID=dd031b32d2f56c990b1425efe6c42ad847e7fe3ab46bf1299f05ecd856bdb7dd
  REVENGE_KITSU_CLIENT_SECRET=54d7307928f63414defd96399fc31ba847961ceaecef3a5fd93144e960c0e151

  # Sync settings
  REVENGE_KITSU_SYNC_INTERVAL=24h
  ```
config_keys: |
  ```yaml
  scrobbling:
    kitsu:
      enabled: true
      client_id: dd031b32d2f56c990b1425efe6c42ad847e7fe3ab46bf1299f05ecd856bdb7dd
      client_secret: 54d7307928f63414defd96399fc31ba847961ceaecef3a5fd93144e960c0e151
      sync_interval: 24h
      auto_sync: true
      scrobble_threshold: 0.9
      metadata_enabled: true
      metadata_priority: 15     # Lower priority than AniList
  ```
oauth_flow: |
  **OAuth 2.0 Password Grant Flow**:

  Kitsu uses Resource Owner Password Credentials grant (legacy, but official):

  1. **User provides credentials in Revenge UI**:
     - Email: user@example.com
     - Password: their-kitsu-password

  2. **Exchange for access token**:
     ```http
     POST https://kitsu.io/api/oauth/token
     Content-Type: application/x-www-form-urlencoded

     grant_type=password&
     username=user@example.com&
     password=their-kitsu-password&
     client_id=dd031b32d2f56c990b1425efe6c42ad847e7fe3ab46bf1299f05ecd856bdb7dd&
     client_secret=54d7307928f63414defd96399fc31ba847961ceaecef3a5fd93144e960c0e151
     ```

  3. **Receive tokens**:
     ```json
     {
       "access_token": "abc123...",
       "token_type": "bearer",
       "expires_in": 2592000,
       "refresh_token": "xyz789...",
       "scope": "public",
       "created_at": 1675200000
     }
     ```

  4. **Store tokens** (access token valid 30 days)

  5. **Refresh before expiry**:
     ```http
     POST https://kitsu.io/api/oauth/token
     Content-Type: application/x-www-form-urlencoded

     grant_type=refresh_token&
     refresh_token=xyz789...&
     client_id=...&
     client_secret=...
     ```

  6. **Use in requests**:
     ```http
     GET https://kitsu.io/api/edge/anime
     Authorization: Bearer abc123...
     Accept: application/vnd.api+json
     Content-Type: application/vnd.api+json
     ```
json_api_examples: |
  **Search Anime**:
  ```http
  GET /api/edge/anime?filter[text]=demon slayer&page[limit]=10
  Authorization: Bearer {token}
  Accept: application/vnd.api+json

  Response:
  {
    "data": [
      {
        "id": "41370",
        "type": "anime",
        "links": {
          "self": "https://kitsu.io/api/edge/anime/41370"
        },
        "attributes": {
          "slug": "kimetsu-no-yaiba",
          "synopsis": "...",
          "canonicalTitle": "Kimetsu no Yaiba",
          "titles": {
            "en": "Demon Slayer: Kimetsu no Yaiba",
            "en_jp": "Kimetsu no Yaiba",
            "ja_jp": "È¨ºÊªÖ„ÅÆÂàÉ"
          },
          "averageRating": "85.23",
          "userCount": 150000,
          "posterImage": {
            "tiny": "https://...",
            "small": "https://...",
            "medium": "https://...",
            "large": "https://...",
            "original": "https://..."
          },
          "episodeCount": 26,
          "episodeLength": 24,
          "status": "finished"
        }
      }
    ],
    "meta": {
      "count": 1
    },
    "links": {
      "first": "...",
      "last": "..."
    }
  }
  ```

  **Get User's Library**:
  ```http
  GET /api/edge/library-entries?filter[user_id]={user_id}&filter[kind]=anime&filter[status]=current&include=anime
  Authorization: Bearer {token}
  Accept: application/vnd.api+json

  Response:
  {
    "data": [
      {
        "id": "123456",
        "type": "libraryEntries",
        "attributes": {
          "status": "current",
          "progress": 15,
          "rating": 18,
          "notes": "Great anime!",
          "private": false,
          "progressedAt": "2026-02-01T10:00:00.000Z",
          "startedAt": "2026-01-15",
          "updatedAt": "2026-02-01T10:00:00.000Z"
        },
        "relationships": {
          "anime": {
            "links": {
              "self": "..."
            },
            "data": {
              "type": "anime",
              "id": "41370"
            }
          }
        }
      }
    ],
    "included": [
      {
        "id": "41370",
        "type": "anime",
        "attributes": {
          "canonicalTitle": "Demon Slayer",
          "episodeCount": 26
        }
      }
    ]
  }
  ```

  **Update Progress** (Scrobble):
  ```http
  PATCH /api/edge/library-entries/123456
  Authorization: Bearer {token}
  Accept: application/vnd.api+json
  Content-Type: application/vnd.api+json

  {
    "data": {
      "id": "123456",
      "type": "libraryEntries",
      "attributes": {
        "progress": 16,
        "status": "current"
      }
    }
  }

  Response:
  {
    "data": {
      "id": "123456",
      "type": "libraryEntries",
      "attributes": {
        "progress": 16,
        "status": "current",
        "updatedAt": "2026-02-01T11:00:00.000Z"
      }
    }
  }
  ```
component_interaction: |
  **Scrobbling Workflow**:

  1. **User watches anime**:
     - Episode plays to 90% completion
     - Scrobbling service triggered

  2. **Queue scrobble job**:
     - River job: ScrobbleToKitsu
     - Payload: anime ID, episode number, user ID

  3. **Process job**:
     - Fetch user's OAuth token
     - Find library entry ID (GET /library-entries with filter)
     - Update progress (PATCH /library-entries/{id})
     - Handle auto-completion (set status=completed if final episode)

  4. **Sync library** (periodic):
     - Cron job runs daily
     - Fetch all user's library entries (paginated)
     - Import missing anime to Revenge
     - Update watch status
api_endpoints: |
  **Revenge API Endpoints**:

  ```
  # OAuth (password grant - user provides Kitsu credentials)
  POST /api/v1/scrobbling/kitsu/connect
  POST /api/v1/scrobbling/kitsu/disconnect

  # Status
  GET  /api/v1/scrobbling/kitsu/status

  # Operations
  POST /api/v1/scrobbling/kitsu/import
  POST /api/v1/scrobbling/kitsu/sync
  ```

  **Example - Connect**:
  ```json
  POST /api/v1/scrobbling/kitsu/connect
  {
    "email": "user@example.com",
    "password": "kitsu-password"
  }

  Response:
  {
    "connected": true,
    "user": {
      "id": "123456",
      "name": "AnimeWatcher",
      "slug": "animewatcher"
    }
  }
  ```
error_handling: |
  **Common Errors**:

  - **401 Unauthorized**: Token expired or invalid
    - Solution: Refresh token or re-authenticate

  - **404 Not Found**: Anime or library entry doesn't exist
    - Solution: Create new library entry or update mapping

  - **422 Unprocessable Entity**: Invalid request data
    - Solution: Validate JSON:API structure

  - **429 Too Many Requests**: Rate limit exceeded
    - Solution: Implement backoff, respect retry-after
unit_tests: |
  ```go
  func TestKitsuClient_SearchAnime(t *testing.T) {
      mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          w.Header().Set("Content-Type", "application/vnd.api+json")
          json.NewEncoder(w).Encode(map[string]interface{}{
              "data": []map[string]interface{}{
                  {
                      "id":   "41370",
                      "type": "anime",
                      "attributes": map[string]interface{}{
                          "slug":           "kimetsu-no-yaiba",
                          "canonicalTitle": "Demon Slayer",
                      },
                  },
              },
          })
      }))
      defer mockServer.Close()

      client := NewKitsuClient(mockServer.URL, "test-token")
      results, err := client.SearchAnime(context.Background(), "Demon Slayer")

      require.NoError(t, err)
      assert.Len(t, results, 1)
      assert.Equal(t, "41370", results[0].ID)
  }

  func TestKitsuScrobbler_UpdateProgress(t *testing.T) {
      // Test scrobbling workflow
  }
  ```
integration_tests: |
  ```go
  func TestKitsu_FullWorkflow(t *testing.T) {
      if testing.Short() {
          t.Skip("skipping integration test")
      }

      token := os.Getenv("KITSU_TOKEN")
      if token == "" {
          t.Skip("no Kitsu token provided")
      }

      client := NewKitsuClient("https://kitsu.io/api/edge", token)

      // Test search
      results, err := client.SearchAnime(context.Background(), "Demon Slayer")
      require.NoError(t, err)
      require.NotEmpty(t, results)

      // Test get details
      details, err := client.GetAnime(context.Background(), results[0].ID)
      require.NoError(t, err)
      assert.NotEmpty(t, details.Synopsis)
  }
  ```
best_practices: |
  **JSON:API**:
  - Always include proper Content-Type and Accept headers
  - Use sparse fieldsets to reduce payload size
  - Include related resources when needed (?include=anime)
  - Handle pagination correctly (follow links)

  **OAuth**:
  - Store credentials securely (never log passwords)
  - Encrypt tokens at rest
  - Implement token refresh before expiry (30 days)
  - Handle re-authentication gracefully

  **Scrobbling**:
  - Queue scrobbles asynchronously
  - Find library entry ID first (may not exist)
  - Create library entry if missing
  - Auto-complete when final episode watched

  **Metadata**:
  - Cache anime details locally
  - Use slug for URL-friendly identifiers
  - Download poster/cover images asynchronously
  - Handle missing fields gracefully (Kitsu data can be incomplete)

  **Performance**:
  - Implement request rate limiting (2-3 req/sec)
  - Use HTTP connection pooling
  - Cache frequently accessed data
  - Batch operations when possible

  **Monitoring**:
  - Log OAuth token refresh events
  - Track scrobble success/failure rates
  - Monitor API response times
  - Alert on authentication failures
