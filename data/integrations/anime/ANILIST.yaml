doc_title: AniList Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Primary metadata and tracking provider for anime and manga'
wiki_tagline: '> Sync anime watch status with AniList'
wiki_overview: Connect your AniList account to sync anime watching progress. Metadata for anime series pulls from AniList
  including cover art, descriptions, and airing schedules. Mark episodes as watched in Revenge and your AniList profile updates
  automatically. Import your existing AniList watchlist to track completion.
sources:
- name: AniList GraphQL API
  url: https://anilist.gitbook.io/anilist-apiv2-docs
  note: Auto-resolved from anilist
- name: AniList GraphQL Schema
  url: https://graphql.anilist.co
  note: Auto-resolved from anilist-graphql
- name: go-blurhash
  url: https://pkg.go.dev/github.com/bbrks/go-blurhash
  note: Auto-resolved from go-blurhash
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
integration_name: AniList
integration_id: anilist
external_service: AniList
api_base_url: https://graphql.anilist.co
auth_method: oauth
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1(["Revenge<br/>Web Player"])
      node2["Anime Item<br/>(TV Show)<br/>River Queue"]
      node3[["Scrobbling<br/>Service"]]
      node4["River Queue<br/>(Background)"]
      node5["AniList<br/>Scrobbler"]
      node6[("Database<br/>(history)")]
      node7[["AniList API<br/>(GraphQL)"]]
      node8["AniList<br/>User Profile"]
      node1 --> node2
      node3 --> node4
      node6 --> node7
      node2 --> node3
      node4 --> node5
      node5 --> node6
      node7 --> node8
  ```
protocol_details: |
  **GraphQL API**:

  **Endpoint**: `https://graphql.anilist.co`
  **Method**: POST (all requests)
  **Authentication**: OAuth 2.0 (Authorization Code flow)

  **GraphQL Structure**:
  - Single endpoint for all queries and mutations
  - Strongly typed schema
  - Flexible field selection
  - Batch requests supported

  **OAuth 2.0 Flow**:
  1. Redirect to: `https://anilist.co/api/v2/oauth/authorize`
  2. User approves access
  3. Exchange code for token at: `https://anilist.co/api/v2/oauth/token`
  4. Use access token in `Authorization: Bearer {token}` header

  **Rate Limiting**:
  - 90 requests per minute
  - No daily limit
  - Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset

  **Key GraphQL Queries**:
  - `Media` - Get anime/manga details
  - `MediaList` - Get user's list entries
  - `User` - Get user profile
  - `MediaTrend` - Get trending anime

  **Key GraphQL Mutations**:
  - `SaveMediaListEntry` - Update watch status
  - `DeleteMediaListEntry` - Remove from list
  - `UpdateUser` - Update user preferences
module_structure: |
  ```
  internal/
    scrobbling/
      anilist/
        client.go         # GraphQL client
        auth.go           # OAuth 2.0 flow
        scrobbler.go      # Scrobbling implementation
        metadata.go       # Metadata fetching
        queries.go        # GraphQL query builders
        mutations.go      # GraphQL mutation builders
        types.go          # Response types
        module.go         # fx module
        client_test.go
        scrobbler_test.go

  config/
    scrobbling/
      anilist.yaml        # AniList configuration example
  ```
key_interfaces: |
  ```go
  // AniListClient manages AniList GraphQL API
  type AniListClient interface {
      // Search for anime by title
      SearchAnime(ctx context.Context, query string) ([]AnimeResult, error)

      // Get anime details by AniList ID
      GetAnime(ctx context.Context, anilistID int) (*AnimeDetails, error)

      // Get user's anime list
      GetUserList(ctx context.Context, userID int, status MediaListStatus) (*MediaListCollection, error)

      // Update watch progress
      UpdateProgress(ctx context.Context, mediaID int, progress int, status MediaListStatus) error

      // Add anime to list
      AddToList(ctx context.Context, mediaID int, status MediaListStatus) (*MediaListEntry, error)

      // Remove from list
      RemoveFromList(ctx context.Context, listEntryID int) error

      // Get current user info
      GetCurrentUser(ctx context.Context) (*User, error)
  }

  // AniListScrobbler implements scrobbling to AniList
  type AniListScrobbler struct {
      client *AniListClient
      config *AniListConfig
  }

  type AniListConfig struct {
      ClientID     string
      ClientSecret string
      RedirectURL  string
      Enabled      bool
      SyncInterval time.Duration // Import user list periodically
  }

  type AnimeResult struct {
      ID           int
      IDMal        int    // MyAnimeList ID
      Title        MediaTitle
      CoverImage   CoverImage
      Format       MediaFormat  // TV, MOVIE, OVA, ONA, etc.
      Status       MediaStatus  // FINISHED, RELEASING, etc.
      Episodes     int
      Season       MediaSeason
      SeasonYear   int
      AverageScore int
      Genres       []string
  }

  type AnimeDetails struct {
      ID              int
      IDMal           int
      Title           MediaTitle
      Description     string
      CoverImage      CoverImage
      BannerImage     string
      Format          MediaFormat
      Status          MediaStatus
      Episodes        int
      Duration        int  // Minutes per episode
      Season          MediaSeason
      SeasonYear      int
      StartDate       FuzzyDate
      EndDate         FuzzyDate
      AverageScore    int
      Genres          []string
      Tags            []MediaTag
      Studios         []Studio
      Relations       MediaConnection
      Recommendations MediaConnection
      ExternalLinks   []MediaExternalLink
  }

  type MediaTitle struct {
      Romaji  string
      English string
      Native  string
  }

  type CoverImage struct {
      ExtraLarge string
      Large      string
      Medium     string
      Color      string  // Hex color
  }

  type MediaFormat string

  const (
      FormatTV      MediaFormat = "TV"
      FormatTVShort MediaFormat = "TV_SHORT"
      FormatMovie   MediaFormat = "MOVIE"
      FormatSpecial MediaFormat = "SPECIAL"
      FormatOVA     MediaFormat = "OVA"
      FormatONA     MediaFormat = "ONA"
      FormatMusic   MediaFormat = "MUSIC"
      FormatManga   MediaFormat = "MANGA"
      FormatNovel   MediaFormat = "NOVEL"
      FormatOneShot MediaFormat = "ONE_SHOT"
  )

  type MediaStatus string

  const (
      StatusFinished     MediaStatus = "FINISHED"
      StatusReleasing    MediaStatus = "RELEASING"
      StatusNotYetReleased MediaStatus = "NOT_YET_RELEASED"
      StatusCancelled    MediaStatus = "CANCELLED"
      StatusHiatus       MediaStatus = "HIATUS"
  )

  type MediaSeason string

  const (
      SeasonWinter MediaSeason = "WINTER"
      SeasonSpring MediaSeason = "SPRING"
      SeasonSummer MediaSeason = "SUMMER"
      SeasonFall   MediaSeason = "FALL"
  )

  type MediaListStatus string

  const (
      ListStatusCurrent   MediaListStatus = "CURRENT"      // Watching
      ListStatusPlanning  MediaListStatus = "PLANNING"     // Plan to watch
      ListStatusCompleted MediaListStatus = "COMPLETED"    // Finished
      ListStatusDropped   MediaListStatus = "DROPPED"      // Abandoned
      ListStatusPaused    MediaListStatus = "PAUSED"       // On hold
      ListStatusRepeating MediaListStatus = "REPEATING"    // Rewatching
  )

  type MediaListEntry struct {
      ID          int
      MediaID     int
      Status      MediaListStatus
      Score       float64  // User rating (0-10)
      Progress    int      // Episodes watched
      Repeat      int      // Rewatch count
      Private     bool
      Notes       string
      StartedAt   FuzzyDate
      CompletedAt FuzzyDate
      UpdatedAt   time.Time
      Media       *AnimeDetails
  }

  type MediaListCollection struct {
      Lists []MediaListGroup
      User  *User
  }

  type MediaListGroup struct {
      Name    string
      Entries []MediaListEntry
      Status  MediaListStatus
  }

  type User struct {
      ID            int
      Name          string
      Avatar        UserAvatar
      BannerImage   string
      About         string
      Statistics    UserStatistics
      SiteURL       string
  }

  type UserAvatar struct {
      Large  string
      Medium string
  }

  type FuzzyDate struct {
      Year  int
      Month int
      Day   int
  }

  type GraphQLRequest struct {
      Query     string                 `json:"query"`
      Variables map[string]interface{} `json:"variables,omitempty"`
  }

  type GraphQLResponse struct {
      Data   json.RawMessage `json:"data"`
      Errors []GraphQLError  `json:"errors,omitempty"`
  }

  type GraphQLError struct {
      Message   string                 `json:"message"`
      Status    int                    `json:"status"`
      Locations []GraphQLErrorLocation `json:"locations,omitempty"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/riverqueue/river` - Background job queue for async scrobbling
  - `golang.org/x/oauth2` - OAuth 2.0 client
  - `encoding/json` - JSON encoding/decoding
  - `net/http` - HTTP client

  **External Services**:
  - AniList API (https://anilist.co)
env_vars: |
  ```bash
  # AniList OAuth configuration
  REVENGE_ANILIST_ENABLED=true
  REVENGE_ANILIST_CLIENT_ID=your-client-id
  REVENGE_ANILIST_CLIENT_SECRET=your-client-secret
  REVENGE_ANILIST_REDIRECT_URL=https://revenge.local/api/v1/scrobbling/anilist/callback

  # Sync settings
  REVENGE_ANILIST_SYNC_INTERVAL=24h
  REVENGE_ANILIST_AUTO_SYNC=true
  ```
config_keys: |
  ```yaml
  scrobbling:
    anilist:
      enabled: true
      client_id: ${REVENGE_ANILIST_CLIENT_ID}
      client_secret: ${REVENGE_ANILIST_CLIENT_SECRET}
      redirect_url: https://revenge.local/api/v1/scrobbling/anilist/callback
      sync_interval: 24h          # Import user list periodically
      auto_sync: true             # Auto-import on login
      scrobble_threshold: 0.9     # Scrobble at 90% progress
      metadata_enabled: true      # Use for anime metadata
      metadata_priority: 10       # Priority in metadata chain (lower = higher priority)
  ```
graphql_queries: |
  **Search Anime**:
  ```graphql
  query SearchAnime($query: String!) {
    Page(page: 1, perPage: 20) {
      media(search: $query, type: ANIME) {
        id
        idMal
        title {
          romaji
          english
          native
        }
        coverImage {
          large
          medium
          color
        }
        format
        status
        episodes
        season
        seasonYear
        averageScore
        genres
      }
    }
  }
  ```

  **Get Anime Details**:
  ```graphql
  query GetAnime($id: Int!) {
    Media(id: $id, type: ANIME) {
      id
      idMal
      title {
        romaji
        english
        native
      }
      description
      coverImage {
        extraLarge
        large
        color
      }
      bannerImage
      format
      status
      episodes
      duration
      season
      seasonYear
      startDate {
        year
        month
        day
      }
      endDate {
        year
        month
        day
      }
      averageScore
      genres
      tags {
        name
        rank
      }
      studios {
        nodes {
          name
        }
      }
      relations {
        edges {
          relationType
          node {
            id
            title {
              romaji
            }
          }
        }
      }
      externalLinks {
        site
        url
      }
    }
  }
  ```

  **Get User's Anime List**:
  ```graphql
  query GetUserList($userId: Int!, $status: MediaListStatus) {
    MediaListCollection(userId: $userId, type: ANIME, status: $status) {
      lists {
        name
        status
        entries {
          id
          mediaId
          status
          score
          progress
          repeat
          private
          notes
          startedAt {
            year
            month
            day
          }
          completedAt {
            year
            month
            day
          }
          updatedAt
          media {
            id
            title {
              romaji
              english
            }
            episodes
          }
        }
      }
    }
  }
  ```

  **Update Progress** (Mutation):
  ```graphql
  mutation SaveMediaListEntry($mediaId: Int!, $progress: Int!, $status: MediaListStatus!) {
    SaveMediaListEntry(mediaId: $mediaId, progress: $progress, status: $status) {
      id
      mediaId
      status
      progress
      updatedAt
    }
  }
  ```

  **Get Current User**:
  ```graphql
  query GetCurrentUser {
    Viewer {
      id
      name
      avatar {
        large
      }
      siteUrl
    }
  }
  ```
oauth_flow: |
  **OAuth 2.0 Authorization Code Flow**:

  1. **Redirect user to AniList**:
     ```
     https://anilist.co/api/v2/oauth/authorize?
       client_id={client_id}&
       redirect_uri={redirect_uri}&
       response_type=code
     ```

  2. **User approves access**

  3. **AniList redirects back with code**:
     ```
     https://revenge.local/api/v1/scrobbling/anilist/callback?code=xyz123
     ```

  4. **Exchange code for access token**:
     ```http
     POST https://anilist.co/api/v2/oauth/token
     Content-Type: application/json

     {
       "grant_type": "authorization_code",
       "client_id": "your-client-id",
       "client_secret": "your-client-secret",
       "redirect_uri": "https://revenge.local/api/v1/scrobbling/anilist/callback",
       "code": "xyz123"
     }
     ```

  5. **Receive tokens**:
     ```json
     {
       "token_type": "Bearer",
       "expires_in": 31536000,
       "access_token": "abc123..."
     }
     ```

  6. **Store access token** (valid for 1 year)

  7. **Use in requests**:
     ```http
     POST https://graphql.anilist.co
     Authorization: Bearer abc123...
     Content-Type: application/json

     {
       "query": "...",
       "variables": {...}
     }
     ```
component_interaction: |
  **Scrobbling Workflow**:

  1. **User watches anime episode**:
     - User plays episode in Revenge player
     - Player tracks playback progress

  2. **Trigger scrobble** (at 90% progress):
     - Player calls ScrobblingService.Scrobble()
     - Service queues River job: ScrobbleToAniList

  3. **Background job processes scrobble**:
     - Fetch user's AniList OAuth token from database
     - Build GraphQL mutation (SaveMediaListEntry)
     - Match Revenge anime to AniList ID (via MAL ID or fuzzy title match)
     - Execute GraphQL request
     - Update progress on AniList

  4. **Handle response**:
     - Success: Update local scrobble history
     - Failure: Retry with exponential backoff (River built-in)

  **Metadata Workflow**:

  1. **Search for anime**:
     - User adds anime to Revenge
     - Metadata service searches AniList via GraphQL
     - Returns list of matches with cover images

  2. **Fetch detailed metadata**:
     - User selects match
     - Fetch full details (description, genres, tags, studios, relations)
     - Download and store cover images
     - Extract banner color for UI theming

  3. **Periodic sync** (import user's list):
     - River cron job runs daily
     - Fetch user's complete AniList library
     - Import missing anime to Revenge
     - Update watch status for existing anime
api_endpoints: |
  **Revenge API Endpoints**:

  ```
  # OAuth flow
  GET  /api/v1/scrobbling/anilist/authorize
  GET  /api/v1/scrobbling/anilist/callback

  # Configuration
  GET  /api/v1/scrobbling/anilist/status
  POST /api/v1/scrobbling/anilist/disconnect

  # Manual operations
  POST /api/v1/scrobbling/anilist/import
  POST /api/v1/scrobbling/anilist/sync
  ```

  **Example - Get Status**:
  ```json
  GET /api/v1/scrobbling/anilist/status

  Response:
  {
    "enabled": true,
    "connected": true,
    "user": {
      "id": 123456,
      "name": "AnimeWatcher",
      "avatar": "https://...",
      "site_url": "https://anilist.co/user/AnimeWatcher"
    },
    "last_sync": "2026-02-01T10:00:00Z",
    "total_entries": 150
  }
  ```

  **Example - Import List**:
  ```json
  POST /api/v1/scrobbling/anilist/import

  Response:
  {
    "imported": 45,
    "updated": 30,
    "skipped": 75,
    "errors": 0
  }
  ```
metadata_matching: |
  **Matching Revenge Anime to AniList**:

  1. **MyAnimeList ID** (preferred):
     - AniList provides `idMal` field
     - Direct 1:1 mapping if available

  2. **Fuzzy Title Match**:
     - Compare romaji, english, and native titles
     - Use Levenshtein distance
     - Threshold: 85% similarity

  3. **Manual Override**:
     - Allow user to manually link if auto-match fails
     - Store mapping in database
error_handling: |
  **Common Errors**:

  - **401 Unauthorized**: Access token expired or invalid
    - Solution: Re-authenticate user via OAuth flow

  - **404 Not Found**: Media ID doesn't exist
    - Solution: Update local AniList ID mapping

  - **429 Too Many Requests**: Rate limit exceeded
    - Solution: Implement exponential backoff, respect retry-after header

  - **500 Internal Server Error**: AniList API issue
    - Solution: Retry with exponential backoff, alert user

  **GraphQL Errors**:
  ```json
  {
    "errors": [
      {
        "message": "Invalid token",
        "status": 401
      }
    ]
  }
  ```
unit_tests: |
  ```go
  func TestAniListClient_SearchAnime(t *testing.T) {
      mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          // Mock AniList GraphQL response
          w.Header().Set("Content-Type", "application/json")
          json.NewEncoder(w).Encode(map[string]interface{}{
              "data": map[string]interface{}{
                  "Page": map[string]interface{}{
                      "media": []map[string]interface{}{
                          {
                              "id":    12345,
                              "idMal": 54321,
                              "title": map[string]string{
                                  "romaji":  "Demon Slayer",
                                  "english": "Demon Slayer: Kimetsu no Yaiba",
                              },
                          },
                      },
                  },
              },
          })
      }))
      defer mockServer.Close()

      client := NewAniListClient(mockServer.URL, "test-token")
      results, err := client.SearchAnime(context.Background(), "Demon Slayer")

      require.NoError(t, err)
      assert.Len(t, results, 1)
      assert.Equal(t, 12345, results[0].ID)
      assert.Equal(t, "Demon Slayer", results[0].Title.Romaji)
  }

  func TestAniListScrobbler_UpdateProgress(t *testing.T) {
      // Test scrobbling workflow
  }

  func TestAniListClient_GraphQLError(t *testing.T) {
      // Test error handling
  }
  ```
integration_tests: |
  ```go
  func TestAniList_FullWorkflow(t *testing.T) {
      // Requires AniList account and valid token
      if testing.Short() {
          t.Skip("skipping integration test")
      }

      token := os.Getenv("ANILIST_TOKEN")
      if token == "" {
          t.Skip("no AniList token provided")
      }

      client := NewAniListClient("https://graphql.anilist.co", token)

      // Test search
      results, err := client.SearchAnime(context.Background(), "Demon Slayer")
      require.NoError(t, err)
      require.NotEmpty(t, results)

      // Test get details
      details, err := client.GetAnime(context.Background(), results[0].ID)
      require.NoError(t, err)
      assert.NotEmpty(t, details.Description)

      // Test get current user
      user, err := client.GetCurrentUser(context.Background())
      require.NoError(t, err)
      assert.NotEmpty(t, user.Name)
  }
  ```
best_practices: |
  **API Usage**:
  - Respect rate limits (90 req/min)
  - Use GraphQL field selection to minimize response size
  - Batch related requests when possible
  - Cache metadata locally (AniList data rarely changes)

  **OAuth**:
  - Access tokens valid for 1 year, no refresh token
  - Store tokens securely (encrypted)
  - Handle re-authentication gracefully when token expires

  **Scrobbling**:
  - Queue scrobbles asynchronously (don't block playback)
  - Use River for retries and error handling
  - Scrobble at 90% progress (standard threshold)
  - Handle edge cases (re-watches, episode 0, specials)

  **Metadata**:
  - Prefer MyAnimeList ID for matching (more reliable)
  - Fall back to fuzzy title match
  - Allow manual overrides for difficult matches
  - Download images asynchronously

  **Performance**:
  - Use connection pooling for HTTP client
  - Implement request coalescing for duplicate queries
  - Cache GraphQL responses (5-15 min TTL)

  **Monitoring**:
  - Log all GraphQL errors with query context
  - Track rate limit usage
  - Alert on scrobble failures
  - Monitor OAuth token expiration
