doc_title: MyAnimeList (MAL) Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Legacy anime tracking platform with extensive database'
wiki_tagline: '> Sync anime progress with MyAnimeList'
wiki_overview: Connect MyAnimeList (MAL) to sync your anime watching history. MAL has the largest anime database with user
  reviews, rankings, and recommendations. Watch status syncs both directions - import your MAL list and export new watches.
  Uses official MAL API for reliable synchronization.
sources:
- name: MyAnimeList API
  url: https://myanimelist.net/apiconfig/references/api/v2
  note: Auto-resolved from myanimelist
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
integration_name: MyAnimeList (MAL)
integration_id: myanimelist_mal
external_service: MyAnimeList (MAL)
api_base_url: https://api.myanimelist.net/v2
auth_method: oauth
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1([Revenge<br/>Web Player])
      node2["Anime Item<br/>(TV Show)<br/>River Queue"]
      node3[[Scrobbling<br/>Service]]
      node4["River Queue<br/>(Background)"]
      node5["MAL<br/>Scrobbler"]
      node6[(Database<br/>(history))]
      node7[[MAL API v2<br/>(REST)]]
      node8["MAL<br/>User Profile"]
      node1 --> node2
      node3 --> node4
      node6 --> node7
      node2 --> node3
      node4 --> node5
      node5 --> node6
      node7 --> node8
  ```
protocol_details: |
  **REST API v2**:

  **Base URL**: `https://api.myanimelist.net/v2`
  **Format**: JSON (standard, not JSON:API)
  **Authentication**: OAuth 2.0 (Authorization Code flow with PKCE)

  **OAuth 2.0 Flow** (PKCE required):
  1. Generate code_verifier and code_challenge
  2. Redirect to: `https://myanimelist.net/v1/oauth2/authorize`
  3. User approves access
  4. Exchange code for token at: `https://myanimelist.net/v1/oauth2/token`
  5. Use access token in `Authorization: Bearer {token}` header
  6. Refresh token before expiry (31 days)

  **Rate Limiting**:
  - No official documented limit
  - Recommended: 1-2 requests/second
  - Monitor for 429 responses

  **Key Endpoints**:
  - `GET /anime` - Search anime
  - `GET /anime/{id}` - Get anime details
  - `GET /users/@me/animelist` - Get user's list
  - `PATCH /anime/{id}/my_list_status` - Update watch status
  - `DELETE /anime/{id}/my_list_status` - Remove from list
  - `GET /users/@me` - Get current user

  **Field Selection**:
  - Use `?fields=` parameter to request specific fields
  - Default: minimal fields (id, title, main_picture)
  - Detailed: `?fields=id,title,synopsis,num_episodes,status,genres,studios`
module_structure: |
  ```
  internal/
    scrobbling/
      myanimelist/
        client.go         # REST API client
        auth.go           # OAuth 2.0 with PKCE
        scrobbler.go      # Scrobbling implementation
        metadata.go       # Metadata fetching
        pkce.go           # PKCE code generation
        types.go          # Response types
        module.go         # fx module
        client_test.go
        scrobbler_test.go

  config/
    scrobbling/
      myanimelist.yaml    # MAL configuration example
  ```
key_interfaces: |
  ```go
  // MALClient manages MyAnimeList API v2
  type MALClient interface {
      // Search for anime
      SearchAnime(ctx context.Context, query string, limit int) ([]AnimeResult, error)

      // Get anime details
      GetAnime(ctx context.Context, malID int, fields []string) (*AnimeDetails, error)

      // Get user's anime list
      GetUserList(ctx context.Context, status ListStatus, sort string, limit int, offset int) (*UserAnimeList, error)

      // Update watch status
      UpdateStatus(ctx context.Context, malID int, status ListStatus, numWatchedEpisodes int) (*ListStatus, error)

      // Delete from list
      DeleteFromList(ctx context.Context, malID int) error

      // Get current user
      GetCurrentUser(ctx context.Context) (*User, error)
  }

  // MALScrobbler implements scrobbling to MAL
  type MALScrobbler struct {
      client *MALClient
      config *MALConfig
  }

  type MALConfig struct {
      ClientID     string
      ClientSecret string
      RedirectURL  string
      Enabled      bool
      SyncInterval time.Duration
  }

  type AnimeResult struct {
      Node struct {
          ID           int           `json:"id"`
          Title        string        `json:"title"`
          MainPicture  Picture       `json:"main_picture"`
          AlternativeTitles AlternativeTitles `json:"alternative_titles,omitempty"`
          StartDate    string        `json:"start_date,omitempty"`
          EndDate      string        `json:"end_date,omitempty"`
          Synopsis     string        `json:"synopsis,omitempty"`
          Mean         float64       `json:"mean,omitempty"`         // Average score
          Rank         int           `json:"rank,omitempty"`
          Popularity   int           `json:"popularity,omitempty"`
          NumListUsers int           `json:"num_list_users,omitempty"`
          NumEpisodes  int           `json:"num_episodes,omitempty"`
          MediaType    string        `json:"media_type,omitempty"`   // tv, movie, ova, etc.
          Status       AnimeStatus   `json:"status,omitempty"`
          Genres       []Genre       `json:"genres,omitempty"`
          Studios      []Studio      `json:"studios,omitempty"`
      } `json:"node"`
  }

  type AnimeDetails struct {
      ID                int                  `json:"id"`
      Title             string               `json:"title"`
      MainPicture       Picture              `json:"main_picture"`
      AlternativeTitles AlternativeTitles    `json:"alternative_titles"`
      StartDate         string               `json:"start_date"`
      EndDate           string               `json:"end_date"`
      Synopsis          string               `json:"synopsis"`
      Mean              float64              `json:"mean"`
      Rank              int                  `json:"rank"`
      Popularity        int                  `json:"popularity"`
      NumListUsers      int                  `json:"num_list_users"`
      NumScoringUsers   int                  `json:"num_scoring_users"`
      NSFW              string               `json:"nsfw"`  // white, gray, black
      Genres            []Genre              `json:"genres"`
      CreatedAt         time.Time            `json:"created_at"`
      UpdatedAt         time.Time            `json:"updated_at"`
      MediaType         string               `json:"media_type"`
      Status            AnimeStatus          `json:"status"`
      NumEpisodes       int                  `json:"num_episodes"`
      StartSeason       Season               `json:"start_season,omitempty"`
      Broadcast         Broadcast            `json:"broadcast,omitempty"`
      Source            string               `json:"source,omitempty"`  // manga, light_novel, etc.
      AverageEpisodeDuration int             `json:"average_episode_duration,omitempty"`
      Rating            string               `json:"rating,omitempty"`  // g, pg, pg_13, r, r+, rx
      Studios           []Studio             `json:"studios,omitempty"`
      Pictures          []Picture            `json:"pictures,omitempty"`
      Background        string               `json:"background,omitempty"`
      RelatedAnime      []RelatedAnime       `json:"related_anime,omitempty"`
      Recommendations   []Recommendation     `json:"recommendations,omitempty"`
      Statistics        Statistics           `json:"statistics,omitempty"`
  }

  type Picture struct {
      Medium string `json:"medium"`
      Large  string `json:"large"`
  }

  type AlternativeTitles struct {
      Synonyms []string `json:"synonyms"`
      En       string   `json:"en"`
      Ja       string   `json:"ja"`
  }

  type Genre struct {
      ID   int    `json:"id"`
      Name string `json:"name"`
  }

  type Studio struct {
      ID   int    `json:"id"`
      Name string `json:"name"`
  }

  type Season struct {
      Year   int    `json:"year"`
      Season string `json:"season"`  // winter, spring, summer, fall
  }

  type Broadcast struct {
      DayOfTheWeek string `json:"day_of_the_week"`  // monday, tuesday, etc.
      StartTime    string `json:"start_time"`       // HH:MM
  }

  type RelatedAnime struct {
      Node                AnimeResult `json:"node"`
      RelationType        string      `json:"relation_type"`  // sequel, prequel, etc.
      RelationTypeFormatted string    `json:"relation_type_formatted"`
  }

  type Recommendation struct {
      Node             AnimeResult `json:"node"`
      NumRecommendations int      `json:"num_recommendations"`
  }

  type Statistics struct {
      NumListUsers int                `json:"num_list_users"`
      Status       StatusStatistics    `json:"status"`
  }

  type StatusStatistics struct {
      Watching    int `json:"watching"`
      Completed   int `json:"completed"`
      OnHold      int `json:"on_hold"`
      Dropped     int `json:"dropped"`
      PlanToWatch int `json:"plan_to_watch"`
  }

  type AnimeStatus string

  const (
      StatusFinishedAiring  AnimeStatus = "finished_airing"
      StatusCurrentlyAiring AnimeStatus = "currently_airing"
      StatusNotYetAired     AnimeStatus = "not_yet_aired"
  )

  type ListStatus string

  const (
      ListWatching    ListStatus = "watching"
      ListCompleted   ListStatus = "completed"
      ListOnHold      ListStatus = "on_hold"
      ListDropped     ListStatus = "dropped"
      ListPlanToWatch ListStatus = "plan_to_watch"
  )

  type UserAnimeListEntry struct {
      Node       AnimeResult     `json:"node"`
      ListStatus UserListStatus  `json:"list_status"`
  }

  type UserListStatus struct {
      Status             ListStatus `json:"status"`
      Score              int        `json:"score"`              // 0-10
      NumEpisodesWatched int        `json:"num_episodes_watched"`
      IsRewatching       bool       `json:"is_rewatching"`
      StartDate          string     `json:"start_date"`         // YYYY-MM-DD
      FinishDate         string     `json:"finish_date"`        // YYYY-MM-DD
      Priority           int        `json:"priority"`           // 0-2 (low, medium, high)
      NumTimesRewatched  int        `json:"num_times_rewatched"`
      RewatchValue       int        `json:"rewatch_value"`      // 0-5
      Tags               []string   `json:"tags"`
      Comments           string     `json:"comments"`
      UpdatedAt          time.Time  `json:"updated_at"`
  }

  type UserAnimeList struct {
      Data   []UserAnimeListEntry `json:"data"`
      Paging Paging               `json:"paging"`
  }

  type Paging struct {
      Previous string `json:"previous,omitempty"`
      Next     string `json:"next,omitempty"`
  }

  type User struct {
      ID       int       `json:"id"`
      Name     string    `json:"name"`
      Picture  string    `json:"picture"`
      Gender   string    `json:"gender"`
      Birthday string    `json:"birthday"`
      Location string    `json:"location"`
      JoinedAt time.Time `json:"joined_at"`
  }

  type PKCEChallenge struct {
      CodeVerifier  string
      CodeChallenge string
      State         string
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/riverqueue/river` - Background job queue
  - `golang.org/x/oauth2` - OAuth 2.0 client
  - `crypto/sha256` - PKCE code challenge
  - `encoding/base64` - PKCE encoding
  - `crypto/rand` - Random code generation

  **External Services**:
  - MyAnimeList API v2 (https://myanimelist.net)
env_vars: |
  ```bash
  # MAL OAuth configuration
  REVENGE_MAL_ENABLED=true
  REVENGE_MAL_CLIENT_ID=your-client-id
  REVENGE_MAL_CLIENT_SECRET=your-client-secret
  REVENGE_MAL_REDIRECT_URL=https://revenge.local/api/v1/scrobbling/mal/callback

  # Sync settings
  REVENGE_MAL_SYNC_INTERVAL=24h
  ```
config_keys: |
  ```yaml
  scrobbling:
    myanimelist:
      enabled: true
      client_id: ${REVENGE_MAL_CLIENT_ID}
      client_secret: ${REVENGE_MAL_CLIENT_SECRET}
      redirect_url: https://revenge.local/api/v1/scrobbling/mal/callback
      sync_interval: 24h
      auto_sync: true
      scrobble_threshold: 0.9
      metadata_enabled: true
      metadata_priority: 20       # Lower priority than AniList/Kitsu
  ```
pkce_implementation: |
  **PKCE (Proof Key for Code Exchange)**:

  MAL requires PKCE for OAuth 2.0 (security enhancement):

  ```go
  // Generate PKCE challenge
  func GeneratePKCE() (*PKCEChallenge, error) {
      // 1. Generate code_verifier (random 43-128 chars)
      verifier := make([]byte, 32)
      if _, err := rand.Read(verifier); err != nil {
          return nil, err
      }
      codeVerifier := base64.RawURLEncoding.EncodeToString(verifier)

      // 2. Generate code_challenge = BASE64URL(SHA256(code_verifier))
      hash := sha256.Sum256([]byte(codeVerifier))
      codeChallenge := base64.RawURLEncoding.EncodeToString(hash[:])

      // 3. Generate state (random string for CSRF protection)
      stateBytes := make([]byte, 16)
      if _, err := rand.Read(stateBytes); err != nil {
          return nil, err
      }
      state := base64.RawURLEncoding.EncodeToString(stateBytes)

      return &PKCEChallenge{
          CodeVerifier:  codeVerifier,
          CodeChallenge: codeChallenge,
          State:         state,
      }, nil
  }
  ```
oauth_flow: |
  **OAuth 2.0 with PKCE Flow**:

  1. **Generate PKCE challenge**:
     ```go
     pkce, _ := GeneratePKCE()
     // Store pkce.CodeVerifier and pkce.State in session
     ```

  2. **Redirect user to MAL**:
     ```
     https://myanimelist.net/v1/oauth2/authorize?
       response_type=code&
       client_id={client_id}&
       redirect_uri={redirect_uri}&
       state={state}&
       code_challenge={code_challenge}&
       code_challenge_method=S256
     ```

  3. **User approves access**

  4. **MAL redirects back with code**:
     ```
     https://revenge.local/api/v1/scrobbling/mal/callback?
       code=xyz123&
       state={state}
     ```

  5. **Verify state, exchange code for token**:
     ```http
     POST https://myanimelist.net/v1/oauth2/token
     Content-Type: application/x-www-form-urlencoded

     client_id={client_id}&
     client_secret={client_secret}&
     code=xyz123&
     code_verifier={code_verifier}&
     grant_type=authorization_code&
     redirect_uri={redirect_uri}
     ```

  6. **Receive tokens**:
     ```json
     {
       "token_type": "Bearer",
       "expires_in": 2678400,
       "access_token": "abc123...",
       "refresh_token": "xyz789..."
     }
     ```

  7. **Store tokens** (access token valid 31 days)

  8. **Refresh before expiry**:
     ```http
     POST https://myanimelist.net/v1/oauth2/token
     Content-Type: application/x-www-form-urlencoded

     grant_type=refresh_token&
     refresh_token=xyz789...&
     client_id={client_id}&
     client_secret={client_secret}
     ```

  9. **Use in API requests**:
     ```http
     GET https://api.myanimelist.net/v2/anime?q=demon%20slayer
     Authorization: Bearer abc123...
     ```
api_examples: |
  **Search Anime**:
  ```http
  GET /v2/anime?q=demon%20slayer&limit=10&fields=id,title,main_picture,synopsis,num_episodes,status
  Authorization: Bearer {token}

  Response:
  {
    "data": [
      {
        "node": {
          "id": 38000,
          "title": "Kimetsu no Yaiba",
          "main_picture": {
            "medium": "https://...",
            "large": "https://..."
          },
          "synopsis": "...",
          "num_episodes": 26,
          "status": "finished_airing"
        }
      }
    ],
    "paging": {}
  }
  ```

  **Get User's Anime List**:
  ```http
  GET /v2/users/@me/animelist?status=watching&limit=100&offset=0&fields=list_status
  Authorization: Bearer {token}

  Response:
  {
    "data": [
      {
        "node": {
          "id": 38000,
          "title": "Demon Slayer",
          "main_picture": {...}
        },
        "list_status": {
          "status": "watching",
          "score": 9,
          "num_episodes_watched": 15,
          "is_rewatching": false,
          "updated_at": "2026-02-01T10:00:00Z"
        }
      }
    ],
    "paging": {
      "next": "https://api.myanimelist.net/v2/users/@me/animelist?offset=100"
    }
  }
  ```

  **Update Watch Status** (Scrobble):
  ```http
  PATCH /v2/anime/38000/my_list_status
  Authorization: Bearer {token}
  Content-Type: application/x-www-form-urlencoded

  status=watching&num_watched_episodes=16&score=9

  Response:
  {
    "status": "watching",
    "score": 9,
    "num_episodes_watched": 16,
    "is_rewatching": false,
    "updated_at": "2026-02-01T11:00:00Z"
  }
  ```
component_interaction: |
  **Scrobbling Workflow**:

  1. **User watches anime**:
     - Episode reaches 90% completion
     - Scrobbling service queues job

  2. **Process scrobble job**:
     - Fetch user's MAL OAuth token
     - Match Revenge anime to MAL ID
     - PATCH /anime/{id}/my_list_status
     - Update progress
     - Auto-complete if final episode

  3. **Periodic sync**:
     - Cron job runs daily
     - GET /users/@me/animelist (paginated)
     - Import missing anime
     - Update watch status
api_endpoints: |
  **Revenge API Endpoints**:

  ```
  # OAuth flow with PKCE
  GET  /api/v1/scrobbling/mal/authorize
  GET  /api/v1/scrobbling/mal/callback

  # Status
  GET  /api/v1/scrobbling/mal/status
  POST /api/v1/scrobbling/mal/disconnect

  # Operations
  POST /api/v1/scrobbling/mal/import
  POST /api/v1/scrobbling/mal/sync
  ```
error_handling: |
  **Common Errors**:

  - **400 Bad Request**: Invalid parameters (check field names)
    - Solution: Validate request format

  - **401 Unauthorized**: Token expired or invalid
    - Solution: Refresh token or re-authenticate

  - **403 Forbidden**: Insufficient permissions
    - Solution: Re-authorize with correct scopes

  - **404 Not Found**: Anime ID doesn't exist
    - Solution: Update local MAL ID mapping

  - **429 Too Many Requests**: Rate limit exceeded
    - Solution: Implement backoff
unit_tests: |
  ```go
  func TestMALClient_SearchAnime(t *testing.T) {
      mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          w.Header().Set("Content-Type", "application/json")
          json.NewEncoder(w).Encode(map[string]interface{}{
              "data": []map[string]interface{}{
                  {
                      "node": map[string]interface{}{
                          "id":    38000,
                          "title": "Demon Slayer",
                      },
                  },
              },
          })
      }))
      defer mockServer.Close()

      client := NewMALClient(mockServer.URL, "test-token")
      results, err := client.SearchAnime(context.Background(), "Demon Slayer", 10)

      require.NoError(t, err)
      assert.Len(t, results, 1)
      assert.Equal(t, 38000, results[0].Node.ID)
  }

  func TestGeneratePKCE(t *testing.T) {
      pkce, err := GeneratePKCE()
      require.NoError(t, err)
      assert.NotEmpty(t, pkce.CodeVerifier)
      assert.NotEmpty(t, pkce.CodeChallenge)
      assert.NotEmpty(t, pkce.State)
  }
  ```
integration_tests: |
  ```go
  func TestMAL_FullWorkflow(t *testing.T) {
      if testing.Short() {
          t.Skip("skipping integration test")
      }

      token := os.Getenv("MAL_TOKEN")
      if token == "" {
          t.Skip("no MAL token provided")
      }

      client := NewMALClient("https://api.myanimelist.net/v2", token)

      // Test search
      results, err := client.SearchAnime(context.Background(), "Demon Slayer", 10)
      require.NoError(t, err)
      require.NotEmpty(t, results)

      // Test get current user
      user, err := client.GetCurrentUser(context.Background())
      require.NoError(t, err)
      assert.NotEmpty(t, user.Name)
  }
  ```
best_practices: |
  **OAuth & PKCE**:
  - Always use PKCE for OAuth 2.0 (MAL requirement)
  - Generate cryptographically secure random code_verifier
  - Store code_verifier securely in session (cleared after exchange)
  - Validate state parameter to prevent CSRF

  **API Usage**:
  - Use `fields` parameter to request only needed data
  - Implement rate limiting (1-2 req/sec)
  - Handle pagination correctly (follow paging.next)
  - Cache metadata locally (MAL data changes infrequently)

  **Scrobbling**:
  - Queue scrobbles asynchronously
  - Match by MAL ID (most reliable)
  - Handle auto-completion logic (final episode)
  - Retry on failures with exponential backoff

  **Metadata**:
  - Use detailed field selection for full metadata
  - Download pictures asynchronously
  - Handle missing fields gracefully (not all anime have all fields)
  - Consider MAL as authoritative ID source (AniList/Kitsu include MAL IDs)

  **Token Management**:
  - Refresh tokens before 31-day expiry
  - Store tokens encrypted at rest
  - Handle token refresh failures gracefully
  - Log re-authentication events

  **Performance**:
  - Use HTTP connection pooling
  - Implement request coalescing
  - Cache API responses (5-15 min TTL)
  - Batch operations when possible

  **Monitoring**:
  - Track OAuth flow completion rate
  - Monitor scrobble success/failure rates
  - Log API errors with context
  - Alert on authentication failures
