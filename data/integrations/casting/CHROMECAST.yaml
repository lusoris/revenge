doc_title: Chromecast Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Google Cast protocol for streaming to Chromecast devices'
wiki_tagline: '> Cast media to Chromecast and Google TV'
wiki_overview: Cast videos from Revenge to any Chromecast, Google TV, or Cast-enabled device. Click the cast icon in the player
  to see available devices on your network. Control playback from your phone or computer while watching on the big screen.
  Supports subtitles and multiple audio tracks.
sources:
- name: go-chromecast
  url: https://github.com/vishen/go-chromecast
  note: Auto-resolved from go-chromecast
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
integration_name: Chromecast
integration_id: chromecast
external_service: Chromecast
api_base_url: https://revenge.example.com/api/v1/stream/movie/123
architecture_diagram: |-
  ```mermaid
  flowchart LR
      subgraph Layer1["Layer 1"]
          node1(["Revenge<br/>Web App"])
          node2["Chromecast<br/>Device"]
      end

      subgraph Layer2["Layer 2"]
          node3["Revenge<br/>Server<br/>(HLS Stream)"]
          node4(["Receiver<br/>Application<br/>(Custom)"])
      end

      %% Connections
      node2 --> node3

      %% Styling
      style Layer1 fill:#1976D2,stroke:#1976D2,color:#fff
      style Layer2 fill:#388E3C,stroke:#388E3C,color:#fff
  ```
protocol_details: |
  **Google Cast Protocol**:
  - Discovery: mDNS/SSDP (automatic network discovery)
  - Connection: WebSocket over TLS (port 8009)
  - Control: JSON-RPC messages via Cast SDK
  - Media Loading: HTTP(S) URLs to media streams

  **Receiver Application**:
  - Custom receiver app hosted by Revenge
  - Or use Default Media Receiver for simple playback
  - Supports HLS, DASH, MP4, WebM

  **Cast SDK**:
  - Browser: Google Cast JavaScript SDK
  - Go backend: go-chromecast library for device control
module_structure: |
  ```
  internal/
    casting/
      chromecast/
        discovery.go       # mDNS device discovery
        client.go          # Cast SDK client wrapper
        receiver.go        # Custom receiver app hosting
        session.go         # Cast session management
        media.go           # Media loading and control
        status.go          # Playback status tracking
        module.go          # fx module definition
        client_test.go
        session_test.go

  web/
    public/
      cast-receiver/       # Custom Cast receiver app
        index.html         # Receiver UI
        player.js          # Vidstack player integration
        cast-sdk.js        # Cast Receiver SDK

    src/
      lib/
        casting/
          useCastSender.ts  # React/Svelte hook for sender
          CastButton.svelte # Cast button component
          CastController.ts # Session controller
  ```
key_interfaces: |
  ```go
  // ChromecastClient manages Cast devices and sessions
  type ChromecastClient interface {
      // Discover Cast devices on the network
      DiscoverDevices(ctx context.Context) ([]CastDevice, error)

      // Connect to a specific Cast device
      Connect(ctx context.Context, deviceID string) (*CastSession, error)

      // Load media on connected device
      LoadMedia(ctx context.Context, sessionID string, media *MediaInfo) error

      // Control playback
      Play(ctx context.Context, sessionID string) error
      Pause(ctx context.Context, sessionID string) error
      Seek(ctx context.Context, sessionID string, position time.Duration) error
      Stop(ctx context.Context, sessionID string) error

      // Get current status
      GetStatus(ctx context.Context, sessionID string) (*PlaybackStatus, error)

      // Disconnect from device
      Disconnect(ctx context.Context, sessionID string) error
  }

  type CastDevice struct {
      ID            string
      Name          string
      ModelName     string
      IPAddress     string
      Port          int
      Capabilities  []string  // video, audio, multizone
  }

  type CastSession struct {
      ID            string
      DeviceID      string
      ReceiverAppID string
      Connected     bool
      CreatedAt     time.Time
  }

  type MediaInfo struct {
      ContentID     string            // URL to media stream
      ContentType   string            // MIME type (video/mp4, application/x-mpegURL)
      StreamType    StreamType        // buffered, live
      Duration      time.Duration
      Metadata      MediaMetadata
      Tracks        []MediaTrack      // Subtitles, audio tracks
  }

  type MediaMetadata struct {
      Type          MetadataType      // movie, tvshow, music
      Title         string
      Subtitle      string            // Episode name, artist
      Images        []Image
      ReleaseDate   string
  }

  type MediaTrack struct {
      TrackID       int
      Type          TrackType         // text, audio, video
      Language      string
      Name          string
      SubType       string            // captions, subtitles, descriptions
  }

  type StreamType string

  const (
      StreamBuffered StreamType = "buffered"  // VOD content
      StreamLive     StreamType = "live"      // Live streams
  )

  type PlaybackStatus struct {
      SessionID     string
      MediaSessionID int
      State         PlaybackState    // idle, buffering, playing, paused
      Position      time.Duration
      Duration      time.Duration
      Volume        float64          // 0.0 - 1.0
      Muted         bool
      CurrentTrack  int
  }

  type PlaybackState string

  const (
      StateIdle      PlaybackState = "idle"
      StateBuffering PlaybackState = "buffering"
      StatePlaying   PlaybackState = "playing"
      StatePaused    PlaybackState = "paused"
  )
  ```
dependencies: |
  **Go Packages**:
  - `github.com/vishen/go-chromecast` - Cast protocol client
  - `github.com/grandcat/zeroconf` - mDNS discovery
  - `github.com/gorilla/websocket` - WebSocket for Cast channel

  **Frontend**:
  - Google Cast JavaScript SDK (sender)
  - Google Cast Receiver SDK (receiver app)
  - Vidstack player for receiver playback
env_vars: |
  ```bash
  # Chromecast configuration
  REVENGE_CAST_ENABLED=true
  REVENGE_CAST_RECEIVER_APP_ID=A1B2C3D4  # Custom receiver app ID (optional)
  REVENGE_CAST_DISCOVERY_TIMEOUT=5s
  REVENGE_CAST_AUTO_RECONNECT=true
  ```
config_keys: |
  ```yaml
  casting:
    chromecast:
      enabled: true
      discovery:
        timeout: 5s
        interval: 30s         # Rediscover devices every 30s
      receiver:
        app_id: ""            # Empty = use Default Media Receiver
        custom_url: ""        # URL to custom receiver app (if hosted externally)
      session:
        timeout: 10m          # Idle session timeout
        auto_reconnect: true
      media:
        supported_codecs: [h264, hevc, av1, vp9]
        transcode_on_incompatible: true
        max_bitrate: 20000    # Max bitrate in kbps
  ```
component_interaction: |
  **Cast Flow**:

  1. **Device Discovery** (on page load):
     - Sender app calls `ChromecastClient.DiscoverDevices()`
     - mDNS scans network for `_googlecast._tcp` services
     - Returns list of available Cast devices
     - UI shows Cast button if devices found

  2. **User Initiates Cast**:
     - User clicks Cast button
     - Selects device from list
     - Sender calls `ChromecastClient.Connect(deviceID)`

  3. **Load Media**:
     - Sender constructs MediaInfo with HLS stream URL
     - Calls `LoadMedia(sessionID, mediaInfo)`
     - Receiver app loads in Chromecast browser
     - Vidstack player initializes with HLS stream

  4. **Playback Control**:
     - User controls (play/pause/seek) sent via Cast SDK
     - Chromecast executes commands on receiver
     - Status updates stream back to sender via WebSocket

  5. **Disconnect**:
     - User stops casting
     - Session closed, receiver app unloads
api_endpoints: |
  **Cast Session Management**:
  ```
  POST /api/v1/cast/sessions
  GET  /api/v1/cast/sessions/{id}
  DELETE /api/v1/cast/sessions/{id}
  ```

  **Device Discovery**:
  ```
  GET /api/v1/cast/devices
  ```

  **Media Control**:
  ```
  POST /api/v1/cast/sessions/{id}/play
  POST /api/v1/cast/sessions/{id}/pause
  POST /api/v1/cast/sessions/{id}/seek
  POST /api/v1/cast/sessions/{id}/stop
  ```

  **Example - Create Session**:
  ```json
  POST /api/v1/cast/sessions
  {
    "device_id": "chromecast-living-room",
    "media": {
      "content_id": "https://revenge.local/stream/movie/123/master.m3u8",
      "content_type": "application/x-mpegURL",
      "stream_type": "buffered",
      "duration": "7200s",
      "metadata": {
        "type": "movie",
        "title": "Fight Club",
        "images": [
          {"url": "https://revenge.local/images/fight-club-poster.jpg"}
        ]
      }
    }
  }
  ```

  **Response**:
  ```json
  {
    "session_id": "cast-session-123",
    "device_id": "chromecast-living-room",
    "receiver_app_id": "CC1AD845",
    "connected": true,
    "status": {
      "state": "buffering",
      "position": "0s",
      "volume": 0.5
    }
  }
  ```
receiver_app: |
  **Custom Receiver Application**:

  Revenge can host a custom Cast receiver app for enhanced features:

  **Features**:
  - Vidstack player with HLS.js support
  - Skip intro button synced from server
  - Trickplay thumbnails
  - Chapter markers
  - Multiple audio/subtitle tracks
  - Custom branding and theme

  **Hosting**:
  ```
  # Served from Revenge web server
  https://revenge.local/cast-receiver/

  # Or hosted externally on CDN
  https://cdn.revenge.app/cast-receiver/v1/
  ```

  **Registration**:
  - Register receiver app in Google Cast Developer Console
  - Get Application ID (e.g., "A1B2C3D4")
  - Configure in Revenge settings

  **Default Media Receiver**:
  - If no custom app configured, use Google's default
  - Limited features but works for basic playback
transcoding: |
  **Codec Compatibility**:

  Chromecast supports:
  - Video: H.264, H.265 (some models), VP8, VP9, AV1 (newer models)
  - Audio: AAC, MP3, Opus, Vorbis
  - Containers: MP4, WebM, HLS, DASH

  **Transcoding Strategy**:
  1. Check device capabilities via Cast SDK
  2. If codec unsupported, trigger real-time transcode
  3. Serve transcoded HLS stream to receiver
  4. Cache segments for future playback

  **Configuration**:
  ```yaml
  casting:
    chromecast:
      media:
        transcode_on_incompatible: true
        fallback_codec: h264
        fallback_audio: aac
  ```
error_handling: |
  **Common Errors**:

  - **Discovery Failed**: Network firewall blocking mDNS (port 5353)
    - Solution: Allow mDNS traffic, check same subnet

  - **Connection Timeout**: Device unreachable or busy
    - Solution: Retry connection, ensure device is idle

  - **Media Load Failed**: Invalid stream URL or unsupported format
    - Solution: Check stream accessibility, enable transcoding

  - **Playback Error**: Network issues, stream interrupted
    - Solution: Retry with exponential backoff

  **Error Codes**:
  ```go
  var (
      ErrDeviceNotFound     = errors.New("cast device not found")
      ErrConnectionFailed   = errors.New("failed to connect to device")
      ErrMediaLoadFailed    = errors.New("failed to load media")
      ErrSessionExpired     = errors.New("cast session expired")
      ErrUnsupportedCodec   = errors.New("codec not supported by device")
  )
  ```
unit_tests: |
  ```go
  func TestChromecastClient_DiscoverDevices(t *testing.T) {
      tests := []struct {
          name    string
          timeout time.Duration
          want    int  // Expected device count
          wantErr bool
      }{
          {
              name:    "discover 2 devices",
              timeout: 5 * time.Second,
              want:    2,
          },
      }

      for _, tt := range tests {
          t.Run(tt.name, func(t *testing.T) {
              client := NewChromecastClient()
              devices, err := client.DiscoverDevices(context.Background())

              if tt.wantErr {
                  require.Error(t, err)
                  return
              }

              require.NoError(t, err)
              assert.Len(t, devices, tt.want)
          })
      }
  }
  ```
integration_tests: |
  ```go
  func TestChromecast_FullWorkflow(t *testing.T) {
      // Requires physical Chromecast device on network
      if testing.Short() {
          t.Skip("skipping integration test")
      }

      client := NewChromecastClient()

      // Discover devices
      devices, err := client.DiscoverDevices(context.Background())
      require.NoError(t, err)
      require.NotEmpty(t, devices)

      // Connect to first device
      session, err := client.Connect(context.Background(), devices[0].ID)
      require.NoError(t, err)
      defer client.Disconnect(context.Background(), session.ID)

      // Load test media
      media := &MediaInfo{
          ContentID:   "http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4",
          ContentType: "video/mp4",
          StreamType:  StreamBuffered,
      }

      err = client.LoadMedia(context.Background(), session.ID, media)
      require.NoError(t, err)

      // Wait for playback to start
      time.Sleep(2 * time.Second)

      // Get status
      status, err := client.GetStatus(context.Background(), session.ID)
      require.NoError(t, err)
      assert.Equal(t, StatePlaying, status.State)
  }
  ```
best_practices: |
  **Network**:
  - Ensure Chromecast and server on same subnet
  - Allow mDNS (port 5353) and Cast protocol (port 8009) in firewall
  - Use reliable WiFi network (5GHz preferred for 4K)

  **Performance**:
  - Pre-transcode popular content to supported codecs
  - Use CDN or edge caching for HLS segments
  - Monitor bandwidth and adjust quality profiles

  **User Experience**:
  - Show Cast button only when devices available
  - Provide visual feedback during connection
  - Handle disconnections gracefully (auto-reconnect)
  - Sync playback position when switching between devices

  **Security**:
  - Use HTTPS for media streams
  - Validate Cast session tokens
  - Rate limit Cast API endpoints
