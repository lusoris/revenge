doc_title: Pornhub Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: ‚úÖ Complete
status_design: ‚úÖ
status_design_notes: '-'
status_sources: ‚úÖ
status_sources_notes: '-'
status_instructions: ‚úÖ
status_instructions_notes: '-'
status_code: üî¥
status_code_notes: '-'
status_linting: üî¥
status_linting_notes: '-'
status_unit_testing: üî¥
status_unit_testing_notes: '-'
status_integration_testing: üî¥
status_integration_testing_notes: '-'
technical_summary: '> LINK-ONLY performer channel references for QAR content'
wiki_tagline: '> Pornhub - Performer channel links and view metrics'
wiki_overview: LINK-ONLY integration for QAR performer profiles. Stores verified channel URLs for performer cross-referencing.
  Extracts view counts and subscriber metrics. **NO content streaming** - only metadata and links. **Web scraping** with heavy
  Cloudflare protection. **Proxy/VPN required** (via HTTP_CLIENT service).
sources:
- name: Go io
  url: https://pkg.go.dev/io
  note: Auto-resolved from go-io
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: PuerkitoBio/goquery
  url: https://pkg.go.dev/github.com/PuerkitoBio/goquery
  note: HTML parsing
- name: golang.org/x/time
  url: https://pkg.go.dev/golang.org/x/time
  note: Rate limiting
- name: chromedp
  url: https://pkg.go.dev/github.com/chromedp/chromedp
  note: Headless browser for Cloudflare bypass
design_refs:
- title: 03_METADATA_SYSTEM
  path: ../../../architecture/03_METADATA_SYSTEM.md
- title: WHISPARR (PRIMARY for QAR)
  path: ../../servarr/WHISPARR.md
- title: STASHDB
  path: ./STASHDB.md
- title: FREEONES
  path: ./FREEONES.md
- title: HTTP_CLIENT (proxy/VPN support)
  path: ../../../services/HTTP_CLIENT.md
- title: ADULT_CONTENT_SYSTEM (QAR module)
  path: ../../../features/adult/ADULT_CONTENT_SYSTEM.md
integration_name: Pornhub
integration_id: pornhub
external_service: Pornhub
api_base_url: https://www.pornhub.com
data_access_method: web_scraping
content_streaming: false
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1["Performer<br/>Profile Page<br/>(Revenge UI)"]
      node2["Pornhub Link<br/>(verified URL)"]
      node3["Pornhub.com<br/>(Cloudflare)"]
      node4["View Count<br/>Subscribers"]
      node5["HTTP_CLIENT<br/>(REQUIRED<br/>proxy/VPN)"]
      node6["Headless<br/>Browser<br/>(Cloudflare)"]
      node3 --> node4
      node1 --> node2
      node2 --> node3
      node4 --> node5
      node5 --> node6
  ```
integration_scope: |
  **WHAT THIS INTEGRATION DOES**:
  - ‚úÖ Stores verified performer channel URLs
  - ‚úÖ Extracts public metrics (views, subscribers, video count)
  - ‚úÖ Cross-references performer identity
  - ‚úÖ Provides "View on Pornhub" links in UI

  **WHAT THIS INTEGRATION DOES NOT DO**:
  - ‚ùå Stream or download any video content
  - ‚ùå Embed Pornhub videos in Revenge
  - ‚ùå Proxy or cache Pornhub content
  - ‚ùå Authenticate users on Pornhub
  - ‚ùå Access premium/private content

  **Legal/Ethical Scope**:
  - Only public, freely accessible page metadata
  - Respects robots.txt where applicable
  - No content redistribution
  - Links open in user's own browser
api_details: |
  **Data Access**: Web scraping (no official API)
  **Base URL**: `https://www.pornhub.com`
  **Authentication**: None (public pages only)
  **Rate Limit**: Self-imposed 0.5 req/sec (very conservative)

  **Cloudflare Protection**: Heavy
  - JavaScript challenge required
  - Headless browser may be needed
  - IP blocks common without proxy

  **Scraping Targets**:
  - `/pornstar/performer-name` - Performer channel page
  - `/pornstar/performer-name/videos` - Video count
  - `/channels/studio-name` - Studio channel

  **Extractable Data**:
  - Performer name and profile image
  - Subscriber count
  - Video view counts
  - Video upload count
  - Channel URL (verified)
database_schema: |
  **Schema**: `qar` (pirate-themed obfuscation)

  ```sql
  -- Pornhub performer channel links
  CREATE TABLE qar.pornhub_channels (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    performer_id UUID NOT NULL REFERENCES qar.crew(id),

    -- Verified channel info
    channel_url TEXT NOT NULL,               -- Full URL to channel
    channel_slug VARCHAR(255) NOT NULL,      -- URL slug
    channel_type VARCHAR(50) NOT NULL,       -- 'pornstar', 'model', 'channel'

    -- Public metrics (at time of fetch)
    subscriber_count BIGINT,
    video_count INT,
    total_views BIGINT,
    profile_image_url TEXT,

    -- Verification
    verified_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    last_checked TIMESTAMPTZ NOT NULL DEFAULT now(),
    is_verified BOOLEAN NOT NULL DEFAULT true,  -- URL still valid

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),

    UNIQUE(performer_id)
  );
  CREATE INDEX idx_pornhub_channels_slug ON qar.pornhub_channels(channel_slug);

  -- Link verification history
  CREATE TABLE qar.external_link_checks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    link_type VARCHAR(50) NOT NULL,          -- 'pornhub', 'xvideos', etc.
    link_url TEXT NOT NULL,
    performer_id UUID REFERENCES qar.crew(id),

    check_result VARCHAR(50) NOT NULL,       -- 'valid', 'broken', 'redirected'
    http_status INT,
    redirect_url TEXT,

    checked_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_link_checks_performer ON qar.external_link_checks(performer_id, checked_at);
  ```
module_structure: |
  ```
  internal/metadata/providers/pornhub/
  ‚îú‚îÄ‚îÄ module.go                    # fx module
  ‚îú‚îÄ‚îÄ client.go                    # HTTP client with Cloudflare handling
  ‚îú‚îÄ‚îÄ provider.go                  # Link provider interface impl
  ‚îú‚îÄ‚îÄ scraper.go                   # HTML parsing logic
  ‚îú‚îÄ‚îÄ metrics.go                   # View/subscriber extraction
  ‚îú‚îÄ‚îÄ verification.go              # Link verification
  ‚îú‚îÄ‚îÄ cloudflare.go                # Cloudflare bypass (chromedp)
  ‚îú‚îÄ‚îÄ ratelimit.go                 # Rate limiter (0.5/sec)
  ‚îî‚îÄ‚îÄ pornhub_test.go
  ```
key_interfaces: |
  ```go
  // Pornhub link provider (LINK-ONLY, no content)
  type PornhubProvider struct {
    httpFactory  httpclient.ClientFactory
    rateLimiter  *rate.Limiter
    cache        Cache
    browserPool  *chromedp.Pool  // For Cloudflare bypass
  }

  // External link provider interface
  type ExternalLinkProvider interface {
    // Search for performer channel
    SearchChannel(ctx context.Context, performerName string) (*ChannelResult, error)

    // Get channel metrics
    GetChannelMetrics(ctx context.Context, channelURL string) (*ChannelMetrics, error)

    // Verify link is still valid
    VerifyLink(ctx context.Context, url string) (*LinkStatus, error)

    // Provider metadata
    ProviderName() string
    ProvidesContent() bool  // Always returns false
  }

  // Channel search result
  type ChannelResult struct {
    URL           string `json:"url"`
    Slug          string `json:"slug"`
    Name          string `json:"name"`
    ChannelType   string `json:"type"`      // pornstar, model, channel
    ProfileImage  string `json:"image"`
    Verified      bool   `json:"verified"`  // Pornhub verified badge
    SubscriberCount int64 `json:"subscribers,omitempty"`
  }

  // Channel public metrics
  type ChannelMetrics struct {
    URL             string    `json:"url"`
    SubscriberCount int64     `json:"subscribers"`
    VideoCount      int       `json:"videos"`
    TotalViews      int64     `json:"total_views"`
    ProfileImage    string    `json:"image"`
    FetchedAt       time.Time `json:"fetched_at"`
  }

  // Link verification result
  type LinkStatus struct {
    URL         string `json:"url"`
    IsValid     bool   `json:"valid"`
    HTTPStatus  int    `json:"status"`
    RedirectURL string `json:"redirect,omitempty"`
    CheckedAt   time.Time `json:"checked_at"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client
  - `github.com/PuerkitoBio/goquery` - HTML parsing
  - `github.com/chromedp/chromedp` - Headless browser (Cloudflare)
  - `golang.org/x/time/rate` - Rate limiting (0.5 req/sec)
  - `github.com/jackc/pgx/v5` - PostgreSQL driver
  - `github.com/riverqueue/river` - Background verification jobs
  - `go.uber.org/fx` - Dependency injection

  **External**:
  - Pornhub website (web scraping, Cloudflare protected)

  **Internal Services**:
  - HTTP_CLIENT - Proxy/VPN routing (REQUIRED)
env_vars: |
  ```bash
  # Pornhub integration
  PORNHUB_ENABLED=true

  # Rate limiting (very conservative)
  PORNHUB_RATE_LIMIT=0.5            # 1 request per 2 seconds
  PORNHUB_RATE_WINDOW=1s

  # Caching
  PORNHUB_CACHE_TTL=168h            # 7 days

  # Proxy/VPN (REQUIRED for Cloudflare)
  PORNHUB_PROXY_ENABLED=true
  PORNHUB_PROXY_URL=socks5://127.0.0.1:9050

  # Headless browser (for Cloudflare bypass)
  PORNHUB_USE_BROWSER=true
  PORNHUB_BROWSER_TIMEOUT=30s
  ```
config_keys: |
  ```yaml
  metadata:
    providers:
      pornhub:
        enabled: true
        rate_limit: 0.5
        rate_window: 1s
        cache_ttl: 168h

        # LINK role only (no content)
        role: link
        provides_content: false     # Explicit: NO content streaming

        # Proxy/VPN support (REQUIRED)
        proxy:
          enabled: true             # REQUIRED for Pornhub
          type: tor
          url: socks5://127.0.0.1:9050

        # Cloudflare bypass
        cloudflare:
          use_browser: true         # Use headless browser
          browser_timeout: 30s
          retry_on_challenge: true
          max_retries: 3

        # Link verification
        verification:
          enabled: true
          check_interval: 168h      # Re-verify weekly
          remove_broken_links: false  # Keep but mark as broken
  ```
component_interaction: |
  **Link Discovery Flow**:
  1. New performer added from Whisparr/StashDB
  2. Enrichment job runs (via River, low priority)
  3. Search Pornhub for performer channel
  4. If found: extract URL, metrics, profile image
  5. Store verified link in pornhub_channels table
  6. Display "View on Pornhub" link in performer profile

  **Cloudflare Handling**:
  1. Initial request returns Cloudflare challenge
  2. Spawn headless browser (chromedp)
  3. Navigate to page, wait for challenge to complete
  4. Extract cookies from browser session
  5. Use cookies for subsequent requests
  6. Cache valid session for reuse

  **Link Verification (Background)**:
  1. Scheduled job runs weekly
  2. For each stored Pornhub link:
  3. HEAD request to check if URL valid
  4. Update is_verified and last_checked
  5. If 404: mark as broken (don't delete)
  6. If redirected: update to new URL

  **UI Display**:
  ```
  Performer Profile Page
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ [Performer Photo]               ‚îÇ
  ‚îÇ Jane Doe                        ‚îÇ
  ‚îÇ                                 ‚îÇ
  ‚îÇ External Links:                 ‚îÇ
  ‚îÇ [üîó Pornhub] ‚Üê Opens new tab    ‚îÇ
  ‚îÇ [üîó Twitter]                    ‚îÇ
  ‚îÇ [üîó OnlyFans]                   ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  ```
cloudflare_bypass: |
  **Cloudflare Challenge Handling**:

  Pornhub uses Cloudflare protection that requires JavaScript execution.
  Two approaches:

  **1. Headless Browser (Recommended)**:
  ```go
  import "github.com/chromedp/chromedp"

  func (p *PornhubProvider) fetchWithBrowser(
    ctx context.Context,
    url string,
  ) (string, error) {
    // Create browser context with proxy
    opts := []chromedp.ExecAllocatorOption{
      chromedp.ProxyServer(p.proxyURL),
      chromedp.UserAgent(p.userAgent),
      chromedp.Headless,
      chromedp.DisableGPU,
    }

    allocCtx, cancel := chromedp.NewExecAllocator(ctx, opts...)
    defer cancel()

    browserCtx, cancel := chromedp.NewContext(allocCtx)
    defer cancel()

    // Set timeout
    browserCtx, cancel = context.WithTimeout(browserCtx, p.browserTimeout)
    defer cancel()

    var html string
    err := chromedp.Run(browserCtx,
      chromedp.Navigate(url),
      chromedp.WaitReady("body", chromedp.ByQuery),
      chromedp.Sleep(2*time.Second),  // Wait for Cloudflare
      chromedp.OuterHTML("html", &html),
    )

    if err != nil {
      return "", fmt.Errorf("browser fetch: %w", err)
    }

    return html, nil
  }
  ```

  **2. Cookie Persistence**:
  ```go
  // After successful browser bypass, extract and reuse cookies
  var cookies []*network.Cookie
  chromedp.Run(ctx, chromedp.ActionFunc(func(ctx context.Context) error {
    cookies, _ = network.GetCookies().Do(ctx)
    return nil
  }))

  // Store cookies for reuse
  p.cookieJar.SetCookies(url, cookies)
  ```
metrics_extraction: |
  **Extracting Public Metrics**:
  ```go
  func (p *PornhubProvider) extractMetrics(doc *goquery.Document) *ChannelMetrics {
    metrics := &ChannelMetrics{}

    // Subscriber count (e.g., "1.2M subscribers")
    subText := doc.Find(".subscribersCount").Text()
    metrics.SubscriberCount = parseCount(subText)

    // Video count
    videoText := doc.Find(".videoCount").Text()
    metrics.VideoCount = parseIntFromText(videoText)

    // Total views
    viewsText := doc.Find(".viewsCount").Text()
    metrics.TotalViews = parseCount(viewsText)

    // Profile image
    if img, exists := doc.Find(".avatar img").Attr("src"); exists {
      metrics.ProfileImage = img
    }

    metrics.FetchedAt = time.Now()
    return metrics
  }

  // Parse "1.2M" ‚Üí 1200000
  func parseCount(s string) int64 {
    s = strings.TrimSpace(s)
    s = strings.ToLower(s)

    multiplier := int64(1)
    if strings.HasSuffix(s, "k") {
      multiplier = 1000
      s = strings.TrimSuffix(s, "k")
    } else if strings.HasSuffix(s, "m") {
      multiplier = 1000000
      s = strings.TrimSuffix(s, "m")
    }

    val, _ := strconv.ParseFloat(s, 64)
    return int64(val * float64(multiplier))
  }
  ```
link_role: |
  **LINK-Only Provider** (no content streaming)

  This integration explicitly does NOT provide any content.
  It only stores and verifies external links.

  **Purpose**:
  - Cross-reference performer identity
  - Provide "official" channel links to users
  - Track popularity metrics over time

  **Why LINK-Only**:
  - Legal compliance (no content redistribution)
  - Resource efficiency (no bandwidth for streaming)
  - User control (they choose to visit external site)

  **UI Behavior**:
  - Links open in new browser tab
  - User navigates Pornhub in their own browser
  - Revenge does not proxy or embed content
proxy_vpn_support: |
  **Proxy/VPN Routing** (REQUIRED)

  Proxy/VPN is **REQUIRED** for Pornhub due to:
  - Heavy Cloudflare protection
  - IP-based rate limiting
  - Geo-restrictions in some regions

  **Configuration**:
  ```yaml
  metadata:
    providers:
      pornhub:
        proxy:
          enabled: true             # REQUIRED
          type: tor
          url: socks5://127.0.0.1:9050
  ```

  **Browser Proxy**:
  Headless browser also routes through configured proxy.
error_handling: |
  **HTTP Error Codes**:
  - 403 Forbidden ‚Üí Cloudflare block, rotate proxy
  - 404 Not Found ‚Üí Channel doesn't exist
  - 503 Service Unavailable ‚Üí Cloudflare challenge
  - Connection timeout ‚Üí Proxy issue

  **Cloudflare Handling**:
  - If challenge detected ‚Üí use headless browser
  - If browser fails ‚Üí rotate proxy, retry
  - After 3 failures ‚Üí skip, retry later
unit_tests: |
  ```go
  func TestPornhub_ParseMetrics(t *testing.T) {
    html := `<html>
      <span class="subscribersCount">1.2M</span>
      <span class="videoCount">150</span>
    </html>`

    doc, _ := goquery.NewDocumentFromReader(strings.NewReader(html))
    metrics := extractMetrics(doc)

    assert.Equal(t, int64(1200000), metrics.SubscriberCount)
    assert.Equal(t, 150, metrics.VideoCount)
  }

  func TestPornhub_ParseCount(t *testing.T) {
    tests := []struct {
      input    string
      expected int64
    }{
      {"1.2M", 1200000},
      {"500K", 500000},
      {"1234", 1234},
    }

    for _, tt := range tests {
      result := parseCount(tt.input)
      assert.Equal(t, tt.expected, result)
    }
  }
  ```
integration_tests: |
  ```go
  func TestPornhub_LinkVerification(t *testing.T) {
    if testing.Short() {
      t.Skip("skipping integration test")
    }

    provider := NewPornhubProvider(httpFactory)

    // Test with known public channel
    status, err := provider.VerifyLink(
      context.Background(),
      "https://www.pornhub.com/pornstar/test-performer",
    )
    require.NoError(t, err)
    // Note: May be valid or 404 depending on if performer exists
  }
  ```
caching_strategy: |
  **Cache Layers**:
  - **L1**: In-memory (otter) for recent lookups (1 hour TTL)
  - **L2**: Dragonfly for metrics (7 day TTL)
  - **Database**: pornhub_channels for permanent storage

  **Long TTL Rationale**:
  - Metrics change slowly
  - Minimize scraping load
  - Cloudflare bypass is expensive

  **Cloudflare Session Caching**:
  - Cache valid cookies for 1 hour
  - Reuse session for multiple requests
  - Refresh session on 403 response
best_practices: |
  **Ethical Scraping**:
  - Very conservative rate limiting (0.5 req/sec)
  - Use proxy to avoid IP blocks
  - Only scrape public pages
  - No content redistribution

  **Cloudflare Handling**:
  - Use headless browser for challenges
  - Cache valid sessions
  - Rotate proxies on blocks
  - Implement exponential backoff

  **Data Handling**:
  - Store only links and metrics
  - No content caching
  - Verify links periodically
  - Mark broken links (don't delete)
