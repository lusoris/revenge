doc_title: TheNude Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> ENRICHMENT-only performer alias database for QAR content'
wiki_tagline: '> TheNude - Performer alias resolution for Whisparr/StashDB'
wiki_overview: ENRICHMENT-only metadata source for QAR performer alias resolution. Comprehensive alias database linking performers
  across different stage names. Physical attributes, measurements, and career data. **Web scraping** required (no official
  API). Used to resolve performer identity conflicts. **Proxy/VPN routing** recommended (via HTTP_CLIENT service).
sources:
- name: Go io
  url: https://pkg.go.dev/io
  note: Auto-resolved from go-io
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: PuerkitoBio/goquery
  url: https://pkg.go.dev/github.com/PuerkitoBio/goquery
  note: HTML parsing for web scraping
- name: golang.org/x/time
  url: https://pkg.go.dev/golang.org/x/time
  note: Rate limiting
design_refs:
- title: 03_METADATA_SYSTEM
  path: ../../../architecture/03_METADATA_SYSTEM.md
- title: WHISPARR (PRIMARY for QAR)
  path: ../../servarr/WHISPARR.md
- title: STASHDB
  path: ./STASHDB.md
- title: FREEONES
  path: ./FREEONES.md
- title: HTTP_CLIENT (proxy/VPN support)
  path: ../../../services/HTTP_CLIENT.md
- title: DATA_RECONCILIATION
  path: ../../../features/adult/DATA_RECONCILIATION.md
integration_name: TheNude
integration_id: thenude
external_service: TheNude
api_base_url: https://www.thenude.com
data_access_method: web_scraping
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1[[Data<br/>Reconciliation<br/>Service]]
      node2[(TheNude<br/>[Alias Database])]
      node3([HTTP_CLIENT<br/>[RECOMMENDED<br/>proxy/VPN]])
      node4["Rate Limiter<br/>[1 req/sec]"]
      node1 --> node2
      node2 --> node3
      node3 --> node4
  ```
api_details: |
  **Data Access**: Web scraping only
  **Base URL**: `https://www.thenude.com`
  **Authentication**: None required (public pages)
  **Rate Limit**: Self-imposed 1 request per second (conservative)

  **Scraping Targets**:
  - `/models/performer-name/` - Performer profile page
  - `/search?q=name` - Search results
  - `/models/` - Model directory

  **Page Structure**:
  - Performer name and aliases listed in header
  - Physical stats in sidebar
  - Career info (sites worked for) in content area
  - Cross-links to other databases

  **IMPORTANT**: No official API exists. Web scraping should:
  - Be very conservative (1 req/sec)
  - Use proxy/VPN
  - Cache extensively
  - Handle Cloudflare protection
database_schema: |
  **Schema**: `qar` (pirate-themed obfuscation)

  ```sql
  -- TheNude performer alias mappings
  CREATE TABLE qar.thenude_aliases (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Canonical performer (primary identity)
    performer_id UUID NOT NULL REFERENCES qar.crew(id),

    -- TheNude reference
    thenude_id VARCHAR(255) NOT NULL,       -- URL slug or ID
    thenude_name VARCHAR(255) NOT NULL,     -- Name as shown on TheNude

    -- All known aliases from TheNude
    aliases TEXT[] NOT NULL DEFAULT '{}',

    -- Physical attributes
    height_cm INT,
    weight_kg INT,
    measurements VARCHAR(50),
    cup_size VARCHAR(10),
    hair_color VARCHAR(50),
    eye_color VARCHAR(50),
    ethnicity VARCHAR(100),

    -- Career info
    birthdate DATE,
    career_start INT,
    career_end INT,                         -- NULL if active

    fetched_at TIMESTAMPTZ DEFAULT now(),
    expires_at TIMESTAMPTZ NOT NULL,

    UNIQUE(performer_id),
    UNIQUE(thenude_id)
  );
  CREATE INDEX idx_thenude_aliases_search ON qar.thenude_aliases USING GIN(aliases);

  -- Alias lookup table for fast resolution
  CREATE TABLE qar.performer_alias_index (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    alias VARCHAR(255) NOT NULL,            -- Any alias (lowercase, normalized)
    canonical_performer_id UUID NOT NULL REFERENCES qar.crew(id),
    source VARCHAR(50) NOT NULL,            -- 'thenude', 'freeones', 'stashdb'

    confidence FLOAT NOT NULL DEFAULT 1.0,  -- Match confidence (0.0-1.0)

    created_at TIMESTAMPTZ DEFAULT now(),

    UNIQUE(alias, source)
  );
  CREATE INDEX idx_alias_lookup ON qar.performer_alias_index(alias);
  ```
module_structure: |
  ```
  internal/metadata/providers/thenude/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ client.go                    # HTTP client with scraping
  â”œâ”€â”€ provider.go                  # Alias resolution provider
  â”œâ”€â”€ scraper.go                   # HTML parsing logic
  â”œâ”€â”€ aliases.go                   # Alias extraction and normalization
  â”œâ”€â”€ search.go                    # Performer search
  â”œâ”€â”€ ratelimit.go                 # Rate limiter (1/sec)
  â””â”€â”€ thenude_test.go
  ```
key_interfaces: |
  ```go
  // TheNude alias resolution provider
  type TheNudeProvider struct {
    httpFactory  httpclient.ClientFactory
    rateLimiter  *rate.Limiter
    cache        Cache
  }

  // Alias resolution provider interface
  type AliasResolutionProvider interface {
    // Search for performer
    SearchPerformer(ctx context.Context, name string) ([]SearchResult, error)

    // Get all aliases for a performer
    GetAliases(ctx context.Context, slug string) (*AliasResult, error)

    // Resolve alias to canonical performer
    ResolveAlias(ctx context.Context, alias string) (string, error)

    // Check if two names are aliases of same person
    AreAliases(ctx context.Context, name1, name2 string) (bool, float64, error)

    // Provider metadata
    ProviderName() string
  }

  // Search result
  type SearchResult struct {
    Slug      string `json:"slug"`
    Name      string `json:"name"`
    ImageURL  string `json:"image"`
    NumScenes int    `json:"num_scenes"`
  }

  // Alias resolution result
  type AliasResult struct {
    Slug          string   `json:"slug"`
    PrimaryName   string   `json:"primary_name"`
    Aliases       []string `json:"aliases"`
    NormalizedSet []string `json:"normalized_set"`  // Lowercase, no punctuation

    // Physical attributes (for verification)
    Height       int    `json:"height_cm,omitempty"`
    Weight       int    `json:"weight_kg,omitempty"`
    Measurements string `json:"measurements,omitempty"`
    HairColor    string `json:"hair_color,omitempty"`
    EyeColor     string `json:"eye_color,omitempty"`

    // Career info
    CareerStart int `json:"career_start,omitempty"`
    CareerEnd   int `json:"career_end,omitempty"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client
  - `github.com/PuerkitoBio/goquery` - HTML parsing
  - `golang.org/x/time/rate` - Rate limiting (1 req/sec)
  - `github.com/jackc/pgx/v5` - PostgreSQL driver
  - `github.com/riverqueue/river` - Background jobs
  - `github.com/lithammer/fuzzysearch` - Fuzzy name matching
  - `go.uber.org/fx` - Dependency injection

  **External**:
  - TheNude website (web scraping, no official API)

  **Internal Services**:
  - HTTP_CLIENT - Proxy/VPN routing (RECOMMENDED)
  - DATA_RECONCILIATION - Alias resolution consumer
env_vars: |
  ```bash
  # TheNude integration
  THENUDE_ENABLED=true

  # Rate limiting (very conservative for scraping)
  THENUDE_RATE_LIMIT=1
  THENUDE_RATE_WINDOW=1s

  # Caching
  THENUDE_CACHE_TTL=336h          # 14 days (alias data changes rarely)

  # Proxy/VPN (RECOMMENDED)
  THENUDE_PROXY_ENABLED=true
  THENUDE_PROXY_URL=socks5://127.0.0.1:9050
  ```
config_keys: |
  ```yaml
  metadata:
    providers:
      thenude:
        enabled: true
        rate_limit: 1
        rate_window: 1s
        cache_ttl: 336h              # 14 days

        # ENRICHMENT role (alias resolution)
        role: enrichment

        # Proxy/VPN support (RECOMMENDED)
        proxy:
          enabled: true
          type: tor
          url: socks5://127.0.0.1:9050

        # Scraping settings
        scraping:
          user_agent: "Mozilla/5.0 (compatible; RevengeBot/1.0)"
          respect_robots_txt: true
          max_retries: 3

        # Alias matching settings
        alias_matching:
          min_fuzzy_score: 0.85     # Minimum similarity for fuzzy match
          normalize_names: true     # Remove punctuation, lowercase
  ```
component_interaction: |
  **Alias Resolution Flow** (Data Reconciliation):
  1. Scene metadata has performer name "Performer X"
  2. Reconciliation service searches local database
  3. No exact match found
  4. Query TheNude for alias resolution
  5. TheNudeProvider.GetAliases(ctx, "performer-x")
  6. Returns: ["Performer X", "Stage Name Y", "Name Z"]
  7. Check if any alias matches existing performer
  8. If match found: link scene to existing performer
  9. If no match: create new performer with all aliases

  **Performer Merge Detection**:
  1. Two performers appear to be same person
  2. Call TheNudeProvider.AreAliases(ctx, "Name A", "Name B")
  3. Provider searches both names on TheNude
  4. If aliases overlap or point to same profile â†’ likely same person
  5. Return confidence score for merge decision

  **Scraping Flow**:
  1. Check rate limiter (1 req/sec - very conservative)
  2. Get HTTP client with proxy (recommended)
  3. Fetch profile: `GET /models/performer-name/`
  4. Parse HTML for alias list
  5. Extract physical attributes for verification
  6. Cache result for 14 days
alias_extraction: |
  **Alias Extraction from HTML**:
  ```go
  func (p *TheNudeProvider) extractAliases(doc *goquery.Document) []string {
    var aliases []string

    // TheNude lists aliases in specific format:
    // "Also known as: Alias1, Alias2, Alias3"
    alsoKnownAs := doc.Find(".also-known-as").Text()
    if alsoKnownAs != "" {
      // Parse comma-separated aliases
      parts := strings.Split(alsoKnownAs, ",")
      for _, part := range parts {
        alias := strings.TrimSpace(part)
        alias = strings.TrimPrefix(alias, "Also known as:")
        alias = strings.TrimSpace(alias)
        if alias != "" {
          aliases = append(aliases, alias)
        }
      }
    }

    // Also check for alternate name listings
    doc.Find(".aliases li").Each(func(i int, s *goquery.Selection) {
      alias := strings.TrimSpace(s.Text())
      if alias != "" {
        aliases = append(aliases, alias)
      }
    })

    return aliases
  }
  ```

  **Alias Normalization**:
  ```go
  func normalizeAlias(alias string) string {
    // Lowercase
    alias = strings.ToLower(alias)

    // Remove punctuation
    alias = regexp.MustCompile(`[^\w\s]`).ReplaceAllString(alias, "")

    // Collapse whitespace
    alias = regexp.MustCompile(`\s+`).ReplaceAllString(alias, " ")

    // Trim
    return strings.TrimSpace(alias)
  }

  // Check if two names are likely the same
  func areNamesEqual(name1, name2 string) bool {
    norm1 := normalizeAlias(name1)
    norm2 := normalizeAlias(name2)
    return norm1 == norm2
  }

  // Fuzzy match for similar names
  func fuzzyMatchScore(name1, name2 string) float64 {
    return fuzzysearch.Match(
      normalizeAlias(name1),
      normalizeAlias(name2),
    )
  }
  ```
data_reconciliation_integration: |
  **Integration with DATA_RECONCILIATION Service**:

  TheNude is a key data source for the reconciliation service that
  resolves performer identity conflicts across different metadata sources.

  **Scenario 1: Same Performer, Different Names**
  ```
  Whisparr: Scene with "Jane Doe"
  StashDB: Same scene with "J. Doe"
  ThePornDB: Same scene with "Jane D."

  â†’ TheNude lookup for "Jane Doe"
  â†’ Aliases: ["Jane Doe", "J. Doe", "Jane D.", "JD"]
  â†’ All three are the same performer
  â†’ Merge into single canonical record
  ```

  **Scenario 2: Name Collision Detection**
  ```
  Two different performers both called "Mia Rose"
  â†’ TheNude may have separate entries
  â†’ Physical attributes differ (height, etc.)
  â†’ Keep as separate performers
  â†’ Add distinguishing info (birthdate, career dates)
  ```

  **Integration Code**:
  ```go
  // In DATA_RECONCILIATION service
  func (s *ReconciliationService) resolvePerformerIdentity(
    ctx context.Context,
    name string,
    attrs *PerformerAttributes,
  ) (*Performer, error) {
    // 1. Check local alias index first
    if canonical, err := s.aliasIndex.Lookup(ctx, name); err == nil {
      return s.repo.GetPerformer(ctx, canonical)
    }

    // 2. Query TheNude for alias resolution
    aliases, err := s.thenude.GetAliases(ctx, slugify(name))
    if err != nil {
      // TheNude not available, fall back to fuzzy local search
      return s.fuzzySearch(ctx, name)
    }

    // 3. Check if any alias matches existing performer
    for _, alias := range aliases.Aliases {
      if performer, err := s.repo.FindPerformerByName(ctx, alias); err == nil {
        // Found match - add alias to index
        s.aliasIndex.Add(ctx, name, performer.ID, "thenude", 1.0)
        return performer, nil
      }
    }

    // 4. No existing match - create new performer
    performer := &Performer{
      Name:    aliases.PrimaryName,
      Aliases: aliases.Aliases,
    }
    return s.repo.CreatePerformer(ctx, performer)
  }
  ```
enrichment_role: |
  **ENRICHMENT-Only Provider** (alias resolution specialist)

  TheNude serves a specific purpose in the metadata pipeline:
  - **PRIMARY use**: Alias resolution for performer identity
  - **SECONDARY use**: Physical attribute verification
  - **NOT used for**: Scene metadata, images, or primary profiles

  **Why Separate from FreeOnes**:
  - TheNude specializes in alias tracking
  - More comprehensive alias lists than FreeOnes
  - Different data focus (identity vs. biography)
  - Used primarily by DATA_RECONCILIATION service

  **Data Flow**:
  ```
  Scene Scan â†’ Performer Name â†’ TheNude Alias Lookup
                                      â†“
                              Alias Resolution
                                      â†“
                              Canonical Performer ID
                                      â†“
                              Link to Performer Record
  ```
proxy_vpn_support: |
  **Proxy/VPN Routing** (RECOMMENDED)

  Similar to FreeOnes, proxy/VPN is recommended for TheNude scraping:
  - Conservative rate limiting (1 req/sec)
  - Tor provides IP rotation
  - Avoid server IP being blocked

  **Configuration**:
  ```yaml
  metadata:
    providers:
      thenude:
        proxy:
          enabled: true
          type: tor
          url: socks5://127.0.0.1:9050
  ```
error_handling: |
  **HTTP Error Codes**:
  - 404 Not Found â†’ Performer doesn't exist on TheNude
  - 403 Forbidden â†’ IP blocked
  - 429 Too Many Requests â†’ Rate limited
  - 503 Service Unavailable â†’ Cloudflare protection

  **Graceful Degradation**:
  - If TheNude unavailable â†’ fall back to local fuzzy matching
  - If performer not found â†’ return empty aliases, don't error
  - If scraping fails â†’ cache failure, retry later
unit_tests: |
  ```go
  func TestTheNude_ExtractAliases(t *testing.T) {
    html := `<html>
      <div class="also-known-as">Also known as: Jane D., JD</div>
    </html>`

    doc, _ := goquery.NewDocumentFromReader(strings.NewReader(html))
    aliases := extractAliases(doc)

    assert.ElementsMatch(t, []string{"Jane D.", "JD"}, aliases)
  }

  func TestTheNude_NormalizeAlias(t *testing.T) {
    tests := []struct {
      input    string
      expected string
    }{
      {"Jane Doe", "jane doe"},
      {"Jane D.", "jane d"},
      {"JANE  DOE", "jane doe"},
    }

    for _, tt := range tests {
      result := normalizeAlias(tt.input)
      assert.Equal(t, tt.expected, result)
    }
  }

  func TestTheNude_AreAliases(t *testing.T) {
    provider := NewTheNudeProvider(mockClient)

    // Mock: both names return same TheNude profile
    isAlias, confidence, err := provider.AreAliases(ctx, "Jane Doe", "J. Doe")

    require.NoError(t, err)
    assert.True(t, isAlias)
    assert.Greater(t, confidence, 0.8)
  }
  ```
integration_tests: |
  ```go
  func TestTheNude_AliasResolution(t *testing.T) {
    if testing.Short() {
      t.Skip("skipping integration test")
    }

    provider := NewTheNudeProvider(httpFactory)

    // Test with known performer who has multiple aliases
    aliases, err := provider.GetAliases(context.Background(), "test-performer")
    require.NoError(t, err)
    assert.NotEmpty(t, aliases.Aliases)
  }
  ```
caching_strategy: |
  **Cache Layers**:
  - **L1**: In-memory cache (otter) for alias lookups (1 hour TTL)
  - **L2**: Dragonfly cache for full profiles (14 day TTL)
  - **Database**: performer_alias_index for permanent storage

  **Long TTL Rationale**:
  - Performer aliases rarely change
  - Minimize scraping load
  - Alias data is stable once fetched

  **Cache Keys**:
  - `thenude:aliases:{slug}` - Full alias list
  - `thenude:search:{query}` - Search results
  - `thenude:resolve:{normalized_name}` - Quick alias resolution
best_practices: |
  **Scraping**:
  - Very conservative rate limit (1 req/sec)
  - Use proxy/VPN
  - Cache for 14+ days
  - Batch alias lookups when possible

  **Alias Matching**:
  - Always normalize names before comparison
  - Use fuzzy matching with minimum threshold (0.85)
  - Cross-reference with FreeOnes for verification
  - Store confidence scores for match quality

  **Data Quality**:
  - Verify aliases against physical attributes when possible
  - Flag potential name collisions for manual review
  - Keep audit log of alias resolutions
