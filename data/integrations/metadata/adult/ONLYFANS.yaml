doc_title: OnlyFans Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ğŸ”´
status_code_notes: '-'
status_linting: ğŸ”´
status_linting_notes: '-'
status_unit_testing: ğŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ğŸ”´
status_integration_testing_notes: '-'
technical_summary: '> LINK-ONLY performer subscription platform profiles for QAR content'
wiki_tagline: '> OnlyFans - Performer profile links for QAR'
wiki_overview: 'LINK-ONLY integration for QAR performer profiles. Stores verified OnlyFans profile URLs. Basic profile verification (existence check). **NO content access or subscription management** - only profile links. **Proxy/VPN recommended** (via HTTP_CLIENT service).'
sources:
- name: golang.org/x/time
  url: https://pkg.go.dev/golang.org/x/time
  note: Rate limiting
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Background verification jobs
design_refs:
- title: 03_METADATA_SYSTEM
  path: ../../../architecture/03_METADATA_SYSTEM.md
- title: FREEONES
  path: ./FREEONES.md
- title: HTTP_CLIENT (proxy/VPN support)
  path: ../../../services/HTTP_CLIENT.md
- title: ADULT_CONTENT_SYSTEM (QAR module)
  path: ../../../features/adult/ADULT_CONTENT_SYSTEM.md
integration_name: OnlyFans
integration_id: onlyfans
external_service: OnlyFans
api_base_url: https://onlyfans.com
data_access_method: link_verification
content_streaming: false
auth_method: none

architecture_diagram: |
  ```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Performer       â”‚
  â”‚   Profile Page    â”‚
  â”‚   (Revenge UI)    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚ Display social links
            â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   OnlyFans Link   â”‚â”€â”€â”€â†’ Opens in new tab
  â”‚   (verified URL)  â”‚     (user's browser)
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚ URL verification only
            â”‚ (NO content access)
            â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   OnlyFans.com    â”‚
  â”‚   (login wall)    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚  HTTP_CLIENT  â”‚
     â”‚  (recommended â”‚
     â”‚   proxy/VPN)  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  IMPORTANT: This integration does NOT access any content.
  Only verifies profile URLs exist.
  ```

integration_scope: |
  **WHAT THIS INTEGRATION DOES**:
  - âœ… Stores performer OnlyFans profile URLs
  - âœ… Verifies profile existence (HEAD request)
  - âœ… Provides "View on OnlyFans" links in UI

  **WHAT THIS INTEGRATION DOES NOT DO**:
  - âŒ Access any content (subscription required)
  - âŒ Manage subscriptions
  - âŒ Download any media
  - âŒ Authenticate users on OnlyFans
  - âŒ Extract profile metrics (not public)

  **OnlyFans Limitations**:
  - All content behind paywall
  - No public API
  - Profile pages mostly behind login
  - Only existence verification possible

api_details: |
  **Data Access**: HEAD request only
  **Base URL**: `https://onlyfans.com`
  **Authentication**: None required for verification
  **Rate Limit**: Self-imposed 0.5 req/sec

  **Verification Method**:
  ```
  HEAD https://onlyfans.com/{username}
  200 OK â†’ Profile exists
  404 Not Found â†’ Profile doesn't exist
  302 Redirect â†’ May still exist (redirect to login)
  ```

  **NO DATA EXTRACTION**:
  OnlyFans provides no public profile information.
  We can only verify that a profile URL is valid.

database_schema: |
  Uses shared `qar.social_profiles` table.

  ```sql
  -- Example OnlyFans entry
  INSERT INTO qar.social_profiles (
    performer_id,
    platform,
    profile_url,
    username,
    link_verified,
    last_checked
  ) VALUES (
    'performer-uuid',
    'onlyfans',
    'https://onlyfans.com/username',
    'username',
    true,
    now()
  );
  ```

module_structure: |
  ```
  internal/metadata/providers/social/onlyfans/
  â”œâ”€â”€ provider.go              # OnlyFans link provider
  â”œâ”€â”€ verification.go          # Profile URL verification
  â””â”€â”€ onlyfans_test.go
  ```

key_interfaces: |
  ```go
  // OnlyFans provider (verification only)
  type OnlyFansProvider struct {
    httpFactory httpclient.ClientFactory
    rateLimiter *rate.Limiter
  }

  func (p *OnlyFansProvider) Platform() string { return "onlyfans" }
  func (p *OnlyFansProvider) BaseURL() string { return "https://onlyfans.com" }

  // Verify username exists
  func (p *OnlyFansProvider) VerifyUsername(
    ctx context.Context,
    username string,
  ) (*ProfileInfo, error) {
    url := fmt.Sprintf("https://onlyfans.com/%s", username)

    // Use HEAD request only
    client, err := p.httpFactory.GetClientForService(ctx, "onlyfans")
    if err != nil {
      return nil, err
    }

    req, _ := http.NewRequestWithContext(ctx, "HEAD", url, nil)
    resp, err := client.Do(req)
    if err != nil {
      return nil, err
    }

    if resp.StatusCode == 200 || resp.StatusCode == 302 {
      // Profile likely exists
      return &ProfileInfo{
        Platform:   "onlyfans",
        Username:   username,
        ProfileURL: url,
        FetchedAt:  time.Now(),
      }, nil
    }

    if resp.StatusCode == 404 {
      return nil, ErrProfileNotFound
    }

    return nil, fmt.Errorf("unexpected status: %d", resp.StatusCode)
  }

  // No GetProfileInfo - OnlyFans has no public data
  func (p *OnlyFansProvider) GetProfileInfo(
    ctx context.Context,
    username string,
  ) (*ProfileInfo, error) {
    // Delegate to VerifyUsername - that's all we can do
    return p.VerifyUsername(ctx, username)
  }
  ```

dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client
  - `golang.org/x/time/rate` - Rate limiting
  - `github.com/riverqueue/river` - Background jobs
  - `go.uber.org/fx` - Dependency injection

  **External**:
  - OnlyFans website (URL verification only)

  **Internal Services**:
  - HTTP_CLIENT - Proxy/VPN routing

env_vars: |
  ```bash
  # OnlyFans integration
  ONLYFANS_ENABLED=true
  ONLYFANS_RATE_LIMIT=0.5
  ONLYFANS_CACHE_TTL=168h

  # Proxy (recommended)
  ONLYFANS_PROXY_ENABLED=true
  ONLYFANS_PROXY_URL=socks5://127.0.0.1:9050
  ```

config_keys: |
  ```yaml
  metadata:
    providers:
      onlyfans:
        enabled: true
        rate_limit: 0.5
        rate_window: 1s
        cache_ttl: 168h

        role: link
        provides_content: false

        proxy:
          enabled: true
          type: tor
          url: socks5://127.0.0.1:9050

        verification:
          enabled: true
          check_interval: 168h
  ```

component_interaction: |
  **Link Storage**:
  1. FreeOnes provides OnlyFans username for performer
  2. OnlyFansProvider.VerifyUsername(ctx, username)
  3. If 200/302: store link in social_profiles
  4. Display "OnlyFans" link on performer profile

  **Link Verification (Background)**:
  1. Weekly job checks all OnlyFans links
  2. HEAD request to each profile URL
  3. Update link_verified status
  4. Mark broken links

link_role: |
  **LINK-Only Provider**

  OnlyFans integration is extremely minimal:
  - Store profile URLs from other sources
  - Verify URL exists (HEAD request)
  - Display link in UI

  **UI Display**:
  ```
  External Links:
  [ğŸ’° OnlyFans] â†’ Opens onlyfans.com/username in new tab
  ```

  **User Experience**:
  - User clicks link
  - Opens OnlyFans in their browser
  - User manages their own subscription

error_handling: |
  **Expected Responses**:
  - 200 OK â†’ Profile exists
  - 302 Redirect â†’ Likely exists (redirect to login)
  - 404 Not Found â†’ Profile doesn't exist
  - 403 Forbidden â†’ Blocked (rotate proxy)
  - 429 Too Many Requests â†’ Rate limited

unit_tests: |
  ```go
  func TestOnlyFans_VerifyUsername(t *testing.T) {
    tests := []struct {
      status   int
      expected bool
    }{
      {200, true},
      {302, true},
      {404, false},
    }

    for _, tt := range tests {
      mockClient := &mockHTTPClient{
        response: &http.Response{StatusCode: tt.status},
      }

      provider := NewOnlyFansProvider(mockClient)
      info, err := provider.VerifyUsername(ctx, "testuser")

      if tt.expected {
        require.NoError(t, err)
        assert.Equal(t, "testuser", info.Username)
      } else {
        assert.Error(t, err)
      }
    }
  }
  ```

best_practices: |
  **OnlyFans Integration**:
  - Keep it minimal (verification only)
  - Accept that no metrics are available
  - Use proxy to avoid blocks
  - Source links from FreeOnes/StashDB
  - Don't attempt content access
