doc_title: OnlyFans Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: ‚úÖ Complete
status_design: ‚úÖ
status_design_notes: '-'
status_sources: ‚úÖ
status_sources_notes: '-'
status_instructions: ‚úÖ
status_instructions_notes: '-'
status_code: üî¥
status_code_notes: '-'
status_linting: üî¥
status_linting_notes: '-'
status_unit_testing: üî¥
status_unit_testing_notes: '-'
status_integration_testing: üî¥
status_integration_testing_notes: '-'
technical_summary: '> LINK-ONLY performer subscription platform profiles for QAR content'
wiki_tagline: '> OnlyFans - Performer profile links for QAR'
wiki_overview: LINK-ONLY integration for QAR performer profiles. Stores verified OnlyFans profile URLs. Basic profile verification
  (existence check). **NO content access or subscription management** - only profile links. **Proxy/VPN recommended** (via
  HTTP_CLIENT service).
sources:
- name: golang.org/x/time
  url: https://pkg.go.dev/golang.org/x/time
  note: Rate limiting
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Background verification jobs
design_refs:
- title: 03_METADATA_SYSTEM
  path: ../../../architecture/03_METADATA_SYSTEM.md
- title: FREEONES
  path: ./FREEONES.md
- title: HTTP_CLIENT (proxy/VPN support)
  path: ../../../services/HTTP_CLIENT.md
- title: ADULT_CONTENT_SYSTEM (QAR module)
  path: ../../../features/adult/ADULT_CONTENT_SYSTEM.md
integration_name: OnlyFans
integration_id: onlyfans
external_service: OnlyFans
api_base_url: https://onlyfans.com
data_access_method: link_verification
content_streaming: false
auth_method: none
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1["Performer<br/>Profile Page<br/>[Revenge UI]"]
      node2["OnlyFans Link<br/>[verified URL]"]
      node3["OnlyFans.com<br/>[login wall]"]
      node4([HTTP_CLIENT<br/>[recommended<br/>proxy/VPN]])
      node1 --> node2
      node2 --> node3
      node3 --> node4
  ```
integration_scope: |
  **WHAT THIS INTEGRATION DOES**:
  - ‚úÖ Stores performer OnlyFans profile URLs
  - ‚úÖ Verifies profile existence (HEAD request)
  - ‚úÖ Provides "View on OnlyFans" links in UI

  **WHAT THIS INTEGRATION DOES NOT DO**:
  - ‚ùå Access any content (subscription required)
  - ‚ùå Manage subscriptions
  - ‚ùå Download any media
  - ‚ùå Authenticate users on OnlyFans
  - ‚ùå Extract profile metrics (not public)

  **OnlyFans Limitations**:
  - All content behind paywall
  - No public API
  - Profile pages mostly behind login
  - Only existence verification possible
api_details: |
  **Data Access**: HEAD request only
  **Base URL**: `https://onlyfans.com`
  **Authentication**: None required for verification
  **Rate Limit**: Self-imposed 0.5 req/sec

  **Verification Method**:
  ```
  HEAD https://onlyfans.com/{username}
  200 OK ‚Üí Profile exists
  404 Not Found ‚Üí Profile doesn't exist
  302 Redirect ‚Üí May still exist (redirect to login)
  ```

  **NO DATA EXTRACTION**:
  OnlyFans provides no public profile information.
  We can only verify that a profile URL is valid.
database_schema: |
  Uses shared `qar.social_profiles` table.

  ```sql
  -- Example OnlyFans entry
  INSERT INTO qar.social_profiles (
    performer_id,
    platform,
    profile_url,
    username,
    link_verified,
    last_checked
  ) VALUES (
    'performer-uuid',
    'onlyfans',
    'https://onlyfans.com/username',
    'username',
    true,
    now()
  );
  ```
module_structure: |
  ```
  internal/metadata/providers/social/onlyfans/
  ‚îú‚îÄ‚îÄ provider.go              # OnlyFans link provider
  ‚îú‚îÄ‚îÄ verification.go          # Profile URL verification
  ‚îî‚îÄ‚îÄ onlyfans_test.go
  ```
key_interfaces: |
  ```go
  // OnlyFans provider (verification only)
  type OnlyFansProvider struct {
    httpFactory httpclient.ClientFactory
    rateLimiter *rate.Limiter
  }

  func (p *OnlyFansProvider) Platform() string { return "onlyfans" }
  func (p *OnlyFansProvider) BaseURL() string { return "https://onlyfans.com" }

  // Verify username exists
  func (p *OnlyFansProvider) VerifyUsername(
    ctx context.Context,
    username string,
  ) (*ProfileInfo, error) {
    url := fmt.Sprintf("https://onlyfans.com/%s", username)

    // Use HEAD request only
    client, err := p.httpFactory.GetClientForService(ctx, "onlyfans")
    if err != nil {
      return nil, err
    }

    req, _ := http.NewRequestWithContext(ctx, "HEAD", url, nil)
    resp, err := client.Do(req)
    if err != nil {
      return nil, err
    }

    if resp.StatusCode == 200 || resp.StatusCode == 302 {
      // Profile likely exists
      return &ProfileInfo{
        Platform:   "onlyfans",
        Username:   username,
        ProfileURL: url,
        FetchedAt:  time.Now(),
      }, nil
    }

    if resp.StatusCode == 404 {
      return nil, ErrProfileNotFound
    }

    return nil, fmt.Errorf("unexpected status: %d", resp.StatusCode)
  }

  // No GetProfileInfo - OnlyFans has no public data
  func (p *OnlyFansProvider) GetProfileInfo(
    ctx context.Context,
    username string,
  ) (*ProfileInfo, error) {
    // Delegate to VerifyUsername - that's all we can do
    return p.VerifyUsername(ctx, username)
  }
  ```
dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client
  - `golang.org/x/time/rate` - Rate limiting
  - `github.com/riverqueue/river` - Background jobs
  - `go.uber.org/fx` - Dependency injection

  **External**:
  - OnlyFans website (URL verification only)

  **Internal Services**:
  - HTTP_CLIENT - Proxy/VPN routing
env_vars: |
  ```bash
  # OnlyFans integration
  ONLYFANS_ENABLED=true
  ONLYFANS_RATE_LIMIT=0.5
  ONLYFANS_CACHE_TTL=168h

  # Proxy (recommended)
  ONLYFANS_PROXY_ENABLED=true
  ONLYFANS_PROXY_URL=socks5://127.0.0.1:9050
  ```
config_keys: |
  ```yaml
  metadata:
    providers:
      onlyfans:
        enabled: true
        rate_limit: 0.5
        rate_window: 1s
        cache_ttl: 168h

        role: link
        provides_content: false

        proxy:
          enabled: true
          type: tor
          url: socks5://127.0.0.1:9050

        verification:
          enabled: true
          check_interval: 168h
  ```
component_interaction: |
  **Link Storage**:
  1. FreeOnes provides OnlyFans username for performer
  2. OnlyFansProvider.VerifyUsername(ctx, username)
  3. If 200/302: store link in social_profiles
  4. Display "OnlyFans" link on performer profile

  **Link Verification (Background)**:
  1. Weekly job checks all OnlyFans links
  2. HEAD request to each profile URL
  3. Update link_verified status
  4. Mark broken links
link_role: |
  **LINK-Only Provider**

  OnlyFans integration is extremely minimal:
  - Store profile URLs from other sources
  - Verify URL exists (HEAD request)
  - Display link in UI

  **UI Display**:
  ```
  External Links:
  [üí∞ OnlyFans] ‚Üí Opens onlyfans.com/username in new tab
  ```

  **User Experience**:
  - User clicks link
  - Opens OnlyFans in their browser
  - User manages their own subscription
error_handling: |
  **Expected Responses**:
  - 200 OK ‚Üí Profile exists
  - 302 Redirect ‚Üí Likely exists (redirect to login)
  - 404 Not Found ‚Üí Profile doesn't exist
  - 403 Forbidden ‚Üí Blocked (rotate proxy)
  - 429 Too Many Requests ‚Üí Rate limited
unit_tests: |
  ```go
  func TestOnlyFans_VerifyUsername(t *testing.T) {
    tests := []struct {
      status   int
      expected bool
    }{
      {200, true},
      {302, true},
      {404, false},
    }

    for _, tt := range tests {
      mockClient := &mockHTTPClient{
        response: &http.Response{StatusCode: tt.status},
      }

      provider := NewOnlyFansProvider(mockClient)
      info, err := provider.VerifyUsername(ctx, "testuser")

      if tt.expected {
        require.NoError(t, err)
        assert.Equal(t, "testuser", info.Username)
      } else {
        assert.Error(t, err)
      }
    }
  }
  ```
best_practices: |
  **OnlyFans Integration**:
  - Keep it minimal (verification only)
  - Accept that no metrics are available
  - Use proxy to avoid blocks
  - Source links from FreeOnes/StashDB
  - Don't attempt content access
