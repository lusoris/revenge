doc_title: TheTVDB Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> SUPPLEMENTARY metadata provider (fallback + enrichment) for TV shows'
wiki_tagline: '> Direct TheTVDB API - Supplementary to Sonarr'
wiki_overview: 'SUPPLEMENTARY metadata source for TV shows. Used as: (1) **Fallback** when Sonarr not setup, unreachable,
  or lacks metadata, (2) **Enrichment** for additional data not cached by Sonarr. Free API with JWT authentication. Strong
  anime support with multiple episode ordering (aired/DVD/absolute). Multi-language metadata. **Optional proxy/VPN routing**
  for restricted regions (via HTTP_CLIENT service).'
sources:
- name: go-blurhash
  url: https://pkg.go.dev/github.com/bbrks/go-blurhash
  note: Auto-resolved from go-blurhash
- name: pgx PostgreSQL Driver
  url: https://pkg.go.dev/github.com/jackc/pgx/v5
  note: Auto-resolved from pgx
- name: PostgreSQL Arrays
  url: https://www.postgresql.org/docs/current/arrays.html
  note: Auto-resolved from postgresql-arrays
- name: PostgreSQL JSON Functions
  url: https://www.postgresql.org/docs/current/functions-json.html
  note: Auto-resolved from postgresql-json
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: TheTVDB API
  url: https://thetvdb.github.io/v4-api/
  note: Auto-resolved from thetvdb
- name: Typesense API
  url: https://typesense.org/docs/latest/api/
  note: Auto-resolved from typesense
- name: Typesense Go Client
  url: https://github.com/typesense/typesense-go
  note: Auto-resolved from typesense-go
design_refs:
- title: 03_METADATA_SYSTEM
  path: ../../../architecture/03_METADATA_SYSTEM.md
- title: SONARR (PRIMARY for TV shows)
  path: ../../servarr/SONARR.md
- title: HTTP_CLIENT (proxy/VPN support)
  path: ../../../services/HTTP_CLIENT.md
- title: TVSHOW_MODULE
  path: ../../../features/video/TVSHOW_MODULE.md
integration_name: TheTVDB
integration_id: thetvdb
external_service: TheTVDB
auth_method: api_key
architecture_diagram: |-
  ```mermaid
  flowchart LR
      subgraph Layer1["Layer 1"]
          node1[["Revenge<br/>Metadata<br/>Service"]]
      end

      subgraph Layer2["Layer 2"]
          node2[("Sonarr<br/>(LOCAL cache)")]
          node3[("TheTVDB API<br/>(fallback +<br/>enrichment)")]
      end

      subgraph Layer3["Layer 3"]
          node4[("TheTVDB API<br/>(external)")]
      end

      subgraph Layer4["Layer 4"]
          node5[["JWT Token<br/>Manager"]]
      end

      %% Connections
      node1 --> node2
      node3 --> node4
      node4 --> node5

      %% Styling
      style Layer1 fill:#1976D2,stroke:#1976D2,color:#fff
      style Layer2 fill:#388E3C,stroke:#388E3C,color:#fff
      style Layer3 fill:#7B1FA2,stroke:#7B1FA2,color:#fff
      style Layer4 fill:#F57C00,stroke:#F57C00,color:#fff
  ```
api_details: |
  **API Version**: v4
  **Base URL**: `https://api4.thetvdb.com/v4`
  **Authentication**: JWT Bearer token (obtained via API key)
  **Rate Limit**: No official limit, but respect fair use (~1 request/second recommended)

  **Key Endpoints**:
  - `/login` - Get JWT token
  - `/search` - Search for TV shows
  - `/series/{id}` - Get series details
  - `/series/{id}/extended` - Get extended series details with episodes
  - `/series/{id}/episodes/default` - Get all episodes (paginated)
  - `/seasons/{id}/extended` - Get season details
  - `/episodes/{id}/extended` - Get episode details
  - `/artwork/{id}` - Get artwork details

  **Episode Ordering**:
  - `default` - Aired order (most common)
  - `dvd` - DVD release order
  - `absolute` - Absolute numbering (anime)
database_schema: |
  **Schema**: `public`

  ```sql
  -- TheTVDB episode mappings
  CREATE TABLE tvdb_episode_mappings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    tvshow_id UUID NOT NULL REFERENCES tvshows(id) ON DELETE CASCADE,
    episode_id UUID NOT NULL REFERENCES episodes(id) ON DELETE CASCADE,

    tvdb_series_id INTEGER NOT NULL,
    tvdb_episode_id INTEGER NOT NULL,

    -- Episode ordering variants
    aired_season INTEGER,
    aired_episode INTEGER,
    dvd_season INTEGER,
    dvd_episode INTEGER,
    absolute_episode INTEGER,

    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(episode_id)
  );
  CREATE INDEX idx_tvdb_mappings_series ON tvdb_episode_mappings(tvdb_series_id);
  CREATE INDEX idx_tvdb_mappings_episode ON tvdb_episode_mappings(tvdb_episode_id);

  -- JWT token storage
  CREATE TABLE provider_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    provider VARCHAR(50) NOT NULL,
    token_type VARCHAR(50) DEFAULT 'bearer',
    access_token TEXT NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,

    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(provider)
  );
  ```
module_structure: |
  ```
  internal/metadata/providers/tvdb/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ client.go                    # TheTVDB API client
  â”œâ”€â”€ auth.go                      # JWT token management
  â”œâ”€â”€ provider.go                  # Metadata provider interface impl
  â”œâ”€â”€ series.go                    # TV series metadata methods
  â”œâ”€â”€ episodes.go                  # Episode metadata methods
  â”œâ”€â”€ images.go                    # Image download
  â””â”€â”€ tvdb_test.go
  ```
key_interfaces: |
  ```go
  // TheTVDB provider implementation
  type TVDBProvider struct {
    client      *TVDBClient
    tokenMgr    *TokenManager
    cache       Cache
  }

  // Token manager (auto-refresh JWT)
  type TokenManager struct {
    apiKey      string
    token       string
    expiresAt   time.Time
    mu          sync.RWMutex
  }

  // Metadata provider interface
  type MetadataProvider interface {
    // Search
    SearchSeries(ctx context.Context, query string, year *int) ([]SeriesSearchResult, error)

    // Fetch details
    GetSeriesDetails(ctx context.Context, tvdbID int) (*SeriesMetadata, error)
    GetSeriesExtended(ctx context.Context, tvdbID int) (*SeriesExtendedMetadata, error)
    GetSeasonDetails(ctx context.Context, seasonID int) (*SeasonMetadata, error)
    GetEpisodeDetails(ctx context.Context, episodeID int) (*EpisodeMetadata, error)

    // Episodes (paginated)
    GetAllEpisodes(ctx context.Context, tvdbID int, ordering string) ([]EpisodeMetadata, error)

    // Images
    GetSeriesArtwork(ctx context.Context, tvdbID int) (*ArtworkSet, error)
  }

  // Series metadata structure
  type SeriesMetadata struct {
    TVDBID        int       `json:"id"`
    Name          string    `json:"name"`
    Overview      string    `json:"overview"`
    FirstAired    string    `json:"firstAired"`
    Status        string    `json:"status"`
    Genres        []Genre   `json:"genres"`
    Networks      []Network `json:"networks"`
    Image         string    `json:"image"`
    Banner        string    `json:"banner"`
    Rating        float64   `json:"rating"`
  }

  // Episode metadata
  type EpisodeMetadata struct {
    TVDBID         int     `json:"id"`
    SeriesID       int     `json:"seriesId"`
    Name           string  `json:"name"`
    Overview       string  `json:"overview"`
    Aired          string  `json:"aired"`
    Runtime        int     `json:"runtime"`
    AiredSeason    int     `json:"airedSeason"`
    AiredEpisode   int     `json:"airedEpisodeNumber"`
    DVDSeason      int     `json:"dvdSeason"`
    DVDEpisode     int     `json:"dvdEpisodeNumber"`
    AbsoluteNumber int     `json:"absoluteNumber"`
    Image          string  `json:"image"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client
  - `github.com/google/uuid` - UUID support
  - `github.com/jackc/pgx/v5` - PostgreSQL driver
  - `github.com/riverqueue/river` - Background jobs
  - `go.uber.org/fx` - Dependency injection

  **External APIs**:
  - TheTVDB API v4 (free tier with API key)
env_vars: |
  ```bash
  # TheTVDB API
  TVDB_API_KEY=your_api_key_here
  TVDB_PIN=optional_pin_for_premium

  # Episode ordering preference
  TVDB_DEFAULT_ORDERING=default  # 'default', 'dvd', 'absolute'

  # Caching
  TVDB_CACHE_TTL=24h
  ```
config_keys: |
  ```yaml
  metadata:
    providers:
      tvdb:
        enabled: true
        api_key: ${TVDB_API_KEY}
        pin: ${TVDB_PIN}
        default_ordering: default
        cache_ttl: 24h

        # SUPPLEMENTARY role configuration
        role: supplementary  # fallback + enrichment

        # Proxy/VPN support (OPTIONAL - must be setup and enabled)
        proxy:
          enabled: false           # Must explicitly enable
          type: tor                # 'http', 'socks5', 'tor', 'vpn'
          url: socks5://127.0.0.1:9050  # Tor SOCKS5 proxy (if type=tor/socks5)
          interface: tun0          # VPN interface (if type=vpn)
  ```
component_interaction: |
  **JWT Authentication Flow**:
  1. Provider initializes, needs JWT token
  2. TokenManager checks if token exists and is valid
  3. If expired/missing, POST to /login with API key
  4. Receive JWT token with expiry (usually 30 days)
  5. Store token in database (provider_tokens table)
  6. Use token in Authorization header for all requests
  7. Auto-refresh token before expiry

  **TV Show Metadata Fetch**:
  1. User adds TV show folder to library
  2. Library scanner extracts show name from folder
  3. Metadata service calls TVDBProvider.SearchSeries(name)
  4. Search /search endpoint with query
  5. Return top match with TVDB series ID
  6. Call GetSeriesExtended(tvdbID) for full details
  7. Parse series metadata + all episodes
  8. Map episodes to seasons using aired ordering
  9. Store external_id mapping (tvdb:12345 â†’ tvshow UUID)
  10. Store all episode mappings in tvdb_episode_mappings

  **Episode Ordering Handling**:
  1. Fetch episode list from API
  2. Store all ordering variants (aired, DVD, absolute)
  3. Allow user to choose ordering preference per show
  4. Display episodes in chosen order
  5. Fall back to aired order if preferred not available
api_request_examples: |
  **Authenticate**:
  ```
  POST https://api4.thetvdb.com/v4/login
  Content-Type: application/json

  {
    "apikey": "your_api_key_here"
  }
  ```

  **Response**:
  ```json
  {
    "data": {
      "token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9..."
    }
  }
  ```

  **Search Series**:
  ```
  GET https://api4.thetvdb.com/v4/search?query=Breaking%20Bad&type=series
  Authorization: Bearer {token}
  ```

  **Response**:
  ```json
  {
    "data": [
      {
        "objectID": "series-81189",
        "id": "81189",
        "name": "Breaking Bad",
        "overview": "A high school chemistry teacher...",
        "image_url": "https://artworks.thetvdb.com/banners/posters/81189-1.jpg"
      }
    ]
  }
  ```

  **Get Series Extended** (includes episodes):
  ```
  GET https://api4.thetvdb.com/v4/series/81189/extended?meta=episodes
  Authorization: Bearer {token}
  ```
supported_metadata: |
  **TV Series**:
  - Series name and original name
  - Overview/description
  - First and last air dates
  - Status (Continuing, Ended)
  - Genres
  - Networks
  - Episode count and runtime
  - Posters, banners, backgrounds
  - IMDb ID, Zap2it ID
  - Content ratings

  **Episodes**:
  - Episode name
  - Overview
  - Air date
  - Runtime
  - Multiple numbering schemes (aired, DVD, absolute)
  - Episode images
  - Guest stars
  - Writer and director credits

  **Seasons**:
  - Season posters
  - Season type (aired, DVD, absolute)
episode_ordering_strategy: |
  **Ordering Types**:
  - **Aired** (default): Episodes in broadcast order
  - **DVD**: Episodes in DVD release order (sometimes different from aired)
  - **Absolute**: Continuous numbering (common for anime, no seasons)

  **Storage Strategy**:
  - Store all three ordering types in tvdb_episode_mappings
  - Let user choose per-show which ordering to use
  - Display episodes in chosen order
  - Default to aired order for most shows

  **Example** (anime with absolute numbering):
  - Aired: S01E01
  - Absolute: E001 (continues across seasons)
  - User chooses "absolute" â†’ episodes shown as E001, E002, E003...
token_management: |
  **JWT Token Lifecycle**:
  1. Request token with POST /login (API key in body)
  2. Receive JWT token with ~30 day expiry
  3. Store in provider_tokens table with expiry timestamp
  4. Use token in all API requests: `Authorization: Bearer {token}`
  5. Check expiry before each request
  6. Refresh token proactively 24 hours before expiry
  7. Handle 401 Unauthorized by refreshing token and retrying

  **Token Refresh Job**:
  - River background job runs daily
  - Query provider_tokens WHERE expires_at < now() + 24h
  - Refresh tokens nearing expiry
  - Update database with new token and expiry
unit_tests: |
  ```go
  func TestTVDBProvider_TokenManagement(t *testing.T) {
    // Test JWT token fetch and refresh
  }

  func TestTVDBProvider_SearchSeries(t *testing.T) {
    // Test series search with mock HTTP client
  }

  func TestTVDBProvider_EpisodeOrdering(t *testing.T) {
    // Test all three ordering types
  }
  ```
integration_tests: |
  ```go
  func TestTVDB_FullWorkflow(t *testing.T) {
    // Use real TheTVDB API (with test key)
    // Test auth, search, fetch, episodes
  }
  ```
anime_support: |
  **Absolute Numbering**:
  - Anime often uses continuous numbering (E001, E002...) instead of seasons
  - TheTVDB provides absolute numbers for these shows
  - Store absolute_episode in database
  - Allow users to toggle between season and absolute views

  **Example** (One Piece):
  - Aired: S01E01, S01E02, ..., S02E01...
  - Absolute: E001, E002, E003, E004... (continuous)
  - Better for anime tracking apps
error_handling: |
  **HTTP Error Codes**:
  - 401 Unauthorized â†’ JWT expired or invalid (refresh and retry)
  - 404 Not Found â†’ Series/episode doesn't exist in TheTVDB
  - 429 Too Many Requests â†’ Rate limit (wait and retry)
  - 500+ Server Errors â†’ TheTVDB outage (retry with exponential backoff)

  **Retry Strategy**:
  - 401: Refresh JWT token, retry once
  - 429, 500+: Exponential backoff (1s, 2s, 4s, max 3 attempts)
  - 404: Don't retry, log and skip
  - Network errors: Retry once after 5 seconds
performance_optimization: |
  **Extended Endpoints**:
  - Use `/series/{id}/extended?meta=episodes` to fetch series + all episodes in one request
  - Reduces API calls significantly (1 instead of 1 + N episodes)

  **Pagination Handling**:
  - Some series have 500+ episodes (e.g., One Piece)
  - API returns paginated results (100 episodes per page)
  - Fetch all pages and combine results
  - Cache full episode list for 24 hours

  **Artwork Optimization**:
  - TheTVDB provides multiple artwork types (poster, banner, background, clearlogo)
  - Fetch only needed types to reduce bandwidth
  - Download highest quality, generate thumbnails locally
supplementary_role: |
  **SUPPLEMENTARY Metadata Provider** (not primary)

  **PRIMARY source**: Sonarr
  - Sonarr aggregates TheTVDB metadata locally
  - Revenge queries Sonarr FIRST for all TV show metadata

  **TheTVDB API used as SUPPLEMENTARY in two scenarios**:

  **1. FALLBACK** (when PRIMARY unavailable):
  - Sonarr not setup or configured
  - Sonarr unreachable (network error, service down)
  - Sonarr lacks specific metadata (show not in their cache)

  **2. ENRICHMENT** (additional data):
  - Multi-language translations not cached by Sonarr
  - Alternate episode ordering (DVD, absolute for anime)
  - Extended episode metadata (guest stars, writers, directors)
  - Additional artwork variants
  - Episode images (stills) not cached by Sonarr

  **Implementation Pattern**:
  ```go
  func (s *MetadataService) GetTVShowMetadata(ctx context.Context, tvdbID int) (*TVShow, error) {
    // 1. Try PRIMARY source (Sonarr)
    if s.sonarr.IsConfigured() {
      show, err := s.sonarr.GetSeries(ctx, tvdbID)
      if err == nil {
        return show, nil
      }
      log.Warn("Sonarr failed, falling back to TheTVDB", "error", err)
    }

    // 2. FALLBACK to TheTVDB API (via optional proxy/VPN)
    show, err := s.tvdb.GetSeriesExtended(ctx, tvdbID)
    if err != nil {
      return nil, fmt.Errorf("both PRIMARY (Sonarr) and SUPPLEMENTARY (TheTVDB) failed: %w", err)
    }

    // 3. Optionally sync to Sonarr for future queries
    go s.sonarr.AddSeriesIfNotExists(context.Background(), show)

    return show, nil
  }
  ```
proxy_vpn_support: |
  **Optional Proxy/VPN Routing** (via HTTP_CLIENT service)

  TheTVDB API calls can be routed through proxy/VPN for:
  - **Region restrictions**: Access TheTVDB from restricted countries
  - **Privacy**: Hide server IP from TheTVDB
  - **Network routing**: Route through specific VPN tunnels

  **IMPORTANT**: Proxy/VPN is **OPTIONAL**
  - Must be explicitly setup and enabled in config
  - NOT required for basic TheTVDB functionality
  - Disabled by default

  **Configuration**:
  ```yaml
  metadata:
    providers:
      tvdb:
        proxy:
          enabled: true              # Must explicitly enable
          type: tor                  # http, socks5, tor, vpn
          url: socks5://127.0.0.1:9050  # For http/socks5/tor
          interface: tun0            # For vpn type
  ```

  **Implementation** (via HTTP_CLIENT service):
  ```go
  import "internal/service/httpclient"

  // Get HTTP client with proxy support
  client, err := httpClientFactory.GetClientForService(ctx, "tvdb")
  if err != nil {
    return nil, fmt.Errorf("failed to get HTTP client: %w", err)
  }

  // Use client for TheTVDB API requests
  resp, err := client.Get("https://api4.thetvdb.com/v4/series/81189")
  ```

  **Proxy Types**:
  - **http/https**: Standard HTTP proxy
  - **socks5**: SOCKS5 proxy (supports Tor)
  - **tor**: Convenience alias for Tor SOCKS5 (127.0.0.1:9050)
  - **vpn**: Bind to specific VPN network interface

  **See**: [HTTP_CLIENT.yaml](../../../services/HTTP_CLIENT.yaml) for proxy/VPN implementation details
