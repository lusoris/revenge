doc_title: OMDb (Open Movie Database) Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> SUPPLEMENTARY ratings enrichment provider (IMDb/RT/Metacritic)'
wiki_tagline: '> Multi-source ratings enrichment (IMDb, Rotten Tomatoes, Metacritic)'
wiki_overview: 'SUPPLEMENTARY ratings enrichment for movies/TV shows. Provides: (1) IMDb ratings + vote counts, (2) Rotten
  Tomatoes scores (Tomatometer/Audience), (3) Metacritic scores, (4) Box office data, (5) Awards info. Free API with 1000
  req/day limit. **Optional proxy/VPN routing** for restricted regions (via HTTP_CLIENT service). Primary use: Display multi-source
  ratings on detail pages.'
sources:
- name: OMDb API
  url: https://www.omdbapi.com/
  note: Auto-resolved from omdb
- name: pgx PostgreSQL Driver
  url: https://pkg.go.dev/github.com/jackc/pgx/v5
  note: Auto-resolved from pgx
- name: PostgreSQL Arrays
  url: https://www.postgresql.org/docs/current/arrays.html
  note: Auto-resolved from postgresql-arrays
- name: PostgreSQL JSON Functions
  url: https://www.postgresql.org/docs/current/functions-json.html
  note: Auto-resolved from postgresql-json
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
design_refs:
- title: 03_METADATA_SYSTEM
  path: ../../../architecture/03_METADATA_SYSTEM.md
- title: HTTP_CLIENT (proxy/VPN support)
  path: ../../../services/HTTP_CLIENT.md
- title: MOVIE_MODULE
  path: ../../../features/video/MOVIE_MODULE.md
- title: TVSHOW_MODULE
  path: ../../../features/video/TVSHOW_MODULE.md
- title: TRAKT (alternative ratings source)
  path: ../../scrobbling/TRAKT.md
integration_name: OMDb (Open Movie Database)
integration_id: omdb_open_movie_database
external_service: OMDb (Open Movie Database)
auth_method: api_key
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1["Metadata<br/>Service"]
      node2["OMDb<br/>Provider"]
      node3["OMDb API<br/>(External)"]
      node4["Rate Limiter<br/>(1000/day)"]
      node1 --> node2
      node2 --> node3
      node3 --> node4
  ```
api_details: |
  **API Version**: v1
  **Base URL**: `http://www.omdbapi.com`
  **Authentication**: API Key via query parameter `?apikey=xxx`
  **Rate Limit**: 1,000 requests per day (free tier), 100,000/day (paid)

  **Key Endpoints**:
  - `/?i={imdb_id}` - Get details by IMDb ID
  - `/?t={title}&y={year}` - Search by title and year
  - `/?s={search}` - Search for movies

  **Supported Data**:
  - IMDb ratings
  - Rotten Tomatoes scores
  - Metacritic scores
  - Awards and nominations
  - Box office revenue
database_schema: |
  **Schema**: `public`

  ```sql
  -- Extended ratings storage
  CREATE TABLE external_ratings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    content_type VARCHAR(50) NOT NULL,     -- 'movie', 'tvshow'
    content_id UUID NOT NULL,

    -- Rating sources
    imdb_rating DECIMAL(3,1),
    imdb_votes INTEGER,
    rotten_tomatoes_rating INTEGER,        -- 0-100
    metacritic_rating INTEGER,             -- 0-100

    -- Box office
    box_office_gross BIGINT,               -- in USD cents

    -- Awards
    awards_text TEXT,

    fetched_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(content_type, content_id)
  );
  CREATE INDEX idx_external_ratings_imdb ON external_ratings(imdb_rating DESC) WHERE imdb_rating IS NOT NULL;
  ```
module_structure: |
  ```
  internal/metadata/providers/omdb/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ client.go                    # OMDb API client
  â”œâ”€â”€ provider.go                  # Metadata provider interface impl
  â”œâ”€â”€ ratings.go                   # Rating fetch methods
  â”œâ”€â”€ ratelimit.go                 # Rate limiter (1000/day)
  â””â”€â”€ omdb_test.go
  ```
key_interfaces: |
  ```go
  // OMDb provider implementation
  type OMDbProvider struct {
    client      *OMDbClient
    rateLimiter *DailyRateLimiter
    cache       Cache
  }

  // Daily rate limiter (1000 requests per day)
  type DailyRateLimiter struct {
    limit     int
    used      int
    resetTime time.Time
    mu        sync.Mutex
  }

  // Metadata provider interface
  type MetadataProvider interface {
    // Fetch by IMDb ID
    GetByIMDbID(ctx context.Context, imdbID string) (*OMDbMetadata, error)

    // Search by title
    SearchByTitle(ctx context.Context, title string, year *int) (*OMDbMetadata, error)

    // Get ratings only (lightweight)
    GetRatings(ctx context.Context, imdbID string) (*Ratings, error)
  }

  // OMDb metadata structure
  type OMDbMetadata struct {
    Title          string  `json:"Title"`
    Year           string  `json:"Year"`
    Rated          string  `json:"Rated"`
    Released       string  `json:"Released"`
    Runtime        string  `json:"Runtime"`
    Genre          string  `json:"Genre"`
    Director       string  `json:"Director"`
    Actors         string  `json:"Actors"`
    Plot           string  `json:"Plot"`
    Awards         string  `json:"Awards"`
    IMDbRating     string  `json:"imdbRating"`
    IMDbVotes      string  `json:"imdbVotes"`
    IMDbID         string  `json:"imdbID"`
    BoxOffice      string  `json:"BoxOffice"`
    Ratings        []Rating `json:"Ratings"`
  }

  type Rating struct {
    Source string `json:"Source"`   // "Internet Movie Database", "Rotten Tomatoes", "Metacritic"
    Value  string `json:"Value"`    // "8.8/10", "87%", "82/100"
  }
  ```
dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client
  - `github.com/google/uuid` - UUID support
  - `github.com/jackc/pgx/v5` - PostgreSQL driver
  - `go.uber.org/fx` - Dependency injection

  **External APIs**:
  - OMDb API (free tier: 1,000 requests/day)
env_vars: |
  ```bash
  # OMDb API
  OMDB_API_KEY=your_api_key_here

  # Rate limiting
  OMDB_DAILY_LIMIT=1000

  # Caching
  OMDB_CACHE_TTL=168h  # 7 days
  ```
config_keys: |
  ```yaml
  metadata:
    providers:
      omdb:
        enabled: true
        api_key: ${OMDB_API_KEY}
        daily_limit: 1000
        cache_ttl: 168h  # 7 days
  ```
component_interaction: |
  **Ratings Fetch Workflow**:
  1. Movie already has TMDb metadata with IMDb ID
  2. Metadata service calls OMDbProvider.GetRatings(imdbID)
  3. Check daily rate limit (1000/day)
  4. Check cache for existing ratings (7 day TTL)
  5. If not cached, make API request: /?i={imdb_id}
  6. Parse JSON response
  7. Extract ratings from multiple sources
  8. Store in external_ratings table
  9. Cache response for 7 days
  10. Return ratings to display on movie detail page

  **Fallback Metadata**:
  1. TMDb metadata fetch fails
  2. Try OMDb as fallback provider
  3. Search by title and year
  4. Parse OMDb response into internal metadata format
  5. Less comprehensive than TMDb, but better than nothing

  **Daily Rate Limit Handling**:
  - Track daily request count in memory
  - Reset counter at midnight UTC
  - If limit reached, return cached data only
  - Log warning when approaching limit (90%)
  - Admins can monitor usage via metrics
api_request_examples: |
  **Get by IMDb ID**:
  ```
  GET http://www.omdbapi.com/?i=tt1375666&apikey=xxx
  ```

  **Response**:
  ```json
  {
    "Title": "Inception",
    "Year": "2010",
    "Rated": "PG-13",
    "Released": "16 Jul 2010",
    "Runtime": "148 min",
    "Genre": "Action, Sci-Fi, Thriller",
    "Director": "Christopher Nolan",
    "Actors": "Leonardo DiCaprio, Joseph Gordon-Levitt, Elliot Page",
    "Plot": "A thief who steals corporate secrets...",
    "Awards": "Won 4 Oscars. 157 wins & 220 nominations total",
    "imdbRating": "8.8",
    "imdbVotes": "2,500,000",
    "imdbID": "tt1375666",
    "BoxOffice": "$292,576,195",
    "Ratings": [
      {
        "Source": "Internet Movie Database",
        "Value": "8.8/10"
      },
      {
        "Source": "Rotten Tomatoes",
        "Value": "87%"
      },
      {
        "Source": "Metacritic",
        "Value": "74/100"
      }
    ]
  }
  ```

  **Search by Title**:
  ```
  GET http://www.omdbapi.com/?t=Inception&y=2010&apikey=xxx
  ```
rating_parsing: |
  **Rating Sources**:
  - **IMDb**: "8.8/10" â†’ Parse to 8.8
  - **Rotten Tomatoes**: "87%" â†’ Parse to 87 (0-100 scale)
  - **Metacritic**: "74/100" â†’ Parse to 74 (0-100 scale)

  **Parsing Logic**:
  ```go
  func parseRatings(omdbRatings []Rating) (*Ratings, error) {
    ratings := &Ratings{}

    for _, r := range omdbRatings {
      switch r.Source {
      case "Internet Movie Database":
        // Parse "8.8/10" to 8.8
        rating := strings.Split(r.Value, "/")[0]
        ratings.IMDb, _ = strconv.ParseFloat(rating, 64)

      case "Rotten Tomatoes":
        // Parse "87%" to 87
        rating := strings.TrimSuffix(r.Value, "%")
        ratings.RottenTomatoes, _ = strconv.Atoi(rating)

      case "Metacritic":
        // Parse "74/100" to 74
        rating := strings.Split(r.Value, "/")[0]
        ratings.Metacritic, _ = strconv.Atoi(rating)
      }
    }

    return ratings, nil
  }
  ```
use_cases: |
  **Primary Use Cases**:
  1. **Multiple Rating Sources**: Display IMDb, Rotten Tomatoes, Metacritic on movie detail pages
  2. **Fallback Provider**: When TMDb lacks data, use OMDb
  3. **Box Office Data**: Display box office revenue
  4. **Awards Information**: Show Oscar wins, nominations

  **Display Example**:
  ```
  Ratings:
  â˜… 8.8/10 IMDb (2.5M votes)
  ðŸ… 87% Rotten Tomatoes
  ðŸ“Š 74/100 Metacritic

  Box Office: $292.6M
  Awards: Won 4 Oscars
  ```
rate_limiting_strategy: |
  **Daily Limit Tracking**:
  ```go
  type DailyRateLimiter struct {
    limit     int           // 1000 for free tier
    used      int           // Requests used today
    resetTime time.Time     // Midnight UTC
    mu        sync.Mutex
  }

  func (l *DailyRateLimiter) Allow() bool {
    l.mu.Lock()
    defer l.mu.Unlock()

    // Reset counter if new day
    if time.Now().After(l.resetTime) {
      l.used = 0
      l.resetTime = time.Now().Truncate(24 * time.Hour).Add(24 * time.Hour)
    }

    // Check limit
    if l.used >= l.limit {
      return false
    }

    l.used++
    return true
  }
  ```

  **When Limit Reached**:
  - Return cached data if available
  - Return error if no cache
  - Log warning to admins
  - Resume requests next day at midnight UTC
unit_tests: |
  ```go
  func TestOMDbProvider_GetByIMDbID(t *testing.T) {
    // Test fetching by IMDb ID with mock HTTP client
  }

  func TestOMDbProvider_RatingParsing(t *testing.T) {
    // Test parsing of different rating formats
  }

  func TestDailyRateLimiter_Reset(t *testing.T) {
    // Test daily reset at midnight UTC
  }
  ```
integration_tests: |
  ```go
  func TestOMDb_FullWorkflow(t *testing.T) {
    // Use real OMDb API (with test key)
    // Test fetch, parsing, caching
  }
  ```
caching_strategy: |
  **Long TTL for Ratings**:
  - Ratings don't change frequently (7 day TTL)
  - Reduces API usage significantly
  - Manual refresh available via admin UI

  **Cache Keys**:
  - `omdb:imdb:{imdb_id}` - Full metadata
  - `omdb:ratings:{imdb_id}` - Ratings only
error_handling: |
  **API Error Responses**:
  - `{"Response":"False","Error":"Movie not found!"}` â†’ 404 Not Found
  - `{"Response":"False","Error":"Invalid API key!"}` â†’ 401 Unauthorized
  - `{"Response":"False","Error":"Request limit reached!"}` â†’ 429 Rate Limit

  **Error Handling**:
  - 401: Log error, disable provider
  - 404: Return nil, don't retry
  - 429: Return cached data, resume tomorrow
  - Network errors: Retry once after 5 seconds
performance_optimization: |
  **Selective Fetching**:
  - Only fetch ratings for popular content (e.g., >100 views)
  - Skip OMDb for content with no IMDb ID
  - Batch requests during off-peak hours

  **Cache Warming**:
  - Background job to pre-fetch ratings for library content
  - Spread requests throughout the day to avoid hitting limit
  - Priority queue: popular movies first
monitoring: |
  **Metrics Exposed** (via Prometheus):
  - `omdb_requests_total` - Total requests made
  - `omdb_daily_limit` - Daily limit (1000)
  - `omdb_daily_used` - Requests used today
  - `omdb_cache_hits_total` - Cache hits
  - `omdb_errors_total` - Errors by type

  **Dashboard**:
  - Show daily usage: 437 / 1000 (43%)
  - Warning when >90% used
  - Estimated time until limit reached
