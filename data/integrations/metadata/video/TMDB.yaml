doc_title: TMDb (The Movie Database) Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> SUPPLEMENTARY metadata provider (fallback + enrichment) for movies and TV shows'
wiki_tagline: '> Direct TMDb API - Supplementary to Radarr/Sonarr'
wiki_overview: 'SUPPLEMENTARY metadata source for movies/TV shows. Used as: (1) **Fallback** when Radarr/Sonarr not setup,
  unreachable, or lacks metadata, (2) **Enrichment** for additional data not cached by Arr services. Free API with 40 req/10s
  rate limit. Supports multi-language metadata, images, cast, trailers. **Optional proxy/VPN routing** for regions with TMDb
  restrictions (via HTTP_CLIENT service).'
sources:
- name: go-blurhash
  url: https://pkg.go.dev/github.com/bbrks/go-blurhash
  note: Auto-resolved from go-blurhash
- name: golang.org/x/time
  url: https://pkg.go.dev/golang.org/x/time
  note: Auto-resolved from golang-x-time
- name: pgx PostgreSQL Driver
  url: https://pkg.go.dev/github.com/jackc/pgx/v5
  note: Auto-resolved from pgx
- name: PostgreSQL Arrays
  url: https://www.postgresql.org/docs/current/arrays.html
  note: Auto-resolved from postgresql-arrays
- name: PostgreSQL JSON Functions
  url: https://www.postgresql.org/docs/current/functions-json.html
  note: Auto-resolved from postgresql-json
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: Typesense API
  url: https://typesense.org/docs/latest/api/
  note: Auto-resolved from typesense
- name: Typesense Go Client
  url: https://github.com/typesense/typesense-go
  note: Auto-resolved from typesense-go
design_refs:
- title: 03_METADATA_SYSTEM
  path: ../../../architecture/03_METADATA_SYSTEM.md
- title: RADARR (PRIMARY for movies)
  path: ../../servarr/RADARR.md
- title: SONARR (PRIMARY for TV shows)
  path: ../../servarr/SONARR.md
- title: HTTP_CLIENT (proxy/VPN support)
  path: ../../../services/HTTP_CLIENT.md
- title: MOVIE_MODULE
  path: ../../../features/video/MOVIE_MODULE.md
- title: TVSHOW_MODULE
  path: ../../../features/video/TVSHOW_MODULE.md
integration_name: TMDb (The Movie Database)
integration_id: tmdb_the_movie_database
external_service: TMDb (The Movie Database)
api_base_url: https://api.themoviedb.org/3
auth_method: api_key
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1[["Revenge<br/>Metadata<br/>Service"]]
      subgraph row1[ ]
          direction LR
          node2[("Radarr/Sonarr<br/>(LOCAL cache)")]
          node3[("TMDb API<br/>(fallback +<br/>enrichment)")]
      end
      node4[("TMDb API<br/>(external)")]
      node5["Rate Limiter<br/>(40 req/10s)"]
      node2 --> node3
      node1 --> node2
      node3 --> node4
      node4 --> node5

      %% Hide row subgraph borders
      style row1 fill:transparent,stroke:transparent
  ```
api_details: |
  **API Version**: v3
  **Base URL**: `https://api.themoviedb.org/3`
  **Authentication**: API Key via query parameter `?api_key=xxx` or Bearer token
  **Rate Limit**: 40 requests per 10 seconds

  **Key Endpoints**:
  - `/search/movie` - Search for movies
  - `/movie/{id}` - Get movie details
  - `/movie/{id}/credits` - Get cast and crew
  - `/movie/{id}/images` - Get posters/backdrops
  - `/movie/{id}/videos` - Get trailers
  - `/search/tv` - Search for TV shows
  - `/tv/{id}` - Get TV show details
  - `/tv/{id}/season/{season_number}` - Get season details
  - `/tv/{id}/season/{season_number}/episode/{episode_number}` - Get episode details
database_schema: |
  **Schema**: `public`

  ```sql
  -- External ID mappings
  CREATE TABLE external_ids (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    content_type VARCHAR(50) NOT NULL,     -- 'movie', 'tvshow', 'episode'
    content_id UUID NOT NULL,

    provider VARCHAR(50) NOT NULL,         -- 'tmdb', 'imdb', 'tvdb'
    external_id VARCHAR(255) NOT NULL,

    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(content_type, content_id, provider)
  );
  CREATE INDEX idx_external_ids_lookup ON external_ids(provider, external_id);

  -- Metadata fetch cache
  CREATE TABLE metadata_cache (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    provider VARCHAR(50) NOT NULL,
    cache_key VARCHAR(255) NOT NULL,      -- e.g., "movie:550"
    response_data JSONB NOT NULL,

    created_at TIMESTAMPTZ DEFAULT now(),
    expires_at TIMESTAMPTZ NOT NULL,

    UNIQUE(provider, cache_key)
  );
  CREATE INDEX idx_metadata_cache_expiry ON metadata_cache(expires_at);
  ```
module_structure: |
  ```
  internal/metadata/providers/tmdb/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ client.go                    # TMDb API client
  â”œâ”€â”€ provider.go                  # Metadata provider interface impl
  â”œâ”€â”€ movies.go                    # Movie metadata methods
  â”œâ”€â”€ tvshows.go                   # TV show metadata methods
  â”œâ”€â”€ images.go                    # Image download and processing
  â”œâ”€â”€ ratelimit.go                 # Rate limiter (40/10s)
  â””â”€â”€ tmdb_test.go
  ```
key_interfaces: |
  ```go
  // TMDb provider implementation
  type TMDbProvider struct {
    client      *TMDbClient
    rateLimiter *rate.Limiter
    cache       Cache
  }

  // Metadata provider interface
  type MetadataProvider interface {
    // Search
    SearchMovie(ctx context.Context, query string, year *int) ([]MovieSearchResult, error)
    SearchTV(ctx context.Context, query string, year *int) ([]TVSearchResult, error)

    // Fetch details
    GetMovieDetails(ctx context.Context, tmdbID int) (*MovieMetadata, error)
    GetTVDetails(ctx context.Context, tmdbID int) (*TVMetadata, error)
    GetSeasonDetails(ctx context.Context, tmdbID, seasonNumber int) (*SeasonMetadata, error)
    GetEpisodeDetails(ctx context.Context, tmdbID, seasonNumber, episodeNumber int) (*EpisodeMetadata, error)

    // Images
    GetMovieImages(ctx context.Context, tmdbID int) (*ImageSet, error)
    DownloadImage(ctx context.Context, path string) ([]byte, error)
  }

  // Movie metadata structure
  type MovieMetadata struct {
    TMDbID         int       `json:"id"`
    IMDbID         string    `json:"imdb_id"`
    Title          string    `json:"title"`
    OriginalTitle  string    `json:"original_title"`
    Overview       string    `json:"overview"`
    ReleaseDate    string    `json:"release_date"`
    Runtime        int       `json:"runtime"`
    Genres         []Genre   `json:"genres"`
    PosterPath     string    `json:"poster_path"`
    BackdropPath   string    `json:"backdrop_path"`
    VoteAverage    float64   `json:"vote_average"`
    Cast           []Cast    `json:"credits.cast"`
    Crew           []Crew    `json:"credits.crew"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client
  - `golang.org/x/time/rate` - Rate limiting
  - `github.com/google/uuid` - UUID support
  - `github.com/jackc/pgx/v5` - PostgreSQL driver
  - `github.com/riverqueue/river` - Background jobs
  - `github.com/bbrks/go-blurhash` - Blurhash generation
  - `go.uber.org/fx` - Dependency injection

  **External APIs**:
  - TMDb API v3 (free tier: 40 requests per 10 seconds)
env_vars: |
  ```bash
  # TMDb API
  TMDB_API_KEY=your_api_key_here
  TMDB_LANGUAGE=en-US
  TMDB_INCLUDE_ADULT=false

  # Rate limiting
  TMDB_RATE_LIMIT=40
  TMDB_RATE_WINDOW=10s

  # Caching
  TMDB_CACHE_TTL=24h
  ```
config_keys: |
  ```yaml
  metadata:
    providers:
      tmdb:
        enabled: true
        api_key: ${TMDB_API_KEY}
        language: en-US
        include_adult: false
        rate_limit: 40
        rate_window: 10s
        cache_ttl: 24h

        # SUPPLEMENTARY role configuration
        role: supplementary  # fallback + enrichment

        # Proxy/VPN support (OPTIONAL - must be setup and enabled)
        proxy:
          enabled: false           # Must explicitly enable
          type: tor                # 'http', 'socks5', 'tor', 'vpn'
          url: socks5://127.0.0.1:9050  # Tor SOCKS5 proxy (if type=tor/socks5)
          interface: tun0          # VPN interface (if type=vpn)
  ```
component_interaction: |
  **Movie Metadata Fetch**:
  1. User adds movie file to library
  2. Library scanner extracts title/year from filename
  3. Metadata service calls TMDbProvider.SearchMovie(title, year)
  4. TMDb provider checks rate limiter (40/10s)
  5. Check cache for recent search results
  6. If not cached, make API request to /search/movie
  7. Parse JSON response into MovieSearchResult[]
  8. Cache response for 24 hours
  9. Return top match

  **Fetch Full Details**:
  1. Service calls GetMovieDetails(tmdbID)
  2. Make parallel requests:
     - /movie/{id}?append_to_response=credits,videos,images
  3. Parse response into MovieMetadata
  4. Download poster and backdrop images
  5. Generate blurhash for images
  6. Store external_id mapping (tmdb:550 â†’ movie UUID)
  7. Store metadata in PostgreSQL
  8. Index in Typesense for search

  **Rate Limiting**:
  - Use golang.org/x/time/rate.Limiter
  - Allow burst of 40 requests
  - Refill 4 tokens per second (40/10s)
  - Block if limit exceeded
api_request_examples: |
  **Search Movie**:
  ```
  GET https://api.themoviedb.org/3/search/movie?api_key=xxx&query=Inception&year=2010
  ```

  **Response**:
  ```json
  {
    "results": [
      {
        "id": 27205,
        "title": "Inception",
        "original_title": "Inception",
        "overview": "Cobb is a skilled thief...",
        "release_date": "2010-07-16",
        "poster_path": "/9gk7adHYeDvHkCSEqAvQNLV5Uge.jpg",
        "backdrop_path": "/s3TBrRGB1iav7gFOCNx3H31MoES.jpg",
        "vote_average": 8.367
      }
    ]
  }
  ```

  **Get Movie Details**:
  ```
  GET https://api.themoviedb.org/3/movie/27205?api_key=xxx&append_to_response=credits,images
  ```

  **Image URLs**:
  - Poster: `https://image.tmdb.org/t/p/original{poster_path}`
  - Backdrop: `https://image.tmdb.org/t/p/original{backdrop_path}`
supported_metadata: |
  **Movies**:
  - Title (localized and original)
  - Overview/description
  - Release date
  - Runtime
  - Genres
  - Cast and crew (with roles)
  - Posters and backdrops (multiple sizes)
  - Trailers (YouTube links)
  - Ratings (TMDb vote average)
  - External IDs (IMDb, Wikidata)
  - Collection information

  **TV Shows**:
  - Show title and overview
  - First/last air dates
  - Episode count and runtime
  - Networks and creators
  - Season details
  - Episode titles and air dates
  - Episode-level posters
  - Cast information
image_handling: |
  **Image Sizes Available**:
  - Poster: w92, w154, w185, w342, w500, w780, original
  - Backdrop: w300, w780, w1280, original

  **Download Strategy**:
  1. Request original size for local storage
  2. Generate blurhash for lazy loading
  3. Store in file system or object storage
  4. Generate multiple sizes on demand (or pregenerate common sizes)

  **Blurhash Generation**:
  ```go
  import "github.com/bbrks/go-blurhash"

  // Download image
  img := downloadImage(url)

  // Generate blurhash (4x3 components)
  hash, _ := blurhash.Encode(4, 3, img)

  // Store in database
  movie.PosterBlurhash = hash
  ```
unit_tests: |
  ```go
  func TestTMDbProvider_SearchMovie(t *testing.T) {
    // Test movie search with mock HTTP client
  }

  func TestTMDbProvider_RateLimit(t *testing.T) {
    // Test rate limiter enforces 40/10s
  }
  ```
integration_tests: |
  ```go
  func TestTMDb_FullWorkflow(t *testing.T) {
    // Use real TMDb API (with test key)
    // Test search, fetch, image download
  }
  ```
caching_strategy: |
  **Cache Layers**:
  - **L1**: In-memory cache (otter) for hot data (5 minute TTL)
  - **L2**: Dragonfly cache for API responses (24 hour TTL)
  - **Database**: metadata_cache table for persistence

  **Cache Keys**:
  - `tmdb:search:movie:{query}:{year}` - Search results
  - `tmdb:movie:{id}` - Movie details
  - `tmdb:tv:{id}:season:{season}` - Season details

  **Invalidation**:
  - Manual refresh via admin UI
  - Automatic expiry after TTL
  - Cleared on provider configuration change
supplementary_role: |
  **SUPPLEMENTARY Metadata Provider** (not primary)

  **PRIMARY source**: Radarr (movies) / Sonarr (TV shows)
  - Arr services aggregate TMDb metadata locally
  - Revenge queries Arr services FIRST for all metadata

  **TMDb API used as SUPPLEMENTARY in two scenarios**:

  **1. FALLBACK** (when PRIMARY unavailable):
  - Radarr/Sonarr not setup or configured
  - Radarr/Sonarr unreachable (network error, service down)
  - Radarr/Sonarr lacks specific metadata (content not in their cache)

  **2. ENRICHMENT** (additional data):
  - Multi-language translations not cached by Arr
  - High-resolution images (original quality)
  - Full cast/crew lists (Arr may have truncated data)
  - Additional artwork (alternate posters, backdrops)
  - Release information for multiple countries

  **Implementation Pattern**:
  ```go
  func (s *MetadataService) GetMovieMetadata(ctx context.Context, tmdbID int) (*Movie, error) {
    // 1. Try PRIMARY source (Radarr)
    if s.radarr.IsConfigured() {
      movie, err := s.radarr.GetMovie(ctx, tmdbID)
      if err == nil {
        return movie, nil
      }
      log.Warn("Radarr failed, falling back to TMDb", "error", err)
    }

    // 2. FALLBACK to TMDb API (via optional proxy/VPN)
    movie, err := s.tmdb.GetMovieDetails(ctx, tmdbID)
    if err != nil {
      return nil, fmt.Errorf("both PRIMARY (Radarr) and SUPPLEMENTARY (TMDb) failed: %w", err)
    }

    // 3. Optionally sync to Radarr for future queries
    go s.radarr.AddMovieIfNotExists(context.Background(), movie)

    return movie, nil
  }
  ```
proxy_vpn_support: |
  **Optional Proxy/VPN Routing** (via HTTP_CLIENT service)

  TMDb API calls can be routed through proxy/VPN for:
  - **Region restrictions**: Access TMDb from restricted countries
  - **Privacy**: Hide server IP from TMDb
  - **Network routing**: Route through specific VPN tunnels

  **IMPORTANT**: Proxy/VPN is **OPTIONAL**
  - Must be explicitly setup and enabled in config
  - NOT required for basic TMDb functionality
  - Disabled by default

  **Configuration**:
  ```yaml
  metadata:
    providers:
      tmdb:
        proxy:
          enabled: true              # Must explicitly enable
          type: tor                  # http, socks5, tor, vpn
          url: socks5://127.0.0.1:9050  # For http/socks5/tor
          interface: tun0            # For vpn type
  ```

  **Implementation** (via HTTP_CLIENT service):
  ```go
  import "internal/service/httpclient"

  // Get HTTP client with proxy support
  client, err := httpClientFactory.GetClientForService(ctx, "tmdb")
  if err != nil {
    return nil, fmt.Errorf("failed to get HTTP client: %w", err)
  }

  // Use client for TMDb API requests
  resp, err := client.Get("https://api.themoviedb.org/3/movie/550")
  ```

  **Proxy Types**:
  - **http/https**: Standard HTTP proxy
  - **socks5**: SOCKS5 proxy (supports Tor)
  - **tor**: Convenience alias for Tor SOCKS5 (127.0.0.1:9050)
  - **vpn**: Bind to specific VPN network interface

  **See**: [HTTP_CLIENT.yaml](../../../services/HTTP_CLIENT.yaml) for proxy/VPN implementation details
error_handling: |
  **HTTP Error Codes**:
  - 401 Unauthorized â†’ Invalid API key
  - 404 Not Found â†’ Content doesn't exist in TMDb
  - 429 Too Many Requests â†’ Rate limit exceeded (retry with backoff)
  - 500+ Server Errors â†’ TMDb outage (retry with exponential backoff)

  **Retry Strategy**:
  - Transient errors (429, 500+): Retry with exponential backoff (max 3 attempts)
  - Permanent errors (401, 404): Don't retry, log error
  - Network errors: Retry once after 5 seconds
performance_optimization: |
  **Batch Requests**:
  - Use `append_to_response` to fetch multiple resources in one request
  - Example: `/movie/{id}?append_to_response=credits,images,videos`

  **Parallel Fetching**:
  - When scanning library, fetch metadata for multiple items concurrently
  - Respect rate limit with semaphore or worker pool

  **Image Optimization**:
  - Download original once, generate multiple sizes locally
  - Use CDN or object storage for serving images
  - Lazy load with blurhash placeholders
