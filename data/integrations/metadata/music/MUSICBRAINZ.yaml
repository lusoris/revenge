doc_title: MusicBrainz Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> SUPPLEMENTARY metadata provider (fallback + enrichment) for music'
wiki_tagline: '> Direct MusicBrainz API - Supplementary to Lidarr'
wiki_overview: 'SUPPLEMENTARY metadata source for music. Used as: (1) **Fallback** when Lidarr not setup, unreachable, or
  lacks metadata, (2) **Enrichment** for additional data not cached by Lidarr. Open database (no API key required) with strict
  1 req/sec rate limit. Provides MBIDs (universal music identifiers), artist/album/track metadata, Cover Art Archive, AcoustID
  fingerprinting. **Optional proxy/VPN routing** if needed (via HTTP_CLIENT service).'
sources:
- name: go-blurhash
  url: https://pkg.go.dev/github.com/bbrks/go-blurhash
  note: Auto-resolved from go-blurhash
- name: Last.fm API
  url: https://www.last.fm/api/intro
  note: Auto-resolved from lastfm-api
- name: MusicBrainz API
  url: https://musicbrainz.org/doc/MusicBrainz_API
  note: Auto-resolved from musicbrainz
design_refs:
- title: 03_METADATA_SYSTEM
  path: ../../../architecture/03_METADATA_SYSTEM.md
- title: LIDARR (PRIMARY for music)
  path: ../../servarr/LIDARR.md
- title: HTTP_CLIENT (proxy/VPN support)
  path: ../../../services/HTTP_CLIENT.md
- title: MUSIC_MODULE
  path: ../../../features/music/MUSIC_MODULE.md
- title: LASTFM (enrichment metadata)
  path: ./LASTFM.md
- title: LISTENBRAINZ (scrobbling)
  path: ../../scrobbling/LISTENBRAINZ.md
integration_name: MusicBrainz
integration_id: musicbrainz
external_service: MusicBrainz
auth_method: none
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1[[Revenge<br/>Metadata<br/>Service]]
      node2[(Lidarr<br/>(LOCAL cache))]
      node3[[MusicBrainz<br/>API<br/>(fallback +]]
      node4([MusicBrainz<br/>API<br/>(external)])
      node5([HTTP_CLIENT<br/>(optional<br/>proxy/VPN)])
      node6["Cover<br/>Art<br/>Archive"]
      node7["AcoustID/<br/>Chromaprint"]
      node8["Rate<br/>Limiter<br/>(1/sec)"]
      node2 --> node3
      node4 --> node5
      node6 --> node7
      node7 --> node8
      node1 --> node2
      node3 --> node4
      node5 --> node6
  ```
api_details: |
  **API Version**: v2
  **Base URL**: `https://musicbrainz.org/ws/2`
  **Authentication**: None required (but User-Agent must be set)
  **Rate Limit**: 1 request per second (strictly enforced)

  **Key Endpoints**:
  - `/artist/{mbid}` - Get artist details
  - `/release-group/{mbid}` - Get album details
  - `/release/{mbid}` - Get release details
  - `/recording/{mbid}` - Get track details
  - `/lookup` - Lookup by MBID
  - `/search` - Search for artists, albums, tracks

  **Cover Art Archive**:
  - `https://coverartarchive.org/release/{mbid}` - Get album covers
  - `https://coverartarchive.org/release-group/{mbid}` - Get release group covers

  **AcoustID** (fingerprinting):
  - `https://api.acoustid.org/v2/lookup` - Identify track by fingerprint
database_schema: |
  **Schema**: `public`

  ```sql
  -- MusicBrainz ID mappings
  CREATE TABLE musicbrainz_ids (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    content_type VARCHAR(50) NOT NULL,     -- 'artist', 'album', 'track'
    content_id UUID NOT NULL,

    mbid UUID NOT NULL,                    -- MusicBrainz ID

    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(content_type, content_id)
  );
  CREATE INDEX idx_mbids_lookup ON musicbrainz_ids(mbid);

  -- Acoustic fingerprints (AcoustID)
  CREATE TABLE acoustic_fingerprints (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    track_id UUID NOT NULL REFERENCES tracks(id) ON DELETE CASCADE,

    -- Chromaprint fingerprint
    fingerprint TEXT NOT NULL,
    duration_seconds INTEGER NOT NULL,

    -- AcoustID identifier
    acoustid UUID,

    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(track_id)
  );
  CREATE INDEX idx_fingerprints_acoustid ON acoustic_fingerprints(acoustid);
  ```
module_structure: |
  ```
  internal/metadata/providers/musicbrainz/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ client.go                    # MusicBrainz API client
  â”œâ”€â”€ provider.go                  # Metadata provider interface impl
  â”œâ”€â”€ artists.go                   # Artist metadata methods
  â”œâ”€â”€ albums.go                    # Album metadata methods
  â”œâ”€â”€ tracks.go                    # Track metadata methods
  â”œâ”€â”€ coverart.go                  # Cover Art Archive integration
  â”œâ”€â”€ acoustid.go                  # AcoustID fingerprinting
  â”œâ”€â”€ ratelimit.go                 # Rate limiter (1/sec)
  â””â”€â”€ musicbrainz_test.go
  ```
key_interfaces: |
  ```go
  // MusicBrainz provider implementation
  type MusicBrainzProvider struct {
    client       *MBClient
    rateLimiter  *rate.Limiter
    coverArtClient *CoverArtClient
    acoustIDClient *AcoustIDClient
    cache        Cache
  }

  // Metadata provider interface
  type MetadataProvider interface {
    // Search
    SearchArtist(ctx context.Context, query string) ([]ArtistSearchResult, error)
    SearchAlbum(ctx context.Context, query string, artist string) ([]AlbumSearchResult, error)
    SearchTrack(ctx context.Context, query string, artist string) ([]TrackSearchResult, error)

    // Lookup by MBID
    GetArtist(ctx context.Context, mbid uuid.UUID) (*ArtistMetadata, error)
    GetAlbum(ctx context.Context, mbid uuid.UUID) (*AlbumMetadata, error)
    GetTrack(ctx context.Context, mbid uuid.UUID) (*TrackMetadata, error)

    // Cover art
    GetCoverArt(ctx context.Context, releaseMBID uuid.UUID) ([]CoverImage, error)

    // Fingerprinting
    LookupByFingerprint(ctx context.Context, fingerprint string, duration int) (*TrackMatch, error)
  }

  // Artist metadata structure
  type ArtistMetadata struct {
    MBID       uuid.UUID `json:"id"`
    Name       string    `json:"name"`
    SortName   string    `json:"sort-name"`
    Country    string    `json:"country"`
    Type       string    `json:"type"`        // "Person", "Group"
    Gender     string    `json:"gender"`
    LifeSpan   *LifeSpan `json:"life-span"`
    Genres     []Genre   `json:"genres"`
    Tags       []Tag     `json:"tags"`
  }

  // Album metadata
  type AlbumMetadata struct {
    MBID          uuid.UUID   `json:"id"`
    Title         string      `json:"title"`
    ArtistCredit  []Artist    `json:"artist-credit"`
    FirstReleased string      `json:"first-release-date"`
    PrimaryType   string      `json:"primary-type"`    // "Album", "EP", "Single"
    SecondaryTypes []string   `json:"secondary-types"` // "Compilation", "Live"
    TrackCount    int         `json:"track-count"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client
  - `golang.org/x/time/rate` - Rate limiting (1 request/second)
  - `github.com/google/uuid` - UUID support (MBIDs are UUIDs)
  - `github.com/jackc/pgx/v5` - PostgreSQL driver
  - `github.com/bbrks/go-blurhash` - Blurhash for cover art
  - `go.uber.org/fx` - Dependency injection

  **External APIs**:
  - MusicBrainz API v2 (free, no key required)
  - Cover Art Archive (free)
  - AcoustID API (free with API key)
env_vars: |
  ```bash
  # MusicBrainz
  MUSICBRAINZ_USER_AGENT="Revenge/1.0.0 (https://example.com)"

  # Cover Art Archive
  COVERART_ENABLED=true

  # AcoustID (fingerprinting)
  ACOUSTID_API_KEY=your_api_key_here
  ACOUSTID_ENABLED=true

  # Rate limiting
  MUSICBRAINZ_RATE_LIMIT=1  # requests per second

  # Caching
  MUSICBRAINZ_CACHE_TTL=168h  # 7 days
  ```
config_keys: |
  ```yaml
  metadata:
    providers:
      musicbrainz:
        enabled: true
        user_agent: "Revenge/1.0.0 (https://example.com)"
        rate_limit: 1  # requests/second
        cache_ttl: 168h

        coverart:
          enabled: true

        acoustid:
          enabled: true
          api_key: ${ACOUSTID_API_KEY}
  ```
component_interaction: |
  **Artist Metadata Fetch**:
  1. User adds music folder to library
  2. Audio file scanner extracts ID3 tags (artist, album, track)
  3. Metadata service calls MusicBrainzProvider.SearchArtist(name)
  4. Rate limiter ensures 1 request/second
  5. Check cache for recent search results
  6. If not cached, make API request: /ws/2/artist?query={name}
  7. Parse XML or JSON response
  8. Return top match with MBID
  9. Call GetArtist(mbid) for full details
  10. Store MBID mapping in musicbrainz_ids table
  11. Cache response for 7 days

  **Album Cover Art Fetch**:
  1. Album has MusicBrainz release-group MBID
  2. Call GetCoverArt(mbid)
  3. Request Cover Art Archive: /release-group/{mbid}
  4. Parse JSON response with image URLs
  5. Download front cover (highest resolution)
  6. Generate blurhash for lazy loading
  7. Store in file system

  **Track Identification by Fingerprint**:
  1. Audio file has no ID3 tags
  2. Extract audio with FFmpeg
  3. Generate Chromaprint fingerprint using fpcalc
  4. Call LookupByFingerprint(fingerprint, duration)
  5. Request AcoustID API: /v2/lookup?fingerprint={fp}&duration={dur}
  6. Response includes MusicBrainz recording MBID
  7. Call GetTrack(mbid) to fetch metadata
  8. Tag file with metadata
rate_limiting: |
  **Strict 1 Request/Second**:
  - MusicBrainz strictly enforces 1 request per second
  - Use `golang.org/x/time/rate.Limiter` with rate=1, burst=1
  - Blocking: wait for rate limiter before each request
  - **User-Agent Required**: Must identify application, or requests blocked

  **Rate Limiter Implementation**:
  ```go
  import "golang.org/x/time/rate"

  // Create limiter: 1 request per second
  limiter := rate.NewLimiter(rate.Every(time.Second), 1)

  // Wait before request
  if err := limiter.Wait(ctx); err != nil {
    return err
  }

  // Make request
  resp, err := client.Get(url)
  ```
api_request_examples: |
  **Search Artist**:
  ```
  GET https://musicbrainz.org/ws/2/artist?query=Beatles&fmt=json
  User-Agent: Revenge/1.0.0 (https://example.com)
  ```

  **Response**:
  ```json
  {
    "artists": [
      {
        "id": "b10bbbfc-cf9e-42e0-be17-e2c3e1d2600d",
        "name": "The Beatles",
        "sort-name": "Beatles, The",
        "country": "GB",
        "type": "Group",
        "life-span": {
          "begin": "1960",
          "end": "1970"
        }
      }
    ]
  }
  ```

  **Get Album Cover Art**:
  ```
  GET https://coverartarchive.org/release-group/482530c2-3485-3370-9b1f-a980b2a8c534
  ```

  **Response**:
  ```json
  {
    "images": [
      {
        "types": ["Front"],
        "front": true,
        "image": "http://coverartarchive.org/release/...jpg",
        "thumbnails": {
          "small": "http://...250.jpg",
          "large": "http://...500.jpg"
        }
      }
    ]
  }
  ```
mbid_system: |
  **MusicBrainz IDs (MBIDs)**:
  - All entities in MusicBrainz have UUIDs
  - MBIDs are globally unique and permanent
  - Can link to other services (Spotify, Last.fm, etc.)

  **Entity Types**:
  - **Artist**: b10bbbfc-cf9e-42e0-be17-e2c3e1d2600d
  - **Release Group** (album): 482530c2-3485-3370-9b1f-a980b2a8c534
  - **Release** (specific pressing): ...
  - **Recording** (track): ...

  **Relationships**:
  - Artist â†’ Release Groups (albums)
  - Release Group â†’ Releases (vinyl, CD, digital editions)
  - Release â†’ Recordings (tracks)
acoustic_fingerprinting: |
  **AcoustID Integration**:
  - Generate Chromaprint fingerprint from audio file
  - Submit to AcoustID for track identification
  - Returns MusicBrainz recording MBID

  **Workflow**:
  1. Install fpcalc (Chromaprint command-line tool)
  2. Run: `fpcalc -json audio.flac`
  3. Extract fingerprint and duration
  4. Submit to AcoustID API
  5. Receive recording MBID
  6. Fetch metadata from MusicBrainz

  **Example** (fpcalc output):
  ```json
  {
    "duration": 263,
    "fingerprint": "AQAAC0kkZUqYREkUnFwaOueDHE... (base64)"
  }
  ```
unit_tests: |
  ```go
  func TestMusicBrainzProvider_SearchArtist(t *testing.T) {
    // Test artist search with mock HTTP client
  }

  func TestMusicBrainzProvider_RateLimiter(t *testing.T) {
    // Test rate limiter enforces 1 req/sec
  }

  func TestAcoustID_FingerprintLookup(t *testing.T) {
    // Test fingerprint identification
  }
  ```
integration_tests: |
  ```go
  func TestMusicBrainz_FullWorkflow(t *testing.T) {
    // Use real MusicBrainz API
    // Test search, fetch, cover art
  }
  ```
user_agent_requirement: |
  **Critical: User-Agent Header**:
  - MusicBrainz REQUIRES a valid User-Agent header
  - Format: `AppName/Version (ContactURL)`
  - Example: `Revenge/1.0.0 (https://example.com)`
  - Requests without User-Agent are blocked (403 Forbidden)

  **Implementation**:
  ```go
  req.Header.Set("User-Agent", "Revenge/1.0.0 (https://example.com)")
  ```
caching_strategy: |
  **Long TTL for Music Metadata**:
  - Artist/album metadata rarely changes (7 day TTL)
  - Cover art permanent until manually replaced
  - Cache MBIDs permanently (they never change)

  **Cache Keys**:
  - `mb:artist:{mbid}` - Artist metadata
  - `mb:album:{mbid}` - Album metadata
  - `mb:coverart:{mbid}` - Cover art URLs
performance_optimization: |
  **Batch Lookups**:
  - When scanning large library, queue lookups
  - Process with rate limiter (1/sec = 3600/hour max)
  - Run during off-hours or over multiple days

  **AcoustID Fallback**:
  - Use fingerprinting only for untagged files
  - ID3-tagged files use direct search (faster)
