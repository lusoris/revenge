doc_title: Audible Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> SUPPLEMENTARY audiobook metadata via Audnexus API (Chaptarr is PRIMARY)'
wiki_tagline: '> Audnexus - Audiobook metadata enrichment for Chaptarr'
wiki_overview: 'SUPPLEMENTARY metadata source for audiobooks. Used as: (1) **Fallback** when Chaptarr not setup or lacks data,
  (2) **Enrichment** for narrator info, chapters, and Audible-specific data. Accessed via Audnexus API (community project).
  ASIN-based matching. **No authentication required**.'
sources:
- name: Audnexus API
  url: https://api.audnex.us/
  note: Auto-resolved from audnexus
- name: go-blurhash
  url: https://pkg.go.dev/github.com/bbrks/go-blurhash
  note: Auto-resolved from go-blurhash
- name: golang.org/x/time
  url: https://pkg.go.dev/golang.org/x/time
  note: Rate limiting
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Background jobs
design_refs:
- title: 03_METADATA_SYSTEM
  path: ../../../architecture/03_METADATA_SYSTEM.md
- title: CHAPTARR (PRIMARY for books/audiobooks)
  path: ../../servarr/CHAPTARR.md
- title: AUDIOBOOK_MODULE
  path: ../../../features/audiobook/AUDIOBOOK_MODULE.md
- title: HTTP_CLIENT
  path: ../../../services/HTTP_CLIENT.md
integration_name: Audible
integration_id: audible
external_service: Audnexus (Audible metadata)
api_base_url: https://api.audnex.us
auth_method: none
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1["Revenge<br/>Audiobook<br/>Service"]
      node2["Chaptarr<br/>(LOCAL cache)"]
      node3["Audnexus<br/>(Audible<br/>metadata)"]
      node4["Rate Limiter<br/>(1 req/sec)"]
      node2 --> node3
      node1 --> node2
      node3 --> node4
  ```
api_details: |
  **API**: Audnexus (community project aggregating Audible data)
  **Base URL**: `https://api.audnex.us`
  **Authentication**: None required (public API)
  **Rate Limit**: Self-imposed 1 req/sec

  **Key Endpoints**:
  - `GET /books/{asin}` - Book metadata by ASIN
  - `GET /books/{asin}/chapters` - Chapter list with timestamps
  - `GET /authors/{asin}` - Author information
  - `GET /search?q={query}&type=book` - Search for books

  **ASIN Sources**:
  - From filename (if included)
  - From Chaptarr match
  - From title/author search
database_schema: |
  **Schema**: `public`

  ```sql
  -- Audnexus audiobook metadata cache
  CREATE TABLE audnexus_cache (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    asin VARCHAR(20) NOT NULL UNIQUE,
    metadata JSONB NOT NULL,
    chapters JSONB,
    fetched_at TIMESTAMPTZ DEFAULT now(),
    expires_at TIMESTAMPTZ NOT NULL
  );
  CREATE INDEX idx_audnexus_asin ON audnexus_cache(asin);

  -- Audiobook chapter markers
  CREATE TABLE audiobook_chapters (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    audiobook_id UUID NOT NULL REFERENCES audiobooks(id),
    chapter_number INT NOT NULL,
    title VARCHAR(255),
    start_offset_ms BIGINT NOT NULL,
    end_offset_ms BIGINT NOT NULL,
    UNIQUE(audiobook_id, chapter_number)
  );
  CREATE INDEX idx_chapters_book ON audiobook_chapters(audiobook_id);
  ```
module_structure: |
  ```
  internal/metadata/providers/audnexus/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ client.go                    # Audnexus API client
  â”œâ”€â”€ provider.go                  # Metadata provider interface
  â”œâ”€â”€ books.go                     # Book metadata
  â”œâ”€â”€ chapters.go                  # Chapter extraction
  â”œâ”€â”€ search.go                    # ASIN search
  â””â”€â”€ audnexus_test.go
  ```
key_interfaces: |
  ```go
  // Audnexus provider
  type AudnexusProvider struct {
    client      *http.Client
    rateLimiter *rate.Limiter
    cache       Cache
  }

  // Audiobook metadata provider interface
  type AudiobookMetadataProvider interface {
    SearchByASIN(ctx context.Context, asin string) (*AudiobookMetadata, error)
    SearchByTitle(ctx context.Context, title, author string) ([]SearchResult, error)
    GetChapters(ctx context.Context, asin string) ([]Chapter, error)
    Priority() int  // Returns 20 (after Chaptarr=10)
  }

  // Audiobook metadata
  type AudiobookMetadata struct {
    ASIN         string    `json:"asin"`
    Title        string    `json:"title"`
    Subtitle     string    `json:"subtitle,omitempty"`
    Authors      []Person  `json:"authors"`
    Narrators    []Person  `json:"narrators"`
    Publisher    string    `json:"publisherName"`
    ReleaseDate  string    `json:"releaseDate"`
    RuntimeMinutes int     `json:"runtimeLengthMin"`
    Description  string    `json:"summary"`
    CoverURL     string    `json:"image"`
    SeriesName   string    `json:"seriesPrimary,omitempty"`
    SeriesPosition string  `json:"seriesPosition,omitempty"`
    Genres       []string  `json:"genres"`
    Language     string    `json:"language"`
    Rating       float64   `json:"rating"`
    ReviewCount  int       `json:"numReviews"`
  }

  // Chapter marker
  type Chapter struct {
    Number       int    `json:"chapterNumber"`
    Title        string `json:"title"`
    StartOffsetMs int64 `json:"startOffsetMs"`
    LengthMs     int64  `json:"lengthMs"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client
  - `golang.org/x/time/rate` - Rate limiting
  - `github.com/jackc/pgx/v5` - PostgreSQL
  - `github.com/riverqueue/river` - Background jobs
  - `github.com/bbrks/go-blurhash` - Blurhash generation
  - `go.uber.org/fx` - DI

  **External APIs**:
  - Audnexus API (free, no key required)
env_vars: |
  ```bash
  AUDNEXUS_ENABLED=true
  AUDNEXUS_RATE_LIMIT=1
  AUDNEXUS_CACHE_TTL=168h    # 7 days
  ```
config_keys: |
  ```yaml
  metadata:
    providers:
      audnexus:
        enabled: true
        rate_limit: 1
        rate_window: 1s
        cache_ttl: 168h
        role: supplementary
        priority: 20
  ```
component_interaction: |
  **Audiobook Identification**:
  1. Audio file added to library
  2. Try Chaptarr (PRIMARY) first
  3. If not found, extract ASIN from filename/metadata
  4. Query Audnexus: `GET /books/{asin}`
  5. Fetch chapters: `GET /books/{asin}/chapters`
  6. Store in cache and link to audiobook record

  **Chapter Sync**:
  1. Audnexus provides chapter timestamps
  2. Chapters stored in audiobook_chapters table
  3. Player uses chapters for navigation
  4. Chapter titles displayed in playback UI
api_request_examples: |
  **Get Book by ASIN**:
  ```bash
  curl "https://api.audnex.us/books/B08ZYXLTYG"
  ```

  **Response**:
  ```json
  {
    "asin": "B08ZYXLTYG",
    "title": "Project Hail Mary",
    "authors": [{"asin": "...", "name": "Andy Weir"}],
    "narrators": [{"name": "Ray Porter"}],
    "runtimeLengthMin": 977,
    "image": "https://m.media-amazon.com/...",
    "seriesPrimary": null,
    "rating": 4.9
  }
  ```

  **Get Chapters**:
  ```bash
  curl "https://api.audnex.us/books/B08ZYXLTYG/chapters"
  ```
supplementary_role: |
  **SUPPLEMENTARY Metadata Provider**

  **PRIMARY source**: Chaptarr (aggregates audiobook metadata locally)

  **Audnexus used as SUPPLEMENTARY**:
  1. **Fallback** when Chaptarr not setup/unreachable
  2. **Enrichment** for narrator info, chapters, Audible-specific data

  **Implementation**:
  ```go
  func (s *AudiobookService) GetMetadata(ctx context.Context, asin string) (*Audiobook, error) {
    // 1. Try Chaptarr (PRIMARY)
    if s.chaptarr.IsConfigured() {
      book, err := s.chaptarr.GetAudiobook(ctx, asin)
      if err == nil {
        return book, nil
      }
    }

    // 2. Fallback to Audnexus
    return s.audnexus.SearchByASIN(ctx, asin)
  }
  ```
error_handling: |
  **HTTP Errors**:
  - 404 Not Found â†’ ASIN not in Audnexus database
  - 429 Too Many Requests â†’ Rate limited
  - 500+ â†’ Service error

  **Fallback**:
  - If Audnexus fails, use filename metadata
  - Store partial data when available
unit_tests: |
  ```go
  func TestAudnexus_GetBook(t *testing.T) {
    mockResp := `{"asin":"B08ZYXLTYG","title":"Project Hail Mary"}`
    provider := NewAudnexusProvider(mockClient(mockResp))

    book, err := provider.SearchByASIN(ctx, "B08ZYXLTYG")
    require.NoError(t, err)
    assert.Equal(t, "Project Hail Mary", book.Title)
  }
  ```
best_practices: |
  **ASIN Extraction**:
  - Check filename patterns (e.g., `[B08ZYXLTYG]`)
  - Extract from embedded metadata
  - Fall back to title search

  **Caching**:
  - Cache for 7+ days (data rarely changes)
  - Store chapters separately for quick access

  **Rate Limiting**:
  - Respect 1 req/sec limit
  - Batch requests when possible
