doc_title: Blackbeard Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: ‚úÖ Complete
status_design: ‚úÖ
status_design_notes: External integration design complete
status_sources: ‚úÖ
status_sources_notes: '-'
status_instructions: ‚úÖ
status_instructions_notes: '-'
status_code: üî¥
status_code_notes: '-'
status_linting: üî¥
status_linting_notes: '-'
status_unit_testing: üî¥
status_unit_testing_notes: '-'
status_integration_testing: üî¥
status_integration_testing_notes: '-'
technical_summary: '> EXTERNAL transcoding service integration - offload CPU/GPU-intensive transcoding to dedicated Blackbeard
  instances'
wiki_tagline: '> Blackbeard - External transcoding offloading'
wiki_overview: EXTERNAL transcoding service integration. Blackbeard is a **third-party distributed transcoding service** (not
  developed by us) that Revenge can optionally integrate with to offload CPU/GPU-intensive video processing. Revenge has **INTERNAL
  basic transcoding** via go-astiav/FFmpeg bindings. Blackbeard integration is OPTIONAL for users who want dedicated transcoding
  hardware. Further implementation details will be provided by Blackbeard project.
sources:
- name: FFmpeg Documentation
  url: https://ffmpeg.org/ffmpeg.html
  note: Auto-resolved from ffmpeg
- name: go-astiav (FFmpeg bindings)
  url: https://pkg.go.dev/github.com/asticode/go-astiav
  note: Internal transcoding (go-astiav)
- name: gohlslib (HLS)
  url: https://pkg.go.dev/github.com/bluenviron/gohlslib/v2
  note: Auto-resolved from gohlslib
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Job queue for transcoding tasks
design_refs:
- title: TRANSCODING service (INTERNAL transcoding)
  path: ../../services/TRANSCODING.md
- title: 04_PLAYER_ARCHITECTURE
  path: ../../architecture/04_PLAYER_ARCHITECTURE.md
- title: TRICKPLAY feature
  path: ../../features/playback/TRICKPLAY.md
- title: HTTP_CLIENT (for Blackbeard API)
  path: ../../services/HTTP_CLIENT.md
integration_name: Blackbeard
integration_id: blackbeard
external_service: Blackbeard
api_protocol: rest
is_external: true
developed_by_us: false
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1(["Revenge Server<br/>Playback Transcoding INTERNAL<br/>Service Service FFmpeg"])
      subgraph row1[ ]
          direction LR
          node2[["Playback<br/>Service"]]
          node3[["Transcoding<br/>Service"]]
          node4["INTERNAL<br/>FFmpeg<br/>(go-astiav)"]
      end
      node5(["Transcoding Router<br/>(choose internal vs external)"])
      node6(["EXTERNAL: Blackbeard Service<br/>(Third-party, NOT developed by us)<br/>Distributed Transcoding Workers"])
      node7[["Distributed Transcoding Workers<br/>- GPU acceleration (NVENC, QSV, VAAPI)<br/>- Multiple worker instances"]]
      node2 --> node3
      node3 --> node4
      node1 --> node2
      node4 --> node5
      node5 --> node6
      node6 --> node7

      %% Hide row subgraph borders
      style row1 fill:transparent,stroke:transparent
  ```
system_overview: |
  **Transcoding Architecture**:

  Revenge has two transcoding approaches:

  1. **INTERNAL Transcoding** (always available)
     - Uses go-astiav (FFmpeg Go bindings)
     - Runs on the Revenge server itself
     - Supports hardware acceleration (NVENC, QSV, VAAPI)
     - Basic transcoding for most use cases
     - See: TRANSCODING service documentation

  2. **EXTERNAL Transcoding via Blackbeard** (optional)
     - Blackbeard is a **third-party service** (not developed by us)
     - Offloads transcoding to dedicated Blackbeard instances
     - Recommended for heavy transcoding workloads
     - Reduces load on Revenge server
     - Further details from Blackbeard project

  **This document** covers the integration with external Blackbeard service.
  For internal transcoding, see the TRANSCODING service documentation.
integration_scope: |
  **WHAT THIS INTEGRATION DOES**:
  - ‚úÖ Connects Revenge to external Blackbeard service
  - ‚úÖ Submits transcoding jobs to Blackbeard API
  - ‚úÖ Monitors job progress and retrieval
  - ‚úÖ Falls back to internal transcoding if Blackbeard unavailable

  **WHAT THIS INTEGRATION DOES NOT DO**:
  - ‚ùå Provide Blackbeard implementation (external project)
  - ‚ùå Run Blackbeard workers (user deploys separately)
  - ‚ùå Develop Blackbeard worker binaries

  **Blackbeard Project**:
  - Developed externally (not by Revenge team)
  - Users deploy Blackbeard independently
  - Revenge integrates via API
  - Implementation details from Blackbeard documentation
api_details: |
  **Protocol**: REST API (expected)
  **Base URL**: User-configured Blackbeard instance
  **Authentication**: API key or token (TBD by Blackbeard)

  **Expected Endpoints** (subject to Blackbeard's API design):
  - `POST /api/v1/jobs` - Submit transcoding job
  - `GET /api/v1/jobs/{id}` - Get job status
  - `GET /api/v1/jobs/{id}/progress` - Get job progress
  - `DELETE /api/v1/jobs/{id}` - Cancel job
  - `GET /api/v1/health` - Service health check

  **NOTE**: Actual API endpoints will be defined by Blackbeard project.
  This is a placeholder based on expected functionality.
database_schema: |
  **Schema**: `public`

  ```sql
  -- External transcoding jobs (tracks jobs sent to Blackbeard)
  CREATE TABLE external_transcode_jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Content reference
    media_id UUID NOT NULL,
    media_type VARCHAR(50) NOT NULL,       -- 'movie', 'episode', etc.
    source_path TEXT NOT NULL,
    output_path TEXT NOT NULL,

    -- Job specification
    profile VARCHAR(50) NOT NULL,
    settings JSONB NOT NULL,
    priority INT NOT NULL DEFAULT 100,

    -- External service tracking
    external_provider VARCHAR(50) NOT NULL DEFAULT 'blackbeard',
    external_job_id VARCHAR(255),          -- ID from Blackbeard
    external_status VARCHAR(50),           -- Status from Blackbeard

    -- Local status
    status VARCHAR(50) NOT NULL DEFAULT 'pending',  -- pending, submitted, processing, completed, failed
    progress FLOAT DEFAULT 0,
    error_message TEXT,

    -- Timestamps
    submitted_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_ext_transcode_status ON external_transcode_jobs(status);
  CREATE INDEX idx_ext_transcode_external ON external_transcode_jobs(external_provider, external_job_id);
  CREATE INDEX idx_ext_transcode_media ON external_transcode_jobs(media_id);
  ```
module_structure: |
  ```
  internal/transcoding/
  ‚îú‚îÄ‚îÄ module.go                    # fx module
  ‚îú‚îÄ‚îÄ service.go                   # Main transcoding service
  ‚îú‚îÄ‚îÄ router.go                    # Routes to internal vs external
  ‚îú‚îÄ‚îÄ internal/
  ‚îÇ   ‚îú‚îÄ‚îÄ ffmpeg.go                # go-astiav FFmpeg wrapper
  ‚îÇ   ‚îú‚îÄ‚îÄ hardware.go              # HW acceleration detection
  ‚îÇ   ‚îî‚îÄ‚îÄ profiles.go              # Encoding profiles
  ‚îú‚îÄ‚îÄ external/
  ‚îÇ   ‚îú‚îÄ‚îÄ blackbeard/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.go            # Blackbeard API client
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types.go             # API types
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ blackbeard_test.go
  ‚îÇ   ‚îî‚îÄ‚îÄ provider.go              # External provider interface
  ‚îî‚îÄ‚îÄ transcoding_test.go
  ```
key_interfaces: |
  ```go
  // External transcoding provider interface
  type ExternalTranscoder interface {
    // Submit job to external service
    SubmitJob(ctx context.Context, job *TranscodeJob) (externalID string, error)

    // Get job status from external service
    GetJobStatus(ctx context.Context, externalID string) (*JobStatus, error)

    // Cancel job on external service
    CancelJob(ctx context.Context, externalID string) error

    // Check if service is available
    IsAvailable(ctx context.Context) bool

    // Provider name
    Name() string
  }

  // Blackbeard client (implements ExternalTranscoder)
  type BlackbeardClient struct {
    baseURL     string
    apiKey      string
    httpClient  *http.Client
  }

  func (c *BlackbeardClient) Name() string { return "blackbeard" }

  func (c *BlackbeardClient) IsAvailable(ctx context.Context) bool {
    // Check Blackbeard health endpoint
    resp, err := c.httpClient.Get(c.baseURL + "/api/v1/health")
    if err != nil {
      return false
    }
    defer resp.Body.Close()
    return resp.StatusCode == http.StatusOK
  }

  func (c *BlackbeardClient) SubmitJob(ctx context.Context, job *TranscodeJob) (string, error) {
    // Submit to Blackbeard API
    // Returns external job ID
  }

  // Transcoding router (chooses internal vs external)
  type TranscodingRouter struct {
    internal    *InternalTranscoder  // go-astiav FFmpeg
    external    ExternalTranscoder   // Blackbeard (optional)
    preferExternal bool
  }

  func (r *TranscodingRouter) Transcode(ctx context.Context, job *TranscodeJob) error {
    // Try external if configured and available
    if r.preferExternal && r.external != nil && r.external.IsAvailable(ctx) {
      externalID, err := r.external.SubmitJob(ctx, job)
      if err == nil {
        // Track external job
        return r.trackExternalJob(ctx, job, externalID)
      }
      slog.Warn("external transcode failed, falling back to internal", "error", err)
    }

    // Fall back to internal transcoding
    return r.internal.Transcode(ctx, job)
  }
  ```
dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client for Blackbeard API
  - `encoding/json` - JSON encoding/decoding
  - `github.com/jackc/pgx/v5` - PostgreSQL for job tracking
  - `github.com/riverqueue/river` - Background job processing
  - `go.uber.org/fx` - Dependency injection

  **For Internal Transcoding** (see TRANSCODING service):
  - `github.com/asticode/go-astiav` - FFmpeg Go bindings
  - `github.com/bluenviron/gohlslib/v2` - HLS streaming

  **External**:
  - Blackbeard service (user-deployed, not developed by us)
env_vars: |
  ```bash
  # Blackbeard external integration (OPTIONAL)
  BLACKBEARD_ENABLED=false             # Enable external offloading
  BLACKBEARD_URL=http://blackbeard:8080
  BLACKBEARD_API_KEY=your_api_key

  # Transcoding preference
  TRANSCODING_PREFER_EXTERNAL=false    # Prefer Blackbeard over internal
  TRANSCODING_EXTERNAL_TIMEOUT=60s     # Timeout for external API calls
  ```
config_keys: |
  ```yaml
  transcoding:
    # Internal transcoding (always available)
    internal:
      enabled: true
      hardware_accel: auto           # auto, nvenc, qsv, vaapi, none
      max_concurrent: 2
      cache_dir: /var/cache/revenge/transcoded
      cache_max_size_gb: 100

    # External transcoding via Blackbeard (OPTIONAL)
    external:
      blackbeard:
        enabled: false               # Disabled by default
        url: ${BLACKBEARD_URL}
        api_key: ${BLACKBEARD_API_KEY}
        timeout: 60s
        prefer_external: false       # Prefer external over internal
        fallback_to_internal: true   # Fall back if Blackbeard unavailable

    # HLS settings (used by both internal and external)
    hls:
      segment_duration: 6s
      target_duration: 6
  ```
component_interaction: |
  **Transcoding Flow (with optional Blackbeard)**:
  1. User requests playback requiring transcoding
  2. Playback service calls TranscodingService
  3. TranscodingRouter checks configuration:
     - If `blackbeard.enabled` and `prefer_external`: try Blackbeard first
     - Otherwise: use internal transcoding
  4. If using Blackbeard:
     a. BlackbeardClient.IsAvailable() checks health
     b. If available: SubmitJob() to Blackbeard API
     c. Track job in external_transcode_jobs table
     d. Poll for completion or receive webhook
     e. If fails: fall back to internal (if enabled)
  5. If using internal:
     a. InternalTranscoder.Transcode() via go-astiav
     b. Uses local hardware acceleration if available
  6. Serve transcoded file to client

  **Job Status Polling (Background)**:
  1. River worker runs periodically
  2. Queries external_transcode_jobs with status='submitted' or 'processing'
  3. Calls BlackbeardClient.GetJobStatus() for each
  4. Updates local status from Blackbeard response
  5. On completion: marks ready for serving
internal_vs_external: |
  **INTERNAL Transcoding** (default, always available):
  - Built into Revenge using go-astiav (FFmpeg bindings)
  - Runs on the Revenge server
  - Supports hardware acceleration (NVENC, QSV, VAAPI)
  - Suitable for most use cases
  - No external dependencies

  **EXTERNAL Transcoding** (optional, requires Blackbeard):
  - Offloads to separate Blackbeard service
  - Reduces Revenge server CPU/GPU usage
  - Recommended for heavy transcoding workloads
  - Requires user to deploy Blackbeard independently
  - Blackbeard is developed by external team

  **When to Use External**:
  - Multiple users transcoding simultaneously
  - Limited server resources
  - Want dedicated transcoding hardware
  - High-volume media library with diverse formats

  **When to Use Internal**:
  - Single user or light usage
  - Server has good CPU/GPU
  - Simpler deployment
  - No need for distributed transcoding
error_handling: |
  **Blackbeard Integration Errors**:
  - Connection refused ‚Üí Blackbeard not running
  - 401 Unauthorized ‚Üí Invalid API key
  - 503 Service Unavailable ‚Üí Blackbeard overloaded
  - Timeout ‚Üí Network issue or slow response

  **Fallback Strategy**:
  ```go
  func (r *TranscodingRouter) handleExternalError(ctx context.Context, job *TranscodeJob, err error) error {
    slog.Warn("external transcoding failed",
      "provider", "blackbeard",
      "error", err,
      "job_id", job.ID)

    if r.config.FallbackToInternal {
      slog.Info("falling back to internal transcoding", "job_id", job.ID)
      return r.internal.Transcode(ctx, job)
    }

    return fmt.Errorf("external transcoding failed and fallback disabled: %w", err)
  }
  ```
unit_tests: |
  ```go
  func TestBlackbeardClient_IsAvailable(t *testing.T) {
    // Mock Blackbeard health endpoint
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
      if r.URL.Path == "/api/v1/health" {
        w.WriteHeader(http.StatusOK)
        return
      }
      w.WriteHeader(http.StatusNotFound)
    }))
    defer server.Close()

    client := NewBlackbeardClient(server.URL, "test-key")
    assert.True(t, client.IsAvailable(context.Background()))
  }

  func TestTranscodingRouter_FallbackToInternal(t *testing.T) {
    // Test that router falls back to internal when Blackbeard unavailable
    mockExternal := &mockExternalTranscoder{available: false}
    mockInternal := &mockInternalTranscoder{}

    router := NewTranscodingRouter(mockInternal, mockExternal, true)

    job := &TranscodeJob{ID: uuid.New()}
    err := router.Transcode(context.Background(), job)

    require.NoError(t, err)
    assert.True(t, mockInternal.transcodeCalled)
    assert.False(t, mockExternal.submitCalled)
  }
  ```
best_practices: |
  **Deployment**:
  - Start with internal transcoding (default)
  - Add Blackbeard only if needed for scale
  - Ensure network connectivity to Blackbeard
  - Configure appropriate timeouts

  **Configuration**:
  - Keep fallback_to_internal enabled for reliability
  - Set appropriate timeout for your network
  - Monitor both internal and external transcoding metrics

  **When Using Blackbeard**:
  - Follow Blackbeard's own deployment guide
  - Ensure shared storage access (if required by Blackbeard)
  - Monitor Blackbeard health separately
  - Plan for Blackbeard maintenance windows

  **Performance**:
  - Internal transcoding with hardware acceleration is fast
  - External offloading helps with concurrent transcodes
  - Cache transcoded files to avoid re-transcoding
