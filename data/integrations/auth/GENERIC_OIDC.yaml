doc_title: Generic OIDC Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Support for any OpenID Connect compatible provider'
wiki_tagline: '> Connect any OIDC provider for authentication'
wiki_overview: Use any OpenID Connect compatible identity provider with Revenge. Works with corporate identity systems, cloud
  providers (Google, Microsoft, Okta), or other self-hosted solutions. Configure the discovery URL, client ID, and secret.
  Map claims to Revenge user attributes and roles.
sources:
- name: Authelia Documentation
  url: https://www.authelia.com/overview/
  note: Auto-resolved from authelia
- name: Authentik Documentation
  url: https://goauthentik.io/docs/
  note: Auto-resolved from authentik
- name: Keycloak Documentation
  url: https://www.keycloak.org/documentation
  note: Auto-resolved from keycloak
- name: OpenID Connect Core
  url: https://openid.net/specs/openid-connect-core-1_0.html
  note: Auto-resolved from oidc
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
integration_name: Generic OIDC
integration_id: generic_oidc
external_service: Generic OIDC
api_base_url: https://revenge.example.com/api/v1/auth/oidc/callback
auth_method: oidc
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1["User<br/>Browser"]
      node2["OIDC Provider<br/>(Any Provider)"]
      node3["Revenge<br/>Server"]
      node4["Provider<br/>Token API"]
      node5["User<br/>Session"]
      node1 --> node2
      node3 --> node4
      node2 --> node3
      node4 --> node5
  ```
protocol_details: |
  **OpenID Connect (OIDC)** with Generic Provider:

  **Discovery-Based Configuration**:
  - **Discovery URL**: `https://provider.example.com/.well-known/openid-configuration`
  - Auto-fetches all required endpoints

  **Standard Endpoints** (from discovery):
  - **Authorization**: `authorization_endpoint`
  - **Token**: `token_endpoint`
  - **UserInfo**: `userinfo_endpoint`
  - **JWKS**: `jwks_uri`
  - **Introspection**: `introspection_endpoint` (optional)
  - **Revocation**: `revocation_endpoint` (optional)
  - **End Session**: `end_session_endpoint` (optional)

  **OAuth2 Flow**: Authorization Code flow with PKCE (recommended)

  **Token Types**:
  - **ID Token** (JWT): User identity claims
  - **Access Token**: API access (JWT or opaque)
  - **Refresh Token**: Long-lived renewal token

  **Supported Providers** (examples):
  - Okta
  - Auth0
  - Azure AD / Microsoft Entra ID
  - Google Identity Platform
  - GitHub OAuth
  - GitLab OAuth
  - Apple Sign In
  - Any OIDC-compliant provider
supported_providers: |
  **Popular OIDC Providers**:

  1. **Okta**:
     - Discovery URL: `https://{tenant}.okta.com/.well-known/openid-configuration`
     - Enterprise IAM, SSO, MFA

  2. **Auth0**:
     - Discovery URL: `https://{tenant}.auth0.com/.well-known/openid-configuration`
     - Developer-friendly, social logins, rules engine

  3. **Azure AD / Microsoft Entra ID**:
     - Discovery URL: `https://login.microsoftonline.com/{tenant}/v2.0/.well-known/openid-configuration`
     - Enterprise Microsoft 365 integration

  4. **Google**:
     - Discovery URL: `https://accounts.google.com/.well-known/openid-configuration`
     - Consumer and Workspace accounts

  5. **GitHub**:
     - Manual configuration (no standard OIDC discovery)
     - OAuth 2.0 compatible

  6. **GitLab**:
     - Discovery URL: `https://gitlab.com/.well-known/openid-configuration`
     - Self-hosted GitLab instances supported

  7. **Apple**:
     - Discovery URL: `https://appleid.apple.com/.well-known/openid-configuration`
     - Sign in with Apple

  8. **Ping Identity**:
     - Discovery URL: `https://{tenant}.pingone.com/{env}/.well-known/openid-configuration`
     - Enterprise IAM

  9. **OneLogin**:
     - Discovery URL: `https://{subdomain}.onelogin.com/oidc/2/.well-known/openid-configuration`
     - Enterprise SSO
module_structure: |
  ```
  internal/
    service/
      auth/
        oidc/
          generic.go          # Generic OIDC provider
          discovery.go        # OIDC discovery client
          provider.go         # Provider interface
          client.go           # OAuth2 client
          token.go            # Token validation
          userinfo.go         # UserInfo endpoint
          claims.go           # Claim mapping logic
          module.go           # fx module
          generic_test.go

  config/
    oidc/
      generic.yaml           # Provider configuration examples
      providers/
        okta.yaml            # Okta example
        auth0.yaml           # Auth0 example
        azure.yaml           # Azure AD example
        google.yaml          # Google example
  ```
key_interfaces: |
  ```go
  // GenericOIDCProvider implements OIDC for any provider
  type GenericOIDCProvider struct {
      config    *GenericOIDCConfig
      discovery *DiscoveryDocument
      oauth     *oauth2.Config
      verifier  *oidc.IDTokenVerifier
  }

  type GenericOIDCConfig struct {
      Name              string            // Provider name (for display)
      DiscoveryURL      string            // OIDC discovery URL
      Issuer            string            // Optional: override issuer from discovery
      ClientID          string            // OAuth2 client ID
      ClientSecret      string            // OAuth2 client secret
      RedirectURL       string            // Callback URL
      Scopes            []string          // Requested scopes (openid required)
      ClaimMappings     ClaimMappings     // Map claims to user fields
      RoleClaim         string            // Claim containing roles/groups
      RoleMappings      map[string]string // Provider role â†’ Revenge role
      AutoCreateUsers   bool              // Create users on first login
      UpdateUserInfo    bool              // Update user info on each login
      UsernameClaim     string            // Claim to use as username
      EmailClaim        string            // Claim to use as email (default: "email")
      NameClaim         string            // Claim to use as name (default: "name")
      PictureClaim      string            // Claim to use as avatar
      ExtraAuthParams   map[string]string // Additional auth params
  }

  type ClaimMappings struct {
      Username string // Claim path for username (e.g., "preferred_username")
      Email    string // Claim path for email
      Name     string // Claim path for display name
      Picture  string // Claim path for avatar URL
      Roles    string // Claim path for roles (e.g., "groups", "roles")
  }

  type DiscoveryDocument struct {
      Issuer                            string   `json:"issuer"`
      AuthorizationEndpoint             string   `json:"authorization_endpoint"`
      TokenEndpoint                     string   `json:"token_endpoint"`
      UserInfoEndpoint                  string   `json:"userinfo_endpoint"`
      JWKSUri                           string   `json:"jwks_uri"`
      IntrospectionEndpoint             string   `json:"introspection_endpoint,omitempty"`
      RevocationEndpoint                string   `json:"revocation_endpoint,omitempty"`
      EndSessionEndpoint                string   `json:"end_session_endpoint,omitempty"`
      ScopesSupported                   []string `json:"scopes_supported"`
      ResponseTypesSupported            []string `json:"response_types_supported"`
      GrantTypesSupported               []string `json:"grant_types_supported"`
      SubjectTypesSupported             []string `json:"subject_types_supported"`
      IDTokenSigningAlgValuesSupported  []string `json:"id_token_signing_alg_values_supported"`
      CodeChallengeMethodsSupported     []string `json:"code_challenge_methods_supported,omitempty"`
  }

  // OIDCProvider interface (generic)
  type OIDCProvider interface {
      // Discover provider metadata
      Discover(ctx context.Context) (*DiscoveryDocument, error)

      // Get authorization URL
      GetAuthURL(state string) string

      // Exchange code for tokens
      ExchangeCode(ctx context.Context, code string) (*TokenResponse, error)

      // Verify ID token
      VerifyIDToken(ctx context.Context, rawIDToken string) (*IDToken, error)

      // Get user info from UserInfo endpoint
      GetUserInfo(ctx context.Context, accessToken string) (*UserInfo, error)

      // Map provider claims/roles to Revenge roles
      MapRoles(ctx context.Context, claims map[string]any) ([]string, error)
  }

  type TokenResponse struct {
      IDToken      string
      AccessToken  string
      RefreshToken string
      ExpiresIn    int
  }

  type IDToken struct {
      Subject       string         // User ID
      Email         string
      EmailVerified bool
      Name          string
      PreferredUsername string
      Picture       string
      IssuedAt      time.Time
      ExpiresAt     time.Time
      Claims        map[string]any // All claims
  }

  type UserInfo struct {
      Sub       string         // Subject (user ID)
      Email     string
      Name      string
      Username  string
      Picture   string
      Claims    map[string]any // All userinfo claims
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/coreos/go-oidc/v3/oidc` - OIDC client
  - `golang.org/x/oauth2` - OAuth2 flow
  - `github.com/golang-jwt/jwt/v5` - JWT parsing (fallback)

  **External Services**:
  - Any OIDC-compliant identity provider
env_vars: |
  ```bash
  # Generic OIDC configuration
  REVENGE_OIDC_PROVIDER=generic
  REVENGE_OIDC_GENERIC_NAME="Okta"
  REVENGE_OIDC_GENERIC_DISCOVERY_URL=https://dev-123456.okta.com/.well-known/openid-configuration
  REVENGE_OIDC_GENERIC_CLIENT_ID=0oa1b2c3d4e5f6g7h8i9
  REVENGE_OIDC_GENERIC_CLIENT_SECRET=very-secret-key
  REVENGE_OIDC_GENERIC_REDIRECT_URL=https://revenge.local/api/v1/auth/oidc/callback
  ```
config_keys: |
  ```yaml
  auth:
    oidc:
      enabled: true
      provider: generic     # Use generic provider
      providers:
        generic:
          name: "Okta"      # Display name
          discovery_url: ${REVENGE_OIDC_GENERIC_DISCOVERY_URL}
          # Optional: override discovery
          # issuer: https://dev-123456.okta.com
          client_id: ${REVENGE_OIDC_GENERIC_CLIENT_ID}
          client_secret: ${REVENGE_OIDC_GENERIC_CLIENT_SECRET}
          redirect_url: https://revenge.local/api/v1/auth/oidc/callback
          scopes:
            - openid
            - profile
            - email
            - groups        # Provider-specific (optional)
          claim_mappings:
            username: "preferred_username"  # Claim path
            email: "email"
            name: "name"
            picture: "picture"
            roles: "groups"                 # Where to find roles
          role_mappings:
            # Provider role/group â†’ Revenge role
            "Revenge Admins": "admin"
            "Revenge Users": "user"
          auto_create_users: true
          update_user_info: true
          username_claim: "preferred_username"
          email_claim: "email"
          name_claim: "name"
          picture_claim: "picture"
          extra_auth_params:
            # Provider-specific params (e.g., Azure AD resource)
            # resource: "https://graph.microsoft.com"
  ```
provider_examples: |
  **Okta Configuration**:
  ```yaml
  generic:
    name: "Okta"
    discovery_url: https://dev-123456.okta.com/.well-known/openid-configuration
    client_id: 0oa1b2c3d4e5f6g7h8i9
    client_secret: secret
    scopes: [openid, profile, email, groups]
    claim_mappings:
      roles: "groups"
    role_mappings:
      "Revenge Admins": "admin"
  ```

  **Auth0 Configuration**:
  ```yaml
  generic:
    name: "Auth0"
    discovery_url: https://dev-abc123.us.auth0.com/.well-known/openid-configuration
    client_id: xyz123abc456
    client_secret: secret
    scopes: [openid, profile, email]
    claim_mappings:
      roles: "https://revenge.app/roles"  # Namespaced claim
    role_mappings:
      "admin": "admin"
      "user": "user"
  ```

  **Azure AD Configuration**:
  ```yaml
  generic:
    name: "Microsoft"
    discovery_url: https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration
    client_id: a1b2c3d4-e5f6-g7h8-i9j0-k1l2m3n4o5p6
    client_secret: secret
    scopes: [openid, profile, email, User.Read]
    claim_mappings:
      roles: "roles"
    role_mappings:
      "Revenge.Admin": "admin"
    extra_auth_params:
      prompt: "consent"  # Force consent screen
  ```

  **Google Configuration**:
  ```yaml
  generic:
    name: "Google"
    discovery_url: https://accounts.google.com/.well-known/openid-configuration
    client_id: 123456789-abc.apps.googleusercontent.com
    client_secret: secret
    scopes: [openid, profile, email]
    claim_mappings:
      username: "email"
      roles: "hd"  # Hosted domain (for Google Workspace)
    extra_auth_params:
      hd: "company.com"  # Restrict to domain
  ```

  **GitLab Configuration**:
  ```yaml
  generic:
    name: "GitLab"
    discovery_url: https://gitlab.com/.well-known/openid-configuration
    client_id: abc123
    client_secret: secret
    scopes: [openid, profile, email, read_user]
    claim_mappings:
      roles: "groups"
  ```
component_interaction: |
  **OIDC Login Flow**:

  1. **Discovery** (on provider configuration):
     - Fetch `{discovery_url}`
     - Parse discovery document
     - Extract endpoints: authorization, token, userinfo, jwks

  2. **User visits Revenge**:
     - Clicks "Login with {Provider}"
     - Revenge redirects to authorization endpoint
     - URL includes: client_id, redirect_uri, scope, state, code_challenge (PKCE)

  3. **User authenticates with Provider**:
     - Enters credentials (or already logged in)
     - Provider verifies user
     - Redirects back to Revenge with authorization code

  4. **Revenge exchanges code for tokens**:
     - POST to token endpoint
     - Includes: code, client_id, client_secret, code_verifier (PKCE)
     - Receives: id_token, access_token, refresh_token

  5. **Revenge verifies ID token**:
     - Fetch JWKS from provider
     - Verify signature, expiration, audience, issuer
     - Extract claims from ID token

  6. **Revenge fetches user info** (optional):
     - GET userinfo endpoint with access token
     - Merge claims with ID token claims

  7. **Revenge creates/updates user**:
     - Extract username from configured claim
     - Check if user exists (by subject or email)
     - If auto_create_users=true, create new user
     - Map provider roles to Revenge roles
     - Update user info if update_user_info=true

  8. **Session creation**:
     - Create Revenge session
     - Set session cookie
     - Redirect to app homepage
api_endpoints: |
  **OIDC Endpoints** (Revenge):
  ```
  GET  /api/v1/auth/oidc/login?provider=generic
  GET  /api/v1/auth/oidc/callback
  POST /api/v1/auth/oidc/refresh
  POST /api/v1/auth/oidc/logout
  ```

  **Example - Initiate Login**:
  ```
  GET /api/v1/auth/oidc/login?provider=generic

  â†’ Redirects to:
  https://provider.example.com/authorize?
    client_id=abc123&
    redirect_uri=https://revenge.local/api/v1/auth/oidc/callback&
    response_type=code&
    scope=openid+profile+email&
    state=random-state&
    code_challenge=...&
    code_challenge_method=S256
  ```

  **Example - Callback**:
  ```
  GET /api/v1/auth/oidc/callback?
    code=authorization-code&
    state=random-state

  â†’ Revenge backend:
  1. Verifies state
  2. Exchanges code for tokens
  3. Verifies ID token
  4. Fetches user info
  5. Creates user/session
  6. Sets session cookie
  7. Redirects to /
  ```
claim_mapping: |
  **Flexible Claim Mapping**:

  Different providers use different claim names. Configure mappings:

  ```yaml
  claim_mappings:
    username: "preferred_username"  # Or "email", "sub", "upn"
    email: "email"                  # Standard
    name: "name"                    # Or "displayName", "full_name"
    picture: "picture"              # Or "avatar_url", "photo"
    roles: "groups"                 # Or "roles", "permissions", custom namespace
  ```

  **Nested Claims**:
  Use dot notation for nested claims:
  ```yaml
  claim_mappings:
    roles: "resource_access.revenge.roles"  # Keycloak-style
  ```

  **Namespaced Claims** (Auth0):
  ```yaml
  claim_mappings:
    roles: "https://revenge.app/roles"  # Namespaced custom claim
  ```

  **Implementation**:
  ```go
  func (p *GenericOIDCProvider) ExtractClaim(claims map[string]any, path string) (any, bool) {
      parts := strings.Split(path, ".")
      current := claims

      for i, part := range parts {
          value, ok := current[part]
          if !ok {
              return nil, false
          }

          if i == len(parts)-1 {
              return value, true
          }

          // Navigate nested object
          if nested, ok := value.(map[string]any); ok {
              current = nested
          } else {
              return nil, false
          }
      }

      return nil, false
  }

  func (p *GenericOIDCProvider) MapRoles(ctx context.Context, claims map[string]any) ([]string, error) {
      roles := []string{"user"}  // Default role

      // Extract roles from configured claim
      roleClaimPath := p.config.ClaimMappings.Roles
      if roleClaimPath == "" {
          return roles, nil
      }

      roleValue, ok := p.ExtractClaim(claims, roleClaimPath)
      if !ok {
          return roles, nil
      }

      // Handle array of roles
      var providerRoles []string
      switch v := roleValue.(type) {
      case []string:
          providerRoles = v
      case []any:
          for _, r := range v {
              if str, ok := r.(string); ok {
                  providerRoles = append(providerRoles, str)
              }
          }
      case string:
          providerRoles = []string{v}
      }

      // Map to Revenge roles
      for _, providerRole := range providerRoles {
          if mappedRole, ok := p.config.RoleMappings[providerRole]; ok {
              roles = append(roles, mappedRole)
          }
      }

      return deduplicateRoles(roles), nil
  }
  ```
discovery: |
  **OIDC Discovery Implementation**:

  ```go
  func (p *GenericOIDCProvider) Discover(ctx context.Context) (*DiscoveryDocument, error) {
      req, err := http.NewRequestWithContext(ctx, "GET", p.config.DiscoveryURL, nil)
      if err != nil {
          return nil, fmt.Errorf("failed to create request: %w", err)
      }

      resp, err := http.DefaultClient.Do(req)
      if err != nil {
          return nil, fmt.Errorf("failed to fetch discovery: %w", err)
      }
      defer resp.Body.Close()

      if resp.StatusCode != http.StatusOK {
          return nil, fmt.Errorf("discovery returned status %d", resp.StatusCode)
      }

      var doc DiscoveryDocument
      if err := json.NewDecoder(resp.Body).Decode(&doc); err != nil {
          return nil, fmt.Errorf("failed to parse discovery: %w", err)
      }

      // Validate required fields
      if doc.Issuer == "" || doc.AuthorizationEndpoint == "" ||
         doc.TokenEndpoint == "" || doc.JWKSUri == "" {
          return nil, fmt.Errorf("discovery document missing required fields")
      }

      p.discovery = &doc
      return &doc, nil
  }
  ```

  **Cache Discovery**:
  - Cache discovery document for 24 hours
  - Refresh on startup or if endpoints fail
  - Reduces latency and external dependencies
token_refresh: |
  **Refresh Token Flow**:

  ```go
  func (p *GenericOIDCProvider) RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error) {
      token, err := p.oauth.TokenSource(ctx, &oauth2.Token{
          RefreshToken: refreshToken,
      }).Token()

      if err != nil {
          return nil, fmt.Errorf("failed to refresh token: %w", err)
      }

      // Extract new ID token if present
      rawIDToken, _ := token.Extra("id_token").(string)

      return &TokenResponse{
          IDToken:      rawIDToken,
          AccessToken:  token.AccessToken,
          RefreshToken: token.RefreshToken,
          ExpiresIn:    int(time.Until(token.Expiry).Seconds()),
      }, nil
  }
  ```
logout: |
  **Logout Flow**:

  Some providers support end_session_endpoint for logout:

  ```go
  func (p *GenericOIDCProvider) GetLogoutURL(idToken string, postLogoutRedirectURI string) (string, error) {
      if p.discovery.EndSessionEndpoint == "" {
          return "", fmt.Errorf("provider does not support logout endpoint")
      }

      logoutURL, err := url.Parse(p.discovery.EndSessionEndpoint)
      if err != nil {
          return "", err
      }

      q := logoutURL.Query()
      q.Set("id_token_hint", idToken)
      q.Set("post_logout_redirect_uri", postLogoutRedirectURI)
      logoutURL.RawQuery = q.Encode()

      return logoutURL.String(), nil
  }
  ```
error_handling: |
  **Common Errors**:

  - **discovery_failed**: Cannot fetch discovery document
    - Solution: Check discovery URL, network connectivity

  - **invalid_client**: Client ID or secret incorrect
    - Solution: Verify credentials in provider console

  - **redirect_uri_mismatch**: Callback URL not registered
    - Solution: Add exact URL to provider allowed redirects

  - **invalid_grant**: Authorization code expired or invalid
    - Solution: User should retry login

  - **invalid_token**: ID token signature invalid
    - Solution: Check JWKS endpoint, verify issuer

  - **unsupported_grant_type**: Provider doesn't support grant type
    - Solution: Check discovery document for supported grant types

  - **claim_not_found**: Required claim missing from token
    - Solution: Adjust claim_mappings or request additional scopes
unit_tests: |
  ```go
  func TestGenericOIDCProvider_Discover(t *testing.T) {
      mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          w.Header().Set("Content-Type", "application/json")
          json.NewEncoder(w).Encode(map[string]interface{}{
              "issuer":                 mockServer.URL,
              "authorization_endpoint": mockServer.URL + "/authorize",
              "token_endpoint":         mockServer.URL + "/token",
              "userinfo_endpoint":      mockServer.URL + "/userinfo",
              "jwks_uri":               mockServer.URL + "/jwks",
          })
      }))
      defer mockServer.Close()

      provider := NewGenericOIDCProvider(&GenericOIDCConfig{
          DiscoveryURL: mockServer.URL + "/.well-known/openid-configuration",
      })

      doc, err := provider.Discover(context.Background())
      require.NoError(t, err)
      assert.Equal(t, mockServer.URL, doc.Issuer)
  }

  func TestGenericOIDCProvider_MapRoles(t *testing.T) {
      tests := []struct {
          name     string
          claims   map[string]any
          config   *GenericOIDCConfig
          wantRole string
      }{
          {
              name: "simple role mapping",
              claims: map[string]any{
                  "groups": []string{"admins"},
              },
              config: &GenericOIDCConfig{
                  ClaimMappings: ClaimMappings{Roles: "groups"},
                  RoleMappings:  map[string]string{"admins": "admin"},
              },
              wantRole: "admin",
          },
          {
              name: "nested claim",
              claims: map[string]any{
                  "resource_access": map[string]any{
                      "revenge": map[string]any{
                          "roles": []string{"admin"},
                      },
                  },
              },
              config: &GenericOIDCConfig{
                  ClaimMappings: ClaimMappings{Roles: "resource_access.revenge.roles"},
                  RoleMappings:  map[string]string{"admin": "admin"},
              },
              wantRole: "admin",
          },
      }

      for _, tt := range tests {
          t.Run(tt.name, func(t *testing.T) {
              provider := NewGenericOIDCProvider(tt.config)
              roles, err := provider.MapRoles(context.Background(), tt.claims)
              require.NoError(t, err)
              assert.Contains(t, roles, tt.wantRole)
          })
      }
  }

  func TestGenericOIDCProvider_ExtractClaim(t *testing.T) {
      // Test nested claim extraction
  }
  ```
integration_tests: |
  ```go
  func TestGenericOIDC_RealProvider(t *testing.T) {
      // Test with real OIDC provider (requires setup)
      if testing.Short() {
          t.Skip("skipping integration test")
      }

      provider := NewGenericOIDCProvider(&GenericOIDCConfig{
          DiscoveryURL: os.Getenv("OIDC_DISCOVERY_URL"),
          ClientID:     os.Getenv("OIDC_CLIENT_ID"),
          ClientSecret: os.Getenv("OIDC_CLIENT_SECRET"),
      })

      // Test discovery
      doc, err := provider.Discover(context.Background())
      require.NoError(t, err)
      assert.NotEmpty(t, doc.AuthorizationEndpoint)

      // Test JWKS fetch
      jwks, err := provider.FetchJWKS(context.Background())
      require.NoError(t, err)
      assert.NotEmpty(t, jwks.Keys)
  }
  ```
best_practices: |
  **Security**:
  - Always use PKCE for authorization code flow
  - Validate state parameter to prevent CSRF
  - Verify ID token signature with JWKS from provider
  - Check token expiration, issuer, and audience claims
  - Use HTTPS for all endpoints
  - Rotate client secrets regularly

  **Configuration**:
  - Use discovery URL for automatic endpoint configuration
  - Cache discovery document (24 hours)
  - Request minimal scopes needed
  - Configure claim mappings for each provider
  - Test with provider's sandbox/dev environment first

  **User Management**:
  - Enable auto_create_users for seamless onboarding
  - Map roles correctly for proper permissions
  - Update user info on login to sync changes
  - Handle missing claims gracefully (use defaults)
  - Support multiple providers simultaneously

  **Token Management**:
  - Store refresh tokens securely (encrypted)
  - Implement token rotation
  - Set appropriate session timeouts
  - Revoke tokens on logout (if provider supports)
  - Handle token refresh failures gracefully

  **Provider-Specific**:
  - Read provider documentation for custom claims
  - Configure extra_auth_params as needed
  - Test role/group claim structure
  - Handle provider-specific quirks (e.g., Azure AD tenant selection)

  **Monitoring**:
  - Log OIDC errors with provider name and context
  - Track failed login attempts per provider
  - Monitor token refresh failures
  - Alert on provider connectivity issues
  - Track discovery document refresh failures

  **Multi-Provider Support**:
  - Allow users to choose provider at login
  - Store provider ID with user account
  - Support account linking (same email, different providers)
  - Handle provider-specific logout flows
