doc_title: Authelia Integration
doc_category: integration
created_date: '2026-02-01'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Lightweight authentication and authorization server for homelab environments'
wiki_tagline: '> Single sign-on with Authelia'
wiki_overview: Connect Revenge to your Authelia identity provider for centralized authentication in homelab setups. Authelia
  provides OIDC with LDAP or file-based backends, perfect for self-hosted environments. Supports two-factor authentication,
  access control policies, and group-based role mapping.
sources:
- name: Authelia Documentation
  url: https://www.authelia.com/overview/
  note: Auto-resolved from authelia
- name: Authelia OIDC Guide
  url: https://www.authelia.com/integration/openid-connect/introduction/
  note: OIDC implementation details
- name: Authelia Configuration
  url: https://www.authelia.com/configuration/prologue/introduction/
  note: Configuration reference
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
integration_name: Authelia
integration_id: authelia
external_service: Authelia
api_base_url: https://auth.homelab.local
auth_method: oidc
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1["User<br/>Browser"]
      node2["Authelia<br/>Auth Server"]
      node3["Revenge<br/>Server"]
      node4["Authelia<br/>OIDC Endpoint"]
      node5["User<br/>Session"]
      node1 --> node2
      node3 --> node4
      node2 --> node3
      node4 --> node5
  ```
protocol_details: |
  **OpenID Connect (OIDC)** with Authelia:

  **Endpoints**:
  - **Authorization**: `https://auth.homelab.local/api/oidc/authorization`
  - **Token**: `https://auth.homelab.local/api/oidc/token`
  - **UserInfo**: `https://auth.homelab.local/api/oidc/userinfo`
  - **JWKS**: `https://auth.homelab.local/jwks.json`
  - **Discovery**: `https://auth.homelab.local/.well-known/openid-configuration`

  **OAuth2 Flow**: Authorization Code flow with PKCE (recommended)

  **Token Types**:
  - **ID Token** (JWT): User identity, email, groups
  - **Access Token**: JWT with user claims
  - **Refresh Token**: Long-lived token for renewal (optional)

  **Authelia-Specific Features**:
  - Two-factor authentication (TOTP, WebAuthn, Duo)
  - Access control policies (bypass, one_factor, two_factor)
  - Session management with Redis or in-memory
  - LDAP/Active Directory backend support
  - File-based user database option
module_structure: |
  ```
  internal/
    service/
      auth/
        oidc/
          authelia.go          # Authelia-specific provider
          provider.go          # Generic OIDC provider interface
          client.go            # OAuth2 client
          token.go             # Token validation
          userinfo.go          # UserInfo endpoint
          groups.go            # Group mapping logic
          module.go            # fx module
          authelia_test.go

  config/
    oidc/
      authelia.yaml            # Provider configuration example
  ```
key_interfaces: |
  ```go
  // AutheliaProvider implements OIDC for Authelia
  type AutheliaProvider struct {
      config   *AutheliaConfig
      oauth    *oauth2.Config
      verifier *oidc.IDTokenVerifier
  }

  type AutheliaConfig struct {
      Issuer           string            // https://auth.homelab.local
      ClientID         string            // revenge-client
      ClientSecret     string            // secret
      RedirectURL      string            // https://revenge.local/api/v1/auth/oidc/callback
      Scopes           []string          // openid, profile, email, groups
      GroupMappings    map[string]string // Authelia group â†’ Revenge role
      AutoCreateUsers  bool              // Create users on first login
      UpdateUserInfo   bool              // Update email/name on each login
      UsePKCE          bool              // Enable PKCE (recommended)
      RequireMFA       bool              // Require two-factor authentication
  }

  // OIDCProvider interface (generic)
  type OIDCProvider interface {
      // Get authorization URL
      GetAuthURL(state string, pkceChallenge string) string

      // Exchange code for tokens
      ExchangeCode(ctx context.Context, code string, pkceVerifier string) (*TokenResponse, error)

      // Verify ID token
      VerifyIDToken(ctx context.Context, rawIDToken string) (*IDToken, error)

      // Get user info from UserInfo endpoint
      GetUserInfo(ctx context.Context, accessToken string) (*UserInfo, error)

      // Map provider groups to Revenge roles
      MapRoles(ctx context.Context, user *UserInfo) ([]string, error)
  }

  type TokenResponse struct {
      IDToken      string
      AccessToken  string
      RefreshToken string  // Optional in Authelia
      ExpiresIn    int
  }

  type IDToken struct {
      Subject           string   // User ID in Authelia
      Email             string
      EmailVerified     bool
      Name              string
      PreferredUsername string
      Groups            []string // Authelia groups
      IssuedAt          time.Time
      ExpiresAt         time.Time
      AuthenticationMethodsReferences []string // amr claim (MFA info)
  }

  type UserInfo struct {
      Sub               string   // Subject (user ID)
      Email             string
      EmailVerified     bool
      Name              string
      PreferredUsername string
      Groups            []string // From Authelia LDAP/file backend
      Picture           string   // Avatar URL (if configured)
      AMR               []string // Authentication methods (pwd, otp, etc.)
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/coreos/go-oidc/v3/oidc` - OIDC client
  - `golang.org/x/oauth2` - OAuth2 flow
  - `github.com/golang-jwt/jwt/v5` - JWT parsing
  - `github.com/google/uuid` - PKCE code verifier generation

  **External Services**:
  - Authelia server (https://www.authelia.com/)
  - Redis (for Authelia session storage, optional)
  - LDAP server (optional backend)
env_vars: |
  ```bash
  # Authelia OIDC configuration
  REVENGE_OIDC_PROVIDER=authelia
  REVENGE_OIDC_AUTHELIA_ISSUER=https://auth.homelab.local
  REVENGE_OIDC_AUTHELIA_CLIENT_ID=revenge-client
  REVENGE_OIDC_AUTHELIA_CLIENT_SECRET=very-secret-key
  REVENGE_OIDC_AUTHELIA_REDIRECT_URL=https://revenge.local/api/v1/auth/oidc/callback
  ```
config_keys: |
  ```yaml
  auth:
    oidc:
      enabled: true
      provider: authelia     # authentik, authelia, keycloak, generic
      providers:
        authelia:
          issuer: ${REVENGE_OIDC_AUTHELIA_ISSUER}
          client_id: ${REVENGE_OIDC_AUTHELIA_CLIENT_ID}
          client_secret: ${REVENGE_OIDC_AUTHELIA_CLIENT_SECRET}
          redirect_url: https://revenge.local/api/v1/auth/oidc/callback
          scopes:
            - openid
            - profile
            - email
            - groups          # Authelia groups claim
          group_mappings:
            # Authelia group â†’ Revenge role
            "admins": "admin"
            "users": "user"
            "readonly": "readonly"
            "family": "family"
          auto_create_users: true
          update_user_info: true
          user_claim: "preferred_username"  # Field to use as username
          use_pkce: true                    # Enable PKCE (recommended)
          require_mfa: false                # Require two-factor auth
  ```
provider_setup: |
  **Authelia Configuration Steps**:

  1. **Install Authelia**:
     ```bash
     # Docker Compose example
     docker-compose up -d authelia
     ```

  2. **Configure OIDC Client** (configuration.yml):
     ```yaml
     identity_providers:
       oidc:
         issuer_private_key: /config/certificates/oidc.pem
         clients:
           - id: revenge-client
             description: Revenge Media Server
             secret: $pbkdf2-sha512$310000$... # Generate with authelia crypto hash generate pbkdf2
             public: false
             authorization_policy: two_factor  # or one_factor, bypass
             redirect_uris:
               - https://revenge.local/api/v1/auth/oidc/callback
             scopes:
               - openid
               - profile
               - email
               - groups
             grant_types:
               - authorization_code
               - refresh_token
             response_types:
               - code
             response_modes:
               - query
             userinfo_signing_algorithm: none
     ```

  3. **Configure User Backend**:

     **Option A: File Backend**:
     ```yaml
     authentication_backend:
       file:
         path: /config/users_database.yml
     ```

     users_database.yml:
     ```yaml
     users:
       john:
         displayname: "John Doe"
         password: "$argon2id$v=19$m=65536,t=3,p=4$..." # Generate with authelia crypto hash generate argon2
         email: john@homelab.local
         groups:
           - admins
           - users
       jane:
         displayname: "Jane Smith"
         password: "$argon2id$v=19$m=65536,t=3,p=4$..."
         email: jane@homelab.local
         groups:
           - users
     ```

     **Option B: LDAP Backend**:
     ```yaml
     authentication_backend:
       ldap:
         implementation: custom
         url: ldap://ldap.homelab.local:389
         base_dn: dc=homelab,dc=local
         username_attribute: uid
         additional_users_dn: ou=users
         users_filter: (&({username_attribute}={input})(objectClass=person))
         additional_groups_dn: ou=groups
         groups_filter: (&(member={dn})(objectClass=groupOfNames))
         group_name_attribute: cn
         mail_attribute: mail
         display_name_attribute: displayName
         user: cn=admin,dc=homelab,dc=local
         password: ldap-admin-password
     ```

  4. **Configure Access Control**:
     ```yaml
     access_control:
       default_policy: deny
       rules:
         - domain: revenge.local
           policy: two_factor
           subject:
             - "group:admins"
             - "group:users"
     ```

  5. **Configure Session**:
     ```yaml
     session:
       name: authelia_session
       domain: homelab.local
       expiration: 1h
       inactivity: 15m
       remember_me_duration: 1M
       redis:
         host: redis
         port: 6379
     ```

  6. **Generate OIDC Private Key**:
     ```bash
     openssl genpkey -algorithm RSA -out oidc.pem -pkeyopt rsa_keygen_bits:4096
     ```

  7. **Test Flow**:
     - Navigate to Revenge login page
     - Click "Login with Authelia"
     - Redirects to Authelia, enter credentials
     - Complete 2FA if required (TOTP, WebAuthn, etc.)
     - Redirects back to Revenge with token
     - User created automatically with mapped roles
component_interaction: |
  **OIDC Login Flow**:

  1. **User visits Revenge**:
     - Clicks "Login with Authelia" button
     - Revenge generates PKCE code verifier and challenge (if enabled)
     - Revenge redirects to Authelia authorization endpoint
     - URL includes: client_id, redirect_uri, scope, state, code_challenge (PKCE)

  2. **User authenticates with Authelia**:
     - Enters username and password (first factor)
     - Authelia checks credentials against backend (LDAP or file)
     - If two_factor policy, prompts for TOTP/WebAuthn/Duo
     - Authelia verifies second factor
     - Redirects back to Revenge with authorization code

  3. **Revenge exchanges code for tokens**:
     - POST to Authelia token endpoint
     - Includes: code, client_id, client_secret, code_verifier (PKCE)
     - Receives: id_token, access_token, refresh_token (optional)

  4. **Revenge verifies ID token**:
     - Fetch JWKS from Authelia
     - Verify signature, expiration, audience, issuer
     - Extract claims: sub, email, name, groups, amr (auth methods)

  5. **Revenge creates/updates user**:
     - Check if user exists (by `sub` or email)
     - If auto_create_users=true, create new user
     - Map Authelia groups to Revenge roles
     - Update user info if update_user_info=true
     - Store authentication method (MFA badge if amr includes otp/mfa)

  6. **Session creation**:
     - Create Revenge session
     - Set session cookie
     - Redirect to app homepage
api_endpoints: |
  **OIDC Endpoints** (Revenge):
  ```
  GET  /api/v1/auth/oidc/login
  GET  /api/v1/auth/oidc/callback
  POST /api/v1/auth/oidc/refresh
  POST /api/v1/auth/oidc/logout
  ```

  **Example - Initiate Login**:
  ```
  GET /api/v1/auth/oidc/login?provider=authelia

  â†’ Generates PKCE verifier and challenge
  â†’ Redirects to:
  https://auth.homelab.local/api/oidc/authorization?
    client_id=revenge-client&
    redirect_uri=https://revenge.local/api/v1/auth/oidc/callback&
    response_type=code&
    scope=openid+profile+email+groups&
    state=random-state&
    code_challenge=...&
    code_challenge_method=S256
  ```

  **Example - Callback**:
  ```
  GET /api/v1/auth/oidc/callback?
    code=authorization-code&
    state=random-state

  â†’ Revenge backend:
  1. Verifies state matches stored value
  2. Exchanges code for tokens (includes PKCE verifier)
  3. Verifies ID token signature
  4. Extracts user info and groups
  5. Creates or updates user
  6. Maps groups to roles
  7. Creates session
  8. Sets session cookie
  9. Redirects to /
  ```

  **Example - Refresh Token**:
  ```
  POST /api/v1/auth/oidc/refresh
  Content-Type: application/json

  {
    "refresh_token": "refresh-token-value"
  }

  â†’ Response:
  {
    "access_token": "new-access-token",
    "id_token": "new-id-token",
    "expires_in": 3600
  }
  ```
group_mapping: |
  **Authelia Group â†’ Revenge Role Mapping**:

  ```yaml
  group_mappings:
    "admins": "admin"
    "moderators": "moderator"
    "users": "user"
    "readonly": "readonly"
    "family": "family"
    "dev": "developer"
  ```

  **Implementation**:
  ```go
  func (p *AutheliaProvider) MapRoles(ctx context.Context, user *UserInfo) ([]string, error) {
      roles := []string{"user"}  // Default role

      for _, group := range user.Groups {
          if role, ok := p.config.GroupMappings[group]; ok {
              roles = append(roles, role)
          }
      }

      return deduplicateRoles(roles), nil
  }

  func deduplicateRoles(roles []string) []string {
      seen := make(map[string]bool)
      result := []string{}

      for _, role := range roles {
          if !seen[role] {
              seen[role] = true
              result = append(result, role)
          }
      }

      return result
  }
  ```

  **Role Precedence**: Admin > Moderator > Developer > User > Readonly

  **LDAP Group Mapping**:
  If using LDAP backend, groups are automatically populated from LDAP:
  ```yaml
  # Authelia config
  additional_groups_dn: ou=groups
  groups_filter: (&(member={dn})(objectClass=groupOfNames))
  group_name_attribute: cn
  ```
token_refresh: |
  **Refresh Token Flow**:

  Authelia optionally supports refresh tokens (must be enabled in client config).

  When access token expires:
  1. Use refresh token to get new access token
  2. POST to Authelia token endpoint
  3. Receive new id_token + access_token
  4. Update user session

  ```go
  func (p *AutheliaProvider) RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error) {
      token, err := p.oauth.TokenSource(ctx, &oauth2.Token{
          RefreshToken: refreshToken,
      }).Token()

      if err != nil {
          return nil, fmt.Errorf("failed to refresh token: %w", err)
      }

      // Verify new ID token
      rawIDToken, ok := token.Extra("id_token").(string)
      if !ok {
          return nil, fmt.Errorf("no id_token in refresh response")
      }

      idToken, err := p.VerifyIDToken(ctx, rawIDToken)
      if err != nil {
          return nil, fmt.Errorf("failed to verify refreshed ID token: %w", err)
      }

      return &TokenResponse{
          IDToken:      rawIDToken,
          AccessToken:  token.AccessToken,
          RefreshToken: token.RefreshToken,
          ExpiresIn:    int(time.Until(token.Expiry).Seconds()),
      }, nil
  }
  ```

  **Note**: If refresh tokens are not enabled in Authelia client config, users must re-authenticate when session expires.
error_handling: |
  **Common Errors**:

  - **invalid_client**: Client ID or secret incorrect
    - Solution: Verify credentials match Authelia configuration.yml
    - Check secret is hashed correctly: `authelia crypto hash generate pbkdf2`

  - **redirect_uri_mismatch**: Callback URL not registered
    - Solution: Add exact URL to Authelia client redirect_uris list

  - **invalid_grant**: Authorization code expired or invalid
    - Solution: User should retry login
    - Check PKCE verifier matches challenge

  - **invalid_token**: ID token signature invalid
    - Solution: Check JWKS endpoint, verify issuer URL matches
    - Ensure Authelia OIDC private key is configured

  - **unauthorized_client**: Client not authorized for grant type
    - Solution: Add "authorization_code" to grant_types in client config

  - **access_denied**: User failed authentication or doesn't meet policy
    - Solution: Check Authelia access_control rules
    - Verify user is in allowed groups
    - Ensure user completed required authentication factors

  - **two_factor_required**: User needs to complete 2FA
    - Solution: User must enroll in TOTP/WebAuthn/Duo
    - Check Authelia policy for client (one_factor vs two_factor)

  **Implementation**:
  ```go
  func (p *AutheliaProvider) ExchangeCode(ctx context.Context, code string, verifier string) (*TokenResponse, error) {
      opts := []oauth2.AuthCodeOption{}
      if p.config.UsePKCE && verifier != "" {
          opts = append(opts, oauth2.SetAuthURLParam("code_verifier", verifier))
      }

      token, err := p.oauth.Exchange(ctx, code, opts...)
      if err != nil {
          var oauthErr *oauth2.RetrieveError
          if errors.As(err, &oauthErr) {
              // Parse Authelia error response
              var errResp struct {
                  Error            string `json:"error"`
                  ErrorDescription string `json:"error_description"`
              }
              json.Unmarshal(oauthErr.Body, &errResp)

              return nil, fmt.Errorf("authelia error: %s - %s", errResp.Error, errResp.ErrorDescription)
          }
          return nil, fmt.Errorf("failed to exchange code: %w", err)
      }

      // Extract ID token
      rawIDToken, ok := token.Extra("id_token").(string)
      if !ok {
          return nil, fmt.Errorf("no id_token in token response")
      }

      return &TokenResponse{
          IDToken:      rawIDToken,
          AccessToken:  token.AccessToken,
          RefreshToken: token.RefreshToken,
          ExpiresIn:    int(time.Until(token.Expiry).Seconds()),
      }, nil
  }
  ```
unit_tests: |
  ```go
  func TestAutheliaProvider_ExchangeCode(t *testing.T) {
      mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          if r.URL.Path == "/api/oidc/token" {
              // Mock Authelia token endpoint
              w.Header().Set("Content-Type", "application/json")
              json.NewEncoder(w).Encode(map[string]interface{}{
                  "id_token":      "mock-id-token",
                  "access_token":  "mock-access-token",
                  "refresh_token": "mock-refresh-token",
                  "expires_in":    3600,
              })
          }
      }))
      defer mockServer.Close()

      provider := NewAutheliaProvider(&AutheliaConfig{
          Issuer:       mockServer.URL,
          ClientID:     "test-client",
          ClientSecret: "test-secret",
          UsePKCE:      true,
      })

      tokens, err := provider.ExchangeCode(context.Background(), "test-code", "test-verifier")
      require.NoError(t, err)
      assert.Equal(t, "mock-id-token", tokens.IDToken)
      assert.Equal(t, "mock-access-token", tokens.AccessToken)
  }

  func TestAutheliaProvider_MapRoles(t *testing.T) {
      provider := NewAutheliaProvider(&AutheliaConfig{
          GroupMappings: map[string]string{
              "admins": "admin",
              "users":  "user",
          },
      })

      tests := []struct {
          name     string
          groups   []string
          expected []string
      }{
          {
              name:     "admin user",
              groups:   []string{"admins", "users"},
              expected: []string{"user", "admin"},
          },
          {
              name:     "regular user",
              groups:   []string{"users"},
              expected: []string{"user"},
          },
          {
              name:     "unmapped group",
              groups:   []string{"unknown"},
              expected: []string{"user"}, // default role
          },
      }

      for _, tt := range tests {
          t.Run(tt.name, func(t *testing.T) {
              user := &UserInfo{Groups: tt.groups}
              roles, err := provider.MapRoles(context.Background(), user)
              require.NoError(t, err)
              assert.ElementsMatch(t, tt.expected, roles)
          })
      }
  }

  func TestAutheliaProvider_VerifyMFA(t *testing.T) {
      // Test AMR claim parsing
      claims := IDToken{
          Subject: "john",
          Email:   "john@homelab.local",
          AuthenticationMethodsReferences: []string{"pwd", "otp"},
      }

      hasMFA := false
      for _, amr := range claims.AuthenticationMethodsReferences {
          if amr == "otp" || amr == "mfa" {
              hasMFA = true
              break
          }
      }

      assert.True(t, hasMFA, "expected MFA to be detected from AMR claim")
  }
  ```
integration_tests: |
  ```go
  func TestAuthelia_FullOIDCFlow(t *testing.T) {
      // Requires running Authelia instance
      if testing.Short() {
          t.Skip("skipping integration test")
      }

      provider := NewAutheliaProvider(&AutheliaConfig{
          Issuer:       os.Getenv("AUTHELIA_ISSUER"),
          ClientID:     os.Getenv("AUTHELIA_CLIENT_ID"),
          ClientSecret: os.Getenv("AUTHELIA_CLIENT_SECRET"),
          UsePKCE:      true,
      })

      ctx := context.Background()

      // Test discovery
      discoveryURL := provider.config.Issuer + "/.well-known/openid-configuration"
      resp, err := http.Get(discoveryURL)
      require.NoError(t, err)
      defer resp.Body.Close()
      assert.Equal(t, http.StatusOK, resp.StatusCode)

      var discovery struct {
          Issuer                string   `json:"issuer"`
          AuthorizationEndpoint string   `json:"authorization_endpoint"`
          TokenEndpoint         string   `json:"token_endpoint"`
          UserinfoEndpoint      string   `json:"userinfo_endpoint"`
          JwksURI               string   `json:"jwks_uri"`
          ScopesSupported       []string `json:"scopes_supported"`
      }
      err = json.NewDecoder(resp.Body).Decode(&discovery)
      require.NoError(t, err)
      assert.Contains(t, discovery.ScopesSupported, "openid")
      assert.Contains(t, discovery.ScopesSupported, "groups")

      // Test JWKS fetch
      jwksResp, err := http.Get(discovery.JwksURI)
      require.NoError(t, err)
      defer jwksResp.Body.Close()

      var jwks struct {
          Keys []map[string]interface{} `json:"keys"`
      }
      err = json.NewDecoder(jwksResp.Body).Decode(&jwks)
      require.NoError(t, err)
      assert.NotEmpty(t, jwks.Keys)
  }

  func TestAuthelia_LDAPIntegration(t *testing.T) {
      // Test with LDAP backend
      if testing.Short() {
          t.Skip("skipping LDAP integration test")
      }

      // This would test:
      // 1. Authelia connected to LDAP
      // 2. User authentication against LDAP
      // 3. Group retrieval from LDAP
      // 4. Group mapping to Revenge roles
  }
  ```
best_practices: |
  **Security**:
  - Use PKCE for authorization code flow (set `use_pkce: true`)
  - Validate state parameter to prevent CSRF attacks
  - Verify ID token signature with JWKS
  - Check token expiration, audience, and issuer claims
  - Use HTTPS for all endpoints
  - Enable two-factor authentication in Authelia (TOTP, WebAuthn)
  - Use strong client secrets (generate with Authelia CLI)
  - Store OIDC private key securely (file permissions, encryption)
  - Implement rate limiting on login endpoints
  - Use Redis for session storage (shared sessions across instances)

  **User Management**:
  - Enable auto_create_users for seamless onboarding
  - Map groups correctly for proper permissions
  - Update user info on login to sync LDAP changes
  - Handle edge cases (email changes, group removals)
  - Consider LDAP backend for centralized user management
  - Use file backend for simple homelab setups
  - Document group naming conventions for consistency

  **Token Management**:
  - Store refresh tokens securely (encrypted in database)
  - Implement token rotation
  - Set appropriate session timeouts (align with Authelia session config)
  - Revoke tokens on logout
  - Handle token expiration gracefully (automatic refresh)
  - Consider not using refresh tokens for high-security applications

  **Authelia Configuration**:
  - Use two_factor authorization policy for sensitive data
  - Configure appropriate session expiration and inactivity timeouts
  - Use Redis for session storage in production
  - Configure access control rules per domain/resource
  - Enable SMTP for password reset emails
  - Set up monitoring and logging
  - Use strong encryption for session cookies

  **LDAP Backend**:
  - Use secure LDAP (LDAPS on port 636)
  - Create dedicated LDAP service account with minimal permissions
  - Use specific base DNs to limit search scope
  - Test LDAP filters thoroughly
  - Cache group memberships appropriately
  - Handle LDAP connection failures gracefully

  **Monitoring**:
  - Log OIDC errors with context (user, timestamp, error type)
  - Track failed login attempts (potential brute force)
  - Monitor token refresh failures
  - Alert on Authelia connectivity issues
  - Track MFA enrollment rates
  - Monitor session duration and user activity
  - Set up Authelia logs aggregation (Loki, ELK)

  **Testing**:
  - Test both one_factor and two_factor policies
  - Test LDAP connectivity and failover
  - Test group mapping edge cases
  - Verify PKCE implementation
  - Test token refresh flow
  - Test logout and session cleanup

  **Documentation**:
  - Document Authelia configuration for users
  - Provide group naming conventions
  - Document MFA enrollment process
  - Create troubleshooting guides
  - Document LDAP schema requirements
  - Provide migration guide from other auth providers
