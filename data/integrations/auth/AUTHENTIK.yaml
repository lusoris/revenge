doc_title: Authentik Integration
doc_category: integration
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Enterprise-grade identity provider for self-hosted environments'
wiki_tagline: '> Single sign-on with Authentik'
wiki_overview: Connect Revenge to your Authentik identity provider for centralized user management. Create users in Authentik
  and they automatically get access to Revenge. Supports OIDC protocol with configurable scopes. Group mappings let you assign
  Revenge roles based on Authentik groups.
sources:
- name: Authelia Documentation
  url: https://www.authelia.com/overview/
  note: Auto-resolved from authelia
- name: Authentik Documentation
  url: https://goauthentik.io/docs/
  note: Auto-resolved from authentik
- name: Keycloak Documentation
  url: https://www.keycloak.org/documentation
  note: Auto-resolved from keycloak
design_refs:
- title: 01_ARCHITECTURE
  path: ../../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../../architecture/03_METADATA_SYSTEM.md
integration_name: Authentik
integration_id: authentik
external_service: Authentik
api_base_url: https://authentik.company.local
auth_method: oidc
architecture_diagram: |-
  ```mermaid
  flowchart LR
      subgraph Layer1["Layer 1"]
          node1["User<br/>Browser"]
          node2["Authentik<br/>IdP Server"]
      end

      subgraph Layer2["Layer 2"]
          node3["Revenge<br/>Server"]
          node4[["Authentik<br/>OAuth2 API"]]
      end

      subgraph Layer3["Layer 3"]
          node5["User<br/>Session"]
      end

      %% Connections
      node2 --> node3
      node4 --> node5

      %% Styling
      style Layer1 fill:#1976D2,stroke:#1976D2,color:#fff
      style Layer2 fill:#388E3C,stroke:#388E3C,color:#fff
      style Layer3 fill:#7B1FA2,stroke:#7B1FA2,color:#fff
  ```
protocol_details: |
  **OpenID Connect (OIDC)** with Authentik:

  **Endpoints**:
  - **Authorization**: `https://authentik.company.local/application/o/authorize/`
  - **Token**: `https://authentik.company.local/application/o/token/`
  - **UserInfo**: `https://authentik.company.local/application/o/userinfo/`
  - **JWKS**: `https://authentik.company.local/application/o/revenge/jwks/`
  - **Discovery**: `https://authentik.company.local/application/o/revenge/.well-known/openid-configuration`

  **OAuth2 Flow**: Authorization Code flow with PKCE

  **Token Types**:
  - **ID Token** (JWT): User identity, email, groups
  - **Access Token**: API access (opaque or JWT)
  - **Refresh Token**: Long-lived token for renewal
module_structure: |
  ```
  internal/
    service/
      auth/
        oidc/
          authentik.go         # Authentik-specific provider
          provider.go          # Generic OIDC provider interface
          client.go            # OAuth2 client
          token.go             # Token validation
          userinfo.go          # UserInfo endpoint
          groups.go            # Group mapping logic
          module.go            # fx module
          authentik_test.go

  config/
    oidc/
      authentik.yaml           # Provider configuration example
  ```
key_interfaces: |
  ```go
  // AuthentikProvider implements OIDC for Authentik
  type AuthentikProvider struct {
      config   *AuthentikConfig
      oauth    *oauth2.Config
      verifier *oidc.IDTokenVerifier
  }

  type AuthentikConfig struct {
      Issuer           string            // https://authentik.company.local/application/o/revenge/
      ClientID         string            // revenge-client
      ClientSecret     string            // secret
      RedirectURL      string            // https://revenge.local/api/v1/auth/oidc/callback
      Scopes           []string          // openid, profile, email, groups
      GroupMappings    map[string]string // Authentik group â†’ Revenge role
      AutoCreateUsers  bool              // Create users on first login
      UpdateUserInfo   bool              // Update email/name on each login
  }

  // OIDCProvider interface (generic)
  type OIDCProvider interface {
      // Get authorization URL
      GetAuthURL(state string) string

      // Exchange code for tokens
      ExchangeCode(ctx context.Context, code string) (*TokenResponse, error)

      // Verify ID token
      VerifyIDToken(ctx context.Context, rawIDToken string) (*IDToken, error)

      // Get user info from UserInfo endpoint
      GetUserInfo(ctx context.Context, accessToken string) (*UserInfo, error)

      // Map provider groups to Revenge roles
      MapRoles(ctx context.Context, user *UserInfo) ([]string, error)
  }

  type TokenResponse struct {
      IDToken      string
      AccessToken  string
      RefreshToken string
      ExpiresIn    int
  }

  type IDToken struct {
      Subject       string   // User ID in Authentik
      Email         string
      EmailVerified bool
      Name          string
      PreferredUsername string
      Groups        []string // Authentik groups
      IssuedAt      time.Time
      ExpiresAt     time.Time
  }

  type UserInfo struct {
      Sub               string   // Subject (user ID)
      Email             string
      EmailVerified     bool
      Name              string
      PreferredUsername string
      Groups            []string // From Authentik
      Picture           string   // Avatar URL
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/coreos/go-oidc/v3/oidc` - OIDC client
  - `golang.org/x/oauth2` - OAuth2 flow
  - `github.com/golang-jwt/jwt/v5` - JWT parsing (fallback)

  **External Services**:
  - Authentik server (https://goauthentik.io/)
env_vars: |
  ```bash
  # Authentik OIDC configuration
  REVENGE_OIDC_PROVIDER=authentik
  REVENGE_OIDC_AUTHENTIK_ISSUER=https://authentik.company.local/application/o/revenge/
  REVENGE_OIDC_AUTHENTIK_CLIENT_ID=revenge-client
  REVENGE_OIDC_AUTHENTIK_CLIENT_SECRET=very-secret-key
  REVENGE_OIDC_AUTHENTIK_REDIRECT_URL=https://revenge.local/api/v1/auth/oidc/callback
  ```
config_keys: |
  ```yaml
  auth:
    oidc:
      enabled: true
      provider: authentik     # authentik, authelia, keycloak, generic
      providers:
        authentik:
          issuer: ${REVENGE_OIDC_AUTHENTIK_ISSUER}
          client_id: ${REVENGE_OIDC_AUTHENTIK_CLIENT_ID}
          client_secret: ${REVENGE_OIDC_AUTHENTIK_CLIENT_SECRET}
          redirect_url: https://revenge.local/api/v1/auth/oidc/callback
          scopes:
            - openid
            - profile
            - email
            - groups          # Authentik groups claim
          group_mappings:
            # Authentik group â†’ Revenge role
            "revenge-admin": "admin"
            "revenge-users": "user"
            "revenge-readonly": "readonly"
          auto_create_users: true
          update_user_info: true
          user_claim: "preferred_username"  # Field to use as username
  ```
authentik_setup: |
  **Authentik Configuration Steps**:

  1. **Create Application**:
     - Navigate to Applications â†’ Create
     - Name: "Revenge Media Server"
     - Provider: "OAuth2/OpenID Provider"

  2. **Create Provider**:
     - Name: "revenge-oidc"
     - Client type: "Confidential"
     - Client ID: Generate or use "revenge-client"
     - Client Secret: Generate secure secret
     - Redirect URIs: `https://revenge.local/api/v1/auth/oidc/callback`
     - Signing Key: Choose or generate
     - Scopes: openid, profile, email, groups

  3. **Configure Groups**:
     - Create groups: "revenge-admin", "revenge-users"
     - Assign users to groups

  4. **Property Mappings** (include groups):
     - Ensure "authentik default OAuth Mapping: OpenID 'groups'" is selected
     - Verifies `groups` claim is in ID token

  5. **Test Flow**:
     - Navigate to Revenge login page
     - Click "Login with Authentik"
     - Redirects to Authentik, login
     - Redirects back to Revenge with token
     - User created automatically with mapped roles
component_interaction: |
  **OIDC Login Flow**:

  1. **User visits Revenge**:
     - Clicks "Login with Authentik" button
     - Revenge redirects to Authentik authorization endpoint
     - URL includes: client_id, redirect_uri, scope, state, code_challenge (PKCE)

  2. **User authenticates with Authentik**:
     - Enters credentials (or already logged in)
     - Authentik verifies user
     - Redirects back to Revenge with authorization code

  3. **Revenge exchanges code for tokens**:
     - POST to Authentik token endpoint
     - Includes: code, client_id, client_secret, code_verifier (PKCE)
     - Receives: id_token, access_token, refresh_token

  4. **Revenge verifies ID token**:
     - Fetch JWKS from Authentik
     - Verify signature, expiration, audience
     - Extract claims: sub, email, name, groups

  5. **Revenge creates/updates user**:
     - Check if user exists (by `sub` or email)
     - If auto_create_users=true, create new user
     - Map Authentik groups to Revenge roles
     - Update user info if update_user_info=true

  6. **Session creation**:
     - Create Revenge session
     - Set session cookie
     - Redirect to app homepage
api_endpoints: |
  **OIDC Endpoints** (Revenge):
  ```
  GET  /api/v1/auth/oidc/login
  GET  /api/v1/auth/oidc/callback
  POST /api/v1/auth/oidc/refresh
  POST /api/v1/auth/oidc/logout
  ```

  **Example - Initiate Login**:
  ```
  GET /api/v1/auth/oidc/login?provider=authentik

  â†’ Redirects to:
  https://authentik.company.local/application/o/authorize/?
    client_id=revenge-client&
    redirect_uri=https://revenge.local/api/v1/auth/oidc/callback&
    response_type=code&
    scope=openid+profile+email+groups&
    state=random-state&
    code_challenge=...&
    code_challenge_method=S256
  ```

  **Example - Callback**:
  ```
  GET /api/v1/auth/oidc/callback?
    code=authorization-code&
    state=random-state

  â†’ Revenge backend:
  1. Verifies state
  2. Exchanges code for tokens
  3. Verifies ID token
  4. Creates user/session
  5. Sets session cookie
  6. Redirects to /
  ```
group_mapping: |
  **Authentik Group â†’ Revenge Role Mapping**:

  ```yaml
  group_mappings:
    "revenge-admin": "admin"
    "revenge-moderator": "moderator"
    "revenge-users": "user"
    "revenge-readonly": "readonly"
    "revenge-family": "family"
  ```

  **Implementation**:
  ```go
  func (p *AuthentikProvider) MapRoles(ctx context.Context, user *UserInfo) ([]string, error) {
      roles := []string{"user"}  // Default role

      for _, group := range user.Groups {
          if role, ok := p.config.GroupMappings[group]; ok {
              roles = append(roles, role)
          }
      }

      return deduplicateRoles(roles), nil
  }
  ```

  **Role Precedence**: Admin > Moderator > User > Readonly
token_refresh: |
  **Refresh Token Flow**:

  When access token expires:
  1. Use refresh token to get new access token
  2. POST to Authentik token endpoint
  3. Receive new id_token + access_token
  4. Update user session

  ```go
  func (p *AuthentikProvider) RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error) {
      token, err := p.oauth.TokenSource(ctx, &oauth2.Token{
          RefreshToken: refreshToken,
      }).Token()

      if err != nil {
          return nil, fmt.Errorf("failed to refresh token: %w", err)
      }

      return &TokenResponse{
          AccessToken:  token.AccessToken,
          RefreshToken: token.RefreshToken,
          ExpiresIn:    int(time.Until(token.Expiry).Seconds()),
      }, nil
  }
  ```
error_handling: |
  **Common Errors**:

  - **invalid_client**: Client ID or secret incorrect
    - Solution: Verify credentials match Authentik provider

  - **redirect_uri_mismatch**: Callback URL not registered
    - Solution: Add exact URL to Authentik allowed redirects

  - **invalid_grant**: Authorization code expired or invalid
    - Solution: User should retry login

  - **invalid_token**: ID token signature invalid
    - Solution: Check JWKS endpoint, verify issuer URL
unit_tests: |
  ```go
  func TestAuthentikProvider_ExchangeCode(t *testing.T) {
      mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          // Mock Authentik token endpoint
          w.Header().Set("Content-Type", "application/json")
          json.NewEncoder(w).Encode(map[string]interface{}{
              "id_token":      "mock-id-token",
              "access_token":  "mock-access-token",
              "refresh_token": "mock-refresh-token",
              "expires_in":    3600,
          })
      }))
      defer mockServer.Close()

      provider := NewAuthentikProvider(&AuthentikConfig{
          Issuer:       mockServer.URL,
          ClientID:     "test-client",
          ClientSecret: "test-secret",
      })

      tokens, err := provider.ExchangeCode(context.Background(), "test-code")
      require.NoError(t, err)
      assert.Equal(t, "mock-id-token", tokens.IDToken)
  }
  ```
integration_tests: |
  ```go
  func TestAuthentik_FullOIDCFlow(t *testing.T) {
      // Requires running Authentik instance
      if testing.Short() {
          t.Skip("skipping integration test")
      }

      provider := NewAuthentikProvider(&AuthentikConfig{
          Issuer:       os.Getenv("AUTHENTIK_ISSUER"),
          ClientID:     os.Getenv("AUTHENTIK_CLIENT_ID"),
          ClientSecret: os.Getenv("AUTHENTIK_CLIENT_SECRET"),
      })

      // Test discovery
      _, err := provider.Discover(context.Background())
      require.NoError(t, err)

      // Test JWKS fetch
      jwks, err := provider.FetchJWKS(context.Background())
      require.NoError(t, err)
      assert.NotEmpty(t, jwks.Keys)
  }
  ```
best_practices: |
  **Security**:
  - Use PKCE for authorization code flow
  - Validate state parameter to prevent CSRF
  - Verify ID token signature with JWKS
  - Check token expiration and audience claims
  - Use HTTPS for all endpoints

  **User Management**:
  - Enable auto_create_users for seamless onboarding
  - Map groups correctly for proper permissions
  - Update user info on login to sync changes
  - Handle edge cases (email changes, group removals)

  **Token Management**:
  - Store refresh tokens securely (encrypted)
  - Implement token rotation
  - Set appropriate session timeouts
  - Revoke tokens on logout

  **Monitoring**:
  - Log OIDC errors with context
  - Track failed login attempts
  - Monitor token refresh failures
  - Alert on Authentik connectivity issues
