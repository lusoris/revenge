doc_title: Production Deployment Setup
doc_category: operations
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: Complete production setup guide
status_sources: âœ…
status_sources_notes: All deployment tools documented
status_instructions: âœ…
status_instructions_notes: Generated from design
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Production deployment guide for self-hosting Revenge


  Multiple deployment options:

  - **Docker Compose**: Recommended for homelab, NAS deployments (Easy)

  - **Kubernetes (K3s)**: Lightweight Kubernetes for self-hosting (Moderate)

  - **Bare Metal**: Direct installation on Linux servers (Advanced)

  - **Reverse Proxy**: Traefik, Caddy, nginx for HTTPS and routing

  '
wiki_tagline: '> Deploy Revenge to your homelab or server with Docker, Kubernetes,
  or bare metal

  '
wiki_overview: 'This guide covers everything you need to deploy Revenge in production.
  The recommended approach uses Docker Compose for simple homelab setups - just create
  a docker-compose.yml, set a few environment variables, and run docker compose up.
  For larger deployments, Kubernetes (K3s) provides high availability and auto-scaling.
  Includes reverse proxy configuration (Traefik, Caddy, nginx), SSL setup with LetsEncrypt,
  backup strategies, and security hardening tips.

  '
sources:
- name: Dragonfly Documentation
  url: https://www.dragonflydb.io/docs
  note: Auto-resolved from dragonfly
- name: FFmpeg Documentation
  url: https://ffmpeg.org/ffmpeg.html
  note: Auto-resolved from ffmpeg
- name: FFmpeg Codecs
  url: https://ffmpeg.org/ffmpeg-codecs.html
  note: Auto-resolved from ffmpeg-codecs
- name: FFmpeg Formats
  url: https://ffmpeg.org/ffmpeg-formats.html
  note: Auto-resolved from ffmpeg-formats
- name: go-astiav (FFmpeg bindings)
  url: https://pkg.go.dev/github.com/asticode/go-astiav
  note: Auto-resolved from go-astiav
- name: go-astiav GitHub README
  url: https://github.com/asticode/go-astiav
  note: Auto-resolved from go-astiav-docs
- name: Go io
  url: https://pkg.go.dev/io
  note: Auto-resolved from go-io
- name: pgx PostgreSQL Driver
  url: https://pkg.go.dev/github.com/jackc/pgx/v5
  note: Auto-resolved from pgx
- name: PostgreSQL Arrays
  url: https://www.postgresql.org/docs/current/arrays.html
  note: Auto-resolved from postgresql-arrays
- name: PostgreSQL JSON Functions
  url: https://www.postgresql.org/docs/current/functions-json.html
  note: Auto-resolved from postgresql-json
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: rueidis
  url: https://pkg.go.dev/github.com/redis/rueidis
  note: Auto-resolved from rueidis
- name: rueidis GitHub README
  url: https://github.com/redis/rueidis
  note: Auto-resolved from rueidis-docs
- name: Typesense API
  url: https://typesense.org/docs/latest/api/
  note: Auto-resolved from typesense
- name: Typesense Go Client
  url: https://github.com/typesense/typesense-go
  note: Auto-resolved from typesense-go
design_refs:
- title: operations
  path: INDEX.md
- title: TECH_STACK
  path: ../technical/TECH_STACK.md
- title: REVERSE_PROXY
  path: ../operations/REVERSE_PROXY.md
- title: 00_SOURCE_OF_TRUTH
  path: 00_SOURCE_OF_TRUTH.md
operation_name: Production Deployment Setup
deployment_methods:
  docker_compose:
    name: Docker Compose
    difficulty: Easy
    recommended: true
    use_case: Homelab, NAS deployments (Synology, Unraid, TrueNAS)
    pros:
    - Simple setup with single docker-compose.yml
    - Built-in networking and volume management
    - Easy updates (docker-compose pull)
    - Minimal resource overhead
    cons:
    - Single-host only (no clustering)
    - No automatic failover
    - Manual backup management
  kubernetes:
    name: Kubernetes (K3s)
    difficulty: Moderate
    recommended: false
    use_case: Multi-server setups, high availability
    pros:
    - High availability and auto-healing
    - Rolling updates with zero downtime
    - Auto-scaling based on load
    - Built-in secrets management
    cons:
    - Higher resource usage (1GB+ RAM for K3s)
    - More complex troubleshooting
    - Overkill for single-user setups
  bare_metal:
    name: Bare Metal
    difficulty: Advanced
    recommended: false
    use_case: Custom installations, embedded systems
    pros:
    - Maximum performance (no container overhead)
    - Full control over system
    - Smallest resource footprint
    cons:
    - Manual dependency management
    - No isolation (conflicts with other apps)
    - Complex updates and rollbacks
system_requirements:
  minimum:
    cpu: 2 cores (x86_64 or ARM64)
    ram: 4 GB
    storage: 50 GB (plus media storage)
    network: 1 Gbps LAN recommended
  recommended:
    cpu: 4+ cores
    ram: 8+ GB
    storage: 500 GB+ SSD for database and cache
    network: 10 Gbps LAN for 4K streaming
  infrastructure_services:
    postgresql: 18.1+ (REQUIRED)
    dragonfly: Latest (Redis-compatible cache)
    typesense: Latest (search engine)
    ffmpeg: 6.0+ (transcoding)
docker_compose_setup: "## Docker Compose Deployment (Recommended)\n\n### 1. Prerequisites\n\
  \n```bash\n# Install Docker and Docker Compose\ncurl -fsSL https://get.docker.com\
  \ | sh\nsudo usermod -aG docker $USER\n\n# Verify installation\ndocker --version\n\
  docker compose version\n```\n\n### 2. Create Directory Structure\n\n```bash\nmkdir\
  \ -p /opt/revenge/{config,data,media}\ncd /opt/revenge\n```\n\n### 3. Download docker-compose.yml\n\
  \n```yaml\nversion: '3.8'\n\nservices:\n  revenge:\n    image: ghcr.io/yourorg/revenge:latest\n\
  \    container_name: revenge\n    restart: unless-stopped\n    ports:\n      - \"\
  8080:8080\"\n    environment:\n      # Database\n      REVENGE_DATABASE_URL: postgres://revenge:revenge@postgres:5432/revenge?sslmode=disable\n\
  \n      # Cache\n      REVENGE_CACHE_URL: redis://dragonfly:6379\n\n      # Search\n\
  \      REVENGE_TYPESENSE_URL: http://typesense:8108\n      REVENGE_TYPESENSE_API_KEY:\
  \ ${TYPESENSE_API_KEY}\n\n      # Server\n      REVENGE_SERVER_PORT: 8080\n    \
  \  REVENGE_LOG_LEVEL: info\n    volumes:\n      - ./config:/config\n      - ./data:/data\n\
  \      - ./media:/media\n    depends_on:\n      postgres:\n        condition: service_healthy\n\
  \      dragonfly:\n        condition: service_started\n      typesense:\n      \
  \  condition: service_started\n\n  postgres:\n    image: postgres:18-alpine\n  \
  \  container_name: revenge-postgres\n    restart: unless-stopped\n    environment:\n\
  \      POSTGRES_DB: revenge\n      POSTGRES_USER: revenge\n      POSTGRES_PASSWORD:\
  \ ${POSTGRES_PASSWORD}\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\
  \    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U revenge\"]\n    \
  \  interval: 10s\n      timeout: 5s\n      retries: 5\n\n  dragonfly:\n    image:\
  \ docker.dragonflydb.io/dragonflydb/dragonfly:latest\n    container_name: revenge-dragonfly\n\
  \    restart: unless-stopped\n    ulimits:\n      memlock: -1\n    volumes:\n  \
  \    - dragonfly_data:/data\n\n  typesense:\n    image: typesense/typesense:latest\n\
  \    container_name: revenge-typesense\n    restart: unless-stopped\n    environment:\n\
  \      TYPESENSE_DATA_DIR: /data\n      TYPESENSE_API_KEY: ${TYPESENSE_API_KEY}\n\
  \    volumes:\n      - typesense_data:/data\n\nvolumes:\n  postgres_data:\n  dragonfly_data:\n\
  \  typesense_data:\n```\n\n### 4. Create .env File\n\n```bash\ncat > .env <<EOF\n\
  POSTGRES_PASSWORD=$(openssl rand -base64 32)\nTYPESENSE_API_KEY=$(openssl rand -base64\
  \ 32)\nEOF\n```\n\n### 5. Start Services\n\n```bash\ndocker compose up -d\n\n# Check\
  \ logs\ndocker compose logs -f revenge\n\n# Verify all services running\ndocker\
  \ compose ps\n```\n\n### 6. First-Time Setup\n\nAccess web UI at: http://your-server:8080\n\
  \nComplete initial setup wizard:\n1. Create admin account\n2. Configure database\
  \ (auto-detected)\n3. Add media libraries\n4. (Optional) Enable QAR module\n"
kubernetes_setup: "## Kubernetes (K3s) Deployment\n\n### 1. Install K3s\n\n```bash\n\
  # Install K3s (single-node)\ncurl -sfL https://get.k3s.io | sh -\n\n# Verify installation\n\
  sudo k3s kubectl get nodes\n```\n\n### 2. Create Namespace\n\n```bash\nsudo k3s\
  \ kubectl create namespace revenge\n```\n\n### 3. Deploy PostgreSQL (StatefulSet)\n\
  \nUse Helm chart or operator (e.g., CloudNativePG).\n\n### 4. Deploy Revenge Application\n\
  \n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: revenge\n \
  \ namespace: revenge\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n    \
  \  app: revenge\n  template:\n    metadata:\n      labels:\n        app: revenge\n\
  \    spec:\n      containers:\n      - name: revenge\n        image: ghcr.io/yourorg/revenge:latest\n\
  \        ports:\n        - containerPort: 8080\n        env:\n        - name: REVENGE_DATABASE_URL\n\
  \          valueFrom:\n            secretKeyRef:\n              name: revenge-secrets\n\
  \              key: database-url\n        volumeMounts:\n        - name: media\n\
  \          mountPath: /media\n      volumes:\n      - name: media\n        persistentVolumeClaim:\n\
  \          claimName: revenge-media-pvc\n```\n\n### 5. Create Ingress (Traefik)\n\
  \n```yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: revenge-ingress\n\
  \  namespace: revenge\nspec:\n  rules:\n  - host: revenge.example.com\n    http:\n\
  \      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n   \
  \       service:\n            name: revenge\n            port:\n              number:\
  \ 8080\n```\n"
reverse_proxy_setup: "## Reverse Proxy Configuration\n\n### Traefik (Recommended for\
  \ Docker)\n\nAdd labels to docker-compose.yml:\n\n```yaml\nservices:\n  revenge:\n\
  \    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.revenge.rule=Host(`revenge.example.com`)\"\
  \n      - \"traefik.http.routers.revenge.entrypoints=websecure\"\n      - \"traefik.http.routers.revenge.tls.certresolver=letsencrypt\"\
  \n```\n\n### Caddy\n\n```\nrevenge.example.com {\n  reverse_proxy revenge:8080\n\
  }\n```\n\n### nginx\n\n```nginx\nserver {\n  listen 443 ssl http2;\n  server_name\
  \ revenge.example.com;\n\n  ssl_certificate /etc/ssl/certs/revenge.crt;\n  ssl_certificate_key\
  \ /etc/ssl/private/revenge.key;\n\n  location / {\n    proxy_pass http://localhost:8080;\n\
  \    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n\
  \    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header\
  \ X-Forwarded-Proto $scheme;\n\n    # WebSocket support\n    proxy_http_version\
  \ 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection\
  \ \"upgrade\";\n  }\n}\n```\n"
ssl_setup: "## HTTPS/SSL Setup\n\n### Let's Encrypt with Traefik (Automatic)\n\nTraefik\
  \ handles SSL automatically with built-in Let's Encrypt support.\n\n### Let's Encrypt\
  \ with Certbot (Manual)\n\n```bash\n# Install certbot\nsudo apt install certbot\n\
  \n# Generate certificate\nsudo certbot certonly --standalone -d revenge.example.com\n\
  \n# Auto-renewal (cron)\nsudo certbot renew --dry-run\n```\n\n### Self-Signed Certificate\
  \ (Testing)\n\n```bash\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n\
  \  -keyout /etc/ssl/private/revenge.key \\\n  -out /etc/ssl/certs/revenge.crt \\\
  \n  -subj \"/CN=revenge.local\"\n```\n"
backup_and_restore: "## Backup Strategy\n\n### What to Backup\n\n1. **Database** (PostgreSQL)\n\
  2. **Configuration** (/config directory)\n3. **User Data** (/data directory - watch\
  \ history, collections, etc.)\n4. **Media** (optional - usually already backed up\
  \ separately)\n\n### PostgreSQL Backup\n\n```bash\n# Manual backup\ndocker exec\
  \ revenge-postgres pg_dump -U revenge revenge > backup.sql\n\n# Automated daily\
  \ backup (cron)\n0 2 * * * docker exec revenge-postgres pg_dump -U revenge revenge\
  \ | gzip > /backups/revenge-$(date +\\%Y\\%m\\%d).sql.gz\n```\n\n### Full Backup\
  \ (Docker Compose)\n\n```bash\n# Stop services\ndocker compose down\n\n# Backup\
  \ volumes\ntar -czf revenge-backup-$(date +%Y%m%d).tar.gz \\\n  /opt/revenge/config\
  \ \\\n  /opt/revenge/data \\\n  /var/lib/docker/volumes/revenge_postgres_data\n\n\
  # Restart services\ndocker compose up -d\n```\n\n### Restore from Backup\n\n```bash\n\
  # Restore PostgreSQL\ndocker exec -i revenge-postgres psql -U revenge revenge <\
  \ backup.sql\n\n# Restore config and data\ntar -xzf revenge-backup-20260131.tar.gz\
  \ -C /\n```\n"
updates_and_maintenance: '## Updates


  ### Docker Compose Updates


  ```bash

  cd /opt/revenge


  # Pull latest images

  docker compose pull


  # Recreate containers

  docker compose up -d


  # Check logs

  docker compose logs -f revenge

  ```


  ### Kubernetes Updates


  ```bash

  # Update image tag

  kubectl set image deployment/revenge revenge=ghcr.io/yourorg/revenge:v2.0.0 -n revenge


  # Rolling update automatically applies

  kubectl rollout status deployment/revenge -n revenge

  ```


  ### Database Migrations


  Migrations run automatically on startup. Check logs:


  ```bash

  docker compose logs revenge | grep migration

  ```

  '
monitoring_and_logs: "## Monitoring\n\n### Health Checks\n\n```bash\n# Liveness check\n\
  curl http://localhost:8080/health/live\n\n# Readiness check\ncurl http://localhost:8080/health/ready\n\
  ```\n\n### Metrics (Prometheus)\n\nMetrics endpoint: http://localhost:8080/metrics\n\
  \n```yaml\n# prometheus.yml\nscrape_configs:\n  - job_name: 'revenge'\n    static_configs:\n\
  \      - targets: ['revenge:8080']\n```\n\n### Logs\n\n```bash\n# Docker Compose\
  \ logs\ndocker compose logs -f revenge\n\n# Kubernetes logs\nkubectl logs -f deployment/revenge\
  \ -n revenge\n\n# Export to Loki/Grafana (optional)\n```\n"
troubleshooting:
- problem: Container won't start
  cause: Environment misconfiguration or dependency issues
  solution: '1. Check logs: `docker compose logs revenge`

    2. Verify environment variables in .env

    3. Ensure PostgreSQL is ready: `docker compose ps postgres`

    '
- problem: Cannot connect to database
  cause: PostgreSQL not ready or network issue
  solution: '1. Check PostgreSQL health: `docker exec revenge-postgres pg_isready`

    2. Verify DATABASE_URL in environment

    3. Check network: `docker compose exec revenge ping postgres`

    '
- problem: Reverse proxy returns 502 Bad Gateway
  cause: Backend not running or unhealthy
  solution: '1. Verify Revenge is running: `docker compose ps`

    2. Check backend is healthy: `curl http://localhost:8080/health/live`

    3. Review proxy logs (Traefik/nginx/Caddy)

    '
- problem: Slow performance / high CPU
  cause: Resource constraints or heavy transcoding load
  solution: '1. Check Docker resource limits

    2. Review active transcoding jobs: `docker compose logs revenge | grep transcode`

    3. Increase dragonfly cache size

    4. Consider offloading transcoding to Blackbeard

    '
security_considerations: "## Security Best Practices\n\n1. **Change Default Passwords**\n\
  \   - PostgreSQL: Use strong password in .env\n   - Typesense: Generate secure API\
  \ key\n\n2. **Use HTTPS**\n   - Always deploy behind reverse proxy with SSL\n  \
  \ - Never expose port 8080 directly to internet\n\n3. **Firewall Rules**\n   ```bash\n\
  \   # Allow only HTTPS and SSH\n   sudo ufw allow 443/tcp\n   sudo ufw allow 22/tcp\n\
  \   sudo ufw enable\n   ```\n\n4. **Regular Updates**\n   - Update Revenge weekly\n\
  \   - Update base images monthly\n   - Monitor security advisories\n\n5. **Backup\
  \ Encryption**\n   - Encrypt backups at rest\n   - Use secure backup location\n\n\
  6. **Network Isolation**\n   - Keep database and cache on internal network only\n\
  \   - Use Docker networks for service isolation\n"
