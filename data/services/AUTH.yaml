doc_title: Auth Service
doc_category: service
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Authentication, registration, and password management'
wiki_tagline: '> Authentication, registration, and password management'
wiki_overview: The Auth service handles user login, registration, and password management. It supports local accounts with
  email/password, plus external providers via OIDC (Google, GitHub, etc.). Passwords are hashed with Argon2. Failed login
  attempts trigger rate limiting and temporary lockouts. Password reset uses secure time-limited tokens sent via email.
sources:
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: ogen OpenAPI Generator
  url: https://pkg.go.dev/github.com/ogen-go/ogen
  note: Auto-resolved from ogen
design_refs:
- title: services
  path: INDEX.md
- title: 01_ARCHITECTURE
  path: ../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../architecture/03_METADATA_SYSTEM.md
service_name: Auth Service
package_path: internal/service/auth
fx_module: auth.Module
architecture_diagram: |-
  ```mermaid
  flowchart TD
      subgraph row1[ ]
          direction LR
          node1(["Client<br/>(Web/App)"])
          node2[["API Handler<br/>(ogen)"]]
          node3[["Service<br/>(Logic)"]]
      end
      subgraph row2[ ]
          direction LR
          node4["Repository<br/>(sqlc)"]
          node5[["Metadata<br/>Service"]]
          node6[("Cache<br/>(otter)")]
      end
      subgraph row3[ ]
          direction LR
          node7[("PostgreSQL<br/>(pgx)")]
          node8(["External<br/>APIs"])
      end
      node1 --> node2
      node2 --> node3
      node4 --> node5
      node5 --> node6
      node7 --> node8
      node3 --> node4
      node6 --> node7

      %% Hide row subgraph borders
      style row1 fill:transparent,stroke:transparent
      style row2 fill:transparent,stroke:transparent
      style row3 fill:transparent,stroke:transparent
  ```
database_schema: |
  **Schema**: `public`

  ```sql
  -- Users (main user accounts)
  CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Identity
    username VARCHAR(255) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    display_name TEXT,

    -- Password (local auth only)
    password_hash TEXT,                            -- Argon2id hash (nullable for OIDC-only users)

    -- Status
    email_verified BOOLEAN DEFAULT false,
    is_active BOOLEAN DEFAULT true,
    is_admin BOOLEAN DEFAULT false,

    -- Account security
    failed_login_attempts INTEGER DEFAULT 0,
    locked_until TIMESTAMPTZ,

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_users_email ON users(email);
  CREATE INDEX idx_users_username ON users(username);
  CREATE INDEX idx_users_active ON users(is_active) WHERE is_active = true;

  -- Password reset tokens
  CREATE TABLE password_reset_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    token_hash TEXT NOT NULL UNIQUE,               -- SHA-256 hash of token
    expires_at TIMESTAMPTZ NOT NULL,

    used_at TIMESTAMPTZ,                           -- NULL if not used yet
    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_reset_tokens_user ON password_reset_tokens(user_id);
  CREATE INDEX idx_reset_tokens_expires ON password_reset_tokens(expires_at);

  -- Email verification tokens
  CREATE TABLE email_verification_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    token_hash TEXT NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL,                   -- Email to verify
    expires_at TIMESTAMPTZ NOT NULL,

    verified_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_email_tokens_user ON email_verification_tokens(user_id);

  -- Login history (audit log)
  CREATE TABLE login_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,

    -- Login details
    username_attempted VARCHAR(255),
    success BOOLEAN NOT NULL,
    failure_reason TEXT,                           -- 'invalid_password', 'account_locked', 'user_not_found'

    -- Client info
    ip_address INET,
    user_agent TEXT,
    device_id TEXT,

    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_login_history_user ON login_history(user_id, created_at DESC);
  CREATE INDEX idx_login_history_ip ON login_history(ip_address, created_at DESC);
  ```
module_structure: |
  ```
  internal/service/auth/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ types.go                     # Domain types
  â”œâ”€â”€ repository.go                # Database operations (sqlc)
  â”œâ”€â”€ service.go                   # Auth service logic
  â”œâ”€â”€ password.go                  # Password hashing (Argon2)
  â”œâ”€â”€ tokens.go                    # Reset/verification token generation
  â”œâ”€â”€ ratelimit.go                 # Login rate limiting
  â”œâ”€â”€ handler.go                   # HTTP API handlers
  â””â”€â”€ auth_test.go

  web/src/routes/(auth)/
  â”œâ”€â”€ login/
  â”‚   â””â”€â”€ +page.svelte             # Login form
  â”œâ”€â”€ register/
  â”‚   â””â”€â”€ +page.svelte             # Registration form
  â”œâ”€â”€ forgot-password/
  â”‚   â””â”€â”€ +page.svelte             # Password reset request
  â”œâ”€â”€ reset-password/
  â”‚   â””â”€â”€ +page.svelte             # Password reset form
  â””â”€â”€ verify-email/
      â””â”€â”€ +page.svelte             # Email verification
  ```
key_interfaces: |
  ```go
  type AuthService interface {
    // Registration
    Register(ctx context.Context, req RegisterRequest) (*User, error)
    VerifyEmail(ctx context.Context, token string) error
    ResendVerification(ctx context.Context, userID uuid.UUID) error

    // Login
    Login(ctx context.Context, username, password string) (*User, error)
    Logout(ctx context.Context, sessionID uuid.UUID) error

    // Password management
    ChangePassword(ctx context.Context, userID uuid.UUID, oldPassword, newPassword string) error
    RequestPasswordReset(ctx context.Context, email string) error
    ResetPassword(ctx context.Context, token, newPassword string) error

    // Account security
    CheckRateLimit(ctx context.Context, identifier string) error
    RecordLoginAttempt(ctx context.Context, userID uuid.UUID, success bool, ip net.IP) error
  }

  type RegisterRequest struct {
    Username    string `json:"username"`
    Email       string `json:"email"`
    Password    string `json:"password"`
    DisplayName string `json:"display_name,omitempty"`
  }

  type User struct {
    ID            uuid.UUID  `db:"id" json:"id"`
    Username      string     `db:"username" json:"username"`
    Email         string     `db:"email" json:"email"`
    DisplayName   *string    `db:"display_name" json:"display_name,omitempty"`
    EmailVerified bool       `db:"email_verified" json:"email_verified"`
    IsActive      bool       `db:"is_active" json:"is_active"`
    IsAdmin       bool       `db:"is_admin" json:"is_admin"`
    CreatedAt     time.Time  `db:"created_at" json:"created_at"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/google/uuid`
  - `github.com/jackc/pgx/v5`
  - `golang.org/x/crypto/argon2` - Password hashing
  - `github.com/alexedwards/argon2id` - Argon2 helper
  - `crypto/rand` - Token generation
  - `crypto/sha256` - Token hashing
  - `go.uber.org/fx`

  **External Services**:
  - Email service (SMTP) for verification and password reset emails
env_vars: |
  ```bash
  AUTH_PASSWORD_MIN_LENGTH=8
  AUTH_ARGON2_TIME=1
  AUTH_ARGON2_MEMORY=64
  AUTH_ARGON2_THREADS=4
  AUTH_RESET_TOKEN_EXPIRY=1h
  AUTH_VERIFICATION_TOKEN_EXPIRY=24h
  AUTH_MAX_LOGIN_ATTEMPTS=5
  AUTH_LOCKOUT_DURATION=15m
  ```
config_keys: |
  ```yaml
  auth:
    password:
      min_length: 8
      require_uppercase: true
      require_lowercase: true
      require_number: true
      require_special: false
    argon2:
      time: 1
      memory: 64  # MiB
      threads: 4
    tokens:
      reset_expiry: 1h
      verification_expiry: 24h
    security:
      max_login_attempts: 5
      lockout_duration: 15m
  ```
component_interaction: |
  **Registration Flow**:
  1. User submits registration form (username, email, password)
  2. POST /api/v1/auth/register
  3. Service validates input (password strength, unique email/username)
  4. Hash password with Argon2id
  5. Insert user into users table (email_verified=false)
  6. Generate email verification token (random 32 bytes, SHA-256 hashed)
  7. Store in email_verification_tokens
  8. Send verification email with token link
  9. Return user (without password hash)

  **Login Flow**:
  1. User submits login form (username/email, password)
  2. POST /api/v1/auth/login
  3. Check rate limit (IP + username)
  4. Fetch user by username or email
  5. Check if account is locked (locked_until > now)
  6. Verify password with Argon2id
  7. If invalid, increment failed_login_attempts, record in login_history
  8. If valid, reset failed_login_attempts, create session (see SESSION service)
  9. Record successful login in login_history
  10. Return session token

  **Password Reset Flow**:
  1. User requests reset via POST /api/v1/auth/forgot-password with email
  2. Service finds user by email
  3. Generate reset token (random 32 bytes, SHA-256 hashed)
  4. Insert into password_reset_tokens with 1h expiry
  5. Send email with reset link
  6. User clicks link: GET /reset-password?token=...
  7. User submits new password: POST /api/v1/auth/reset-password
  8. Service verifies token (not expired, not used)
  9. Hash new password, update users.password_hash
  10. Mark token as used (used_at = now)
api_endpoints: |
  ```
  POST   /api/v1/auth/register          # Register new user
  POST   /api/v1/auth/login             # Login with credentials
  POST   /api/v1/auth/logout            # Logout (invalidate session)
  POST   /api/v1/auth/verify-email      # Verify email with token
  POST   /api/v1/auth/resend-verification # Resend verification email
  POST   /api/v1/auth/forgot-password   # Request password reset
  POST   /api/v1/auth/reset-password    # Reset password with token
  POST   /api/v1/auth/change-password   # Change password (authenticated)
  ```

  **Example Register Request**:
  ```json
  {
    "username": "johndoe",
    "email": "john@example.com",
    "password": "SecurePass123!",
    "display_name": "John Doe"
  }
  ```

  **Example Register Response**:
  ```json
  {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "username": "johndoe",
    "email": "john@example.com",
    "display_name": "John Doe",
    "email_verified": false,
    "is_active": true,
    "created_at": "2026-02-01T10:00:00Z"
  }
  ```

  **Example Login Request**:
  ```json
  {
    "username": "johndoe",
    "password": "SecurePass123!"
  }
  ```

  **Example Login Response**:
  ```json
  {
    "user": {
      "id": "123e4567-e89b-12d3-a456-426614174000",
      "username": "johndoe",
      "email": "john@example.com"
    },
    "session_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }
  ```
unit_tests: |
  ```go
  func TestAuthService_Register(t *testing.T) {
    // Test user registration with valid inputs
    // Test duplicate email/username rejection
  }

  func TestAuthService_Login(t *testing.T) {
    // Test successful login
    // Test invalid password
    // Test account lockout after max attempts
  }

  func TestPassword_Hashing(t *testing.T) {
    // Test Argon2 password hashing and verification
  }
  ```
integration_tests: |
  ```go
  func TestAuth_RegistrationFlow(t *testing.T) {
    // Test complete registration + email verification flow
  }

  func TestAuth_PasswordResetFlow(t *testing.T) {
    // Test forgot password + reset workflow
  }

  func TestAuth_RateLimiting(t *testing.T) {
    // Test rate limiting after failed login attempts
  }
  ```
