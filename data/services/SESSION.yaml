doc_title: Session Service
doc_category: service
created_date: '2026-01-31'
overall_status: ‚úÖ Complete
status_design: ‚úÖ
status_design_notes: '-'
status_sources: ‚úÖ
status_sources_notes: '-'
status_instructions: ‚úÖ
status_instructions_notes: '-'
status_code: üî¥
status_code_notes: '-'
status_linting: üî¥
status_linting_notes: '-'
status_unit_testing: üî¥
status_unit_testing_notes: '-'
status_integration_testing: üî¥
status_integration_testing_notes: '-'
technical_summary: '> Session token management and device tracking'
wiki_tagline: '> Session token management and device tracking'
wiki_overview: The Session service tracks active login sessions across devices. Each login creates a session with device info
  (browser, OS, IP). Users can view all active sessions and revoke access to specific devices. Sessions expire automatically
  after inactivity. Admins can forcibly terminate sessions for security incidents.
sources:
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: ogen OpenAPI Generator
  url: https://pkg.go.dev/github.com/ogen-go/ogen
  note: Auto-resolved from ogen
- name: pgx PostgreSQL Driver
  url: https://pkg.go.dev/github.com/jackc/pgx/v5
  note: Auto-resolved from pgx
- name: PostgreSQL Arrays
  url: https://www.postgresql.org/docs/current/arrays.html
  note: Auto-resolved from postgresql-arrays
- name: PostgreSQL JSON Functions
  url: https://www.postgresql.org/docs/current/functions-json.html
  note: Auto-resolved from postgresql-json
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: sqlc
  url: https://docs.sqlc.dev/en/stable/
  note: Auto-resolved from sqlc
- name: sqlc Configuration
  url: https://docs.sqlc.dev/en/stable/reference/config.html
  note: Auto-resolved from sqlc-config
design_refs:
- title: services
  path: INDEX.md
- title: 01_ARCHITECTURE
  path: ../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../architecture/03_METADATA_SYSTEM.md
service_name: Session Service
package_path: internal/service/session
fx_module: session.Module
architecture_diagram: |-
  ```mermaid
  flowchart TD
      node1["Client<br/>(Web/App)"]
      node2["Middleware<br/>(Auth)"]
      node3["Service<br/>(Logic)"]
      node4["‚ñº            ‚ñº            ‚ñº<br/>‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br/>tory"]
      node5["PostgreSQL<br/>(pgx)"]
      node1 --> node2
      node2 --> node3
      node3 --> node4
      node4 --> node5
  ```
database_schema: |
  **Schema**: `public`

  ```sql
  -- Active user sessions
  CREATE TABLE sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Token
    token_hash TEXT NOT NULL UNIQUE,               -- SHA-256 hash of session token

    -- Device info
    device_id TEXT,
    device_name TEXT,
    user_agent TEXT,
    ip_address INET,

    -- Geolocation
    country VARCHAR(2),                            -- ISO 3166-1 alpha-2
    city TEXT,

    -- Session lifecycle
    created_at TIMESTAMPTZ DEFAULT now(),
    last_activity_at TIMESTAMPTZ DEFAULT now(),
    expires_at TIMESTAMPTZ NOT NULL,

    -- Status
    is_active BOOLEAN DEFAULT true,
    revoked_at TIMESTAMPTZ,
    revoked_reason TEXT                            -- 'user_logout', 'admin_revoke', 'security_incident'
  );
  CREATE INDEX idx_sessions_user ON sessions(user_id, created_at DESC);
  CREATE INDEX idx_sessions_token_hash ON sessions(token_hash);
  CREATE INDEX idx_sessions_active ON sessions(is_active, expires_at) WHERE is_active = true;
  CREATE INDEX idx_sessions_expires ON sessions(expires_at);

  -- Session refresh tokens (for mobile apps)
  CREATE TABLE refresh_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,

    token_hash TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMPTZ NOT NULL,

    used_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_refresh_tokens_session ON refresh_tokens(session_id);
  CREATE INDEX idx_refresh_tokens_token_hash ON refresh_tokens(token_hash);
  ```
module_structure: |
  ```
  internal/service/session/
  ‚îú‚îÄ‚îÄ module.go                    # fx module
  ‚îú‚îÄ‚îÄ types.go                     # Domain types
  ‚îú‚îÄ‚îÄ repository.go                # Database operations (sqlc)
  ‚îú‚îÄ‚îÄ service.go                   # Session service logic
  ‚îú‚îÄ‚îÄ tokens.go                    # Token generation and hashing
  ‚îú‚îÄ‚îÄ middleware.go                # HTTP auth middleware
  ‚îú‚îÄ‚îÄ cleanup.go                   # Expired session cleanup (River job)
  ‚îú‚îÄ‚îÄ handler.go                   # HTTP API handlers
  ‚îî‚îÄ‚îÄ session_test.go

  web/src/routes/(app)/settings/
  ‚îî‚îÄ‚îÄ sessions/
      ‚îî‚îÄ‚îÄ +page.svelte             # Active sessions management
  ```
key_interfaces: |
  ```go
  type SessionService interface {
    // Session management
    CreateSession(ctx context.Context, userID uuid.UUID, deviceInfo DeviceInfo) (*Session, string, error) // Returns session and token
    GetSession(ctx context.Context, token string) (*Session, error)
    ValidateSession(ctx context.Context, token string) (*Session, error)
    RefreshSession(ctx context.Context, refreshToken string) (*Session, string, error)

    // Session operations
    RevokeSession(ctx context.Context, sessionID uuid.UUID) error
    RevokeAllSessions(ctx context.Context, userID uuid.UUID) error
    ListUserSessions(ctx context.Context, userID uuid.UUID) ([]Session, error)
    UpdateActivity(ctx context.Context, sessionID uuid.UUID) error

    // Cleanup
    CleanupExpiredSessions(ctx context.Context) (int, error)
  }

  type Session struct {
    ID             uuid.UUID  `db:"id" json:"id"`
    UserID         uuid.UUID  `db:"user_id" json:"user_id"`
    DeviceID       *string    `db:"device_id" json:"device_id,omitempty"`
    DeviceName     *string    `db:"device_name" json:"device_name,omitempty"`
    UserAgent      *string    `db:"user_agent" json:"user_agent,omitempty"`
    IPAddress      *net.IP    `db:"ip_address" json:"ip_address,omitempty"`
    CreatedAt      time.Time  `db:"created_at" json:"created_at"`
    LastActivityAt time.Time  `db:"last_activity_at" json:"last_activity_at"`
    ExpiresAt      time.Time  `db:"expires_at" json:"expires_at"`
    IsActive       bool       `db:"is_active" json:"is_active"`
  }

  type DeviceInfo struct {
    DeviceID   string
    DeviceName string
    UserAgent  string
    IPAddress  net.IP
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/google/uuid`
  - `github.com/jackc/pgx/v5`
  - `github.com/redis/rueidis` - Session cache (L2)
  - `github.com/maypok86/otter` - Session cache (L1)
  - `crypto/rand` - Token generation
  - `crypto/sha256` - Token hashing
  - `github.com/riverqueue/river` - Session cleanup jobs
  - `net` - IP address handling
  - `go.uber.org/fx`
env_vars: |
  ```bash
  SESSION_TOKEN_LENGTH=32           # bytes
  SESSION_EXPIRY=720h               # 30 days
  SESSION_REFRESH_TOKEN_EXPIRY=2160h  # 90 days
  SESSION_INACTIVITY_TIMEOUT=168h   # 7 days
  SESSION_CLEANUP_INTERVAL=1h
  ```
config_keys: |
  ```yaml
  session:
    token_length: 32
    expiry: 720h
    refresh_token_expiry: 2160h
    inactivity_timeout: 168h
    cleanup_interval: 1h
    max_sessions_per_user: 10
  ```
component_interaction: |
  **Session Creation** (on login):
  1. User successfully authenticates (see AUTH service)
  2. Generate session token (32 random bytes, base64 encoded)
  3. Hash token with SHA-256
  4. Parse User-Agent for device info (browser, OS)
  5. Insert into sessions table (token_hash, user_id, device_info, expires_at)
  6. Cache session in Redis: SET session:{token_hash} {session_id} EX 30days
  7. Return raw token to client (only time it's visible)

  **Session Validation** (middleware):
  1. Extract Bearer token from Authorization header
  2. Hash token with SHA-256
  3. Check L1 cache (otter) for session
  4. If miss, check L2 cache (Redis): GET session:{token_hash}
  5. If miss, query sessions table by token_hash
  6. Verify: is_active = true AND expires_at > now AND last_activity_at within inactivity_timeout
  7. If valid:
     - Update last_activity_at (debounced, max once per 5 min)
     - Store in L1/L2 cache
     - Attach user to request context
  8. If invalid, return 401 Unauthorized

  **Session Revocation** (logout):
  1. User clicks logout
  2. POST /api/v1/sessions/current/revoke
  3. Service marks session as inactive: UPDATE sessions SET is_active = false, revoked_at = now, revoked_reason = 'user_logout'
  4. Invalidate cache: DEL session:{token_hash}
  5. Return success

  **Session Cleanup** (background):
  1. River job runs every hour
  2. Delete expired sessions: DELETE FROM sessions WHERE expires_at < now OR (is_active = true AND last_activity_at < now - inactivity_timeout)
  3. Cleanup orphaned refresh tokens
api_endpoints: |
  ```
  POST   /api/v1/sessions              # Create session (internal, called by auth service)
  GET    /api/v1/sessions              # List current user's sessions
  GET    /api/v1/sessions/current      # Get current session info
  POST   /api/v1/sessions/refresh      # Refresh session with refresh token
  DELETE /api/v1/sessions/current      # Revoke current session (logout)
  DELETE /api/v1/sessions/:id          # Revoke specific session
  DELETE /api/v1/sessions              # Revoke all sessions (logout everywhere)
  ```

  **Example Session Response**:
  ```json
  {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "user_id": "987fcdeb-51a2-43d7-9876-ba98765432ab",
    "device_name": "Chrome on MacOS",
    "ip_address": "192.168.1.100",
    "created_at": "2026-02-01T10:00:00Z",
    "last_activity_at": "2026-02-01T12:30:00Z",
    "expires_at": "2026-03-03T10:00:00Z",
    "is_active": true
  }
  ```

  **Example List Sessions Response**:
  ```json
  {
    "sessions": [
      {
        "id": "...",
        "device_name": "Chrome on MacOS",
        "ip_address": "192.168.1.100",
        "country": "US",
        "city": "New York",
        "created_at": "2026-02-01T10:00:00Z",
        "last_activity_at": "2026-02-01T12:30:00Z",
        "is_current": true
      },
      {
        "id": "...",
        "device_name": "Revenge iOS App",
        "ip_address": "10.0.0.50",
        "created_at": "2026-01-25T08:00:00Z",
        "last_activity_at": "2026-02-01T09:00:00Z",
        "is_current": false
      }
    ]
  }
  ```
unit_tests: |
  ```go
  func TestSessionService_CreateSession(t *testing.T) {
    // Test session creation with token generation
  }

  func TestSessionService_ValidateSession(t *testing.T) {
    // Test session validation (active, not expired)
    // Test invalid session (revoked, expired)
  }

  func TestTokens_Generation(t *testing.T) {
    // Test secure random token generation
  }
  ```
integration_tests: |
  ```go
  func TestSession_FullLifecycle(t *testing.T) {
    // Test create -> validate -> revoke workflow
  }

  func TestSession_Middleware(t *testing.T) {
    // Test HTTP middleware auth flow
  }

  func TestSession_Cleanup(t *testing.T) {
    // Test expired session cleanup job
  }
  ```
