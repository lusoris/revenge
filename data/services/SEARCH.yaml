doc_title: Search Service
doc_category: service
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Full-text search via Typesense with per-module collections'
wiki_tagline: '> Full-text search via Typesense with per-module collections'
wiki_overview: Search instantly across your entire library using Typesense. Find movies, shows, music, and people with typo-tolerant
  full-text search. Results are filtered by user permissions - you only see content you have access to. Search supports filters
  (year, genre, rating), facets, and sorting. Separate collections per media type ensure fast, relevant results.
sources:
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
- name: Typesense API
  url: https://typesense.org/docs/latest/api/
  note: Auto-resolved from typesense
- name: Typesense Go Client
  url: https://github.com/typesense/typesense-go
  note: Auto-resolved from typesense-go
design_refs:
- title: services
  path: INDEX.md
- title: 01_ARCHITECTURE
  path: ../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../architecture/03_METADATA_SYSTEM.md
service_name: Search Service
package_path: internal/service/search
fx_module: search.Module
architecture_diagram: |-
  ```mermaid
  flowchart LR
      subgraph Layer1["Layer 1"]
          node1(["Client<br/>(Web/App)"])
          node2[["API Handler<br/>(ogen)"]]
          node3[["Service<br/>(Logic)"]]
      end

      subgraph Layer2["Layer 2"]
          node4["Repository<br/>(sqlc)"]
          node5(["Typesense<br/>Client"])
          node6[["RBAC<br/>Service"]]
      end

      subgraph Layer3["Layer 3"]
          node7[("PostgreSQL<br/>(pgx)")]
          node8["Typesense<br/>Server"]
      end

      %% Connections
      node3 --> node4
      node6 --> node7

      %% Styling
      style Layer1 fill:#1976D2,stroke:#1976D2,color:#fff
      style Layer2 fill:#388E3C,stroke:#388E3C,color:#fff
      style Layer3 fill:#7B1FA2,stroke:#7B1FA2,color:#fff
  ```
database_schema: |
  **Schema**: `public`

  ```sql
  -- Search indexing queue (sync from PostgreSQL to Typesense)
  CREATE TABLE search_index_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Content reference
    collection_name VARCHAR(100) NOT NULL,         -- 'movies', 'tvshows', 'albums', 'people'
    document_id TEXT NOT NULL,
    operation VARCHAR(20) NOT NULL,                -- 'index', 'update', 'delete'

    -- Document data (JSONB for Typesense)
    document_data JSONB,

    -- Status
    status VARCHAR(20) DEFAULT 'pending',          -- 'pending', 'processing', 'completed', 'failed'
    attempts INTEGER DEFAULT 0,
    error_message TEXT,

    queued_at TIMESTAMPTZ DEFAULT now(),
    processed_at TIMESTAMPTZ
  );
  CREATE INDEX idx_search_queue_status ON search_index_queue(status, queued_at);
  CREATE INDEX idx_search_queue_collection ON search_index_queue(collection_name, status);

  -- Search query log (analytics)
  CREATE TABLE search_query_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,

    -- Query details
    query TEXT NOT NULL,
    collection_name VARCHAR(100),
    filters JSONB,                                 -- Applied filters
    results_count INTEGER,

    -- Performance
    latency_ms INTEGER,

    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_search_log_user ON search_query_log(user_id, created_at DESC);
  CREATE INDEX idx_search_log_query ON search_query_log(query, created_at DESC);
  ```
module_structure: |
  ```
  internal/service/search/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ types.go                     # Domain types
  â”œâ”€â”€ repository.go                # Database operations (sqlc)
  â”œâ”€â”€ service.go                   # Search service logic
  â”œâ”€â”€ typesense.go                 # Typesense client wrapper
  â”œâ”€â”€ indexer.go                   # Document indexing
  â”œâ”€â”€ sync.go                      # PostgreSQL -> Typesense sync (River jobs)
  â”œâ”€â”€ collections.go               # Collection schema definitions
  â”œâ”€â”€ handler.go                   # HTTP API handlers
  â””â”€â”€ search_test.go

  web/src/routes/(app)/search/
  â””â”€â”€ +page.svelte                 # Global search UI
  ```
key_interfaces: |
  ```go
  type SearchService interface {
    // Search
    Search(ctx context.Context, query SearchQuery) (*SearchResults, error)
    MultiSearch(ctx context.Context, queries []SearchQuery) ([]SearchResults, error)

    // Indexing
    IndexDocument(ctx context.Context, collection string, document interface{}) error
    UpdateDocument(ctx context.Context, collection, id string, document interface{}) error
    DeleteDocument(ctx context.Context, collection, id string) error
    BulkIndex(ctx context.Context, collection string, documents []interface{}) error

    // Collections
    CreateCollection(ctx context.Context, schema CollectionSchema) error
    DeleteCollection(ctx context.Context, name string) error
    ListCollections(ctx context.Context) ([]string, error)

    // Sync
    SyncAll(ctx context.Context) error
    SyncCollection(ctx context.Context, collectionName string) error
  }

  type SearchQuery struct {
    Query          string            `json:"q"`
    Collections    []string          `json:"collections"`    // ['movies', 'tvshows']
    QueryBy        []string          `json:"query_by"`       // ['title', 'overview']
    FilterBy       string            `json:"filter_by"`      // 'release_year:>2020'
    SortBy         string            `json:"sort_by"`        // 'rating:desc'
    Page           int               `json:"page"`
    PerPage        int               `json:"per_page"`
    UserID         uuid.UUID         `json:"-"`              // For permission filtering
  }

  type SearchResults struct {
    Hits          []SearchHit       `json:"hits"`
    Found         int               `json:"found"`
    Page          int               `json:"page"`
    SearchTimeMS  int               `json:"search_time_ms"`
  }

  type SearchHit struct {
    Document      map[string]interface{} `json:"document"`
    Highlights    map[string]interface{} `json:"highlights"`
    TextMatch     int64                  `json:"text_match"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/google/uuid`
  - `github.com/jackc/pgx/v5`
  - `github.com/typesense/typesense-go/typesense` - Typesense client
  - `github.com/riverqueue/river` - Background sync jobs
  - `go.uber.org/fx`

  **External Services**:
  - Typesense server (https://typesense.org/)
env_vars: |
  ```bash
  TYPESENSE_HOST=localhost
  TYPESENSE_PORT=8108
  TYPESENSE_API_KEY=your_api_key
  TYPESENSE_PROTOCOL=http
  SEARCH_SYNC_INTERVAL=5m
  ```
config_keys: |
  ```yaml
  search:
    typesense:
      host: localhost
      port: 8108
      api_key: your_api_key
      protocol: http
    sync:
      interval: 5m
      batch_size: 100
    query:
      max_results: 50
      typo_tolerance: true
  ```
component_interaction: |
  **Document Indexing** (when content is added):
  1. New movie created in PostgreSQL (via library scanner)
  2. INSERT trigger enqueues search_index_queue record
  3. River job processes queue every 5 seconds
  4. For each pending item:
     - Build Typesense document from PostgreSQL data
     - POST to Typesense: /collections/movies/documents
     - Mark as completed in queue
  5. Document is now searchable

  **Search Query**:
  1. User types "inception" in search box
  2. Frontend debounces, sends: GET /api/v1/search?q=inception&collections=movies,tvshows
  3. Service applies RBAC filters:
     - Query user's library permissions
     - Add filter_by: library_id:[allowed_library_ids]
  4. Query Typesense: POST /multi_search with collections
  5. Typesense returns ranked results with highlights
  6. Log query in search_query_log
  7. Return results to frontend

  **Bulk Sync** (initial setup or resync):
  1. Admin triggers: POST /api/v1/search/sync
  2. For each collection (movies, tvshows, albums, etc.):
     - Query PostgreSQL: SELECT * FROM movies
     - Transform to Typesense schema
     - Batch import: POST /collections/movies/documents/import
  3. Background job completes
api_endpoints: |
  ```
  # Search
  GET    /api/v1/search?q=query&collections=movies,tvshows  # Multi-collection search
  POST   /api/v1/search/multi                               # Advanced multi-search

  # Admin (indexing)
  POST   /api/v1/search/sync                                # Trigger full sync
  POST   /api/v1/search/sync/:collection                    # Sync specific collection
  POST   /api/v1/search/reindex/:collection                 # Drop and recreate collection
  ```

  **Example Search Request**:
  ```json
  GET /api/v1/search?q=inception&collections=movies&filter_by=release_year:>2000&sort_by=rating:desc
  ```

  **Example Search Response**:
  ```json
  {
    "hits": [
      {
        "document": {
          "id": "27205",
          "title": "Inception",
          "overview": "A thief who steals corporate secrets...",
          "release_year": 2010,
          "rating": 8.4,
          "poster_url": "https://..."
        },
        "highlights": {
          "title": {
            "matched_tokens": ["Inception"],
            "snippet": "<mark>Inception</mark>"
          }
        },
        "text_match": 578934906667
      }
    ],
    "found": 1,
    "page": 1,
    "search_time_ms": 12
  }
  ```

  **Typesense Collection Schema** (Movies):
  ```json
  {
    "name": "movies",
    "fields": [
      {"name": "id", "type": "string"},
      {"name": "title", "type": "string"},
      {"name": "overview", "type": "string"},
      {"name": "release_year", "type": "int32", "facet": true},
      {"name": "rating", "type": "float"},
      {"name": "genres", "type": "string[]", "facet": true},
      {"name": "library_id", "type": "string"},
      {"name": "poster_url", "type": "string", "optional": true}
    ],
    "default_sorting_field": "rating"
  }
  ```
unit_tests: |
  ```go
  func TestSearchService_Search(t *testing.T) {
    // Test search with mock Typesense client
  }

  func TestSearchIndexer_BuildDocument(t *testing.T) {
    // Test document transformation from PostgreSQL to Typesense
  }
  ```
integration_tests: |
  ```go
  func TestSearch_EndToEnd(t *testing.T) {
    // Test index, search, update, delete workflow with real Typesense
  }

  func TestSearch_PermissionFiltering(t *testing.T) {
    // Test RBAC filtering in search results
  }
  ```
