doc_title: Electronic Program Guide (EPG) Service
doc_category: service
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: Complete EPG service design
status_sources: âœ…
status_sources_notes: XMLTV and Live TV sources documented
status_instructions: âœ…
status_instructions_notes: Generated from design
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> TV program schedule and guide data management service


  EPG capabilities:

  - **Format**: XMLTV standard for program data

  - **Sources**: TVHeadend, NextPVR, ErsatzTV integration

  - **Refresh**: Automatic scheduled updates every 6 hours

  - **Search**: Full-text search via Typesense for programs

  - **Cache**: Dragonfly cache for frequently accessed schedules

  - **API**: RESTful endpoints for channel listings and program queries'
wiki_tagline: '> TV program schedules and guide data for Live TV and DVR'
wiki_overview: The Electronic Program Guide (EPG) Service provides comprehensive TV
  program schedule information for Live TV and DVR functionality. Fetches guide data
  from multiple sources in XMLTV format, indexes programs for fast search, and delivers
  schedule information via REST API. Automatic refresh keeps guide data current. Supports
  filtering by channel, genre, time range, and full-text search across program titles
  and descriptions.
sources:
- name: XMLTV Format
  url: http://wiki.xmltv.org/index.php/XMLTVFormat
  note: EPG data format standard
- name: Typesense Go Client
  url: https://github.com/typesense/typesense-go
  note: Full-text search for programs
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Scheduled EPG refresh jobs
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Dependency injection
design_refs:
- title: services
  path: INDEX.md
- title: 01_ARCHITECTURE
  path: ../architecture/01_ARCHITECTURE.md
- title: LIVE_TV_DVR
  path: ../features/livetv/LIVE_TV_DVR.md
- title: TVHEADEND
  path: ../integrations/livetv/TVHEADEND.md
- title: NEXTPVR
  path: ../integrations/livetv/NEXTPVR.md
- title: ERSATZTV
  path: ../integrations/livetv/ERSATZTV.md
service_name: EPG Service
package_path: internal/service/epg
fx_module: epg.Module
epg_sources:
  tvheadend:
    name: TVHeadend
    endpoint: http://tvheadend:9981/xmltv
    format: XMLTV
    refresh_interval: 6 hours
    supports:
    - Channel listings
    - Program schedules
    - Episode metadata
    - Series information
    authentication: HTTP Basic Auth
  nextpvr:
    name: NextPVR
    endpoint: http://nextpvr:8866/service
    format: XMLTV via API
    refresh_interval: 6 hours
    supports:
    - Channel guide
    - Program metadata
    - Recording schedules
    authentication: API Key
  ersatztv:
    name: ErsatzTV
    endpoint: http://ersatztv:8409/api/xmltv
    format: XMLTV
    refresh_interval: 12 hours
    supports:
    - Virtual channel lineups
    - Custom schedules
    - Program metadata
    authentication: None (local)
xmltv_format:
  structure: "```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<tv generator-info-name=\"\
    TVHeadend\">\n  <channel id=\"channel-1\">\n    <display-name>HBO</display-name>\n\
    \    <icon src=\"http://example.com/hbo.png\"/>\n  </channel>\n  \n  <programme\
    \ start=\"20260131180000 +0000\" stop=\"20260131190000 +0000\" channel=\"channel-1\"\
    >\n    <title lang=\"en\">Game of Thrones</title>\n    <sub-title lang=\"en\"\
    >Winter Is Coming</sub-title>\n    <desc lang=\"en\">Eddard Stark is torn between\
    \ his family and an old friend...</desc>\n    <category lang=\"en\">Drama</category>\n\
    \    <category lang=\"en\">Fantasy</category>\n    <episode-num system=\"onscreen\"\
    >S01E01</episode-num>\n    <episode-num system=\"xmltv_ns\">0.0.0/1</episode-num>\n\
    \    <icon src=\"http://example.com/got-s01e01.jpg\"/>\n    <rating system=\"\
    MPAA\">\n      <value>TV-MA</value>\n    </rating>\n  </programme>\n</tv>\n```"
  fields:
  - field: channel
    description: Channel metadata (ID, display name, icon)
    required: true
  - field: programme
    description: Program entry with schedule and metadata
    required: true
  - field: title
    description: Program title
    required: true
  - field: sub-title
    description: Episode title
    required: false
  - field: desc
    description: Program description
    required: false
  - field: category
    description: Genre classifications
    required: false
  - field: episode-num
    description: Episode numbering (supports multiple systems)
    required: false
  - field: icon
    description: Poster/thumbnail URL
    required: false
  - field: rating
    description: Content rating
    required: false
database_schema: "```sql\n-- EPG channels\nCREATE TABLE epg_channels (\n  id UUID\
  \ PRIMARY KEY DEFAULT gen_random_uuid(),\n  source VARCHAR(50) NOT NULL, -- 'tvheadend',\
  \ 'nextpvr', 'ersatztv'\n  external_id VARCHAR(255) NOT NULL,\n  display_name VARCHAR(255)\
  \ NOT NULL,\n  icon_url VARCHAR(500),\n  number INTEGER,\n  \n  created_at TIMESTAMPTZ\
  \ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  \n  CONSTRAINT epg_channels_source_external_unique\
  \ UNIQUE(source, external_id)\n);\n\n-- EPG programs\nCREATE TABLE epg_programs\
  \ (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  channel_id UUID NOT NULL\
  \ REFERENCES epg_channels(id) ON DELETE CASCADE,\n  \n  title VARCHAR(500) NOT NULL,\n\
  \  subtitle VARCHAR(500),\n  description TEXT,\n  \n  start_time TIMESTAMPTZ NOT\
  \ NULL,\n  stop_time TIMESTAMPTZ NOT NULL,\n  \n  -- Episode numbering\n  season_number\
  \ INTEGER,\n  episode_number INTEGER,\n  episode_onscreen VARCHAR(50), -- \"S01E01\"\
  \n  \n  -- Metadata\n  categories TEXT[], -- ['Drama', 'Fantasy']\n  poster_url\
  \ VARCHAR(500),\n  rating VARCHAR(50), -- 'TV-MA', 'PG-13'\n  \n  -- Search optimization\n\
  \  search_vector tsvector GENERATED ALWAYS AS (\n    setweight(to_tsvector('english',\
  \ coalesce(title, '')), 'A') ||\n    setweight(to_tsvector('english', coalesce(subtitle,\
  \ '')), 'B') ||\n    setweight(to_tsvector('english', coalesce(description, '')),\
  \ 'C')\n  ) STORED,\n  \n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ\
  \ DEFAULT NOW(),\n  \n  CONSTRAINT epg_programs_channel_time_unique UNIQUE(channel_id,\
  \ start_time)\n);\n\n-- Indexes\nCREATE INDEX idx_epg_channels_source ON epg_channels(source);\n\
  CREATE INDEX idx_epg_programs_channel_id ON epg_programs(channel_id);\nCREATE INDEX\
  \ idx_epg_programs_time_range ON epg_programs(start_time, stop_time);\nCREATE INDEX\
  \ idx_epg_programs_search ON epg_programs USING GIN(search_vector);\nCREATE INDEX\
  \ idx_epg_programs_categories ON epg_programs USING GIN(categories);\n```"
epg_refresh_pipeline:
  scheduled_job: "```go\ntype RefreshEPGArgs struct {\n    Source string `json:\"\
    source\"` // 'tvheadend', 'nextpvr', 'ersatztv'\n}\n\nfunc (s *EPGService) ScheduleRefresh(ctx\
    \ context.Context) error {\n    sources := []string{\"tvheadend\", \"nextpvr\"\
    , \"ersatztv\"}\n    \n    for _, source := range sources {\n        _, err :=\
    \ s.riverClient.InsertMany(ctx, []river.InsertManyParams{\n            {\n   \
    \             Args: &RefreshEPGArgs{Source: source},\n                ScheduledAt:\
    \ time.Now().Add(s.getRefreshInterval(source)),\n            },\n        })\n\
    \        if err != nil {\n            return err\n        }\n    }\n    \n   \
    \ return nil\n}\n```"
  worker_implementation: "```go\ntype RefreshEPGWorker struct {\n    river.WorkerDefaults[RefreshEPGArgs]\n\
    \    epgService *EPGService\n}\n\nfunc (w *RefreshEPGWorker) Work(ctx context.Context,\
    \ job *river.Job[RefreshEPGArgs]) error {\n    slog.Info(\"refreshing EPG data\"\
    , \"source\", job.Args.Source)\n    \n    // Fetch XMLTV data from source\n  \
    \  xmltvData, err := w.epgService.FetchXMLTV(ctx, job.Args.Source)\n    if err\
    \ != nil {\n        return fmt.Errorf(\"fetch xmltv: %w\", err)\n    }\n    \n\
    \    // Parse XMLTV\n    guide, err := w.epgService.ParseXMLTV(xmltvData)\n  \
    \  if err != nil {\n        return fmt.Errorf(\"parse xmltv: %w\", err)\n    }\n\
    \    \n    // Update database\n    err = w.epgService.UpdateGuideData(ctx, job.Args.Source,\
    \ guide)\n    if err != nil {\n        return fmt.Errorf(\"update guide data:\
    \ %w\", err)\n    }\n    \n    // Index in Typesense for search\n    err = w.epgService.IndexPrograms(ctx,\
    \ guide.Programs)\n    if err != nil {\n        slog.Warn(\"failed to index programs\"\
    , \"error\", err)\n        // Don't fail job if search indexing fails\n    }\n\
    \    \n    // Schedule next refresh\n    _, err = w.epgService.riverClient.Insert(ctx,\
    \ &RefreshEPGArgs{\n        Source: job.Args.Source,\n    }, &river.InsertOpts{\n\
    \        ScheduledAt: time.Now().Add(w.epgService.getRefreshInterval(job.Args.Source)),\n\
    \    })\n    \n    return err\n}\n```"
  xmltv_parsing: "```go\ntype XMLTVGuide struct {\n    Channels []XMLTVChannel  `xml:\"\
    channel\"`\n    Programs []XMLTVProgram  `xml:\"programme\"`\n}\n\nfunc (s *EPGService)\
    \ ParseXMLTV(data []byte) (*XMLTVGuide, error) {\n    var guide XMLTVGuide\n \
    \   err := xml.Unmarshal(data, &guide)\n    if err != nil {\n        return nil,\
    \ fmt.Errorf(\"unmarshal xmltv: %w\", err)\n    }\n    \n    return &guide, nil\n\
    }\n\nfunc (s *EPGService) UpdateGuideData(ctx context.Context, source string,\
    \ guide *XMLTVGuide) error {\n    tx, err := s.db.Begin(ctx)\n    if err != nil\
    \ {\n        return err\n    }\n    defer tx.Rollback(ctx)\n    \n    // Upsert\
    \ channels\n    for _, channel := range guide.Channels {\n        _, err = s.repo.UpsertChannel(ctx,\
    \ tx, source, &channel)\n        if err != nil {\n            return err\n   \
    \     }\n    }\n    \n    // Delete old programs (older than 24 hours)\n    err\
    \ = s.repo.DeleteOldPrograms(ctx, tx, time.Now().Add(-24*time.Hour))\n    if err\
    \ != nil {\n        return err\n    }\n    \n    // Insert new programs\n    for\
    \ _, program := range guide.Programs {\n        _, err = s.repo.InsertProgram(ctx,\
    \ tx, &program)\n        if err != nil {\n            // Skip duplicates\n   \
    \         if errors.Is(err, ErrProgramExists) {\n                continue\n  \
    \          }\n            return err\n        }\n    }\n    \n    return tx.Commit(ctx)\n\
    }\n```"
search_integration:
  typesense_schema: "```go\nfunc (s *EPGService) CreateSearchSchema(ctx context.Context)\
    \ error {\n    schema := &api.CollectionSchema{\n        Name: \"epg_programs\"\
    ,\n        Fields: []api.Field{\n            {Name: \"id\", Type: \"string\"},\n\
    \            {Name: \"channel_id\", Type: \"string\"},\n            {Name: \"\
    channel_name\", Type: \"string\", Facet: ptr.Bool(true)},\n            {Name:\
    \ \"title\", Type: \"string\"},\n            {Name: \"subtitle\", Type: \"string\"\
    , Optional: ptr.Bool(true)},\n            {Name: \"description\", Type: \"string\"\
    , Optional: ptr.Bool(true)},\n            {Name: \"categories\", Type: \"string[]\"\
    , Facet: ptr.Bool(true)},\n            {Name: \"start_time\", Type: \"int64\"\
    }, // Unix timestamp\n            {Name: \"stop_time\", Type: \"int64\"},\n  \
    \          {Name: \"rating\", Type: \"string\", Facet: ptr.Bool(true), Optional:\
    \ ptr.Bool(true)},\n        },\n        DefaultSortingField: ptr.String(\"start_time\"\
    ),\n    }\n    \n    _, err := s.typesense.Collections().Create(schema)\n    return\
    \ err\n}\n```"
  search_query: "```go\nfunc (s *EPGService) SearchPrograms(ctx context.Context, query\
    \ string, filters EPGFilters) ([]Program, error) {\n    searchParams := &api.SearchCollectionParams{\n\
    \        Q:       query,\n        QueryBy: \"title,subtitle,description\",\n \
    \       FilterBy: ptr.String(s.buildFilterString(filters)),\n        PerPage:\
    \  ptr.Int(50),\n        SortBy:   ptr.String(\"start_time:asc\"),\n    }\n  \
    \  \n    results, err := s.typesense.Collection(\"epg_programs\").Documents().Search(searchParams)\n\
    \    if err != nil {\n        return nil, err\n    }\n    \n    return s.convertSearchResults(results),\
    \ nil\n}\n\nfunc (s *EPGService) buildFilterString(filters EPGFilters) string\
    \ {\n    var parts []string\n    \n    if filters.ChannelID != uuid.Nil {\n  \
    \      parts = append(parts, fmt.Sprintf(\"channel_id:=%s\", filters.ChannelID))\n\
    \    }\n    \n    if len(filters.Categories) > 0 {\n        categories := strings.Join(filters.Categories,\
    \ \",\")\n        parts = append(parts, fmt.Sprintf(\"categories:[%s]\", categories))\n\
    \    }\n    \n    if !filters.StartAfter.IsZero() {\n        parts = append(parts,\
    \ fmt.Sprintf(\"start_time:>=%d\", filters.StartAfter.Unix()))\n    }\n    \n\
    \    if !filters.StopBefore.IsZero() {\n        parts = append(parts, fmt.Sprintf(\"\
    stop_time:<=%d\", filters.StopBefore.Unix()))\n    }\n    \n    return strings.Join(parts,\
    \ \" && \")\n}\n```"
caching_strategy: 'Dragonfly cache with tiered TTLs:

  - epg:channel:{channel_id}:schedule:{date} - Daily schedule (1 hour TTL)

  - epg:program:{program_id} - Program details (6 hours TTL)

  - epg:channels:all - Channel listings (24 hours TTL)'
cache_keys: '```

  epg:channel:{channel_id}:schedule:{date}  # Daily schedule for channel

  epg:program:{program_id}                  # Individual program details

  epg:channels:all                          # List of all channels

  ```'
cache_implementation: "```go\nfunc (s *EPGService) GetChannelSchedule(ctx context.Context,\
  \ channelID uuid.UUID, date time.Time) ([]Program, error) {\n    cacheKey := fmt.Sprintf(\"\
  epg:channel:%s:schedule:%s\", channelID, date.Format(\"2006-01-02\"))\n\n    //\
  \ Try cache first\n    cached, err := s.cache.Do(ctx, s.cache.B().Get().Key(cacheKey).Build()).ToString()\n\
  \    if err == nil {\n        var programs []Program\n        json.Unmarshal([]byte(cached),\
  \ &programs)\n        return programs, nil\n    }\n\n    // Cache miss, query database\n\
  \    startOfDay := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0,\
  \ date.Location())\n    endOfDay := startOfDay.Add(24 * time.Hour)\n\n    programs,\
  \ err := s.repo.GetProgramsByChannelAndTimeRange(ctx, channelID, startOfDay, endOfDay)\n\
  \    if err != nil {\n        return nil, err\n    }\n\n    // Store in cache\n\
  \    data, _ := json.Marshal(programs)\n    s.cache.Do(ctx, s.cache.B().Set().Key(cacheKey).Value(string(data)).Ex(1*time.Hour).Build())\n\
  \n    return programs, nil\n}\n```"
api_endpoints:
- method: GET
  path: /api/v1/epg/channels
  description: List all EPG channels
  response: "{\n  \"channels\": [\n    {\n      \"id\": \"uuid-123\",\n      \"display_name\"\
    : \"HBO\",\n      \"number\": 501,\n      \"icon_url\": \"http://example.com/hbo.png\"\
    \n    }\n  ]\n}"
- method: GET
  path: /api/v1/epg/channels/{id}/schedule
  description: Get channel schedule
  query_params:
  - 'date (optional): Date for schedule (default: today)'
  - 'days (optional): Number of days (default: 1, max: 7)'
  response: "{\n  \"channel_id\": \"uuid-123\",\n  \"date\": \"2026-01-31\",\n  \"\
    programs\": [\n    {\n      \"id\": \"uuid-456\",\n      \"title\": \"Game of\
    \ Thrones\",\n      \"subtitle\": \"Winter Is Coming\",\n      \"start_time\"\
    : \"2026-01-31T18:00:00Z\",\n      \"stop_time\": \"2026-01-31T19:00:00Z\",\n\
    \      \"categories\": [\"Drama\", \"Fantasy\"]\n    }\n  ]\n}"
- method: GET
  path: /api/v1/epg/programs/{id}
  description: Get program details
  response: "{\n  \"id\": \"uuid-456\",\n  \"title\": \"Game of Thrones\",\n  \"subtitle\"\
    : \"Winter Is Coming\",\n  \"description\": \"Eddard Stark is torn between...\"\
    ,\n  \"start_time\": \"2026-01-31T18:00:00Z\",\n  \"stop_time\": \"2026-01-31T19:00:00Z\"\
    ,\n  \"season_number\": 1,\n  \"episode_number\": 1,\n  \"categories\": [\"Drama\"\
    , \"Fantasy\"],\n  \"rating\": \"TV-MA\",\n  \"poster_url\": \"http://example.com/got.jpg\"\
    \n}"
- method: GET
  path: /api/v1/epg/search
  description: Search EPG programs
  query_params:
  - 'q: Search query'
  - 'channel_id (optional): Filter by channel'
  - 'categories (optional): Comma-separated genre list'
  - 'start_after (optional): ISO 8601 timestamp'
  - 'stop_before (optional): ISO 8601 timestamp'
  response: "{\n  \"results\": [\n    {\n      \"id\": \"uuid-456\",\n      \"title\"\
    : \"Game of Thrones\",\n      \"channel_name\": \"HBO\",\n      \"start_time\"\
    : \"2026-01-31T18:00:00Z\"\n    }\n  ],\n  \"total\": 1\n}"
- method: POST
  path: /api/v1/epg/refresh
  description: Trigger EPG refresh (admin only)
  auth_required: true
  request: "{\n  \"source\": \"tvheadend\"\n}"
  response: "{\n  \"job_id\": \"uuid-789\",\n  \"status\": \"queued\"\n}"
- method: GET
  path: /api/v1/epg/stats
  description: Get EPG statistics
  response: "{\n  \"total_channels\": 150,\n  \"total_programs\": 12543,\n  \"oldest_program\"\
    : \"2026-01-30T00:00:00Z\",\n  \"newest_program\": \"2026-02-07T23:59:59Z\",\n\
    \  \"last_refresh\": {\n    \"tvheadend\": \"2026-01-31T12:00:00Z\",\n    \"nextpvr\"\
    : \"2026-01-31T11:30:00Z\"\n  }\n}"
best_practices:
- practice: Refresh EPG data regularly
  reason: Keep program schedules up to date
- practice: Delete old programs (>24 hours past)
  reason: Prevent database bloat with historical data
- practice: Cache daily schedules
  reason: Reduce database load for frequent queries
- practice: Use Typesense for search
  reason: Fast full-text search across programs
- practice: Index programs after refresh
  reason: Ensure search results are current
- practice: Handle XMLTV parsing errors gracefully
  reason: Don't fail entire refresh on one bad entry
- practice: Support multiple EPG sources
  reason: Redundancy and coverage across providers
- practice: Validate channel/program uniqueness
  reason: Avoid duplicate entries
- practice: Use PostgreSQL full-text search as fallback
  reason: If Typesense unavailable
- practice: Monitor refresh job failures
  reason: Alert when EPG data becomes stale
