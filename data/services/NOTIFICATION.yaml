doc_title: Notification Service
doc_category: service
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Multi-channel notifications for users and admins'
wiki_tagline: '> Multi-channel notifications for users and admins'
wiki_overview: Get notified about important events through multiple channels. Receive alerts when new media is added, downloads
  complete, or errors occur. Supports email, push notifications (via FCM), webhooks, and in-app notifications. Configure which
  events trigger notifications and choose delivery channels per user or globally.
sources:
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: ogen OpenAPI Generator
  url: https://pkg.go.dev/github.com/ogen-go/ogen
  note: Auto-resolved from ogen
- name: pgx PostgreSQL Driver
  url: https://pkg.go.dev/github.com/jackc/pgx/v5
  note: Auto-resolved from pgx
- name: PostgreSQL Arrays
  url: https://www.postgresql.org/docs/current/arrays.html
  note: Auto-resolved from postgresql-arrays
- name: PostgreSQL JSON Functions
  url: https://www.postgresql.org/docs/current/functions-json.html
  note: Auto-resolved from postgresql-json
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
design_refs:
- title: services
  path: INDEX.md
- title: 01_ARCHITECTURE
  path: ../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../architecture/03_METADATA_SYSTEM.md
service_name: Notification Service
package_path: internal/service/notification
fx_module: notification.Module
architecture_diagram: |-
  ```mermaid
  flowchart TD
      subgraph row1[ ]
          direction LR
          node1["Event<br/>Publisher"]
          node2[["Notification<br/>Service"]]
          node3(["Channels<br/>(Email,<br/>Push,"])
      end
      subgraph row2[ ]
          direction LR
          node4[("PostgreSQL<br/>(pgx)")]
          node5(["External<br/>Services<br/>(SMTP, FCM)"])
      end
      node1 --> node2
      node2 --> node3
      node4 --> node5
      node3 --> node4

      %% Hide row subgraph borders
      style row1 fill:transparent,stroke:transparent
      style row2 fill:transparent,stroke:transparent
  ```
database_schema: |
  **Schema**: `public`

  ```sql
  -- Notification templates
  CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Template identification
    event_type VARCHAR(100) NOT NULL UNIQUE,       -- 'content_added', 'download_complete', 'request_approved'
    channel VARCHAR(50) NOT NULL,                  -- 'email', 'push', 'webhook', 'in_app'

    -- Template content
    subject_template TEXT,                         -- For email
    body_template TEXT NOT NULL,                   -- Go template with placeholders
    icon_url TEXT,                                 -- For push/in-app

    -- Configuration
    enabled BOOLEAN DEFAULT true,
    priority VARCHAR(20) DEFAULT 'normal',         -- 'low', 'normal', 'high', 'urgent'

    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_notification_templates_event ON notification_templates(event_type, channel);

  -- Notification queue (pending delivery)
  CREATE TABLE notification_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Recipient
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    channel VARCHAR(50) NOT NULL,                  -- 'email', 'push', 'webhook'

    -- Message
    subject TEXT,
    body TEXT NOT NULL,
    data JSONB,                                    -- Extra data for rendering

    -- Delivery
    status VARCHAR(20) DEFAULT 'pending',          -- 'pending', 'sent', 'failed', 'cancelled'
    attempts INTEGER DEFAULT 0,
    error_message TEXT,

    -- Priority
    priority VARCHAR(20) DEFAULT 'normal',

    queued_at TIMESTAMPTZ DEFAULT now(),
    sent_at TIMESTAMPTZ
  );
  CREATE INDEX idx_notification_queue_status ON notification_queue(status, priority, queued_at);
  CREATE INDEX idx_notification_queue_user ON notification_queue(user_id, queued_at DESC);

  -- In-app notifications (persisted)
  CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Notification details
    title TEXT NOT NULL,
    body TEXT NOT NULL,
    icon_url TEXT,
    action_url TEXT,                               -- Link when clicked
    event_type VARCHAR(100),

    -- Status
    is_read BOOLEAN DEFAULT false,
    read_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_notifications_user ON notifications(user_id, created_at DESC);
  CREATE INDEX idx_notifications_unread ON notifications(user_id, is_read) WHERE is_read = false;

  -- User notification preferences (per event type)
  CREATE TABLE user_notification_preferences (
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    event_type VARCHAR(100) NOT NULL,

    -- Channel enablement
    email_enabled BOOLEAN DEFAULT true,
    push_enabled BOOLEAN DEFAULT true,
    in_app_enabled BOOLEAN DEFAULT true,

    PRIMARY KEY (user_id, event_type)
  );

  -- Push notification devices (FCM tokens)
  CREATE TABLE push_notification_devices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Device token
    fcm_token TEXT NOT NULL UNIQUE,
    device_type VARCHAR(50),                       -- 'android', 'ios', 'web'
    device_name TEXT,

    -- Status
    is_active BOOLEAN DEFAULT true,
    last_used_at TIMESTAMPTZ DEFAULT now(),

    created_at TIMESTAMPTZ DEFAULT now()
  );
  CREATE INDEX idx_push_devices_user ON push_notification_devices(user_id);
  ```
module_structure: |
  ```
  internal/service/notification/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ types.go                     # Domain types
  â”œâ”€â”€ repository.go                # Database operations (sqlc)
  â”œâ”€â”€ service.go                   # Notification service logic
  â”œâ”€â”€ templates.go                 # Template rendering
  â”œâ”€â”€ handler.go                   # HTTP API handlers
  â””â”€â”€ channels/
      â”œâ”€â”€ channel.go               # Channel interface
      â”œâ”€â”€ email.go                 # SMTP email delivery
      â”œâ”€â”€ push.go                  # Firebase Cloud Messaging (FCM)
      â”œâ”€â”€ webhook.go               # Webhook delivery
      â””â”€â”€ inapp.go                 # In-app notification storage
  ```
key_interfaces: |
  ```go
  type NotificationService interface {
    // Send notifications
    Send(ctx context.Context, notification Notification) error
    SendToUser(ctx context.Context, userID uuid.UUID, notification Notification) error
    SendBulk(ctx context.Context, userIDs []uuid.UUID, notification Notification) error

    // In-app notifications
    GetNotifications(ctx context.Context, userID uuid.UUID, filters NotificationFilters) ([]InAppNotification, error)
    MarkAsRead(ctx context.Context, notificationID uuid.UUID) error
    MarkAllAsRead(ctx context.Context, userID uuid.UUID) error
    DeleteNotification(ctx context.Context, notificationID uuid.UUID) error

    // Preferences
    GetPreferences(ctx context.Context, userID uuid.UUID) (map[string]NotificationPreference, error)
    UpdatePreference(ctx context.Context, userID uuid.UUID, eventType string, pref NotificationPreference) error

    // Push devices
    RegisterPushDevice(ctx context.Context, userID uuid.UUID, fcmToken, deviceType string) error
    UnregisterPushDevice(ctx context.Context, fcmToken string) error
  }

  type Notification struct {
    EventType string                 `json:"event_type"`
    Title     string                 `json:"title"`
    Body      string                 `json:"body"`
    ActionURL *string                `json:"action_url,omitempty"`
    Data      map[string]interface{} `json:"data,omitempty"`
    Priority  string                 `json:"priority"`
  }

  type NotificationChannel interface {
    Name() string
    Send(ctx context.Context, recipient User, notification Notification) error
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/google/uuid`
  - `github.com/jackc/pgx/v5`
  - `github.com/riverqueue/river` - Background notification delivery
  - `net/smtp` - Email delivery
  - `firebase.google.com/go/v4/messaging` - Firebase Cloud Messaging (FCM)
  - `text/template` - Template rendering
  - `net/http` - Webhook delivery
  - `go.uber.org/fx`

  **External Services**:
  - SMTP server for email
  - Firebase Cloud Messaging (FCM) for push notifications
env_vars: |
  ```bash
  NOTIFICATION_SMTP_HOST=smtp.gmail.com
  NOTIFICATION_SMTP_PORT=587
  NOTIFICATION_SMTP_USER=noreply@example.com
  NOTIFICATION_SMTP_PASSWORD=your_password
  NOTIFICATION_FCM_CREDENTIALS_FILE=/config/fcm-service-account.json
  NOTIFICATION_DELIVERY_WORKERS=5
  ```
config_keys: |
  ```yaml
  notification:
    email:
      smtp_host: smtp.gmail.com
      smtp_port: 587
      smtp_user: noreply@example.com
      smtp_password: your_password
      from_address: Revenge <noreply@example.com>
    push:
      fcm_credentials_file: /config/fcm-service-account.json
    webhook:
      timeout: 10s
    delivery:
      workers: 5
      retry_attempts: 3
      retry_delay: 5m
  ```
component_interaction: |
  **Notification Flow** (content added):
  1. Library scanner adds new movie
  2. Publish event: EventBus.Publish("content_added", {movie_id, title})
  3. Notification service receives event
  4. Query users who should be notified:
     - Check user_notification_preferences for 'content_added'
     - Filter by enabled channels
  5. For each user:
     - Render template with event data
     - Queue notification in notification_queue (one per channel)
  6. River workers process queue:
     - Email channel: Send via SMTP
     - Push channel: Send via FCM to all user's devices
     - In-app channel: Insert into notifications table
  7. Mark as sent or failed

  **In-App Notification**:
  1. Frontend polls: GET /api/v1/notifications?unread=true
  2. Service queries notifications table WHERE is_read = false
  3. Return unread notifications with count
  4. User clicks notification:
     - PATCH /api/v1/notifications/:id/read
     - Set is_read = true, read_at = now
     - Navigate to action_url

  **Push Notification Registration**:
  1. Mobile app gets FCM token from Firebase SDK
  2. POST /api/v1/notifications/devices with token
  3. Store in push_notification_devices
  4. When sending push, query all active devices for user
  5. Send to each FCM token
api_endpoints: |
  ```
  # In-app notifications
  GET    /api/v1/notifications              # List notifications
  GET    /api/v1/notifications/unread/count # Get unread count
  PATCH  /api/v1/notifications/:id/read     # Mark as read
  POST   /api/v1/notifications/read-all     # Mark all as read
  DELETE /api/v1/notifications/:id          # Delete notification

  # Preferences
  GET    /api/v1/notifications/preferences  # Get preferences
  PUT    /api/v1/notifications/preferences/:event # Update preference

  # Push devices
  POST   /api/v1/notifications/devices      # Register push device
  DELETE /api/v1/notifications/devices/:token # Unregister device
  ```

  **Example Notification Response**:
  ```json
  {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "title": "New Movie Added",
    "body": "Inception (2010) has been added to your library",
    "icon_url": "https://image.tmdb.org/t/p/w200/...",
    "action_url": "/movies/27205",
    "is_read": false,
    "created_at": "2026-02-01T10:30:00Z"
  }
  ```

  **Example Email Template**:
  ```
  Subject: {{ .Title }}

  Hi {{ .UserDisplayName }},

  {{ .Body }}

  {{ if .ActionURL }}
  View: {{ .ActionURL }}
  {{ end }}

  --
  Revenge Media Server
  ```
unit_tests: |
  ```go
  func TestNotificationService_Send(t *testing.T) {
    // Test notification queuing
  }

  func TestNotificationTemplates_Render(t *testing.T) {
    // Test template rendering with data
  }
  ```
integration_tests: |
  ```go
  func TestNotification_EmailDelivery(t *testing.T) {
    // Test full email delivery flow (use mock SMTP)
  }

  func TestNotification_PushDelivery(t *testing.T) {
    // Test FCM push delivery (use mock FCM client)
  }
  ```
