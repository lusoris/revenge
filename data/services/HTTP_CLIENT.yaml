doc_title: HTTP Client & Proxy Service
doc_category: service
created_date: '2026-02-01'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: ðŸŸ¡
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Centralized HTTP client factory with proxy/VPN support for external API calls'
wiki_tagline: '> Route external API calls through proxy or VPN for privacy'
wiki_overview: The HTTP client service provides centralized HTTP client management
  with proxy and VPN support. External metadata API calls (TMDb, TheTVDB, MusicBrainz,
  etc.) route through configured proxies or VPN tunnels for privacy and geo-unblocking.
  Local services (Arr stack, Stash) bypass proxy. Supports HTTP/HTTPS proxies, SOCKS5
  (Tor), and VPN interface binding. Per-service routing rules, health checking, and
  automatic failover.
sources:
- name: Go context
  url: https://pkg.go.dev/context
  note: Auto-resolved from go-context
- name: Go net/http
  url: https://pkg.go.dev/net/http
  note: Auto-resolved from go-http
- name: Go net/http.Transport
  url: https://pkg.go.dev/net/http#Transport
  note: Auto-resolved from go-http-transport
- name: golang.org/x/net/proxy
  url: https://pkg.go.dev/golang.org/x/net/proxy
  note: Auto-resolved from go-proxy
- name: koanf
  url: https://pkg.go.dev/github.com/knadh/koanf/v2
  note: Auto-resolved from koanf
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
design_refs:
- title: 01_ARCHITECTURE
  path: ../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../architecture/03_METADATA_SYSTEM.md
service_name: HTTP Client & Proxy
module_name: http_client
package_path: internal/httpclient

architecture_diagram: |
  ```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  External APIs  â”‚â—€â”€â”€â”€â”€â”‚  HTTP Client     â”‚â—€â”€â”€â”€â”€â”‚  Services   â”‚
  â”‚  (TMDb, TVDB)   â”‚     â”‚  Factory         â”‚     â”‚  (Metadata, â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚                  â”‚     â”‚   Requests) â”‚
                          â”‚  - Proxy Router  â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚  - VPN Binding   â”‚
  â”‚  Proxy/VPN      â”‚â—€â”€â”€â”€â”€â”‚  - Health Check  â”‚
  â”‚  (Tor, HTTP)    â”‚     â”‚  - Middleware    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
  â”‚  Local Services â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚  (Arr, Stash)   â”‚    (Direct, no proxy)
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ```

design_rationale: |
  **Why a Dedicated HTTP Client Service?**

  **Problem**:
  - External metadata APIs need proxy/VPN for privacy (hide queries from ISP)
  - Different services have different proxy needs:
    - TMDb, TheTVDB â†’ Proxy/VPN (external, privacy-sensitive)
    - Radarr, Sonarr, Lidarr â†’ No proxy (local network)
    - Tor/Stash APIs â†’ SOCKS5 proxy preferred
  - Rate limiting requires per-service HTTP client configuration
  - Health monitoring and failover for proxy pools

  **Solution**: Centralized HTTP Client Factory
  - Single source of truth for all HTTP clients
  - Routing rules: external services â†’ proxy, local services â†’ direct
  - Proxy types: HTTP/HTTPS, SOCKS5, VPN interface binding
  - Middleware chain: logging, metrics, rate limiting, retries
  - Health checking and automatic failover
  - fx dependency injection for type-safe client provisioning

  **Benefits**:
  - Privacy: External API calls hidden from ISP
  - Geo-unblocking: Access region-restricted APIs
  - Rate limit mitigation: Rotate IPs through proxy pool
  - Simplified configuration: One place to configure all HTTP behavior
  - Testability: Mock HTTP clients for unit tests

module_structure: |
  ```
  internal/httpclient/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ factory.go                   # HTTP client factory
  â”œâ”€â”€ config.go                    # Configuration types
  â”œâ”€â”€ proxy.go                     # Proxy management
  â”œâ”€â”€ vpn.go                       # VPN interface binding
  â”œâ”€â”€ router.go                    # Service-based routing
  â”œâ”€â”€ middleware.go                # Request/response middleware
  â”œâ”€â”€ health.go                    # Proxy health checking
  â”œâ”€â”€ pool.go                      # Proxy pool (load balancing)
  â””â”€â”€ httpclient_test.go

  # Usage example in other services:
  internal/metadata/providers/tmdb/
  â”œâ”€â”€ client.go                    # Receives *http.Client via fx
  ```

key_interfaces: |
  ```go
  // HTTP client factory
  type ClientFactory interface {
    // Get HTTP client for specific service
    GetClient(service string) *http.Client

    // Get HTTP client with specific proxy
    GetClientWithProxy(proxyURL string) *http.Client

    // Get HTTP client bound to VPN interface
    GetClientWithVPN(interfaceName string) (*http.Client, error)

    // Health check for proxy
    CheckProxyHealth(ctx context.Context, proxyURL string) error
  }

  // Proxy configuration
  type ProxyConfig struct {
    Enabled bool   `koanf:"enabled"`
    Type    string `koanf:"type"`  // "http", "socks5", "vpn"
    URL     string `koanf:"url"`

    // Optional auth
    Username string `koanf:"username"`
    Password string `koanf:"password"`

    // VPN-specific
    Interface string `koanf:"interface"`  // "tun0", "wg0"

    // Health checking
    HealthCheckURL      string        `koanf:"health_check_url"`
    HealthCheckInterval time.Duration `koanf:"health_check_interval"`
  }

  // Service routing configuration
  type ServiceRoute struct {
    Service   string `koanf:"service"`   // "tmdb", "tvdb", "musicbrainz"
    ProxyName string `koanf:"proxy"`     // "default", "tor", "vpn", "none"
  }

  // Complete configuration
  type Config struct {
    // Proxies
    Proxies map[string]ProxyConfig `koanf:"proxies"`

    // Default proxy for external services
    DefaultProxy string `koanf:"default_proxy"`

    // Service-specific routing
    Routes []ServiceRoute `koanf:"routes"`

    // Global settings
    Timeout         time.Duration `koanf:"timeout"`
    MaxIdleConns    int           `koanf:"max_idle_conns"`
    IdleConnTimeout time.Duration `koanf:"idle_conn_timeout"`
  }

  // HTTP client with metadata
  type Client struct {
    *http.Client
    Service   string
    ProxyName string
    ProxyURL  string
  }

  // Middleware chain
  type Middleware func(http.RoundTripper) http.RoundTripper

  // Logging middleware
  func LoggingMiddleware(logger *slog.Logger) Middleware

  // Metrics middleware
  func MetricsMiddleware(registry prometheus.Registry) Middleware

  // Rate limiting middleware
  func RateLimitMiddleware(limiter *rate.Limiter) Middleware

  // Retry middleware
  func RetryMiddleware(maxRetries int, backoff time.Duration) Middleware
  ```

dependencies: |
  **Go Packages**:
  - `net/http` - HTTP client
  - `net/http.Transport` - Transport configuration
  - `net` - Network interface binding (VPN)
  - `golang.org/x/net/proxy` - SOCKS5 proxy support
  - `golang.org/x/time/rate` - Rate limiting
  - `github.com/knadh/koanf/v2` - Configuration
  - `go.uber.org/fx` - Dependency injection
  - `log/slog` - Structured logging

config_keys: |
  ```yaml
  httpclient:
    # Global settings
    timeout: 30s
    max_idle_conns: 100
    idle_conn_timeout: 90s

    # Default proxy for external services
    default_proxy: tor

    # Proxy definitions
    proxies:
      tor:
        enabled: true
        type: socks5
        url: socks5://127.0.0.1:9050

      http_proxy:
        enabled: true
        type: http
        url: http://proxy.example.com:8080
        username: user
        password: pass

      vpn:
        enabled: true
        type: vpn
        interface: tun0
        health_check_url: https://api.ipify.org
        health_check_interval: 5m

    # Service-specific routing
    routes:
      - service: tmdb
        proxy: tor              # TMDb â†’ Tor

      - service: tvdb
        proxy: tor              # TheTVDB â†’ Tor

      - service: musicbrainz
        proxy: http_proxy       # MusicBrainz â†’ HTTP proxy

      - service: radarr
        proxy: none             # Radarr â†’ Direct (local)

      - service: sonarr
        proxy: none             # Sonarr â†’ Direct (local)

      - service: lidarr
        proxy: none             # Lidarr â†’ Direct (local)

      - service: stash
        proxy: none             # Stash â†’ Direct (local)
  ```

env_vars: |
  ```bash
  # HTTP proxy
  HTTP_PROXY=http://proxy.example.com:8080
  HTTPS_PROXY=http://proxy.example.com:8080

  # SOCKS5 proxy (Tor)
  SOCKS5_PROXY=socks5://127.0.0.1:9050

  # VPN interface
  VPN_INTERFACE=tun0

  # Default proxy for external APIs
  DEFAULT_PROXY=tor  # "tor", "http", "vpn", "none"
  ```

implementation_factory: |
  **HTTP Client Factory Implementation**:

  ```go
  package httpclient

  import (
    "context"
    "fmt"
    "net"
    "net/http"
    "net/url"
    "time"

    "golang.org/x/net/proxy"
    "log/slog"
  )

  type Factory struct {
    config Config
    logger *slog.Logger

    // Cached clients (one per service)
    clients map[string]*Client
  }

  func NewFactory(cfg Config, logger *slog.Logger) *Factory {
    return &Factory{
      config:  cfg,
      logger:  logger,
      clients: make(map[string]*Client),
    }
  }

  func (f *Factory) GetClient(service string) *http.Client {
    // Check cache
    if client, ok := f.clients[service]; ok {
      return client.Client
    }

    // Find route for service
    proxyName := f.config.DefaultProxy
    for _, route := range f.config.Routes {
      if route.Service == service {
        proxyName = route.ProxyName
        break
      }
    }

    // Create client based on proxy
    var httpClient *http.Client
    if proxyName == "none" || proxyName == "" {
      httpClient = f.createDirectClient()
    } else {
      proxyCfg := f.config.Proxies[proxyName]
      httpClient = f.createProxiedClient(proxyCfg)
    }

    // Cache and return
    f.clients[service] = &Client{
      Client:    httpClient,
      Service:   service,
      ProxyName: proxyName,
    }

    f.logger.Info("created HTTP client",
      "service", service,
      "proxy", proxyName,
    )

    return httpClient
  }

  func (f *Factory) createDirectClient() *http.Client {
    return &http.Client{
      Timeout: f.config.Timeout,
      Transport: &http.Transport{
        MaxIdleConns:        f.config.MaxIdleConns,
        IdleConnTimeout:     f.config.IdleConnTimeout,
        TLSHandshakeTimeout: 10 * time.Second,
      },
    }
  }

  func (f *Factory) createProxiedClient(cfg ProxyConfig) *http.Client {
    switch cfg.Type {
    case "http", "https":
      return f.createHTTPProxyClient(cfg)
    case "socks5":
      return f.createSOCKS5Client(cfg)
    case "vpn":
      client, _ := f.createVPNClient(cfg)
      return client
    default:
      return f.createDirectClient()
    }
  }

  func (f *Factory) createHTTPProxyClient(cfg ProxyConfig) *http.Client {
    proxyURL, _ := url.Parse(cfg.URL)
    if cfg.Username != "" {
      proxyURL.User = url.UserPassword(cfg.Username, cfg.Password)
    }

    transport := &http.Transport{
      Proxy:               http.ProxyURL(proxyURL),
      MaxIdleConns:        f.config.MaxIdleConns,
      IdleConnTimeout:     f.config.IdleConnTimeout,
      TLSHandshakeTimeout: 10 * time.Second,
    }

    return &http.Client{
      Timeout:   f.config.Timeout,
      Transport: transport,
    }
  }

  func (f *Factory) createSOCKS5Client(cfg ProxyConfig) *http.Client {
    // Parse SOCKS5 URL
    proxyURL, _ := url.Parse(cfg.URL)

    var auth *proxy.Auth
    if cfg.Username != "" {
      auth = &proxy.Auth{
        User:     cfg.Username,
        Password: cfg.Password,
      }
    }

    // Create SOCKS5 dialer
    dialer, err := proxy.SOCKS5("tcp", proxyURL.Host, auth, proxy.Direct)
    if err != nil {
      f.logger.Error("failed to create SOCKS5 dialer", "error", err)
      return f.createDirectClient()
    }

    transport := &http.Transport{
      Dial:                dialer.Dial,
      MaxIdleConns:        f.config.MaxIdleConns,
      IdleConnTimeout:     f.config.IdleConnTimeout,
      TLSHandshakeTimeout: 10 * time.Second,
    }

    return &http.Client{
      Timeout:   f.config.Timeout,
      Transport: transport,
    }
  }

  func (f *Factory) createVPNClient(cfg ProxyConfig) (*http.Client, error) {
    // Get VPN interface
    iface, err := net.InterfaceByName(cfg.Interface)
    if err != nil {
      return nil, fmt.Errorf("VPN interface %s not found: %w", cfg.Interface, err)
    }

    // Get IP address of VPN interface
    addrs, err := iface.Addrs()
    if err != nil || len(addrs) == 0 {
      return nil, fmt.Errorf("no addresses on VPN interface %s", cfg.Interface)
    }

    localIP := addrs[0].(*net.IPNet).IP

    // Create dialer bound to VPN interface
    dialer := &net.Dialer{
      LocalAddr: &net.TCPAddr{IP: localIP},
      Timeout:   30 * time.Second,
      KeepAlive: 30 * time.Second,
    }

    transport := &http.Transport{
      DialContext:         dialer.DialContext,
      MaxIdleConns:        f.config.MaxIdleConns,
      IdleConnTimeout:     f.config.IdleConnTimeout,
      TLSHandshakeTimeout: 10 * time.Second,
    }

    return &http.Client{
      Timeout:   f.config.Timeout,
      Transport: transport,
    }, nil
  }

  func (f *Factory) CheckProxyHealth(ctx context.Context, proxyName string) error {
    cfg, ok := f.config.Proxies[proxyName]
    if !ok {
      return fmt.Errorf("proxy %s not found", proxyName)
    }

    if cfg.HealthCheckURL == "" {
      return nil  // No health check configured
    }

    client := f.createProxiedClient(cfg)

    req, _ := http.NewRequestWithContext(ctx, http.MethodGet, cfg.HealthCheckURL, nil)
    resp, err := client.Do(req)
    if err != nil {
      return fmt.Errorf("proxy health check failed: %w", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
      return fmt.Errorf("proxy health check returned status %d", resp.StatusCode)
    }

    return nil
  }
  ```

middleware_chain: |
  **Middleware Implementation**:

  ```go
  package httpclient

  import (
    "log/slog"
    "net/http"
    "time"
  )

  type Middleware func(http.RoundTripper) http.RoundTripper

  // Apply middleware chain
  func ApplyMiddleware(base http.RoundTripper, middlewares ...Middleware) http.RoundTripper {
    result := base
    for i := len(middlewares) - 1; i >= 0; i-- {
      result = middlewares[i](result)
    }
    return result
  }

  // Logging middleware
  type loggingTransport struct {
    base   http.RoundTripper
    logger *slog.Logger
  }

  func (t *loggingTransport) RoundTrip(req *http.Request) (*http.Response, error) {
    start := time.Now()

    t.logger.Debug("HTTP request",
      "method", req.Method,
      "url", req.URL.String(),
    )

    resp, err := t.base.RoundTrip(req)

    duration := time.Since(start)

    if err != nil {
      t.logger.Error("HTTP request failed",
        "method", req.Method,
        "url", req.URL.String(),
        "duration", duration,
        "error", err,
      )
    } else {
      t.logger.Debug("HTTP request completed",
        "method", req.Method,
        "url", req.URL.String(),
        "status", resp.StatusCode,
        "duration", duration,
      )
    }

    return resp, err
  }

  func LoggingMiddleware(logger *slog.Logger) Middleware {
    return func(base http.RoundTripper) http.RoundTripper {
      return &loggingTransport{base: base, logger: logger}
    }
  }

  // Retry middleware
  type retryTransport struct {
    base       http.RoundTripper
    maxRetries int
    backoff    time.Duration
  }

  func (t *retryTransport) RoundTrip(req *http.Request) (*http.Response, error) {
    var resp *http.Response
    var err error

    for i := 0; i <= t.maxRetries; i++ {
      resp, err = t.base.RoundTrip(req)
      if err == nil && resp.StatusCode < 500 {
        return resp, nil
      }

      if i < t.maxRetries {
        time.Sleep(t.backoff * time.Duration(i+1))
      }
    }

    return resp, err
  }

  func RetryMiddleware(maxRetries int, backoff time.Duration) Middleware {
    return func(base http.RoundTripper) http.RoundTripper {
      return &retryTransport{
        base:       base,
        maxRetries: maxRetries,
        backoff:    backoff,
      }
    }
  }
  ```

fx_module: |
  **fx Dependency Injection**:

  ```go
  package httpclient

  import (
    "go.uber.org/fx"
  )

  var Module = fx.Module("httpclient",
    fx.Provide(
      NewConfig,        // Load config from koanf
      NewFactory,       // Create factory
      NewHealthChecker, // Background health checking
    ),

    // Named HTTP clients for different services
    fx.Provide(
      fx.Annotate(
        func(f *Factory) *http.Client {
          return f.GetClient("tmdb")
        },
        fx.ResultTags(`name:"tmdb"`),
      ),
      fx.Annotate(
        func(f *Factory) *http.Client {
          return f.GetClient("tvdb")
        },
        fx.ResultTags(`name:"tvdb"`),
      ),
      fx.Annotate(
        func(f *Factory) *http.Client {
          return f.GetClient("musicbrainz")
        },
        fx.ResultTags(`name:"musicbrainz"`),
      ),
      fx.Annotate(
        func(f *Factory) *http.Client {
          return f.GetClient("radarr")
        },
        fx.ResultTags(`name:"radarr"`),
      ),
      // ... more services
    ),
  )

  // Usage in other services:
  package tmdb

  type Client struct {
    httpClient *http.Client
  }

  func NewClient(httpClient *http.Client) *Client {
    return &Client{httpClient: httpClient}
  }

  // In fx module:
  fx.Provide(
    fx.Annotate(
      tmdb.NewClient,
      fx.ParamTags(`name:"tmdb"`),  // Inject TMDb HTTP client
    ),
  )
  ```

health_checking: |
  **Background Health Checking**:

  ```go
  package httpclient

  import (
    "context"
    "log/slog"
    "time"
  )

  type HealthChecker struct {
    factory *Factory
    logger  *slog.Logger
    config  Config
  }

  func NewHealthChecker(factory *Factory, logger *slog.Logger, config Config) *HealthChecker {
    return &HealthChecker{
      factory: factory,
      logger:  logger,
      config:  config,
    }
  }

  func (h *HealthChecker) Start(ctx context.Context) {
    for proxyName, proxyCfg := range h.config.Proxies {
      if !proxyCfg.Enabled || proxyCfg.HealthCheckInterval == 0 {
        continue
      }

      go h.checkProxyPeriodically(ctx, proxyName, proxyCfg)
    }
  }

  func (h *HealthChecker) checkProxyPeriodically(ctx context.Context, proxyName string, cfg ProxyConfig) {
    ticker := time.NewTicker(cfg.HealthCheckInterval)
    defer ticker.Stop()

    for {
      select {
      case <-ctx.Done():
        return
      case <-ticker.C:
        err := h.factory.CheckProxyHealth(ctx, proxyName)
        if err != nil {
          h.logger.Warn("proxy health check failed",
            "proxy", proxyName,
            "error", err,
          )
        } else {
          h.logger.Debug("proxy health check passed",
            "proxy", proxyName,
          )
        }
      }
    }
  }
  ```

usage_examples: |
  **Usage in Metadata Services**:

  ```go
  // TMDb client receives HTTP client via fx
  package tmdb

  import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
  )

  type Client struct {
    httpClient *http.Client  // Injected by fx (routes through Tor proxy)
    apiKey     string
    baseURL    string
  }

  func NewClient(httpClient *http.Client, apiKey string) *Client {
    return &Client{
      httpClient: httpClient,
      apiKey:     apiKey,
      baseURL:    "https://api.themoviedb.org/3",
    }
  }

  func (c *Client) GetMovie(ctx context.Context, tmdbID string) (*Movie, error) {
    url := fmt.Sprintf("%s/movie/%s?api_key=%s", c.baseURL, tmdbID, c.apiKey)

    req, _ := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
    resp, err := c.httpClient.Do(req)  // Routes through Tor proxy automatically
    if err != nil {
      return nil, err
    }
    defer resp.Body.Close()

    var movie Movie
    json.NewDecoder(resp.Body).Decode(&movie)

    return &movie, nil
  }

  // Radarr client receives different HTTP client (direct, no proxy)
  package radarr

  type Client struct {
    httpClient *http.Client  // Injected by fx (direct connection, no proxy)
    baseURL    string
    apiKey     string
  }

  func NewClient(httpClient *http.Client, baseURL, apiKey string) *Client {
    return &Client{
      httpClient: httpClient,
      baseURL:    baseURL,
      apiKey:     apiKey,
    }
  }

  func (c *Client) GetMovies(ctx context.Context) ([]Movie, error) {
    req, _ := http.NewRequestWithContext(ctx, http.MethodGet, c.baseURL+"/api/v3/movie", nil)
    req.Header.Set("X-Api-Key", c.apiKey)

    resp, err := c.httpClient.Do(req)  // Direct connection (local network)
    // ...
  }
  ```

unit_tests: |
  ```go
  func TestFactory_GetClient(t *testing.T) {
    // Test client creation for different services
    // Verify proxy routing
  }

  func TestFactory_ProxyTypes(t *testing.T) {
    // Test HTTP proxy
    // Test SOCKS5 proxy
    // Test VPN binding
  }

  func TestFactory_HealthCheck(t *testing.T) {
    // Test proxy health checking
    // Test failover on health check failure
  }

  func TestMiddleware_Logging(t *testing.T) {
    // Test logging middleware
  }

  func TestMiddleware_Retry(t *testing.T) {
    // Test retry middleware
    // Test exponential backoff
  }
  ```

integration_tests: |
  ```go
  func TestHTTPClient_RealProxy(t *testing.T) {
    // Test with real Tor proxy (if available)
    // Verify IP changes through proxy
  }

  func TestHTTPClient_VPN(t *testing.T) {
    // Test VPN interface binding
    // Verify traffic routes through VPN
  }

  func TestHTTPClient_TMDbViaProxy(t *testing.T) {
    // Test TMDb API call through proxy
    // Verify successful metadata fetch
  }
  ```
