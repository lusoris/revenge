doc_title: Grants Service
doc_category: service
created_date: '2026-01-31'
overall_status: âœ… Complete
status_design: âœ…
status_design_notes: '-'
status_sources: âœ…
status_sources_notes: '-'
status_instructions: âœ…
status_instructions_notes: '-'
status_code: ðŸ”´
status_code_notes: '-'
status_linting: ðŸ”´
status_linting_notes: '-'
status_unit_testing: ðŸ”´
status_unit_testing_notes: '-'
status_integration_testing: ðŸ”´
status_integration_testing_notes: '-'
technical_summary: '> Polymorphic resource access grants for fine-grained sharing'
wiki_tagline: '> Polymorphic resource access grants for fine-grained sharing'
wiki_overview: The Grants service enables sharing specific items with other users. Share a movie, playlist, or library with
  friends without giving them full access. Grants can be time-limited (expires in 7 days) or permanent. Revoke access anytime.
  Works with all resource types through polymorphic references.
sources:
- name: Casbin
  url: https://pkg.go.dev/github.com/casbin/casbin/v2
  note: Auto-resolved from casbin
- name: Uber fx
  url: https://pkg.go.dev/go.uber.org/fx
  note: Auto-resolved from fx
- name: pgx PostgreSQL Driver
  url: https://pkg.go.dev/github.com/jackc/pgx/v5
  note: Auto-resolved from pgx
- name: PostgreSQL Arrays
  url: https://www.postgresql.org/docs/current/arrays.html
  note: Auto-resolved from postgresql-arrays
- name: PostgreSQL JSON Functions
  url: https://www.postgresql.org/docs/current/functions-json.html
  note: Auto-resolved from postgresql-json
- name: River Job Queue
  url: https://pkg.go.dev/github.com/riverqueue/river
  note: Auto-resolved from river
design_refs:
- title: services
  path: INDEX.md
- title: 01_ARCHITECTURE
  path: ../architecture/01_ARCHITECTURE.md
- title: 02_DESIGN_PRINCIPLES
  path: ../architecture/02_DESIGN_PRINCIPLES.md
- title: 03_METADATA_SYSTEM
  path: ../architecture/03_METADATA_SYSTEM.md
service_name: Grants Service
package_path: internal/service/grants
fx_module: grants.Module
architecture_diagram: |-
  ```mermaid
  flowchart TD
      subgraph row1[ ]
          direction LR
          node1(["Client<br/>(Web/App)"])
          node2[["API Handler<br/>(ogen)"]]
          node3[["Service<br/>(Logic)"]]
      end
      subgraph row2[ ]
          direction LR
          node4["Repository<br/>(sqlc)"]
          node5[["RBAC<br/>Service"]]
          node6[("Cache<br/>(otter)")]
      end
      node7[("PostgreSQL<br/>(pgx)")]
      node1 --> node2
      node2 --> node3
      node4 --> node5
      node5 --> node6
      node3 --> node4
      node6 --> node7

      %% Hide row subgraph borders
      style row1 fill:transparent,stroke:transparent
      style row2 fill:transparent,stroke:transparent
  ```
database_schema: |
  **Schema**: `public`

  ```sql
  -- Access grants (polymorphic sharing)
  CREATE TABLE access_grants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Grantor (who shares)
    granted_by_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Grantee (who receives access)
    granted_to_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Resource (polymorphic)
    resource_type VARCHAR(50) NOT NULL,            -- 'movie', 'tvshow', 'library', 'playlist'
    resource_id UUID NOT NULL,

    -- Permission
    permission VARCHAR(50) NOT NULL,               -- 'view', 'edit', 'download'

    -- Expiration
    expires_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ DEFAULT now(),
    revoked_at TIMESTAMPTZ
  );
  CREATE INDEX idx_access_grants_grantee ON access_grants(granted_to_user_id, resource_type);
  CREATE INDEX idx_access_grants_resource ON access_grants(resource_type, resource_id);
  CREATE INDEX idx_access_grants_expires ON access_grants(expires_at) WHERE expires_at IS NOT NULL;
  ```
module_structure: |
  ```
  internal/service/grants/
  â”œâ”€â”€ module.go                    # fx module
  â”œâ”€â”€ types.go                     # Domain types
  â”œâ”€â”€ repository.go                # Database operations (sqlc)
  â”œâ”€â”€ service.go                   # Grants service logic
  â”œâ”€â”€ cleanup.go                   # Expired grants cleanup (River job)
  â”œâ”€â”€ handler.go                   # HTTP API handlers
  â””â”€â”€ grants_test.go
  ```
key_interfaces: |
  ```go
  type GrantsService interface {
    // Grant management
    GrantAccess(ctx context.Context, req GrantRequest) (*AccessGrant, error)
    RevokeGrant(ctx context.Context, grantID uuid.UUID) error
    CheckAccess(ctx context.Context, userID uuid.UUID, resourceType string, resourceID uuid.UUID, permission string) (bool, error)

    // List grants
    GetUserGrants(ctx context.Context, userID uuid.UUID) ([]AccessGrant, error)
    GetResourceGrants(ctx context.Context, resourceType string, resourceID uuid.UUID) ([]AccessGrant, error)

    // Cleanup
    CleanupExpiredGrants(ctx context.Context) (int, error)
  }

  type GrantRequest struct {
    GrantedToUserID uuid.UUID  `json:"granted_to_user_id"`
    ResourceType    string     `json:"resource_type"`
    ResourceID      uuid.UUID  `json:"resource_id"`
    Permission      string     `json:"permission"`
    ExpiresAt       *time.Time `json:"expires_at,omitempty"`
  }
  ```
dependencies: |
  **Go Packages**:
  - `github.com/google/uuid`
  - `github.com/jackc/pgx/v5`
  - `github.com/riverqueue/river` - Cleanup jobs
  - `github.com/maypok86/otter` - Grant cache
  - `go.uber.org/fx`
env_vars: |
  ```bash
  GRANTS_CLEANUP_INTERVAL=1h
  GRANTS_DEFAULT_EXPIRY=168h  # 7 days
  ```
config_keys: |
  ```yaml
  grants:
    cleanup_interval: 1h
    default_expiry: 168h
  ```
component_interaction: |
  **Share Resource**:
  1. User A shares movie with User B
  2. POST /api/v1/grants with {granted_to_user_id, resource_type: "movie", resource_id, permission: "view"}
  3. Service validates User A owns/can share the resource
  4. Insert into access_grants
  5. User B can now view the movie

  **Access Check**:
  1. User B requests GET /api/v1/movies/:id
  2. Middleware checks if User B has access
  3. Query access_grants WHERE granted_to_user_id = B AND resource_type = 'movie' AND resource_id = :id
  4. If found and not expired, allow access
  5. If not found, fallback to RBAC/library permissions
api_endpoints: |
  ```
  POST   /api/v1/grants                       # Grant access
  DELETE /api/v1/grants/:id                   # Revoke grant
  GET    /api/v1/grants/me                    # Get my grants
  GET    /api/v1/grants/resource/:type/:id    # Get resource grants
  ```
unit_tests: |
  ```go
  func TestGrantsService_GrantAccess(t *testing.T) {
    // Test granting access with expiration
  }

  func TestGrantsService_CheckAccess(t *testing.T) {
    // Test access checking (active, expired)
  }
  ```
integration_tests: |
  ```go
  func TestGrants_ExpiryCleanup(t *testing.T) {
    // Test expired grant cleanup job
  }
  ```
