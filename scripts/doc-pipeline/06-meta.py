#!/usr/bin/env python3
"""Generate meta documentation files.

Creates:
1. Table of contents for large documents
2. Updates DESIGN_INDEX.md with comprehensive navigation

Usage:
    python scripts/doc-pipeline/06-meta.py               # Dry run
    python scripts/doc-pipeline/06-meta.py --apply       # Write files
"""

from __future__ import annotations

import argparse
import re
import sys
from pathlib import Path
from typing import Any


SCRIPT_DIR = Path(__file__).parent
PROJECT_ROOT = SCRIPT_DIR.parent.parent
DESIGN_DIR = PROJECT_ROOT / "docs" / "dev" / "design"
SOURCES_DIR = PROJECT_ROOT / "docs" / "dev" / "sources"

DESIGN_INDEX_FILE = DESIGN_DIR / "DESIGN_INDEX.md"

CATEGORY_ORDER = [
    "architecture",
    "features",
    "integrations",
    "services",
    "technical",
    "operations",
    "research",
    "planning",
]

CATEGORY_TITLES = {
    "architecture": "ðŸ—ï¸ Architecture",
    "features": "âœ¨ Features",
    "integrations": "ðŸ”Œ Integrations",
    "services": "âš™ï¸ Services",
    "technical": "ðŸ”§ Technical",
    "operations": "ðŸ“¦ Operations",
    "research": "ðŸ”¬ Research",
    "planning": "ðŸ“‹ Planning",
}


def find_all_docs() -> dict[str, list[Path]]:
    """Find all design documents grouped by category."""
    docs: dict[str, list[Path]] = {}

    for md_file in sorted(DESIGN_DIR.rglob("*.md")):
        if ".archive" in str(md_file):
            continue
        if ".analysis" in str(md_file):
            continue
        if md_file.parent == DESIGN_DIR:
            continue
        if md_file.name.startswith("INDEX"):
            continue

        try:
            rel = md_file.relative_to(DESIGN_DIR)
            category = rel.parts[0]
        except ValueError:
            continue

        if category not in docs:
            docs[category] = []
        docs[category].append(md_file)

    return docs


def extract_doc_metadata(doc_path: Path) -> dict[str, Any]:
    """Extract metadata from a document."""
    content = doc_path.read_text(encoding="utf-8")

    title_match = re.search(r"^#\s+(.+)$", content, re.MULTILINE)
    title = title_match.group(1) if title_match else doc_path.stem.replace("_", " ")

    desc_match = re.search(r"^>\s*(.+)$", content, re.MULTILINE)
    desc = desc_match.group(1) if desc_match else ""

    status_match = re.search(r"\|\s*Design\s*\|\s*([^\|]+)\s*\|", content)
    status = status_match.group(1).strip() if status_match else "ðŸ”´"

    line_count = len(content.split("\n"))

    return {
        "title": title,
        "desc": desc[:80] if len(desc) > 80 else desc,
        "status": status,
        "lines": line_count,
        "path": doc_path,
    }


def generate_design_index(docs: dict[str, list[Path]]) -> str:
    """Generate comprehensive DESIGN_INDEX.md content."""
    lines = [
        "# Design Documentation Index",
        "",
        "> Comprehensive index of all design documentation",
        ">",
        "> Auto-generated by `scripts/doc-pipeline/06-meta.py`",
        "",
        "**Source of Truth**: [00_SOURCE_OF_TRUTH.md](00_SOURCE_OF_TRUTH.md)",
        "",
        "---",
        "",
        "## Quick Navigation",
        "",
    ]

    # Quick navigation links
    for category in CATEGORY_ORDER:
        if category in docs:
            title = CATEGORY_TITLES.get(category, category.title())
            lines.append(f"- [{title}](#{category})")
    lines.append("")

    # Statistics
    total_docs = sum(len(d) for d in docs.values())
    total_lines = 0
    status_counts = {"âœ…": 0, "ðŸŸ¡": 0, "ðŸ”´": 0}

    for doc_list in docs.values():
        for doc_path in doc_list:
            meta = extract_doc_metadata(doc_path)
            total_lines += meta["lines"]
            for status_key in status_counts:
                if status_key in meta["status"]:
                    status_counts[status_key] += 1
                    break

    lines.extend(
        [
            "---",
            "",
            "## Statistics",
            "",
            "| Metric | Value |",
            "|--------|-------|",
            f"| Total Documents | {total_docs} |",
            f"| Total Lines | {total_lines:,} |",
            f"| Designed (âœ…) | {status_counts['âœ…']} |",
            f"| Partial (ðŸŸ¡) | {status_counts['ðŸŸ¡']} |",
            f"| Not Started (ðŸ”´) | {status_counts['ðŸ”´']} |",
            "",
            "---",
            "",
        ],
    )

    # Category sections
    for category in CATEGORY_ORDER:
        if category not in docs:
            continue

        doc_list = docs[category]
        title = CATEGORY_TITLES.get(category, category.title())

        lines.extend(
            [
                f"## {title}",
                "",
                f'<a id="{category}"></a>',
                "",
                "| Document | Description | Status |",
                "|----------|-------------|--------|",
            ],
        )

        for doc_path in sorted(doc_list, key=lambda x: x.name):
            meta = extract_doc_metadata(doc_path)
            rel_path = doc_path.relative_to(DESIGN_DIR)
            lines.append(
                f"| [{meta['title']}]({rel_path}) | {meta['desc']} | {meta['status']} |",
            )

        lines.extend(["", "---", ""])

    # Footer
    lines.extend(
        [
            "## External Resources",
            "",
            "- [External Sources](../sources/SOURCES.md)",
            "- [Source of Truth](00_SOURCE_OF_TRUTH.md)",
            "",
            "---",
            "",
            "## Status Legend",
            "",
            "| Status | Meaning |",
            "|--------|---------|",
            "| âœ… | Complete / Designed |",
            "| ðŸŸ¡ | Partial / In Progress |",
            "| ðŸ”´ | Not Started / Planned |",
            "| âšª | N/A / Not Applicable |",
            "",
            "---",
            "",
            "*Auto-generated by `scripts/doc-pipeline/06-meta.py`*",
            "",
        ],
    )

    return "\n".join(lines)


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate meta documentation files")
    parser.add_argument(
        "--apply",
        action="store_true",
        help="Write files (default: dry-run)",
    )
    args = parser.parse_args()

    dry_run = not args.apply

    if dry_run:
        print("=== DRY RUN (use --apply to write) ===\n")

    print("Finding design documents...")
    docs = find_all_docs()
    total = sum(len(d) for d in docs.values())
    print(f"  Found {total} documents in {len(docs)} categories")

    print("\nGenerating DESIGN_INDEX.md...")
    content = generate_design_index(docs)

    if dry_run:
        print(f"  Would write {len(content)} bytes to {DESIGN_INDEX_FILE}")
    else:
        DESIGN_INDEX_FILE.write_text(content, encoding="utf-8")
        print(f"  Wrote {DESIGN_INDEX_FILE}")

    if dry_run:
        print("\n=== DRY RUN complete. Use --apply to write. ===")

    return 0


if __name__ == "__main__":
    sys.exit(main())
