// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: provisions.sql

package adultdb

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addCargoHoldUsage = `-- name: AddCargoHoldUsage :one
UPDATE qar.cargo_hold
SET
    total_used_gb = total_used_gb + $1,
    expedition_used_gb = CASE WHEN $2 THEN expedition_used_gb + $1 ELSE expedition_used_gb END,
    voyage_used_gb = CASE WHEN NOT $2 THEN voyage_used_gb + $1 ELSE voyage_used_gb END
WHERE id = 1
RETURNING id, total_quota_gb, total_used_gb, expedition_quota_gb, expedition_used_gb, voyage_quota_gb, voyage_used_gb, updated_at
`

type AddCargoHoldUsageParams struct {
	TotalUsedGb      pgtype.Numeric `json:"totalUsedGb"`
	ExpeditionUsedGb pgtype.Numeric `json:"expeditionUsedGb"`
}

func (q *Queries) AddCargoHoldUsage(ctx context.Context, arg AddCargoHoldUsageParams) (QarCargoHold, error) {
	row := q.db.QueryRow(ctx, addCargoHoldUsage, arg.TotalUsedGb, arg.ExpeditionUsedGb)
	var i QarCargoHold
	err := row.Scan(
		&i.ID,
		&i.TotalQuotaGb,
		&i.TotalUsedGb,
		&i.ExpeditionQuotaGb,
		&i.ExpeditionUsedGb,
		&i.VoyageQuotaGb,
		&i.VoyageUsedGb,
		&i.UpdatedAt,
	)
	return i, err
}

const addRationCargoUsage = `-- name: AddRationCargoUsage :one
UPDATE qar.rations
SET cargo_used_gb = cargo_used_gb + $2
WHERE user_id = $1
RETURNING user_id, daily_limit, weekly_limit, monthly_limit, daily_used, weekly_used, monthly_used, cargo_quota_gb, cargo_used_gb, last_reset_daily, last_reset_weekly, last_reset_monthly, created_at, updated_at
`

type AddRationCargoUsageParams struct {
	UserID      uuid.UUID      `json:"userId"`
	CargoUsedGb pgtype.Numeric `json:"cargoUsedGb"`
}

func (q *Queries) AddRationCargoUsage(ctx context.Context, arg AddRationCargoUsageParams) (QarRation, error) {
	row := q.db.QueryRow(ctx, addRationCargoUsage, arg.UserID, arg.CargoUsedGb)
	var i QarRation
	err := row.Scan(
		&i.UserID,
		&i.DailyLimit,
		&i.WeeklyLimit,
		&i.MonthlyLimit,
		&i.DailyUsed,
		&i.WeeklyUsed,
		&i.MonthlyUsed,
		&i.CargoQuotaGb,
		&i.CargoUsedGb,
		&i.LastResetDaily,
		&i.LastResetWeekly,
		&i.LastResetMonthly,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countProvisionAyes = `-- name: CountProvisionAyes :one
SELECT COUNT(*) FROM qar.provision_ayes WHERE provision_id = $1
`

func (q *Queries) CountProvisionAyes(ctx context.Context, provisionID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProvisionAyes, provisionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProvisionMissives = `-- name: CountProvisionMissives :one
SELECT COUNT(*) FROM qar.provision_missives WHERE provision_id = $1
`

func (q *Queries) CountProvisionMissives(ctx context.Context, provisionID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProvisionMissives, provisionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProvisionsByStatus = `-- name: CountProvisionsByStatus :one
SELECT COUNT(*) FROM qar.provisions WHERE status = $1
`

func (q *Queries) CountProvisionsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countProvisionsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProvisionsByUser = `-- name: CountProvisionsByUser :one
SELECT COUNT(*) FROM qar.provisions WHERE user_id = $1
`

func (q *Queries) CountProvisionsByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProvisionsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createArticle = `-- name: CreateArticle :one
INSERT INTO qar.articles (
    name,
    description,
    content_type,
    condition_type,
    condition_value,
    action,
    automation_trigger,
    enabled,
    priority
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, name, description, content_type, condition_type, condition_value, action, automation_trigger, enabled, priority, created_at, updated_at
`

type CreateArticleParams struct {
	Name              string          `json:"name"`
	Description       *string         `json:"description"`
	ContentType       *string         `json:"contentType"`
	ConditionType     string          `json:"conditionType"`
	ConditionValue    json.RawMessage `json:"conditionValue"`
	Action            string          `json:"action"`
	AutomationTrigger *string         `json:"automationTrigger"`
	Enabled           bool            `json:"enabled"`
	Priority          int32           `json:"priority"`
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (QarArticle, error) {
	row := q.db.QueryRow(ctx, createArticle,
		arg.Name,
		arg.Description,
		arg.ContentType,
		arg.ConditionType,
		arg.ConditionValue,
		arg.Action,
		arg.AutomationTrigger,
		arg.Enabled,
		arg.Priority,
	)
	var i QarArticle
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ContentType,
		&i.ConditionType,
		&i.ConditionValue,
		&i.Action,
		&i.AutomationTrigger,
		&i.Enabled,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProvision = `-- name: CreateProvision :one
INSERT INTO qar.provisions (
    user_id,
    content_type,
    request_subtype,
    external_id,
    external_source,
    title,
    release_year,
    manifest,
    estimated_cargo_gb
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id
`

type CreateProvisionParams struct {
	UserID           uuid.UUID      `json:"userId"`
	ContentType      string         `json:"contentType"`
	RequestSubtype   *string        `json:"requestSubtype"`
	ExternalID       *string        `json:"externalId"`
	ExternalSource   *string        `json:"externalSource"`
	Title            string         `json:"title"`
	ReleaseYear      *int32         `json:"releaseYear"`
	Manifest         []byte         `json:"manifest"`
	EstimatedCargoGb pgtype.Numeric `json:"estimatedCargoGb"`
}

func (q *Queries) CreateProvision(ctx context.Context, arg CreateProvisionParams) (QarProvision, error) {
	row := q.db.QueryRow(ctx, createProvision,
		arg.UserID,
		arg.ContentType,
		arg.RequestSubtype,
		arg.ExternalID,
		arg.ExternalSource,
		arg.Title,
		arg.ReleaseYear,
		arg.Manifest,
		arg.EstimatedCargoGb,
	)
	var i QarProvision
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContentType,
		&i.RequestSubtype,
		&i.ExternalID,
		&i.ExternalSource,
		&i.Title,
		&i.ReleaseYear,
		&i.Manifest,
		&i.Status,
		&i.AutoApproved,
		&i.AutoArticleID,
		&i.ApprovedByUserID,
		&i.ApprovedAt,
		&i.DeclinedReason,
		&i.Priority,
		&i.AyesCount,
		&i.IntegrationID,
		&i.IntegrationStatus,
		&i.EstimatedCargoGb,
		&i.ActualCargoGb,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableAt,
		&i.TriggeredByAutomation,
		&i.ParentProvisionID,
	)
	return i, err
}

const createProvisionAye = `-- name: CreateProvisionAye :one
INSERT INTO qar.provision_ayes (provision_id, user_id)
VALUES ($1, $2)
RETURNING provision_id, user_id, voted_at
`

type CreateProvisionAyeParams struct {
	ProvisionID uuid.UUID `json:"provisionId"`
	UserID      uuid.UUID `json:"userId"`
}

func (q *Queries) CreateProvisionAye(ctx context.Context, arg CreateProvisionAyeParams) (QarProvisionAye, error) {
	row := q.db.QueryRow(ctx, createProvisionAye, arg.ProvisionID, arg.UserID)
	var i QarProvisionAye
	err := row.Scan(&i.ProvisionID, &i.UserID, &i.VotedAt)
	return i, err
}

const createProvisionMissive = `-- name: CreateProvisionMissive :one
INSERT INTO qar.provision_missives (
    provision_id,
    user_id,
    message,
    is_captain_order
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, provision_id, user_id, message, is_captain_order, created_at
`

type CreateProvisionMissiveParams struct {
	ProvisionID    uuid.UUID   `json:"provisionId"`
	UserID         pgtype.UUID `json:"userId"`
	Message        string      `json:"message"`
	IsCaptainOrder bool        `json:"isCaptainOrder"`
}

func (q *Queries) CreateProvisionMissive(ctx context.Context, arg CreateProvisionMissiveParams) (QarProvisionMissive, error) {
	row := q.db.QueryRow(ctx, createProvisionMissive,
		arg.ProvisionID,
		arg.UserID,
		arg.Message,
		arg.IsCaptainOrder,
	)
	var i QarProvisionMissive
	err := row.Scan(
		&i.ID,
		&i.ProvisionID,
		&i.UserID,
		&i.Message,
		&i.IsCaptainOrder,
		&i.CreatedAt,
	)
	return i, err
}

const createRation = `-- name: CreateRation :one
INSERT INTO qar.rations (user_id)
VALUES ($1)
RETURNING user_id, daily_limit, weekly_limit, monthly_limit, daily_used, weekly_used, monthly_used, cargo_quota_gb, cargo_used_gb, last_reset_daily, last_reset_weekly, last_reset_monthly, created_at, updated_at
`

func (q *Queries) CreateRation(ctx context.Context, userID uuid.UUID) (QarRation, error) {
	row := q.db.QueryRow(ctx, createRation, userID)
	var i QarRation
	err := row.Scan(
		&i.UserID,
		&i.DailyLimit,
		&i.WeeklyLimit,
		&i.MonthlyLimit,
		&i.DailyUsed,
		&i.WeeklyUsed,
		&i.MonthlyUsed,
		&i.CargoQuotaGb,
		&i.CargoUsedGb,
		&i.LastResetDaily,
		&i.LastResetWeekly,
		&i.LastResetMonthly,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteArticle = `-- name: DeleteArticle :exec
DELETE FROM qar.articles WHERE id = $1
`

func (q *Queries) DeleteArticle(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteArticle, id)
	return err
}

const deleteProvision = `-- name: DeleteProvision :exec
DELETE FROM qar.provisions WHERE id = $1
`

func (q *Queries) DeleteProvision(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProvision, id)
	return err
}

const deleteProvisionAye = `-- name: DeleteProvisionAye :exec
DELETE FROM qar.provision_ayes
WHERE provision_id = $1 AND user_id = $2
`

type DeleteProvisionAyeParams struct {
	ProvisionID uuid.UUID `json:"provisionId"`
	UserID      uuid.UUID `json:"userId"`
}

func (q *Queries) DeleteProvisionAye(ctx context.Context, arg DeleteProvisionAyeParams) error {
	_, err := q.db.Exec(ctx, deleteProvisionAye, arg.ProvisionID, arg.UserID)
	return err
}

const deleteProvisionMissive = `-- name: DeleteProvisionMissive :exec
DELETE FROM qar.provision_missives WHERE id = $1
`

func (q *Queries) DeleteProvisionMissive(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProvisionMissive, id)
	return err
}

const getArticle = `-- name: GetArticle :one

SELECT id, name, description, content_type, condition_type, condition_value, action, automation_trigger, enabled, priority, created_at, updated_at FROM qar.articles WHERE id = $1
`

// ============================================================================
// ARTICLES (Rules)
// ============================================================================
func (q *Queries) GetArticle(ctx context.Context, id uuid.UUID) (QarArticle, error) {
	row := q.db.QueryRow(ctx, getArticle, id)
	var i QarArticle
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ContentType,
		&i.ConditionType,
		&i.ConditionValue,
		&i.Action,
		&i.AutomationTrigger,
		&i.Enabled,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCargoHold = `-- name: GetCargoHold :one

SELECT id, total_quota_gb, total_used_gb, expedition_quota_gb, expedition_used_gb, voyage_quota_gb, voyage_used_gb, updated_at FROM qar.cargo_hold WHERE id = 1
`

// ============================================================================
// CARGO HOLD (Global Storage Quotas)
// ============================================================================
func (q *Queries) GetCargoHold(ctx context.Context) (QarCargoHold, error) {
	row := q.db.QueryRow(ctx, getCargoHold)
	var i QarCargoHold
	err := row.Scan(
		&i.ID,
		&i.TotalQuotaGb,
		&i.TotalUsedGb,
		&i.ExpeditionQuotaGb,
		&i.ExpeditionUsedGb,
		&i.VoyageQuotaGb,
		&i.VoyageUsedGb,
		&i.UpdatedAt,
	)
	return i, err
}

const getProvisionAye = `-- name: GetProvisionAye :one

SELECT provision_id, user_id, voted_at FROM qar.provision_ayes
WHERE provision_id = $1 AND user_id = $2
`

type GetProvisionAyeParams struct {
	ProvisionID uuid.UUID `json:"provisionId"`
	UserID      uuid.UUID `json:"userId"`
}

// ============================================================================
// PROVISION AYES (Votes)
// ============================================================================
func (q *Queries) GetProvisionAye(ctx context.Context, arg GetProvisionAyeParams) (QarProvisionAye, error) {
	row := q.db.QueryRow(ctx, getProvisionAye, arg.ProvisionID, arg.UserID)
	var i QarProvisionAye
	err := row.Scan(&i.ProvisionID, &i.UserID, &i.VotedAt)
	return i, err
}

const getProvisionByExternalID = `-- name: GetProvisionByExternalID :one
SELECT id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id FROM qar.provisions
WHERE external_source = $1 AND external_id = $2
`

type GetProvisionByExternalIDParams struct {
	ExternalSource *string `json:"externalSource"`
	ExternalID     *string `json:"externalId"`
}

func (q *Queries) GetProvisionByExternalID(ctx context.Context, arg GetProvisionByExternalIDParams) (QarProvision, error) {
	row := q.db.QueryRow(ctx, getProvisionByExternalID, arg.ExternalSource, arg.ExternalID)
	var i QarProvision
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContentType,
		&i.RequestSubtype,
		&i.ExternalID,
		&i.ExternalSource,
		&i.Title,
		&i.ReleaseYear,
		&i.Manifest,
		&i.Status,
		&i.AutoApproved,
		&i.AutoArticleID,
		&i.ApprovedByUserID,
		&i.ApprovedAt,
		&i.DeclinedReason,
		&i.Priority,
		&i.AyesCount,
		&i.IntegrationID,
		&i.IntegrationStatus,
		&i.EstimatedCargoGb,
		&i.ActualCargoGb,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableAt,
		&i.TriggeredByAutomation,
		&i.ParentProvisionID,
	)
	return i, err
}

const getProvisionByID = `-- name: GetProvisionByID :one


SELECT id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id FROM qar.provisions WHERE id = $1
`

// Provisions (Content Requests) - QAR obfuscated queries
// Request system for adult content
// ============================================================================
// PROVISIONS (Requests)
// ============================================================================
func (q *Queries) GetProvisionByID(ctx context.Context, id uuid.UUID) (QarProvision, error) {
	row := q.db.QueryRow(ctx, getProvisionByID, id)
	var i QarProvision
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContentType,
		&i.RequestSubtype,
		&i.ExternalID,
		&i.ExternalSource,
		&i.Title,
		&i.ReleaseYear,
		&i.Manifest,
		&i.Status,
		&i.AutoApproved,
		&i.AutoArticleID,
		&i.ApprovedByUserID,
		&i.ApprovedAt,
		&i.DeclinedReason,
		&i.Priority,
		&i.AyesCount,
		&i.IntegrationID,
		&i.IntegrationStatus,
		&i.EstimatedCargoGb,
		&i.ActualCargoGb,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableAt,
		&i.TriggeredByAutomation,
		&i.ParentProvisionID,
	)
	return i, err
}

const getProvisionMissive = `-- name: GetProvisionMissive :one

SELECT id, provision_id, user_id, message, is_captain_order, created_at FROM qar.provision_missives WHERE id = $1
`

// ============================================================================
// PROVISION MISSIVES (Comments)
// ============================================================================
func (q *Queries) GetProvisionMissive(ctx context.Context, id uuid.UUID) (QarProvisionMissive, error) {
	row := q.db.QueryRow(ctx, getProvisionMissive, id)
	var i QarProvisionMissive
	err := row.Scan(
		&i.ID,
		&i.ProvisionID,
		&i.UserID,
		&i.Message,
		&i.IsCaptainOrder,
		&i.CreatedAt,
	)
	return i, err
}

const getRation = `-- name: GetRation :one

SELECT user_id, daily_limit, weekly_limit, monthly_limit, daily_used, weekly_used, monthly_used, cargo_quota_gb, cargo_used_gb, last_reset_daily, last_reset_weekly, last_reset_monthly, created_at, updated_at FROM qar.rations WHERE user_id = $1
`

// ============================================================================
// RATIONS (User Quotas)
// ============================================================================
func (q *Queries) GetRation(ctx context.Context, userID uuid.UUID) (QarRation, error) {
	row := q.db.QueryRow(ctx, getRation, userID)
	var i QarRation
	err := row.Scan(
		&i.UserID,
		&i.DailyLimit,
		&i.WeeklyLimit,
		&i.MonthlyLimit,
		&i.DailyUsed,
		&i.WeeklyUsed,
		&i.MonthlyUsed,
		&i.CargoQuotaGb,
		&i.CargoUsedGb,
		&i.LastResetDaily,
		&i.LastResetWeekly,
		&i.LastResetMonthly,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const hasUserVoted = `-- name: HasUserVoted :one
SELECT EXISTS(
    SELECT 1 FROM qar.provision_ayes
    WHERE provision_id = $1 AND user_id = $2
)
`

type HasUserVotedParams struct {
	ProvisionID uuid.UUID `json:"provisionId"`
	UserID      uuid.UUID `json:"userId"`
}

func (q *Queries) HasUserVoted(ctx context.Context, arg HasUserVotedParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasUserVoted, arg.ProvisionID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const incrementRationUsage = `-- name: IncrementRationUsage :one
UPDATE qar.rations
SET
    daily_used = daily_used + 1,
    weekly_used = weekly_used + 1,
    monthly_used = monthly_used + 1
WHERE user_id = $1
RETURNING user_id, daily_limit, weekly_limit, monthly_limit, daily_used, weekly_used, monthly_used, cargo_quota_gb, cargo_used_gb, last_reset_daily, last_reset_weekly, last_reset_monthly, created_at, updated_at
`

func (q *Queries) IncrementRationUsage(ctx context.Context, userID uuid.UUID) (QarRation, error) {
	row := q.db.QueryRow(ctx, incrementRationUsage, userID)
	var i QarRation
	err := row.Scan(
		&i.UserID,
		&i.DailyLimit,
		&i.WeeklyLimit,
		&i.MonthlyLimit,
		&i.DailyUsed,
		&i.WeeklyUsed,
		&i.MonthlyUsed,
		&i.CargoQuotaGb,
		&i.CargoUsedGb,
		&i.LastResetDaily,
		&i.LastResetWeekly,
		&i.LastResetMonthly,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listArticles = `-- name: ListArticles :many
SELECT id, name, description, content_type, condition_type, condition_value, action, automation_trigger, enabled, priority, created_at, updated_at FROM qar.articles
ORDER BY priority DESC, created_at ASC
`

func (q *Queries) ListArticles(ctx context.Context) ([]QarArticle, error) {
	rows, err := q.db.Query(ctx, listArticles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QarArticle{}
	for rows.Next() {
		var i QarArticle
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ContentType,
			&i.ConditionType,
			&i.ConditionValue,
			&i.Action,
			&i.AutomationTrigger,
			&i.Enabled,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticlesByContentType = `-- name: ListArticlesByContentType :many
SELECT id, name, description, content_type, condition_type, condition_value, action, automation_trigger, enabled, priority, created_at, updated_at FROM qar.articles
WHERE content_type = $1 OR content_type IS NULL
ORDER BY priority DESC
`

func (q *Queries) ListArticlesByContentType(ctx context.Context, contentType *string) ([]QarArticle, error) {
	rows, err := q.db.Query(ctx, listArticlesByContentType, contentType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QarArticle{}
	for rows.Next() {
		var i QarArticle
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ContentType,
			&i.ConditionType,
			&i.ConditionValue,
			&i.Action,
			&i.AutomationTrigger,
			&i.Enabled,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledArticles = `-- name: ListEnabledArticles :many
SELECT id, name, description, content_type, condition_type, condition_value, action, automation_trigger, enabled, priority, created_at, updated_at FROM qar.articles
WHERE enabled = true
ORDER BY priority DESC
`

func (q *Queries) ListEnabledArticles(ctx context.Context) ([]QarArticle, error) {
	rows, err := q.db.Query(ctx, listEnabledArticles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QarArticle{}
	for rows.Next() {
		var i QarArticle
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ContentType,
			&i.ConditionType,
			&i.ConditionValue,
			&i.Action,
			&i.AutomationTrigger,
			&i.Enabled,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingProvisions = `-- name: ListPendingProvisions :many
SELECT id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id FROM qar.provisions
WHERE status = 'pending'
ORDER BY priority DESC, ayes_count DESC, created_at DESC
LIMIT $1 OFFSET $2
`

type ListPendingProvisionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPendingProvisions(ctx context.Context, arg ListPendingProvisionsParams) ([]QarProvision, error) {
	rows, err := q.db.Query(ctx, listPendingProvisions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QarProvision{}
	for rows.Next() {
		var i QarProvision
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContentType,
			&i.RequestSubtype,
			&i.ExternalID,
			&i.ExternalSource,
			&i.Title,
			&i.ReleaseYear,
			&i.Manifest,
			&i.Status,
			&i.AutoApproved,
			&i.AutoArticleID,
			&i.ApprovedByUserID,
			&i.ApprovedAt,
			&i.DeclinedReason,
			&i.Priority,
			&i.AyesCount,
			&i.IntegrationID,
			&i.IntegrationStatus,
			&i.EstimatedCargoGb,
			&i.ActualCargoGb,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AvailableAt,
			&i.TriggeredByAutomation,
			&i.ParentProvisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProvisionAyes = `-- name: ListProvisionAyes :many
SELECT provision_id, user_id, voted_at FROM qar.provision_ayes
WHERE provision_id = $1
ORDER BY voted_at DESC
`

func (q *Queries) ListProvisionAyes(ctx context.Context, provisionID uuid.UUID) ([]QarProvisionAye, error) {
	rows, err := q.db.Query(ctx, listProvisionAyes, provisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QarProvisionAye{}
	for rows.Next() {
		var i QarProvisionAye
		if err := rows.Scan(&i.ProvisionID, &i.UserID, &i.VotedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProvisionMissives = `-- name: ListProvisionMissives :many
SELECT id, provision_id, user_id, message, is_captain_order, created_at FROM qar.provision_missives
WHERE provision_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListProvisionMissives(ctx context.Context, provisionID uuid.UUID) ([]QarProvisionMissive, error) {
	rows, err := q.db.Query(ctx, listProvisionMissives, provisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QarProvisionMissive{}
	for rows.Next() {
		var i QarProvisionMissive
		if err := rows.Scan(
			&i.ID,
			&i.ProvisionID,
			&i.UserID,
			&i.Message,
			&i.IsCaptainOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProvisions = `-- name: ListProvisions :many
SELECT id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id FROM qar.provisions
ORDER BY
    CASE WHEN $3::text = 'priority' THEN priority END DESC,
    CASE WHEN $3::text = 'ayes_count' THEN ayes_count END DESC,
    CASE WHEN $3::text = 'created_at' OR $3::text = '' THEN created_at END DESC
LIMIT $1 OFFSET $2
`

type ListProvisionsParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	SortBy string `json:"sortBy"`
}

func (q *Queries) ListProvisions(ctx context.Context, arg ListProvisionsParams) ([]QarProvision, error) {
	rows, err := q.db.Query(ctx, listProvisions, arg.Limit, arg.Offset, arg.SortBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QarProvision{}
	for rows.Next() {
		var i QarProvision
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContentType,
			&i.RequestSubtype,
			&i.ExternalID,
			&i.ExternalSource,
			&i.Title,
			&i.ReleaseYear,
			&i.Manifest,
			&i.Status,
			&i.AutoApproved,
			&i.AutoArticleID,
			&i.ApprovedByUserID,
			&i.ApprovedAt,
			&i.DeclinedReason,
			&i.Priority,
			&i.AyesCount,
			&i.IntegrationID,
			&i.IntegrationStatus,
			&i.EstimatedCargoGb,
			&i.ActualCargoGb,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AvailableAt,
			&i.TriggeredByAutomation,
			&i.ParentProvisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProvisionsByContentType = `-- name: ListProvisionsByContentType :many
SELECT id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id FROM qar.provisions
WHERE content_type = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListProvisionsByContentTypeParams struct {
	ContentType string `json:"contentType"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) ListProvisionsByContentType(ctx context.Context, arg ListProvisionsByContentTypeParams) ([]QarProvision, error) {
	rows, err := q.db.Query(ctx, listProvisionsByContentType, arg.ContentType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QarProvision{}
	for rows.Next() {
		var i QarProvision
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContentType,
			&i.RequestSubtype,
			&i.ExternalID,
			&i.ExternalSource,
			&i.Title,
			&i.ReleaseYear,
			&i.Manifest,
			&i.Status,
			&i.AutoApproved,
			&i.AutoArticleID,
			&i.ApprovedByUserID,
			&i.ApprovedAt,
			&i.DeclinedReason,
			&i.Priority,
			&i.AyesCount,
			&i.IntegrationID,
			&i.IntegrationStatus,
			&i.EstimatedCargoGb,
			&i.ActualCargoGb,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AvailableAt,
			&i.TriggeredByAutomation,
			&i.ParentProvisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProvisionsByStatus = `-- name: ListProvisionsByStatus :many
SELECT id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id FROM qar.provisions
WHERE status = $1
ORDER BY priority DESC, ayes_count DESC, created_at DESC
LIMIT $2 OFFSET $3
`

type ListProvisionsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListProvisionsByStatus(ctx context.Context, arg ListProvisionsByStatusParams) ([]QarProvision, error) {
	rows, err := q.db.Query(ctx, listProvisionsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QarProvision{}
	for rows.Next() {
		var i QarProvision
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContentType,
			&i.RequestSubtype,
			&i.ExternalID,
			&i.ExternalSource,
			&i.Title,
			&i.ReleaseYear,
			&i.Manifest,
			&i.Status,
			&i.AutoApproved,
			&i.AutoArticleID,
			&i.ApprovedByUserID,
			&i.ApprovedAt,
			&i.DeclinedReason,
			&i.Priority,
			&i.AyesCount,
			&i.IntegrationID,
			&i.IntegrationStatus,
			&i.EstimatedCargoGb,
			&i.ActualCargoGb,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AvailableAt,
			&i.TriggeredByAutomation,
			&i.ParentProvisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProvisionsByUser = `-- name: ListProvisionsByUser :many
SELECT id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id FROM qar.provisions
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListProvisionsByUserParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListProvisionsByUser(ctx context.Context, arg ListProvisionsByUserParams) ([]QarProvision, error) {
	rows, err := q.db.Query(ctx, listProvisionsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QarProvision{}
	for rows.Next() {
		var i QarProvision
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContentType,
			&i.RequestSubtype,
			&i.ExternalID,
			&i.ExternalSource,
			&i.Title,
			&i.ReleaseYear,
			&i.Manifest,
			&i.Status,
			&i.AutoApproved,
			&i.AutoArticleID,
			&i.ApprovedByUserID,
			&i.ApprovedAt,
			&i.DeclinedReason,
			&i.Priority,
			&i.AyesCount,
			&i.IntegrationID,
			&i.IntegrationStatus,
			&i.EstimatedCargoGb,
			&i.ActualCargoGb,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AvailableAt,
			&i.TriggeredByAutomation,
			&i.ParentProvisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetDailyRations = `-- name: ResetDailyRations :exec
UPDATE qar.rations
SET
    daily_used = 0,
    last_reset_daily = CURRENT_DATE
WHERE last_reset_daily < CURRENT_DATE
`

func (q *Queries) ResetDailyRations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetDailyRations)
	return err
}

const resetMonthlyRations = `-- name: ResetMonthlyRations :exec
UPDATE qar.rations
SET
    monthly_used = 0,
    last_reset_monthly = CURRENT_DATE
WHERE last_reset_monthly < (CURRENT_DATE - INTERVAL '30 days')
`

func (q *Queries) ResetMonthlyRations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetMonthlyRations)
	return err
}

const resetWeeklyRations = `-- name: ResetWeeklyRations :exec
UPDATE qar.rations
SET
    weekly_used = 0,
    last_reset_weekly = CURRENT_DATE
WHERE last_reset_weekly < (CURRENT_DATE - INTERVAL '7 days')
`

func (q *Queries) ResetWeeklyRations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetWeeklyRations)
	return err
}

const searchProvisions = `-- name: SearchProvisions :many
SELECT id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id FROM qar.provisions
WHERE title ILIKE '%' || $1 || '%'
ORDER BY priority DESC, ayes_count DESC, created_at DESC
LIMIT $2 OFFSET $3
`

type SearchProvisionsParams struct {
	Column1 *string `json:"column1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

func (q *Queries) SearchProvisions(ctx context.Context, arg SearchProvisionsParams) ([]QarProvision, error) {
	rows, err := q.db.Query(ctx, searchProvisions, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QarProvision{}
	for rows.Next() {
		var i QarProvision
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContentType,
			&i.RequestSubtype,
			&i.ExternalID,
			&i.ExternalSource,
			&i.Title,
			&i.ReleaseYear,
			&i.Manifest,
			&i.Status,
			&i.AutoApproved,
			&i.AutoArticleID,
			&i.ApprovedByUserID,
			&i.ApprovedAt,
			&i.DeclinedReason,
			&i.Priority,
			&i.AyesCount,
			&i.IntegrationID,
			&i.IntegrationStatus,
			&i.EstimatedCargoGb,
			&i.ActualCargoGb,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AvailableAt,
			&i.TriggeredByAutomation,
			&i.ParentProvisionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setArticleEnabled = `-- name: SetArticleEnabled :one
UPDATE qar.articles
SET enabled = $2
WHERE id = $1
RETURNING id, name, description, content_type, condition_type, condition_value, action, automation_trigger, enabled, priority, created_at, updated_at
`

type SetArticleEnabledParams struct {
	ID      uuid.UUID `json:"id"`
	Enabled bool      `json:"enabled"`
}

func (q *Queries) SetArticleEnabled(ctx context.Context, arg SetArticleEnabledParams) (QarArticle, error) {
	row := q.db.QueryRow(ctx, setArticleEnabled, arg.ID, arg.Enabled)
	var i QarArticle
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ContentType,
		&i.ConditionType,
		&i.ConditionValue,
		&i.Action,
		&i.AutomationTrigger,
		&i.Enabled,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setProvisionAutoApproved = `-- name: SetProvisionAutoApproved :one
UPDATE qar.provisions
SET
    auto_approved = true,
    auto_article_id = $2,
    status = 'approved',
    approved_at = NOW()
WHERE id = $1
RETURNING id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id
`

type SetProvisionAutoApprovedParams struct {
	ID            uuid.UUID   `json:"id"`
	AutoArticleID pgtype.UUID `json:"autoArticleId"`
}

func (q *Queries) SetProvisionAutoApproved(ctx context.Context, arg SetProvisionAutoApprovedParams) (QarProvision, error) {
	row := q.db.QueryRow(ctx, setProvisionAutoApproved, arg.ID, arg.AutoArticleID)
	var i QarProvision
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContentType,
		&i.RequestSubtype,
		&i.ExternalID,
		&i.ExternalSource,
		&i.Title,
		&i.ReleaseYear,
		&i.Manifest,
		&i.Status,
		&i.AutoApproved,
		&i.AutoArticleID,
		&i.ApprovedByUserID,
		&i.ApprovedAt,
		&i.DeclinedReason,
		&i.Priority,
		&i.AyesCount,
		&i.IntegrationID,
		&i.IntegrationStatus,
		&i.EstimatedCargoGb,
		&i.ActualCargoGb,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableAt,
		&i.TriggeredByAutomation,
		&i.ParentProvisionID,
	)
	return i, err
}

const updateArticle = `-- name: UpdateArticle :one
UPDATE qar.articles
SET
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    content_type = $4,
    condition_type = COALESCE($5, condition_type),
    condition_value = COALESCE($6, condition_value),
    action = COALESCE($7, action),
    automation_trigger = $8,
    enabled = COALESCE($9, enabled),
    priority = COALESCE($10, priority)
WHERE id = $1
RETURNING id, name, description, content_type, condition_type, condition_value, action, automation_trigger, enabled, priority, created_at, updated_at
`

type UpdateArticleParams struct {
	ID                uuid.UUID       `json:"id"`
	Name              string          `json:"name"`
	Description       *string         `json:"description"`
	ContentType       *string         `json:"contentType"`
	ConditionType     string          `json:"conditionType"`
	ConditionValue    json.RawMessage `json:"conditionValue"`
	Action            string          `json:"action"`
	AutomationTrigger *string         `json:"automationTrigger"`
	Enabled           bool            `json:"enabled"`
	Priority          int32           `json:"priority"`
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) (QarArticle, error) {
	row := q.db.QueryRow(ctx, updateArticle,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ContentType,
		arg.ConditionType,
		arg.ConditionValue,
		arg.Action,
		arg.AutomationTrigger,
		arg.Enabled,
		arg.Priority,
	)
	var i QarArticle
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ContentType,
		&i.ConditionType,
		&i.ConditionValue,
		&i.Action,
		&i.AutomationTrigger,
		&i.Enabled,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCargoHoldQuotas = `-- name: UpdateCargoHoldQuotas :one
UPDATE qar.cargo_hold
SET
    total_quota_gb = $1,
    expedition_quota_gb = $2,
    voyage_quota_gb = $3
WHERE id = 1
RETURNING id, total_quota_gb, total_used_gb, expedition_quota_gb, expedition_used_gb, voyage_quota_gb, voyage_used_gb, updated_at
`

type UpdateCargoHoldQuotasParams struct {
	TotalQuotaGb      pgtype.Numeric `json:"totalQuotaGb"`
	ExpeditionQuotaGb pgtype.Numeric `json:"expeditionQuotaGb"`
	VoyageQuotaGb     pgtype.Numeric `json:"voyageQuotaGb"`
}

func (q *Queries) UpdateCargoHoldQuotas(ctx context.Context, arg UpdateCargoHoldQuotasParams) (QarCargoHold, error) {
	row := q.db.QueryRow(ctx, updateCargoHoldQuotas, arg.TotalQuotaGb, arg.ExpeditionQuotaGb, arg.VoyageQuotaGb)
	var i QarCargoHold
	err := row.Scan(
		&i.ID,
		&i.TotalQuotaGb,
		&i.TotalUsedGb,
		&i.ExpeditionQuotaGb,
		&i.ExpeditionUsedGb,
		&i.VoyageQuotaGb,
		&i.VoyageUsedGb,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCargoHoldUsage = `-- name: UpdateCargoHoldUsage :one
UPDATE qar.cargo_hold
SET
    total_used_gb = $1,
    expedition_used_gb = $2,
    voyage_used_gb = $3
WHERE id = 1
RETURNING id, total_quota_gb, total_used_gb, expedition_quota_gb, expedition_used_gb, voyage_quota_gb, voyage_used_gb, updated_at
`

type UpdateCargoHoldUsageParams struct {
	TotalUsedGb      pgtype.Numeric `json:"totalUsedGb"`
	ExpeditionUsedGb pgtype.Numeric `json:"expeditionUsedGb"`
	VoyageUsedGb     pgtype.Numeric `json:"voyageUsedGb"`
}

func (q *Queries) UpdateCargoHoldUsage(ctx context.Context, arg UpdateCargoHoldUsageParams) (QarCargoHold, error) {
	row := q.db.QueryRow(ctx, updateCargoHoldUsage, arg.TotalUsedGb, arg.ExpeditionUsedGb, arg.VoyageUsedGb)
	var i QarCargoHold
	err := row.Scan(
		&i.ID,
		&i.TotalQuotaGb,
		&i.TotalUsedGb,
		&i.ExpeditionQuotaGb,
		&i.ExpeditionUsedGb,
		&i.VoyageQuotaGb,
		&i.VoyageUsedGb,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProvisionAvailable = `-- name: UpdateProvisionAvailable :one
UPDATE qar.provisions
SET
    status = 'available',
    actual_cargo_gb = $2,
    available_at = NOW()
WHERE id = $1
RETURNING id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id
`

type UpdateProvisionAvailableParams struct {
	ID            uuid.UUID      `json:"id"`
	ActualCargoGb pgtype.Numeric `json:"actualCargoGb"`
}

func (q *Queries) UpdateProvisionAvailable(ctx context.Context, arg UpdateProvisionAvailableParams) (QarProvision, error) {
	row := q.db.QueryRow(ctx, updateProvisionAvailable, arg.ID, arg.ActualCargoGb)
	var i QarProvision
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContentType,
		&i.RequestSubtype,
		&i.ExternalID,
		&i.ExternalSource,
		&i.Title,
		&i.ReleaseYear,
		&i.Manifest,
		&i.Status,
		&i.AutoApproved,
		&i.AutoArticleID,
		&i.ApprovedByUserID,
		&i.ApprovedAt,
		&i.DeclinedReason,
		&i.Priority,
		&i.AyesCount,
		&i.IntegrationID,
		&i.IntegrationStatus,
		&i.EstimatedCargoGb,
		&i.ActualCargoGb,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableAt,
		&i.TriggeredByAutomation,
		&i.ParentProvisionID,
	)
	return i, err
}

const updateProvisionIntegration = `-- name: UpdateProvisionIntegration :one
UPDATE qar.provisions
SET
    integration_id = $2,
    integration_status = $3
WHERE id = $1
RETURNING id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id
`

type UpdateProvisionIntegrationParams struct {
	ID                uuid.UUID `json:"id"`
	IntegrationID     *string   `json:"integrationId"`
	IntegrationStatus *string   `json:"integrationStatus"`
}

func (q *Queries) UpdateProvisionIntegration(ctx context.Context, arg UpdateProvisionIntegrationParams) (QarProvision, error) {
	row := q.db.QueryRow(ctx, updateProvisionIntegration, arg.ID, arg.IntegrationID, arg.IntegrationStatus)
	var i QarProvision
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContentType,
		&i.RequestSubtype,
		&i.ExternalID,
		&i.ExternalSource,
		&i.Title,
		&i.ReleaseYear,
		&i.Manifest,
		&i.Status,
		&i.AutoApproved,
		&i.AutoArticleID,
		&i.ApprovedByUserID,
		&i.ApprovedAt,
		&i.DeclinedReason,
		&i.Priority,
		&i.AyesCount,
		&i.IntegrationID,
		&i.IntegrationStatus,
		&i.EstimatedCargoGb,
		&i.ActualCargoGb,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableAt,
		&i.TriggeredByAutomation,
		&i.ParentProvisionID,
	)
	return i, err
}

const updateProvisionPriority = `-- name: UpdateProvisionPriority :one
UPDATE qar.provisions
SET priority = $2
WHERE id = $1
RETURNING id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id
`

type UpdateProvisionPriorityParams struct {
	ID       uuid.UUID `json:"id"`
	Priority int32     `json:"priority"`
}

func (q *Queries) UpdateProvisionPriority(ctx context.Context, arg UpdateProvisionPriorityParams) (QarProvision, error) {
	row := q.db.QueryRow(ctx, updateProvisionPriority, arg.ID, arg.Priority)
	var i QarProvision
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContentType,
		&i.RequestSubtype,
		&i.ExternalID,
		&i.ExternalSource,
		&i.Title,
		&i.ReleaseYear,
		&i.Manifest,
		&i.Status,
		&i.AutoApproved,
		&i.AutoArticleID,
		&i.ApprovedByUserID,
		&i.ApprovedAt,
		&i.DeclinedReason,
		&i.Priority,
		&i.AyesCount,
		&i.IntegrationID,
		&i.IntegrationStatus,
		&i.EstimatedCargoGb,
		&i.ActualCargoGb,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableAt,
		&i.TriggeredByAutomation,
		&i.ParentProvisionID,
	)
	return i, err
}

const updateProvisionStatus = `-- name: UpdateProvisionStatus :one
UPDATE qar.provisions
SET
    status = $2,
    approved_by_user_id = $3,
    approved_at = $4,
    declined_reason = $5
WHERE id = $1
RETURNING id, user_id, content_type, request_subtype, external_id, external_source, title, release_year, manifest, status, auto_approved, auto_article_id, approved_by_user_id, approved_at, declined_reason, priority, ayes_count, integration_id, integration_status, estimated_cargo_gb, actual_cargo_gb, created_at, updated_at, available_at, triggered_by_automation, parent_provision_id
`

type UpdateProvisionStatusParams struct {
	ID               uuid.UUID          `json:"id"`
	Status           string             `json:"status"`
	ApprovedByUserID pgtype.UUID        `json:"approvedByUserId"`
	ApprovedAt       pgtype.Timestamptz `json:"approvedAt"`
	DeclinedReason   *string            `json:"declinedReason"`
}

func (q *Queries) UpdateProvisionStatus(ctx context.Context, arg UpdateProvisionStatusParams) (QarProvision, error) {
	row := q.db.QueryRow(ctx, updateProvisionStatus,
		arg.ID,
		arg.Status,
		arg.ApprovedByUserID,
		arg.ApprovedAt,
		arg.DeclinedReason,
	)
	var i QarProvision
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContentType,
		&i.RequestSubtype,
		&i.ExternalID,
		&i.ExternalSource,
		&i.Title,
		&i.ReleaseYear,
		&i.Manifest,
		&i.Status,
		&i.AutoApproved,
		&i.AutoArticleID,
		&i.ApprovedByUserID,
		&i.ApprovedAt,
		&i.DeclinedReason,
		&i.Priority,
		&i.AyesCount,
		&i.IntegrationID,
		&i.IntegrationStatus,
		&i.EstimatedCargoGb,
		&i.ActualCargoGb,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableAt,
		&i.TriggeredByAutomation,
		&i.ParentProvisionID,
	)
	return i, err
}

const updateRationLimits = `-- name: UpdateRationLimits :one
UPDATE qar.rations
SET
    daily_limit = COALESCE($2, daily_limit),
    weekly_limit = COALESCE($3, weekly_limit),
    monthly_limit = COALESCE($4, monthly_limit),
    cargo_quota_gb = COALESCE($5, cargo_quota_gb)
WHERE user_id = $1
RETURNING user_id, daily_limit, weekly_limit, monthly_limit, daily_used, weekly_used, monthly_used, cargo_quota_gb, cargo_used_gb, last_reset_daily, last_reset_weekly, last_reset_monthly, created_at, updated_at
`

type UpdateRationLimitsParams struct {
	UserID       uuid.UUID      `json:"userId"`
	DailyLimit   int32          `json:"dailyLimit"`
	WeeklyLimit  int32          `json:"weeklyLimit"`
	MonthlyLimit int32          `json:"monthlyLimit"`
	CargoQuotaGb pgtype.Numeric `json:"cargoQuotaGb"`
}

func (q *Queries) UpdateRationLimits(ctx context.Context, arg UpdateRationLimitsParams) (QarRation, error) {
	row := q.db.QueryRow(ctx, updateRationLimits,
		arg.UserID,
		arg.DailyLimit,
		arg.WeeklyLimit,
		arg.MonthlyLimit,
		arg.CargoQuotaGb,
	)
	var i QarRation
	err := row.Scan(
		&i.UserID,
		&i.DailyLimit,
		&i.WeeklyLimit,
		&i.MonthlyLimit,
		&i.DailyUsed,
		&i.WeeklyUsed,
		&i.MonthlyUsed,
		&i.CargoQuotaGb,
		&i.CargoUsedGb,
		&i.LastResetDaily,
		&i.LastResetWeekly,
		&i.LastResetMonthly,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertRation = `-- name: UpsertRation :one
INSERT INTO qar.rations (user_id)
VALUES ($1)
ON CONFLICT (user_id) DO UPDATE SET user_id = EXCLUDED.user_id
RETURNING user_id, daily_limit, weekly_limit, monthly_limit, daily_used, weekly_used, monthly_used, cargo_quota_gb, cargo_used_gb, last_reset_daily, last_reset_weekly, last_reset_monthly, created_at, updated_at
`

func (q *Queries) UpsertRation(ctx context.Context, userID uuid.UUID) (QarRation, error) {
	row := q.db.QueryRow(ctx, upsertRation, userID)
	var i QarRation
	err := row.Scan(
		&i.UserID,
		&i.DailyLimit,
		&i.WeeklyLimit,
		&i.MonthlyLimit,
		&i.DailyUsed,
		&i.WeeklyUsed,
		&i.MonthlyUsed,
		&i.CargoQuotaGb,
		&i.CargoUsedGb,
		&i.LastResetDaily,
		&i.LastResetWeekly,
		&i.LastResetMonthly,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
