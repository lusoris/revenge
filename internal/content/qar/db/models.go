// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package adultdb

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type ActivitySeverity string

const (
	ActivitySeverityInfo     ActivitySeverity = "info"
	ActivitySeverityWarning  ActivitySeverity = "warning"
	ActivitySeverityError    ActivitySeverity = "error"
	ActivitySeverityCritical ActivitySeverity = "critical"
)

func (e *ActivitySeverity) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ActivitySeverity(s)
	case string:
		*e = ActivitySeverity(s)
	default:
		return fmt.Errorf("unsupported scan type for ActivitySeverity: %T", src)
	}
	return nil
}

type NullActivitySeverity struct {
	ActivitySeverity ActivitySeverity `json:"activitySeverity"`
	Valid            bool             `json:"valid"` // Valid is true if ActivitySeverity is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullActivitySeverity) Scan(value interface{}) error {
	if value == nil {
		ns.ActivitySeverity, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ActivitySeverity.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullActivitySeverity) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ActivitySeverity), nil
}

type ActivityType string

const (
	ActivityTypeUserLogin       ActivityType = "user_login"
	ActivityTypeUserLogout      ActivityType = "user_logout"
	ActivityTypeUserCreated     ActivityType = "user_created"
	ActivityTypeUserUpdated     ActivityType = "user_updated"
	ActivityTypeUserDeleted     ActivityType = "user_deleted"
	ActivityTypePasswordChanged ActivityType = "password_changed"
	ActivityTypeSessionCreated  ActivityType = "session_created"
	ActivityTypeSessionExpired  ActivityType = "session_expired"
	ActivityTypeLibraryCreated  ActivityType = "library_created"
	ActivityTypeLibraryUpdated  ActivityType = "library_updated"
	ActivityTypeLibraryDeleted  ActivityType = "library_deleted"
	ActivityTypeLibraryScanned  ActivityType = "library_scanned"
	ActivityTypeContentPlayed   ActivityType = "content_played"
	ActivityTypeContentRated    ActivityType = "content_rated"
	ActivityTypeSettingsChanged ActivityType = "settings_changed"
	ActivityTypeApiError        ActivityType = "api_error"
	ActivityTypeSecurityEvent   ActivityType = "security_event"
)

func (e *ActivityType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ActivityType(s)
	case string:
		*e = ActivityType(s)
	default:
		return fmt.Errorf("unsupported scan type for ActivityType: %T", src)
	}
	return nil
}

type NullActivityType struct {
	ActivityType ActivityType `json:"activityType"`
	Valid        bool         `json:"valid"` // Valid is true if ActivityType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullActivityType) Scan(value interface{}) error {
	if value == nil {
		ns.ActivityType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ActivityType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullActivityType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ActivityType), nil
}

type CollectionType string

const (
	CollectionTypeVideo     CollectionType = "video"
	CollectionTypeAudio     CollectionType = "audio"
	CollectionTypeMixed     CollectionType = "mixed"
	CollectionTypeFranchise CollectionType = "franchise"
	CollectionTypeBoxSet    CollectionType = "box_set"
	CollectionTypeSmart     CollectionType = "smart"
)

func (e *CollectionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CollectionType(s)
	case string:
		*e = CollectionType(s)
	default:
		return fmt.Errorf("unsupported scan type for CollectionType: %T", src)
	}
	return nil
}

type NullCollectionType struct {
	CollectionType CollectionType `json:"collectionType"`
	Valid          bool           `json:"valid"` // Valid is true if CollectionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCollectionType) Scan(value interface{}) error {
	if value == nil {
		ns.CollectionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CollectionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCollectionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CollectionType), nil
}

type PermissionCategory string

const (
	PermissionCategorySystem    PermissionCategory = "system"
	PermissionCategoryUsers     PermissionCategory = "users"
	PermissionCategoryLibraries PermissionCategory = "libraries"
	PermissionCategoryContent   PermissionCategory = "content"
	PermissionCategoryPlayback  PermissionCategory = "playback"
	PermissionCategorySocial    PermissionCategory = "social"
	PermissionCategoryAdult     PermissionCategory = "adult"
)

func (e *PermissionCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PermissionCategory(s)
	case string:
		*e = PermissionCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for PermissionCategory: %T", src)
	}
	return nil
}

type NullPermissionCategory struct {
	PermissionCategory PermissionCategory `json:"permissionCategory"`
	Valid              bool               `json:"valid"` // Valid is true if PermissionCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPermissionCategory) Scan(value interface{}) error {
	if value == nil {
		ns.PermissionCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PermissionCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPermissionCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PermissionCategory), nil
}

type PlaylistType string

const (
	PlaylistTypeVideo PlaylistType = "video"
	PlaylistTypeAudio PlaylistType = "audio"
	PlaylistTypeMixed PlaylistType = "mixed"
)

func (e *PlaylistType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PlaylistType(s)
	case string:
		*e = PlaylistType(s)
	default:
		return fmt.Errorf("unsupported scan type for PlaylistType: %T", src)
	}
	return nil
}

type NullPlaylistType struct {
	PlaylistType PlaylistType `json:"playlistType"`
	Valid        bool         `json:"valid"` // Valid is true if PlaylistType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPlaylistType) Scan(value interface{}) error {
	if value == nil {
		ns.PlaylistType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PlaylistType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPlaylistType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PlaylistType), nil
}

type PlaylistVisibility string

const (
	PlaylistVisibilityPrivate PlaylistVisibility = "private"
	PlaylistVisibilityShared  PlaylistVisibility = "shared"
	PlaylistVisibilityPublic  PlaylistVisibility = "public"
)

func (e *PlaylistVisibility) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PlaylistVisibility(s)
	case string:
		*e = PlaylistVisibility(s)
	default:
		return fmt.Errorf("unsupported scan type for PlaylistVisibility: %T", src)
	}
	return nil
}

type NullPlaylistVisibility struct {
	PlaylistVisibility PlaylistVisibility `json:"playlistVisibility"`
	Valid              bool               `json:"valid"` // Valid is true if PlaylistVisibility is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPlaylistVisibility) Scan(value interface{}) error {
	if value == nil {
		ns.PlaylistVisibility, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PlaylistVisibility.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPlaylistVisibility) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PlaylistVisibility), nil
}

type RatingSystem string

const (
	RatingSystemMPAA       RatingSystem = "MPAA"
	RatingSystemFSK        RatingSystem = "FSK"
	RatingSystemPEGI       RatingSystem = "PEGI"
	RatingSystemBBFC       RatingSystem = "BBFC"
	RatingSystemACB        RatingSystem = "ACB"
	RatingSystemKIJKWIJZER RatingSystem = "KIJKWIJZER"
)

func (e *RatingSystem) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RatingSystem(s)
	case string:
		*e = RatingSystem(s)
	default:
		return fmt.Errorf("unsupported scan type for RatingSystem: %T", src)
	}
	return nil
}

type NullRatingSystem struct {
	RatingSystem RatingSystem `json:"ratingSystem"`
	Valid        bool         `json:"valid"` // Valid is true if RatingSystem is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRatingSystem) Scan(value interface{}) error {
	if value == nil {
		ns.RatingSystem, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RatingSystem.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRatingSystem) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RatingSystem), nil
}

type UserRole string

const (
	UserRoleAdmin     UserRole = "admin"
	UserRoleModerator UserRole = "moderator"
	UserRoleUser      UserRole = "user"
	UserRoleGuest     UserRole = "guest"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"userRole"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type VideoCreditRole string

const (
	VideoCreditRoleActor              VideoCreditRole = "actor"
	VideoCreditRoleDirector           VideoCreditRole = "director"
	VideoCreditRoleWriter             VideoCreditRole = "writer"
	VideoCreditRoleCreator            VideoCreditRole = "creator"
	VideoCreditRoleShowrunner         VideoCreditRole = "showrunner"
	VideoCreditRoleProducer           VideoCreditRole = "producer"
	VideoCreditRoleExecutiveProducer  VideoCreditRole = "executive_producer"
	VideoCreditRoleComposer           VideoCreditRole = "composer"
	VideoCreditRoleCinematographer    VideoCreditRole = "cinematographer"
	VideoCreditRoleEditor             VideoCreditRole = "editor"
	VideoCreditRoleProductionDesigner VideoCreditRole = "production_designer"
	VideoCreditRoleCostumeDesigner    VideoCreditRole = "costume_designer"
	VideoCreditRoleMakeupArtist       VideoCreditRole = "makeup_artist"
	VideoCreditRoleVisualEffects      VideoCreditRole = "visual_effects"
	VideoCreditRoleStuntCoordinator   VideoCreditRole = "stunt_coordinator"
	VideoCreditRoleSoundDesigner      VideoCreditRole = "sound_designer"
	VideoCreditRoleGuestStar          VideoCreditRole = "guest_star"
)

func (e *VideoCreditRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = VideoCreditRole(s)
	case string:
		*e = VideoCreditRole(s)
	default:
		return fmt.Errorf("unsupported scan type for VideoCreditRole: %T", src)
	}
	return nil
}

type NullVideoCreditRole struct {
	VideoCreditRole VideoCreditRole `json:"videoCreditRole"`
	Valid           bool            `json:"valid"` // Valid is true if VideoCreditRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVideoCreditRole) Scan(value interface{}) error {
	if value == nil {
		ns.VideoCreditRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.VideoCreditRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVideoCreditRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.VideoCreditRole), nil
}

// Partitioned audit log for metadata changes, written async via River
type ActivityLog struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// Action type: metadata.edit, metadata.lock, metadata.unlock, metadata.refresh, image.upload, image.select, image.delete, content.delete, user.login, user.logout
	Action string `json:"action"`
	// Module: movie, tvshow, qar, user, library, system
	Module     string    `json:"module"`
	EntityID   uuid.UUID `json:"entityId"`
	EntityType string    `json:"entityType"`
	// JSONB of field changes: {"field": {"old": value, "new": value}}
	Changes   json.RawMessage `json:"changes"`
	IpAddress netip.Addr      `json:"ipAddress"`
	UserAgent *string         `json:"userAgent"`
	CreatedAt time.Time       `json:"createdAt"`
}

type ActivityLog202601 struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// Action type: metadata.edit, metadata.lock, metadata.unlock, metadata.refresh, image.upload, image.select, image.delete, content.delete, user.login, user.logout
	Action string `json:"action"`
	// Module: movie, tvshow, qar, user, library, system
	Module     string    `json:"module"`
	EntityID   uuid.UUID `json:"entityId"`
	EntityType string    `json:"entityType"`
	// JSONB of field changes: {"field": {"old": value, "new": value}}
	Changes   json.RawMessage `json:"changes"`
	IpAddress netip.Addr      `json:"ipAddress"`
	UserAgent *string         `json:"userAgent"`
	CreatedAt time.Time       `json:"createdAt"`
}

type ActivityLog202602 struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// Action type: metadata.edit, metadata.lock, metadata.unlock, metadata.refresh, image.upload, image.select, image.delete, content.delete, user.login, user.logout
	Action string `json:"action"`
	// Module: movie, tvshow, qar, user, library, system
	Module     string    `json:"module"`
	EntityID   uuid.UUID `json:"entityId"`
	EntityType string    `json:"entityType"`
	// JSONB of field changes: {"field": {"old": value, "new": value}}
	Changes   json.RawMessage `json:"changes"`
	IpAddress netip.Addr      `json:"ipAddress"`
	UserAgent *string         `json:"userAgent"`
	CreatedAt time.Time       `json:"createdAt"`
}

type ActivityLog202603 struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// Action type: metadata.edit, metadata.lock, metadata.unlock, metadata.refresh, image.upload, image.select, image.delete, content.delete, user.login, user.logout
	Action string `json:"action"`
	// Module: movie, tvshow, qar, user, library, system
	Module     string    `json:"module"`
	EntityID   uuid.UUID `json:"entityId"`
	EntityType string    `json:"entityType"`
	// JSONB of field changes: {"field": {"old": value, "new": value}}
	Changes   json.RawMessage `json:"changes"`
	IpAddress netip.Addr      `json:"ipAddress"`
	UserAgent *string         `json:"userAgent"`
	CreatedAt time.Time       `json:"createdAt"`
}

type ActivityLog202604 struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// Action type: metadata.edit, metadata.lock, metadata.unlock, metadata.refresh, image.upload, image.select, image.delete, content.delete, user.login, user.logout
	Action string `json:"action"`
	// Module: movie, tvshow, qar, user, library, system
	Module     string    `json:"module"`
	EntityID   uuid.UUID `json:"entityId"`
	EntityType string    `json:"entityType"`
	// JSONB of field changes: {"field": {"old": value, "new": value}}
	Changes   json.RawMessage `json:"changes"`
	IpAddress netip.Addr      `json:"ipAddress"`
	UserAgent *string         `json:"userAgent"`
	CreatedAt time.Time       `json:"createdAt"`
}

type ActivityLog202605 struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// Action type: metadata.edit, metadata.lock, metadata.unlock, metadata.refresh, image.upload, image.select, image.delete, content.delete, user.login, user.logout
	Action string `json:"action"`
	// Module: movie, tvshow, qar, user, library, system
	Module     string    `json:"module"`
	EntityID   uuid.UUID `json:"entityId"`
	EntityType string    `json:"entityType"`
	// JSONB of field changes: {"field": {"old": value, "new": value}}
	Changes   json.RawMessage `json:"changes"`
	IpAddress netip.Addr      `json:"ipAddress"`
	UserAgent *string         `json:"userAgent"`
	CreatedAt time.Time       `json:"createdAt"`
}

type ActivityLog202606 struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// Action type: metadata.edit, metadata.lock, metadata.unlock, metadata.refresh, image.upload, image.select, image.delete, content.delete, user.login, user.logout
	Action string `json:"action"`
	// Module: movie, tvshow, qar, user, library, system
	Module     string    `json:"module"`
	EntityID   uuid.UUID `json:"entityId"`
	EntityType string    `json:"entityType"`
	// JSONB of field changes: {"field": {"old": value, "new": value}}
	Changes   json.RawMessage `json:"changes"`
	IpAddress netip.Addr      `json:"ipAddress"`
	UserAgent *string         `json:"userAgent"`
	CreatedAt time.Time       `json:"createdAt"`
}

type ActivityLogDefault struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// Action type: metadata.edit, metadata.lock, metadata.unlock, metadata.refresh, image.upload, image.select, image.delete, content.delete, user.login, user.logout
	Action string `json:"action"`
	// Module: movie, tvshow, qar, user, library, system
	Module     string    `json:"module"`
	EntityID   uuid.UUID `json:"entityId"`
	EntityType string    `json:"entityType"`
	// JSONB of field changes: {"field": {"old": value, "new": value}}
	Changes   json.RawMessage `json:"changes"`
	IpAddress netip.Addr      `json:"ipAddress"`
	UserAgent *string         `json:"userAgent"`
	CreatedAt time.Time       `json:"createdAt"`
}

type ApiKey struct {
	ID         uuid.UUID          `json:"id"`
	UserID     uuid.UUID          `json:"userId"`
	Name       string             `json:"name"`
	KeyHash    string             `json:"keyHash"`
	KeyPrefix  string             `json:"keyPrefix"`
	Scopes     []string           `json:"scopes"`
	LastUsedAt pgtype.Timestamptz `json:"lastUsedAt"`
	UseCount   int64              `json:"useCount"`
	ExpiresAt  pgtype.Timestamptz `json:"expiresAt"`
	CreatedAt  time.Time          `json:"createdAt"`
}

type Collection struct {
	ID               uuid.UUID      `json:"id"`
	Name             string         `json:"name"`
	Slug             *string        `json:"slug"`
	Description      *string        `json:"description"`
	CollectionType   CollectionType `json:"collectionType"`
	PosterUrl        *string        `json:"posterUrl"`
	BackdropUrl      *string        `json:"backdropUrl"`
	LogoUrl          *string        `json:"logoUrl"`
	ThemeColor       *string        `json:"themeColor"`
	ItemCount        int32          `json:"itemCount"`
	TotalDurationMs  int64          `json:"totalDurationMs"`
	TmdbCollectionID *int32         `json:"tmdbCollectionId"`
	TvdbID           *int32         `json:"tvdbId"`
	ImdbID           *string        `json:"imdbId"`
	SmartRules       []byte         `json:"smartRules"`
	IsVisible        bool           `json:"isVisible"`
	SortOrder        int32          `json:"sortOrder"`
	CreatedBy        pgtype.UUID    `json:"createdBy"`
	CreatedAt        time.Time      `json:"createdAt"`
	UpdatedAt        time.Time      `json:"updatedAt"`
}

type CollectionItem struct {
	ID                 uuid.UUID `json:"id"`
	CollectionID       uuid.UUID `json:"collectionId"`
	ContentType        string    `json:"contentType"`
	ContentID          uuid.UUID `json:"contentId"`
	Position           int32     `json:"position"`
	ReleaseOrder       *int32    `json:"releaseOrder"`
	ChronologicalOrder *int32    `json:"chronologicalOrder"`
	CustomTitle        *string   `json:"customTitle"`
	Notes              *string   `json:"notes"`
	AddedAt            time.Time `json:"addedAt"`
}

type CollectionSubscription struct {
	CollectionID   uuid.UUID `json:"collectionId"`
	UserID         uuid.UUID `json:"userId"`
	NotifyNewItems bool      `json:"notifyNewItems"`
	SubscribedAt   time.Time `json:"subscribedAt"`
}

type CollectionTag struct {
	CollectionID uuid.UUID `json:"collectionId"`
	Tag          string    `json:"tag"`
}

type ContentRating struct {
	ID          uuid.UUID    `json:"id"`
	System      RatingSystem `json:"system"`
	Code        string       `json:"code"`
	DisplayName string       `json:"displayName"`
	Description *string      `json:"description"`
	MinAge      *int32       `json:"minAge"`
	IconUrl     *string      `json:"iconUrl"`
	SortOrder   int32        `json:"sortOrder"`
	CreatedAt   time.Time    `json:"createdAt"`
	UpdatedAt   time.Time    `json:"updatedAt"`
}

type Genre struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	Slug      string    `json:"slug"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

type OidcProvider struct {
	ID              uuid.UUID       `json:"id"`
	Name            string          `json:"name"`
	Slug            string          `json:"slug"`
	Enabled         bool            `json:"enabled"`
	IssuerUrl       string          `json:"issuerUrl"`
	ClientID        string          `json:"clientId"`
	ClientSecretEnc []byte          `json:"clientSecretEnc"`
	Scopes          []string        `json:"scopes"`
	ClaimMapping    json.RawMessage `json:"claimMapping"`
	RoleMapping     json.RawMessage `json:"roleMapping"`
	AutoProvision   bool            `json:"autoProvision"`
	DefaultRole     string          `json:"defaultRole"`
	CreatedAt       time.Time       `json:"createdAt"`
	UpdatedAt       time.Time       `json:"updatedAt"`
}

type OidcUserLink struct {
	ID          uuid.UUID          `json:"id"`
	UserID      uuid.UUID          `json:"userId"`
	ProviderID  uuid.UUID          `json:"providerId"`
	Subject     string             `json:"subject"`
	Email       *string            `json:"email"`
	Name        *string            `json:"name"`
	Groups      []string           `json:"groups"`
	LinkedAt    time.Time          `json:"linkedAt"`
	LastLoginAt pgtype.Timestamptz `json:"lastLoginAt"`
}

type Permission struct {
	ID          int32     `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Category    string    `json:"category"`
	CreatedAt   time.Time `json:"createdAt"`
}

type PermissionDefinition struct {
	ID          int32     `json:"id"`
	Name        string    `json:"name"`
	DisplayName string    `json:"displayName"`
	Description string    `json:"description"`
	Category    string    `json:"category"`
	IsDangerous bool      `json:"isDangerous"`
	CreatedAt   time.Time `json:"createdAt"`
}

type Playlist struct {
	ID              uuid.UUID          `json:"id"`
	UserID          uuid.UUID          `json:"userId"`
	Name            string             `json:"name"`
	Description     *string            `json:"description"`
	PlaylistType    PlaylistType       `json:"playlistType"`
	Visibility      PlaylistVisibility `json:"visibility"`
	ThumbnailUrl    *string            `json:"thumbnailUrl"`
	SortOrder       int32              `json:"sortOrder"`
	ShuffleEnabled  bool               `json:"shuffleEnabled"`
	RepeatMode      string             `json:"repeatMode"`
	ItemCount       int32              `json:"itemCount"`
	TotalDurationMs int64              `json:"totalDurationMs"`
	CreatedAt       time.Time          `json:"createdAt"`
	UpdatedAt       time.Time          `json:"updatedAt"`
	LastPlayedAt    pgtype.Timestamptz `json:"lastPlayedAt"`
}

type PlaylistCollaborator struct {
	PlaylistID uuid.UUID `json:"playlistId"`
	UserID     uuid.UUID `json:"userId"`
	CanEdit    bool      `json:"canEdit"`
	AddedAt    time.Time `json:"addedAt"`
}

type PlaylistItem struct {
	ID           uuid.UUID          `json:"id"`
	PlaylistID   uuid.UUID          `json:"playlistId"`
	ContentType  string             `json:"contentType"`
	ContentID    uuid.UUID          `json:"contentId"`
	Position     int32              `json:"position"`
	StartTimeMs  *int64             `json:"startTimeMs"`
	EndTimeMs    *int64             `json:"endTimeMs"`
	Title        *string            `json:"title"`
	DurationMs   *int64             `json:"durationMs"`
	ThumbnailUrl *string            `json:"thumbnailUrl"`
	AddedAt      time.Time          `json:"addedAt"`
	LastPlayedAt pgtype.Timestamptz `json:"lastPlayedAt"`
}

type Profile struct {
	ID                        uuid.UUID `json:"id"`
	UserID                    uuid.UUID `json:"userId"`
	Name                      string    `json:"name"`
	AvatarUrl                 *string   `json:"avatarUrl"`
	IsDefault                 bool      `json:"isDefault"`
	IsKids                    bool      `json:"isKids"`
	MaxRatingLevel            int32     `json:"maxRatingLevel"`
	AdultEnabled              bool      `json:"adultEnabled"`
	PreferredLanguage         *string   `json:"preferredLanguage"`
	PreferredAudioLanguage    *string   `json:"preferredAudioLanguage"`
	PreferredSubtitleLanguage *string   `json:"preferredSubtitleLanguage"`
	AutoplayNext              *bool     `json:"autoplayNext"`
	AutoplayPreviews          *bool     `json:"autoplayPreviews"`
	CreatedAt                 time.Time `json:"createdAt"`
	UpdatedAt                 time.Time `json:"updatedAt"`
	// Whether to auto-play next episode/item
	AutoPlayEnabled bool `json:"autoPlayEnabled"`
	// Countdown seconds before auto-play (0-60)
	AutoPlayDelaySeconds int32 `json:"autoPlayDelaySeconds"`
	// Days to keep items in continue watching (1-365)
	ContinueWatchingDays int32 `json:"continueWatchingDays"`
	// Percentage of media watched to mark as complete (50-100)
	MarkWatchedPercent int32 `json:"markWatchedPercent"`
	// Hashed PIN for adult content access (optional)
	AdultPinHash *string `json:"adultPinHash"`
}

type QarBounty struct {
	UserID       uuid.UUID `json:"userId"`
	ExpeditionID uuid.UUID `json:"expeditionId"`
	Reward       *int16    `json:"reward"`
	CreatedAt    time.Time `json:"createdAt"`
	UpdatedAt    time.Time `json:"updatedAt"`
}

type QarCrew struct {
	ID             uuid.UUID   `json:"id"`
	Name           string      `json:"name"`
	Disambiguation *string     `json:"disambiguation"`
	Gender         *string     `json:"gender"`
	Christening    pgtype.Date `json:"christening"`
	DeathDate      pgtype.Date `json:"deathDate"`
	BirthCity      *string     `json:"birthCity"`
	Origin         *string     `json:"origin"`
	Nationality    *string     `json:"nationality"`
	Rigging        *string     `json:"rigging"`
	Compass        *string     `json:"compass"`
	HeightCm       *int32      `json:"heightCm"`
	WeightKg       *int32      `json:"weightKg"`
	Measurements   *string     `json:"measurements"`
	CupSize        *string     `json:"cupSize"`
	BreastType     *string     `json:"breastType"`
	Markings       *string     `json:"markings"`
	Anchors        *string     `json:"anchors"`
	MaidenVoyage   *int32      `json:"maidenVoyage"`
	LastPort       *int32      `json:"lastPort"`
	Bio            *string     `json:"bio"`
	StashID        *string     `json:"stashId"`
	Charter        *string     `json:"charter"`
	Registry       *string     `json:"registry"`
	Manifest       *string     `json:"manifest"`
	Twitter        *string     `json:"twitter"`
	Instagram      *string     `json:"instagram"`
	ImagePath      *string     `json:"imagePath"`
	CreatedAt      time.Time   `json:"createdAt"`
	UpdatedAt      time.Time   `json:"updatedAt"`
}

type QarCrewName struct {
	CrewID uuid.UUID `json:"crewId"`
	Name   string    `json:"name"`
}

type QarCrewPortrait struct {
	ID           uuid.UUID   `json:"id"`
	CrewID       pgtype.UUID `json:"crewId"`
	Path         string      `json:"path"`
	Type         *string     `json:"type"`
	Source       *string     `json:"source"`
	PrimaryImage *bool       `json:"primaryImage"`
	CreatedAt    time.Time   `json:"createdAt"`
}

type QarCrewRoster struct {
	UserID     uuid.UUID `json:"userId"`
	CrewID     uuid.UUID `json:"crewId"`
	EnlistedAt time.Time `json:"enlistedAt"`
}

type QarExpedition struct {
	ID            uuid.UUID   `json:"id"`
	WhisparrID    *int32      `json:"whisparrId"`
	Charter       *string     `json:"charter"`
	Registry      *string     `json:"registry"`
	Title         string      `json:"title"`
	SortTitle     *string     `json:"sortTitle"`
	OriginalTitle *string     `json:"originalTitle"`
	Overview      *string     `json:"overview"`
	LaunchDate    pgtype.Date `json:"launchDate"`
	RuntimeTicks  *int64      `json:"runtimeTicks"`
	PortID        pgtype.UUID `json:"portId"`
	Director      *string     `json:"director"`
	Series        *string     `json:"series"`
	Path          string      `json:"path"`
	SizeBytes     *int64      `json:"sizeBytes"`
	Container     *string     `json:"container"`
	VideoCodec    *string     `json:"videoCodec"`
	AudioCodec    *string     `json:"audioCodec"`
	Resolution    *string     `json:"resolution"`
	Coordinates   *string     `json:"coordinates"`
	Oshash        *string     `json:"oshash"`
	HasFile       *bool       `json:"hasFile"`
	IsHdr         *bool       `json:"isHdr"`
	Is3d          *bool       `json:"is3d"`
	CreatedAt     time.Time   `json:"createdAt"`
	UpdatedAt     time.Time   `json:"updatedAt"`
	FleetID       uuid.UUID   `json:"fleetId"`
}

type QarExpeditionChart struct {
	ID           uuid.UUID   `json:"id"`
	ExpeditionID pgtype.UUID `json:"expeditionId"`
	Type         string      `json:"type"`
	Path         string      `json:"path"`
	Source       *string     `json:"source"`
	PrimaryImage *bool       `json:"primaryImage"`
	CreatedAt    time.Time   `json:"createdAt"`
}

type QarExpeditionCrew struct {
	ExpeditionID  uuid.UUID `json:"expeditionId"`
	CrewID        uuid.UUID `json:"crewId"`
	CharacterName *string   `json:"characterName"`
}

type QarExpeditionFlag struct {
	ExpeditionID uuid.UUID `json:"expeditionId"`
	FlagID       uuid.UUID `json:"flagId"`
}

type QarFlag struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	ParentID    pgtype.UUID `json:"parentId"`
	StashdbID   *string     `json:"stashdbId"`
	CreatedAt   time.Time   `json:"createdAt"`
	Waters      *string     `json:"waters"`
}

type QarFleet struct {
	ID                uuid.UUID   `json:"id"`
	Name              string      `json:"name"`
	FleetType         string      `json:"fleetType"`
	Paths             []string    `json:"paths"`
	StashdbEndpoint   *string     `json:"stashdbEndpoint"`
	TpdbEnabled       bool        `json:"tpdbEnabled"`
	WhisparrSync      bool        `json:"whisparrSync"`
	AutoTagCrew       bool        `json:"autoTagCrew"`
	FingerprintOnScan bool        `json:"fingerprintOnScan"`
	OwnerUserID       pgtype.UUID `json:"ownerUserId"`
	CreatedAt         time.Time   `json:"createdAt"`
	UpdatedAt         time.Time   `json:"updatedAt"`
}

type QarMarkedChart struct {
	UserID       uuid.UUID `json:"userId"`
	ExpeditionID uuid.UUID `json:"expeditionId"`
	CreatedAt    time.Time `json:"createdAt"`
}

type QarPort struct {
	ID        uuid.UUID   `json:"id"`
	Name      string      `json:"name"`
	ParentID  pgtype.UUID `json:"parentId"`
	StashdbID *string     `json:"stashdbId"`
	TpdbID    *string     `json:"tpdbId"`
	Url       *string     `json:"url"`
	LogoPath  *string     `json:"logoPath"`
	CreatedAt time.Time   `json:"createdAt"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

type QarTreasure struct {
	ID           uuid.UUID   `json:"id"`
	ExpeditionID pgtype.UUID `json:"expeditionId"`
	Title        string      `json:"title"`
	Path         *string     `json:"path"`
	CreatedAt    time.Time   `json:"createdAt"`
}

type QarTreasureMap struct {
	ID         uuid.UUID   `json:"id"`
	TreasureID pgtype.UUID `json:"treasureId"`
	Path       string      `json:"path"`
	Bearing    int32       `json:"bearing"`
	CreatedAt  time.Time   `json:"createdAt"`
}

type QarVoyage struct {
	ID          uuid.UUID   `json:"id"`
	Title       string      `json:"title"`
	SortTitle   *string     `json:"sortTitle"`
	Overview    *string     `json:"overview"`
	LaunchDate  pgtype.Date `json:"launchDate"`
	Distance    *int32      `json:"distance"`
	PortID      pgtype.UUID `json:"portId"`
	WhisparrID  *int32      `json:"whisparrId"`
	StashID     *string     `json:"stashId"`
	Charter     *string     `json:"charter"`
	Registry    *string     `json:"registry"`
	Path        string      `json:"path"`
	SizeBytes   *int64      `json:"sizeBytes"`
	VideoCodec  *string     `json:"videoCodec"`
	AudioCodec  *string     `json:"audioCodec"`
	Resolution  *string     `json:"resolution"`
	Oshash      *string     `json:"oshash"`
	Coordinates *string     `json:"coordinates"`
	Md5         *string     `json:"md5"`
	CoverPath   *string     `json:"coverPath"`
	CreatedAt   time.Time   `json:"createdAt"`
	UpdatedAt   time.Time   `json:"updatedAt"`
	FleetID     uuid.UUID   `json:"fleetId"`
}

type QarVoyageCrew struct {
	VoyageID uuid.UUID `json:"voyageId"`
	CrewID   uuid.UUID `json:"crewId"`
	Role     *string   `json:"role"`
}

type QarVoyageFlag struct {
	VoyageID uuid.UUID `json:"voyageId"`
	FlagID   uuid.UUID `json:"flagId"`
}

type QarVoyageLog struct {
	ID           uuid.UUID   `json:"id"`
	UserID       uuid.UUID   `json:"userId"`
	ExpeditionID pgtype.UUID `json:"expeditionId"`
	WatchedAt    time.Time   `json:"watchedAt"`
	BearingTicks *int64      `json:"bearingTicks"`
	Completed    *bool       `json:"completed"`
}

type QarVoyageRecord struct {
	UserID      uuid.UUID          `json:"userId"`
	VoyageID    uuid.UUID          `json:"voyageId"`
	BearingMs   *int64             `json:"bearingMs"`
	Crossings   *int32             `json:"crossings"`
	LastWatched pgtype.Timestamptz `json:"lastWatched"`
	Bounty      *int16             `json:"bounty"`
	OCounter    *int32             `json:"oCounter"`
	Marked      *bool              `json:"marked"`
	IsOrganized *bool              `json:"isOrganized"`
}

type QarVoyageWaypoint struct {
	ID            uuid.UUID   `json:"id"`
	VoyageID      pgtype.UUID `json:"voyageId"`
	Title         *string     `json:"title"`
	StartSeconds  float64     `json:"startSeconds"`
	EndSeconds    *float64    `json:"endSeconds"`
	FlagID        pgtype.UUID `json:"flagId"`
	StashMarkerID *string     `json:"stashMarkerId"`
	CreatedAt     time.Time   `json:"createdAt"`
}

// Polymorphic per-resource access grants for sharing libraries, playlists, etc.
type ResourceGrant struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// Type of resource: movie_library, tv_library, music_library, adult_library, playlist, collection
	ResourceType string    `json:"resourceType"`
	ResourceID   uuid.UUID `json:"resourceId"`
	// Access level: view, edit, manage, owner
	GrantType string             `json:"grantType"`
	GrantedBy pgtype.UUID        `json:"grantedBy"`
	GrantedAt time.Time          `json:"grantedAt"`
	ExpiresAt pgtype.Timestamptz `json:"expiresAt"`
}

type Role struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	DisplayName string      `json:"displayName"`
	Description *string     `json:"description"`
	Color       *string     `json:"color"`
	Icon        *string     `json:"icon"`
	IsSystem    bool        `json:"isSystem"`
	IsDefault   bool        `json:"isDefault"`
	Priority    int32       `json:"priority"`
	CreatedAt   time.Time   `json:"createdAt"`
	UpdatedAt   time.Time   `json:"updatedAt"`
	CreatedBy   pgtype.UUID `json:"createdBy"`
}

type RolePermission struct {
	Role         string `json:"role"`
	PermissionID int32  `json:"permissionId"`
}

type ServerSetting struct {
	Key         string          `json:"key"`
	Value       json.RawMessage `json:"value"`
	Category    string          `json:"category"`
	Description *string         `json:"description"`
	IsPublic    bool            `json:"isPublic"`
	CreatedAt   time.Time       `json:"createdAt"`
	UpdatedAt   time.Time       `json:"updatedAt"`
}

type Session struct {
	ID            uuid.UUID   `json:"id"`
	UserID        uuid.UUID   `json:"userId"`
	ProfileID     pgtype.UUID `json:"profileId"`
	TokenHash     string      `json:"tokenHash"`
	DeviceName    *string     `json:"deviceName"`
	DeviceType    *string     `json:"deviceType"`
	ClientName    *string     `json:"clientName"`
	ClientVersion *string     `json:"clientVersion"`
	IpAddress     netip.Addr  `json:"ipAddress"`
	UserAgent     *string     `json:"userAgent"`
	IsActive      bool        `json:"isActive"`
	LastActivity  time.Time   `json:"lastActivity"`
	ExpiresAt     time.Time   `json:"expiresAt"`
	CreatedAt     time.Time   `json:"createdAt"`
}

type User struct {
	ID                    uuid.UUID          `json:"id"`
	Username              string             `json:"username"`
	Email                 *string            `json:"email"`
	PasswordHash          *string            `json:"passwordHash"`
	IsAdmin               bool               `json:"isAdmin"`
	IsDisabled            bool               `json:"isDisabled"`
	MaxRatingLevel        int32              `json:"maxRatingLevel"`
	AdultEnabled          bool               `json:"adultEnabled"`
	PreferredLanguage     *string            `json:"preferredLanguage"`
	PreferredRatingSystem *string            `json:"preferredRatingSystem"`
	LastLoginAt           pgtype.Timestamptz `json:"lastLoginAt"`
	CreatedAt             time.Time          `json:"createdAt"`
	UpdatedAt             time.Time          `json:"updatedAt"`
	Role                  string             `json:"role"`
	RoleID                pgtype.UUID        `json:"roleId"`
}

type VideoPerson struct {
	ID                   uuid.UUID   `json:"id"`
	Name                 string      `json:"name"`
	SortName             *string     `json:"sortName"`
	OriginalName         *string     `json:"originalName"`
	Biography            *string     `json:"biography"`
	Birthdate            pgtype.Date `json:"birthdate"`
	Deathdate            pgtype.Date `json:"deathdate"`
	Birthplace           *string     `json:"birthplace"`
	Gender               *string     `json:"gender"`
	PrimaryImageUrl      *string     `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string     `json:"primaryImageBlurhash"`
	TmdbID               *int32      `json:"tmdbId"`
	ImdbID               *string     `json:"imdbId"`
	TvdbID               *int32      `json:"tvdbId"`
	CreatedAt            time.Time   `json:"createdAt"`
	UpdatedAt            time.Time   `json:"updatedAt"`
}
