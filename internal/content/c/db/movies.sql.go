// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: movies.sql

package adultdb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAdultMovie = `-- name: CreateAdultMovie :one
INSERT INTO c.movies (
    library_id,
    title,
    sort_title,
    original_title,
    overview,
    release_date,
    runtime_ticks,
    studio_id,
    director,
    series,
    path,
    size_bytes,
    container,
    video_codec,
    audio_codec,
    resolution,
    phash,
    oshash,
    whisparr_id,
    stashdb_id,
    tpdb_id,
    has_file,
    is_hdr,
    is_3d
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8,
    $9, $10, $11, $12, $13, $14, $15, $16,
    $17, $18, $19, $20, $21, $22, $23, $24
)
RETURNING id, library_id, whisparr_id, stashdb_id, tpdb_id, title, sort_title, original_title, overview, release_date, runtime_ticks, studio_id, director, series, path, size_bytes, container, video_codec, audio_codec, resolution, phash, oshash, has_file, is_hdr, is_3d, created_at, updated_at
`

type CreateAdultMovieParams struct {
	LibraryID     uuid.UUID   `json:"libraryId"`
	Title         string      `json:"title"`
	SortTitle     *string     `json:"sortTitle"`
	OriginalTitle *string     `json:"originalTitle"`
	Overview      *string     `json:"overview"`
	ReleaseDate   pgtype.Date `json:"releaseDate"`
	RuntimeTicks  *int64      `json:"runtimeTicks"`
	StudioID      pgtype.UUID `json:"studioId"`
	Director      *string     `json:"director"`
	Series        *string     `json:"series"`
	Path          string      `json:"path"`
	SizeBytes     *int64      `json:"sizeBytes"`
	Container     *string     `json:"container"`
	VideoCodec    *string     `json:"videoCodec"`
	AudioCodec    *string     `json:"audioCodec"`
	Resolution    *string     `json:"resolution"`
	Phash         *string     `json:"phash"`
	Oshash        *string     `json:"oshash"`
	WhisparrID    *int32      `json:"whisparrId"`
	StashdbID     *string     `json:"stashdbId"`
	TpdbID        *string     `json:"tpdbId"`
	HasFile       *bool       `json:"hasFile"`
	IsHdr         *bool       `json:"isHdr"`
	Is3d          *bool       `json:"is3d"`
}

func (q *Queries) CreateAdultMovie(ctx context.Context, arg CreateAdultMovieParams) (CMovie, error) {
	row := q.db.QueryRow(ctx, createAdultMovie,
		arg.LibraryID,
		arg.Title,
		arg.SortTitle,
		arg.OriginalTitle,
		arg.Overview,
		arg.ReleaseDate,
		arg.RuntimeTicks,
		arg.StudioID,
		arg.Director,
		arg.Series,
		arg.Path,
		arg.SizeBytes,
		arg.Container,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
		arg.Phash,
		arg.Oshash,
		arg.WhisparrID,
		arg.StashdbID,
		arg.TpdbID,
		arg.HasFile,
		arg.IsHdr,
		arg.Is3d,
	)
	var i CMovie
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.WhisparrID,
		&i.StashdbID,
		&i.TpdbID,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Overview,
		&i.ReleaseDate,
		&i.RuntimeTicks,
		&i.StudioID,
		&i.Director,
		&i.Series,
		&i.Path,
		&i.SizeBytes,
		&i.Container,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.Phash,
		&i.Oshash,
		&i.HasFile,
		&i.IsHdr,
		&i.Is3d,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAdultMovie = `-- name: DeleteAdultMovie :exec
DELETE FROM c.movies WHERE id = $1
`

func (q *Queries) DeleteAdultMovie(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAdultMovie, id)
	return err
}

const getAdultMovieByID = `-- name: GetAdultMovieByID :one
SELECT id, library_id, whisparr_id, stashdb_id, tpdb_id, title, sort_title, original_title, overview, release_date, runtime_ticks, studio_id, director, series, path, size_bytes, container, video_codec, audio_codec, resolution, phash, oshash, has_file, is_hdr, is_3d, created_at, updated_at FROM c.movies WHERE id = $1
`

func (q *Queries) GetAdultMovieByID(ctx context.Context, id uuid.UUID) (CMovie, error) {
	row := q.db.QueryRow(ctx, getAdultMovieByID, id)
	var i CMovie
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.WhisparrID,
		&i.StashdbID,
		&i.TpdbID,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Overview,
		&i.ReleaseDate,
		&i.RuntimeTicks,
		&i.StudioID,
		&i.Director,
		&i.Series,
		&i.Path,
		&i.SizeBytes,
		&i.Container,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.Phash,
		&i.Oshash,
		&i.HasFile,
		&i.IsHdr,
		&i.Is3d,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAdultMovies = `-- name: ListAdultMovies :many
SELECT id, library_id, whisparr_id, stashdb_id, tpdb_id, title, sort_title, original_title, overview, release_date, runtime_ticks, studio_id, director, series, path, size_bytes, container, video_codec, audio_codec, resolution, phash, oshash, has_file, is_hdr, is_3d, created_at, updated_at FROM c.movies
ORDER BY title
LIMIT $1 OFFSET $2
`

type ListAdultMoviesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAdultMovies(ctx context.Context, arg ListAdultMoviesParams) ([]CMovie, error) {
	rows, err := q.db.Query(ctx, listAdultMovies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CMovie{}
	for rows.Next() {
		var i CMovie
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.WhisparrID,
			&i.StashdbID,
			&i.TpdbID,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Overview,
			&i.ReleaseDate,
			&i.RuntimeTicks,
			&i.StudioID,
			&i.Director,
			&i.Series,
			&i.Path,
			&i.SizeBytes,
			&i.Container,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.Phash,
			&i.Oshash,
			&i.HasFile,
			&i.IsHdr,
			&i.Is3d,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdultMoviesByLibrary = `-- name: ListAdultMoviesByLibrary :many
SELECT id, library_id, whisparr_id, stashdb_id, tpdb_id, title, sort_title, original_title, overview, release_date, runtime_ticks, studio_id, director, series, path, size_bytes, container, video_codec, audio_codec, resolution, phash, oshash, has_file, is_hdr, is_3d, created_at, updated_at FROM c.movies
WHERE library_id = $1
ORDER BY title
LIMIT $2 OFFSET $3
`

type ListAdultMoviesByLibraryParams struct {
	LibraryID uuid.UUID `json:"libraryId"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) ListAdultMoviesByLibrary(ctx context.Context, arg ListAdultMoviesByLibraryParams) ([]CMovie, error) {
	rows, err := q.db.Query(ctx, listAdultMoviesByLibrary, arg.LibraryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CMovie{}
	for rows.Next() {
		var i CMovie
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.WhisparrID,
			&i.StashdbID,
			&i.TpdbID,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Overview,
			&i.ReleaseDate,
			&i.RuntimeTicks,
			&i.StudioID,
			&i.Director,
			&i.Series,
			&i.Path,
			&i.SizeBytes,
			&i.Container,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.Phash,
			&i.Oshash,
			&i.HasFile,
			&i.IsHdr,
			&i.Is3d,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAdultMovie = `-- name: UpdateAdultMovie :one
UPDATE c.movies
SET
    library_id = $2,
    title = $3,
    sort_title = $4,
    original_title = $5,
    overview = $6,
    release_date = $7,
    runtime_ticks = $8,
    studio_id = $9,
    director = $10,
    series = $11,
    path = $12,
    size_bytes = $13,
    container = $14,
    video_codec = $15,
    audio_codec = $16,
    resolution = $17,
    phash = $18,
    oshash = $19,
    whisparr_id = $20,
    stashdb_id = $21,
    tpdb_id = $22,
    has_file = $23,
    is_hdr = $24,
    is_3d = $25
WHERE id = $1
RETURNING id, library_id, whisparr_id, stashdb_id, tpdb_id, title, sort_title, original_title, overview, release_date, runtime_ticks, studio_id, director, series, path, size_bytes, container, video_codec, audio_codec, resolution, phash, oshash, has_file, is_hdr, is_3d, created_at, updated_at
`

type UpdateAdultMovieParams struct {
	ID            uuid.UUID   `json:"id"`
	LibraryID     uuid.UUID   `json:"libraryId"`
	Title         string      `json:"title"`
	SortTitle     *string     `json:"sortTitle"`
	OriginalTitle *string     `json:"originalTitle"`
	Overview      *string     `json:"overview"`
	ReleaseDate   pgtype.Date `json:"releaseDate"`
	RuntimeTicks  *int64      `json:"runtimeTicks"`
	StudioID      pgtype.UUID `json:"studioId"`
	Director      *string     `json:"director"`
	Series        *string     `json:"series"`
	Path          string      `json:"path"`
	SizeBytes     *int64      `json:"sizeBytes"`
	Container     *string     `json:"container"`
	VideoCodec    *string     `json:"videoCodec"`
	AudioCodec    *string     `json:"audioCodec"`
	Resolution    *string     `json:"resolution"`
	Phash         *string     `json:"phash"`
	Oshash        *string     `json:"oshash"`
	WhisparrID    *int32      `json:"whisparrId"`
	StashdbID     *string     `json:"stashdbId"`
	TpdbID        *string     `json:"tpdbId"`
	HasFile       *bool       `json:"hasFile"`
	IsHdr         *bool       `json:"isHdr"`
	Is3d          *bool       `json:"is3d"`
}

func (q *Queries) UpdateAdultMovie(ctx context.Context, arg UpdateAdultMovieParams) (CMovie, error) {
	row := q.db.QueryRow(ctx, updateAdultMovie,
		arg.ID,
		arg.LibraryID,
		arg.Title,
		arg.SortTitle,
		arg.OriginalTitle,
		arg.Overview,
		arg.ReleaseDate,
		arg.RuntimeTicks,
		arg.StudioID,
		arg.Director,
		arg.Series,
		arg.Path,
		arg.SizeBytes,
		arg.Container,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
		arg.Phash,
		arg.Oshash,
		arg.WhisparrID,
		arg.StashdbID,
		arg.TpdbID,
		arg.HasFile,
		arg.IsHdr,
		arg.Is3d,
	)
	var i CMovie
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.WhisparrID,
		&i.StashdbID,
		&i.TpdbID,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Overview,
		&i.ReleaseDate,
		&i.RuntimeTicks,
		&i.StudioID,
		&i.Director,
		&i.Series,
		&i.Path,
		&i.SizeBytes,
		&i.Container,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.Phash,
		&i.Oshash,
		&i.HasFile,
		&i.IsHdr,
		&i.Is3d,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
