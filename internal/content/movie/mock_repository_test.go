// Code generated by mockery v2.53.5. DO NOT EDIT.

package movie

import (
	context "context"

	mock "github.com/stretchr/testify/mock"

	uuid "github.com/google/uuid"
)

// MockMovieRepository is an autogenerated mock type for the Repository type
type MockMovieRepository struct {
	mock.Mock
}

type MockMovieRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMovieRepository) EXPECT() *MockMovieRepository_Expecter {
	return &MockMovieRepository_Expecter{mock: &_m.Mock}
}

// AddMovieGenre provides a mock function with given fields: ctx, movieID, tmdbGenreID, name
func (_m *MockMovieRepository) AddMovieGenre(ctx context.Context, movieID uuid.UUID, tmdbGenreID int32, name string) error {
	ret := _m.Called(ctx, movieID, tmdbGenreID, name)

	if len(ret) == 0 {
		panic("no return value specified for AddMovieGenre")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int32, string) error); ok {
		r0 = rf(ctx, movieID, tmdbGenreID, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockMovieRepository_AddMovieGenre_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddMovieGenre'
type MockMovieRepository_AddMovieGenre_Call struct {
	*mock.Call
}

// AddMovieGenre is a helper method to define mock.On call
//   - ctx context.Context
//   - movieID uuid.UUID
//   - tmdbGenreID int32
//   - name string
func (_e *MockMovieRepository_Expecter) AddMovieGenre(ctx interface{}, movieID interface{}, tmdbGenreID interface{}, name interface{}) *MockMovieRepository_AddMovieGenre_Call {
	return &MockMovieRepository_AddMovieGenre_Call{Call: _e.mock.On("AddMovieGenre", ctx, movieID, tmdbGenreID, name)}
}

func (_c *MockMovieRepository_AddMovieGenre_Call) Run(run func(ctx context.Context, movieID uuid.UUID, tmdbGenreID int32, name string)) *MockMovieRepository_AddMovieGenre_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int32), args[3].(string))
	})
	return _c
}

func (_c *MockMovieRepository_AddMovieGenre_Call) Return(_a0 error) *MockMovieRepository_AddMovieGenre_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMovieRepository_AddMovieGenre_Call) RunAndReturn(run func(context.Context, uuid.UUID, int32, string) error) *MockMovieRepository_AddMovieGenre_Call {
	_c.Call.Return(run)
	return _c
}

// AddMovieToCollection provides a mock function with given fields: ctx, collectionID, movieID, collectionOrder
func (_m *MockMovieRepository) AddMovieToCollection(ctx context.Context, collectionID uuid.UUID, movieID uuid.UUID, collectionOrder *int32) error {
	ret := _m.Called(ctx, collectionID, movieID, collectionOrder)

	if len(ret) == 0 {
		panic("no return value specified for AddMovieToCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, *int32) error); ok {
		r0 = rf(ctx, collectionID, movieID, collectionOrder)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockMovieRepository_AddMovieToCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddMovieToCollection'
type MockMovieRepository_AddMovieToCollection_Call struct {
	*mock.Call
}

// AddMovieToCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - collectionID uuid.UUID
//   - movieID uuid.UUID
//   - collectionOrder *int32
func (_e *MockMovieRepository_Expecter) AddMovieToCollection(ctx interface{}, collectionID interface{}, movieID interface{}, collectionOrder interface{}) *MockMovieRepository_AddMovieToCollection_Call {
	return &MockMovieRepository_AddMovieToCollection_Call{Call: _e.mock.On("AddMovieToCollection", ctx, collectionID, movieID, collectionOrder)}
}

func (_c *MockMovieRepository_AddMovieToCollection_Call) Run(run func(ctx context.Context, collectionID uuid.UUID, movieID uuid.UUID, collectionOrder *int32)) *MockMovieRepository_AddMovieToCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(*int32))
	})
	return _c
}

func (_c *MockMovieRepository_AddMovieToCollection_Call) Return(_a0 error) *MockMovieRepository_AddMovieToCollection_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMovieRepository_AddMovieToCollection_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, *int32) error) *MockMovieRepository_AddMovieToCollection_Call {
	_c.Call.Return(run)
	return _c
}

// CountMovies provides a mock function with given fields: ctx
func (_m *MockMovieRepository) CountMovies(ctx context.Context) (int64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountMovies")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_CountMovies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountMovies'
type MockMovieRepository_CountMovies_Call struct {
	*mock.Call
}

// CountMovies is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockMovieRepository_Expecter) CountMovies(ctx interface{}) *MockMovieRepository_CountMovies_Call {
	return &MockMovieRepository_CountMovies_Call{Call: _e.mock.On("CountMovies", ctx)}
}

func (_c *MockMovieRepository_CountMovies_Call) Run(run func(ctx context.Context)) *MockMovieRepository_CountMovies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockMovieRepository_CountMovies_Call) Return(_a0 int64, _a1 error) *MockMovieRepository_CountMovies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_CountMovies_Call) RunAndReturn(run func(context.Context) (int64, error)) *MockMovieRepository_CountMovies_Call {
	_c.Call.Return(run)
	return _c
}

// CountMovieCast provides a mock function with given fields: ctx, movieID
func (_m *MockMovieRepository) CountMovieCast(ctx context.Context, movieID uuid.UUID) (int64, error) {
	ret := _m.Called(ctx, movieID)

	if len(ret) == 0 {
		panic("no return value specified for CountMovieCast")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (int64, error)); ok {
		return rf(ctx, movieID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) int64); ok {
		r0 = rf(ctx, movieID)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, movieID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_CountMovieCast_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountMovieCast'
type MockMovieRepository_CountMovieCast_Call struct {
	*mock.Call
}

// CountMovieCast is a helper method to define mock.On call
//   - ctx context.Context
//   - movieID uuid.UUID
func (_e *MockMovieRepository_Expecter) CountMovieCast(ctx interface{}, movieID interface{}) *MockMovieRepository_CountMovieCast_Call {
	return &MockMovieRepository_CountMovieCast_Call{Call: _e.mock.On("CountMovieCast", ctx, movieID)}
}

func (_c *MockMovieRepository_CountMovieCast_Call) Run(run func(ctx context.Context, movieID uuid.UUID)) *MockMovieRepository_CountMovieCast_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_CountMovieCast_Call) Return(_a0 int64, _a1 error) *MockMovieRepository_CountMovieCast_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_CountMovieCast_Call) RunAndReturn(run func(context.Context, uuid.UUID) (int64, error)) *MockMovieRepository_CountMovieCast_Call {
	_c.Call.Return(run)
	return _c
}

// CountMovieCrew provides a mock function with given fields: ctx, movieID
func (_m *MockMovieRepository) CountMovieCrew(ctx context.Context, movieID uuid.UUID) (int64, error) {
	ret := _m.Called(ctx, movieID)

	if len(ret) == 0 {
		panic("no return value specified for CountMovieCrew")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (int64, error)); ok {
		return rf(ctx, movieID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) int64); ok {
		r0 = rf(ctx, movieID)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, movieID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_CountMovieCrew_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountMovieCrew'
type MockMovieRepository_CountMovieCrew_Call struct {
	*mock.Call
}

// CountMovieCrew is a helper method to define mock.On call
//   - ctx context.Context
//   - movieID uuid.UUID
func (_e *MockMovieRepository_Expecter) CountMovieCrew(ctx interface{}, movieID interface{}) *MockMovieRepository_CountMovieCrew_Call {
	return &MockMovieRepository_CountMovieCrew_Call{Call: _e.mock.On("CountMovieCrew", ctx, movieID)}
}

func (_c *MockMovieRepository_CountMovieCrew_Call) Run(run func(ctx context.Context, movieID uuid.UUID)) *MockMovieRepository_CountMovieCrew_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_CountMovieCrew_Call) Return(_a0 int64, _a1 error) *MockMovieRepository_CountMovieCrew_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_CountMovieCrew_Call) RunAndReturn(run func(context.Context, uuid.UUID) (int64, error)) *MockMovieRepository_CountMovieCrew_Call {
	_c.Call.Return(run)
	return _c
}

// CountTopRated provides a mock function with given fields: ctx, minVotes
func (_m *MockMovieRepository) CountTopRated(ctx context.Context, minVotes int32) (int64, error) {
	ret := _m.Called(ctx, minVotes)

	if len(ret) == 0 {
		panic("no return value specified for CountTopRated")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32) (int64, error)); ok {
		return rf(ctx, minVotes)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32) int64); ok {
		r0 = rf(ctx, minVotes)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32) error); ok {
		r1 = rf(ctx, minVotes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_CountTopRated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountTopRated'
type MockMovieRepository_CountTopRated_Call struct {
	*mock.Call
}

// CountTopRated is a helper method to define mock.On call
//   - ctx context.Context
//   - minVotes int32
func (_e *MockMovieRepository_Expecter) CountTopRated(ctx interface{}, minVotes interface{}) *MockMovieRepository_CountTopRated_Call {
	return &MockMovieRepository_CountTopRated_Call{Call: _e.mock.On("CountTopRated", ctx, minVotes)}
}

func (_c *MockMovieRepository_CountTopRated_Call) Run(run func(ctx context.Context, minVotes int32)) *MockMovieRepository_CountTopRated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_CountTopRated_Call) Return(_a0 int64, _a1 error) *MockMovieRepository_CountTopRated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_CountTopRated_Call) RunAndReturn(run func(context.Context, int32) (int64, error)) *MockMovieRepository_CountTopRated_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMovie provides a mock function with given fields: ctx, params
func (_m *MockMovieRepository) CreateMovie(ctx context.Context, params CreateMovieParams) (*Movie, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for CreateMovie")
	}

	var r0 *Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, CreateMovieParams) (*Movie, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, CreateMovieParams) *Movie); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, CreateMovieParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_CreateMovie_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMovie'
type MockMovieRepository_CreateMovie_Call struct {
	*mock.Call
}

// CreateMovie is a helper method to define mock.On call
//   - ctx context.Context
//   - params CreateMovieParams
func (_e *MockMovieRepository_Expecter) CreateMovie(ctx interface{}, params interface{}) *MockMovieRepository_CreateMovie_Call {
	return &MockMovieRepository_CreateMovie_Call{Call: _e.mock.On("CreateMovie", ctx, params)}
}

func (_c *MockMovieRepository_CreateMovie_Call) Run(run func(ctx context.Context, params CreateMovieParams)) *MockMovieRepository_CreateMovie_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(CreateMovieParams))
	})
	return _c
}

func (_c *MockMovieRepository_CreateMovie_Call) Return(_a0 *Movie, _a1 error) *MockMovieRepository_CreateMovie_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_CreateMovie_Call) RunAndReturn(run func(context.Context, CreateMovieParams) (*Movie, error)) *MockMovieRepository_CreateMovie_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMovieCollection provides a mock function with given fields: ctx, params
func (_m *MockMovieRepository) CreateMovieCollection(ctx context.Context, params CreateMovieCollectionParams) (*MovieCollection, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for CreateMovieCollection")
	}

	var r0 *MovieCollection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, CreateMovieCollectionParams) (*MovieCollection, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, CreateMovieCollectionParams) *MovieCollection); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieCollection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, CreateMovieCollectionParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_CreateMovieCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMovieCollection'
type MockMovieRepository_CreateMovieCollection_Call struct {
	*mock.Call
}

// CreateMovieCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - params CreateMovieCollectionParams
func (_e *MockMovieRepository_Expecter) CreateMovieCollection(ctx interface{}, params interface{}) *MockMovieRepository_CreateMovieCollection_Call {
	return &MockMovieRepository_CreateMovieCollection_Call{Call: _e.mock.On("CreateMovieCollection", ctx, params)}
}

func (_c *MockMovieRepository_CreateMovieCollection_Call) Run(run func(ctx context.Context, params CreateMovieCollectionParams)) *MockMovieRepository_CreateMovieCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(CreateMovieCollectionParams))
	})
	return _c
}

func (_c *MockMovieRepository_CreateMovieCollection_Call) Return(_a0 *MovieCollection, _a1 error) *MockMovieRepository_CreateMovieCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_CreateMovieCollection_Call) RunAndReturn(run func(context.Context, CreateMovieCollectionParams) (*MovieCollection, error)) *MockMovieRepository_CreateMovieCollection_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMovieCredit provides a mock function with given fields: ctx, params
func (_m *MockMovieRepository) CreateMovieCredit(ctx context.Context, params CreateMovieCreditParams) (*MovieCredit, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for CreateMovieCredit")
	}

	var r0 *MovieCredit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, CreateMovieCreditParams) (*MovieCredit, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, CreateMovieCreditParams) *MovieCredit); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieCredit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, CreateMovieCreditParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_CreateMovieCredit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMovieCredit'
type MockMovieRepository_CreateMovieCredit_Call struct {
	*mock.Call
}

// CreateMovieCredit is a helper method to define mock.On call
//   - ctx context.Context
//   - params CreateMovieCreditParams
func (_e *MockMovieRepository_Expecter) CreateMovieCredit(ctx interface{}, params interface{}) *MockMovieRepository_CreateMovieCredit_Call {
	return &MockMovieRepository_CreateMovieCredit_Call{Call: _e.mock.On("CreateMovieCredit", ctx, params)}
}

func (_c *MockMovieRepository_CreateMovieCredit_Call) Run(run func(ctx context.Context, params CreateMovieCreditParams)) *MockMovieRepository_CreateMovieCredit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(CreateMovieCreditParams))
	})
	return _c
}

func (_c *MockMovieRepository_CreateMovieCredit_Call) Return(_a0 *MovieCredit, _a1 error) *MockMovieRepository_CreateMovieCredit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_CreateMovieCredit_Call) RunAndReturn(run func(context.Context, CreateMovieCreditParams) (*MovieCredit, error)) *MockMovieRepository_CreateMovieCredit_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMovieFile provides a mock function with given fields: ctx, params
func (_m *MockMovieRepository) CreateMovieFile(ctx context.Context, params CreateMovieFileParams) (*MovieFile, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for CreateMovieFile")
	}

	var r0 *MovieFile
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, CreateMovieFileParams) (*MovieFile, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, CreateMovieFileParams) *MovieFile); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieFile)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, CreateMovieFileParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_CreateMovieFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMovieFile'
type MockMovieRepository_CreateMovieFile_Call struct {
	*mock.Call
}

// CreateMovieFile is a helper method to define mock.On call
//   - ctx context.Context
//   - params CreateMovieFileParams
func (_e *MockMovieRepository_Expecter) CreateMovieFile(ctx interface{}, params interface{}) *MockMovieRepository_CreateMovieFile_Call {
	return &MockMovieRepository_CreateMovieFile_Call{Call: _e.mock.On("CreateMovieFile", ctx, params)}
}

func (_c *MockMovieRepository_CreateMovieFile_Call) Run(run func(ctx context.Context, params CreateMovieFileParams)) *MockMovieRepository_CreateMovieFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(CreateMovieFileParams))
	})
	return _c
}

func (_c *MockMovieRepository_CreateMovieFile_Call) Return(_a0 *MovieFile, _a1 error) *MockMovieRepository_CreateMovieFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_CreateMovieFile_Call) RunAndReturn(run func(context.Context, CreateMovieFileParams) (*MovieFile, error)) *MockMovieRepository_CreateMovieFile_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateWatchProgress provides a mock function with given fields: ctx, params
func (_m *MockMovieRepository) CreateOrUpdateWatchProgress(ctx context.Context, params CreateWatchProgressParams) (*MovieWatched, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateWatchProgress")
	}

	var r0 *MovieWatched
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, CreateWatchProgressParams) (*MovieWatched, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, CreateWatchProgressParams) *MovieWatched); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieWatched)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, CreateWatchProgressParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_CreateOrUpdateWatchProgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateWatchProgress'
type MockMovieRepository_CreateOrUpdateWatchProgress_Call struct {
	*mock.Call
}

// CreateOrUpdateWatchProgress is a helper method to define mock.On call
//   - ctx context.Context
//   - params CreateWatchProgressParams
func (_e *MockMovieRepository_Expecter) CreateOrUpdateWatchProgress(ctx interface{}, params interface{}) *MockMovieRepository_CreateOrUpdateWatchProgress_Call {
	return &MockMovieRepository_CreateOrUpdateWatchProgress_Call{Call: _e.mock.On("CreateOrUpdateWatchProgress", ctx, params)}
}

func (_c *MockMovieRepository_CreateOrUpdateWatchProgress_Call) Run(run func(ctx context.Context, params CreateWatchProgressParams)) *MockMovieRepository_CreateOrUpdateWatchProgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(CreateWatchProgressParams))
	})
	return _c
}

func (_c *MockMovieRepository_CreateOrUpdateWatchProgress_Call) Return(_a0 *MovieWatched, _a1 error) *MockMovieRepository_CreateOrUpdateWatchProgress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_CreateOrUpdateWatchProgress_Call) RunAndReturn(run func(context.Context, CreateWatchProgressParams) (*MovieWatched, error)) *MockMovieRepository_CreateOrUpdateWatchProgress_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMovie provides a mock function with given fields: ctx, id
func (_m *MockMovieRepository) DeleteMovie(ctx context.Context, id uuid.UUID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMovie")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockMovieRepository_DeleteMovie_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMovie'
type MockMovieRepository_DeleteMovie_Call struct {
	*mock.Call
}

// DeleteMovie is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockMovieRepository_Expecter) DeleteMovie(ctx interface{}, id interface{}) *MockMovieRepository_DeleteMovie_Call {
	return &MockMovieRepository_DeleteMovie_Call{Call: _e.mock.On("DeleteMovie", ctx, id)}
}

func (_c *MockMovieRepository_DeleteMovie_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockMovieRepository_DeleteMovie_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_DeleteMovie_Call) Return(_a0 error) *MockMovieRepository_DeleteMovie_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMovieRepository_DeleteMovie_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockMovieRepository_DeleteMovie_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMovieCredits provides a mock function with given fields: ctx, movieID
func (_m *MockMovieRepository) DeleteMovieCredits(ctx context.Context, movieID uuid.UUID) error {
	ret := _m.Called(ctx, movieID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMovieCredits")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, movieID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockMovieRepository_DeleteMovieCredits_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMovieCredits'
type MockMovieRepository_DeleteMovieCredits_Call struct {
	*mock.Call
}

// DeleteMovieCredits is a helper method to define mock.On call
//   - ctx context.Context
//   - movieID uuid.UUID
func (_e *MockMovieRepository_Expecter) DeleteMovieCredits(ctx interface{}, movieID interface{}) *MockMovieRepository_DeleteMovieCredits_Call {
	return &MockMovieRepository_DeleteMovieCredits_Call{Call: _e.mock.On("DeleteMovieCredits", ctx, movieID)}
}

func (_c *MockMovieRepository_DeleteMovieCredits_Call) Run(run func(ctx context.Context, movieID uuid.UUID)) *MockMovieRepository_DeleteMovieCredits_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_DeleteMovieCredits_Call) Return(_a0 error) *MockMovieRepository_DeleteMovieCredits_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMovieRepository_DeleteMovieCredits_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockMovieRepository_DeleteMovieCredits_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMovieFile provides a mock function with given fields: ctx, id
func (_m *MockMovieRepository) DeleteMovieFile(ctx context.Context, id uuid.UUID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMovieFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockMovieRepository_DeleteMovieFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMovieFile'
type MockMovieRepository_DeleteMovieFile_Call struct {
	*mock.Call
}

// DeleteMovieFile is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockMovieRepository_Expecter) DeleteMovieFile(ctx interface{}, id interface{}) *MockMovieRepository_DeleteMovieFile_Call {
	return &MockMovieRepository_DeleteMovieFile_Call{Call: _e.mock.On("DeleteMovieFile", ctx, id)}
}

func (_c *MockMovieRepository_DeleteMovieFile_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockMovieRepository_DeleteMovieFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_DeleteMovieFile_Call) Return(_a0 error) *MockMovieRepository_DeleteMovieFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMovieRepository_DeleteMovieFile_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockMovieRepository_DeleteMovieFile_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMovieGenres provides a mock function with given fields: ctx, movieID
func (_m *MockMovieRepository) DeleteMovieGenres(ctx context.Context, movieID uuid.UUID) error {
	ret := _m.Called(ctx, movieID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMovieGenres")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, movieID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockMovieRepository_DeleteMovieGenres_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMovieGenres'
type MockMovieRepository_DeleteMovieGenres_Call struct {
	*mock.Call
}

// DeleteMovieGenres is a helper method to define mock.On call
//   - ctx context.Context
//   - movieID uuid.UUID
func (_e *MockMovieRepository_Expecter) DeleteMovieGenres(ctx interface{}, movieID interface{}) *MockMovieRepository_DeleteMovieGenres_Call {
	return &MockMovieRepository_DeleteMovieGenres_Call{Call: _e.mock.On("DeleteMovieGenres", ctx, movieID)}
}

func (_c *MockMovieRepository_DeleteMovieGenres_Call) Run(run func(ctx context.Context, movieID uuid.UUID)) *MockMovieRepository_DeleteMovieGenres_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_DeleteMovieGenres_Call) Return(_a0 error) *MockMovieRepository_DeleteMovieGenres_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMovieRepository_DeleteMovieGenres_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockMovieRepository_DeleteMovieGenres_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWatchProgress provides a mock function with given fields: ctx, userID, movieID
func (_m *MockMovieRepository) DeleteWatchProgress(ctx context.Context, userID uuid.UUID, movieID uuid.UUID) error {
	ret := _m.Called(ctx, userID, movieID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWatchProgress")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) error); ok {
		r0 = rf(ctx, userID, movieID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockMovieRepository_DeleteWatchProgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWatchProgress'
type MockMovieRepository_DeleteWatchProgress_Call struct {
	*mock.Call
}

// DeleteWatchProgress is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - movieID uuid.UUID
func (_e *MockMovieRepository_Expecter) DeleteWatchProgress(ctx interface{}, userID interface{}, movieID interface{}) *MockMovieRepository_DeleteWatchProgress_Call {
	return &MockMovieRepository_DeleteWatchProgress_Call{Call: _e.mock.On("DeleteWatchProgress", ctx, userID, movieID)}
}

func (_c *MockMovieRepository_DeleteWatchProgress_Call) Run(run func(ctx context.Context, userID uuid.UUID, movieID uuid.UUID)) *MockMovieRepository_DeleteWatchProgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_DeleteWatchProgress_Call) Return(_a0 error) *MockMovieRepository_DeleteWatchProgress_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMovieRepository_DeleteWatchProgress_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID) error) *MockMovieRepository_DeleteWatchProgress_Call {
	_c.Call.Return(run)
	return _c
}

// GetCollectionForMovie provides a mock function with given fields: ctx, movieID
func (_m *MockMovieRepository) GetCollectionForMovie(ctx context.Context, movieID uuid.UUID) (*MovieCollection, error) {
	ret := _m.Called(ctx, movieID)

	if len(ret) == 0 {
		panic("no return value specified for GetCollectionForMovie")
	}

	var r0 *MovieCollection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*MovieCollection, error)); ok {
		return rf(ctx, movieID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *MovieCollection); ok {
		r0 = rf(ctx, movieID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieCollection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, movieID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_GetCollectionForMovie_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCollectionForMovie'
type MockMovieRepository_GetCollectionForMovie_Call struct {
	*mock.Call
}

// GetCollectionForMovie is a helper method to define mock.On call
//   - ctx context.Context
//   - movieID uuid.UUID
func (_e *MockMovieRepository_Expecter) GetCollectionForMovie(ctx interface{}, movieID interface{}) *MockMovieRepository_GetCollectionForMovie_Call {
	return &MockMovieRepository_GetCollectionForMovie_Call{Call: _e.mock.On("GetCollectionForMovie", ctx, movieID)}
}

func (_c *MockMovieRepository_GetCollectionForMovie_Call) Run(run func(ctx context.Context, movieID uuid.UUID)) *MockMovieRepository_GetCollectionForMovie_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_GetCollectionForMovie_Call) Return(_a0 *MovieCollection, _a1 error) *MockMovieRepository_GetCollectionForMovie_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_GetCollectionForMovie_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*MovieCollection, error)) *MockMovieRepository_GetCollectionForMovie_Call {
	_c.Call.Return(run)
	return _c
}

// GetMovie provides a mock function with given fields: ctx, id
func (_m *MockMovieRepository) GetMovie(ctx context.Context, id uuid.UUID) (*Movie, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetMovie")
	}

	var r0 *Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*Movie, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *Movie); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_GetMovie_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMovie'
type MockMovieRepository_GetMovie_Call struct {
	*mock.Call
}

// GetMovie is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockMovieRepository_Expecter) GetMovie(ctx interface{}, id interface{}) *MockMovieRepository_GetMovie_Call {
	return &MockMovieRepository_GetMovie_Call{Call: _e.mock.On("GetMovie", ctx, id)}
}

func (_c *MockMovieRepository_GetMovie_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockMovieRepository_GetMovie_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_GetMovie_Call) Return(_a0 *Movie, _a1 error) *MockMovieRepository_GetMovie_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_GetMovie_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*Movie, error)) *MockMovieRepository_GetMovie_Call {
	_c.Call.Return(run)
	return _c
}

// GetMovieByIMDbID provides a mock function with given fields: ctx, imdbID
func (_m *MockMovieRepository) GetMovieByIMDbID(ctx context.Context, imdbID string) (*Movie, error) {
	ret := _m.Called(ctx, imdbID)

	if len(ret) == 0 {
		panic("no return value specified for GetMovieByIMDbID")
	}

	var r0 *Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*Movie, error)); ok {
		return rf(ctx, imdbID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *Movie); ok {
		r0 = rf(ctx, imdbID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, imdbID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_GetMovieByIMDbID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMovieByIMDbID'
type MockMovieRepository_GetMovieByIMDbID_Call struct {
	*mock.Call
}

// GetMovieByIMDbID is a helper method to define mock.On call
//   - ctx context.Context
//   - imdbID string
func (_e *MockMovieRepository_Expecter) GetMovieByIMDbID(ctx interface{}, imdbID interface{}) *MockMovieRepository_GetMovieByIMDbID_Call {
	return &MockMovieRepository_GetMovieByIMDbID_Call{Call: _e.mock.On("GetMovieByIMDbID", ctx, imdbID)}
}

func (_c *MockMovieRepository_GetMovieByIMDbID_Call) Run(run func(ctx context.Context, imdbID string)) *MockMovieRepository_GetMovieByIMDbID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockMovieRepository_GetMovieByIMDbID_Call) Return(_a0 *Movie, _a1 error) *MockMovieRepository_GetMovieByIMDbID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_GetMovieByIMDbID_Call) RunAndReturn(run func(context.Context, string) (*Movie, error)) *MockMovieRepository_GetMovieByIMDbID_Call {
	_c.Call.Return(run)
	return _c
}

// GetMovieByRadarrID provides a mock function with given fields: ctx, radarrID
func (_m *MockMovieRepository) GetMovieByRadarrID(ctx context.Context, radarrID int32) (*Movie, error) {
	ret := _m.Called(ctx, radarrID)

	if len(ret) == 0 {
		panic("no return value specified for GetMovieByRadarrID")
	}

	var r0 *Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32) (*Movie, error)); ok {
		return rf(ctx, radarrID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32) *Movie); ok {
		r0 = rf(ctx, radarrID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32) error); ok {
		r1 = rf(ctx, radarrID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_GetMovieByRadarrID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMovieByRadarrID'
type MockMovieRepository_GetMovieByRadarrID_Call struct {
	*mock.Call
}

// GetMovieByRadarrID is a helper method to define mock.On call
//   - ctx context.Context
//   - radarrID int32
func (_e *MockMovieRepository_Expecter) GetMovieByRadarrID(ctx interface{}, radarrID interface{}) *MockMovieRepository_GetMovieByRadarrID_Call {
	return &MockMovieRepository_GetMovieByRadarrID_Call{Call: _e.mock.On("GetMovieByRadarrID", ctx, radarrID)}
}

func (_c *MockMovieRepository_GetMovieByRadarrID_Call) Run(run func(ctx context.Context, radarrID int32)) *MockMovieRepository_GetMovieByRadarrID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_GetMovieByRadarrID_Call) Return(_a0 *Movie, _a1 error) *MockMovieRepository_GetMovieByRadarrID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_GetMovieByRadarrID_Call) RunAndReturn(run func(context.Context, int32) (*Movie, error)) *MockMovieRepository_GetMovieByRadarrID_Call {
	_c.Call.Return(run)
	return _c
}

// GetMovieByTMDbID provides a mock function with given fields: ctx, tmdbID
func (_m *MockMovieRepository) GetMovieByTMDbID(ctx context.Context, tmdbID int32) (*Movie, error) {
	ret := _m.Called(ctx, tmdbID)

	if len(ret) == 0 {
		panic("no return value specified for GetMovieByTMDbID")
	}

	var r0 *Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32) (*Movie, error)); ok {
		return rf(ctx, tmdbID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32) *Movie); ok {
		r0 = rf(ctx, tmdbID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32) error); ok {
		r1 = rf(ctx, tmdbID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_GetMovieByTMDbID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMovieByTMDbID'
type MockMovieRepository_GetMovieByTMDbID_Call struct {
	*mock.Call
}

// GetMovieByTMDbID is a helper method to define mock.On call
//   - ctx context.Context
//   - tmdbID int32
func (_e *MockMovieRepository_Expecter) GetMovieByTMDbID(ctx interface{}, tmdbID interface{}) *MockMovieRepository_GetMovieByTMDbID_Call {
	return &MockMovieRepository_GetMovieByTMDbID_Call{Call: _e.mock.On("GetMovieByTMDbID", ctx, tmdbID)}
}

func (_c *MockMovieRepository_GetMovieByTMDbID_Call) Run(run func(ctx context.Context, tmdbID int32)) *MockMovieRepository_GetMovieByTMDbID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_GetMovieByTMDbID_Call) Return(_a0 *Movie, _a1 error) *MockMovieRepository_GetMovieByTMDbID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_GetMovieByTMDbID_Call) RunAndReturn(run func(context.Context, int32) (*Movie, error)) *MockMovieRepository_GetMovieByTMDbID_Call {
	_c.Call.Return(run)
	return _c
}

// GetMovieCollection provides a mock function with given fields: ctx, id
func (_m *MockMovieRepository) GetMovieCollection(ctx context.Context, id uuid.UUID) (*MovieCollection, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetMovieCollection")
	}

	var r0 *MovieCollection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*MovieCollection, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *MovieCollection); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieCollection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_GetMovieCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMovieCollection'
type MockMovieRepository_GetMovieCollection_Call struct {
	*mock.Call
}

// GetMovieCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockMovieRepository_Expecter) GetMovieCollection(ctx interface{}, id interface{}) *MockMovieRepository_GetMovieCollection_Call {
	return &MockMovieRepository_GetMovieCollection_Call{Call: _e.mock.On("GetMovieCollection", ctx, id)}
}

func (_c *MockMovieRepository_GetMovieCollection_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockMovieRepository_GetMovieCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_GetMovieCollection_Call) Return(_a0 *MovieCollection, _a1 error) *MockMovieRepository_GetMovieCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_GetMovieCollection_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*MovieCollection, error)) *MockMovieRepository_GetMovieCollection_Call {
	_c.Call.Return(run)
	return _c
}

// GetMovieCollectionByTMDbID provides a mock function with given fields: ctx, tmdbCollectionID
func (_m *MockMovieRepository) GetMovieCollectionByTMDbID(ctx context.Context, tmdbCollectionID int32) (*MovieCollection, error) {
	ret := _m.Called(ctx, tmdbCollectionID)

	if len(ret) == 0 {
		panic("no return value specified for GetMovieCollectionByTMDbID")
	}

	var r0 *MovieCollection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32) (*MovieCollection, error)); ok {
		return rf(ctx, tmdbCollectionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32) *MovieCollection); ok {
		r0 = rf(ctx, tmdbCollectionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieCollection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32) error); ok {
		r1 = rf(ctx, tmdbCollectionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_GetMovieCollectionByTMDbID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMovieCollectionByTMDbID'
type MockMovieRepository_GetMovieCollectionByTMDbID_Call struct {
	*mock.Call
}

// GetMovieCollectionByTMDbID is a helper method to define mock.On call
//   - ctx context.Context
//   - tmdbCollectionID int32
func (_e *MockMovieRepository_Expecter) GetMovieCollectionByTMDbID(ctx interface{}, tmdbCollectionID interface{}) *MockMovieRepository_GetMovieCollectionByTMDbID_Call {
	return &MockMovieRepository_GetMovieCollectionByTMDbID_Call{Call: _e.mock.On("GetMovieCollectionByTMDbID", ctx, tmdbCollectionID)}
}

func (_c *MockMovieRepository_GetMovieCollectionByTMDbID_Call) Run(run func(ctx context.Context, tmdbCollectionID int32)) *MockMovieRepository_GetMovieCollectionByTMDbID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_GetMovieCollectionByTMDbID_Call) Return(_a0 *MovieCollection, _a1 error) *MockMovieRepository_GetMovieCollectionByTMDbID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_GetMovieCollectionByTMDbID_Call) RunAndReturn(run func(context.Context, int32) (*MovieCollection, error)) *MockMovieRepository_GetMovieCollectionByTMDbID_Call {
	_c.Call.Return(run)
	return _c
}

// GetMovieFile provides a mock function with given fields: ctx, id
func (_m *MockMovieRepository) GetMovieFile(ctx context.Context, id uuid.UUID) (*MovieFile, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetMovieFile")
	}

	var r0 *MovieFile
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*MovieFile, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *MovieFile); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieFile)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_GetMovieFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMovieFile'
type MockMovieRepository_GetMovieFile_Call struct {
	*mock.Call
}

// GetMovieFile is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockMovieRepository_Expecter) GetMovieFile(ctx interface{}, id interface{}) *MockMovieRepository_GetMovieFile_Call {
	return &MockMovieRepository_GetMovieFile_Call{Call: _e.mock.On("GetMovieFile", ctx, id)}
}

func (_c *MockMovieRepository_GetMovieFile_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockMovieRepository_GetMovieFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_GetMovieFile_Call) Return(_a0 *MovieFile, _a1 error) *MockMovieRepository_GetMovieFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_GetMovieFile_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*MovieFile, error)) *MockMovieRepository_GetMovieFile_Call {
	_c.Call.Return(run)
	return _c
}

// GetMovieFileByPath provides a mock function with given fields: ctx, path
func (_m *MockMovieRepository) GetMovieFileByPath(ctx context.Context, path string) (*MovieFile, error) {
	ret := _m.Called(ctx, path)

	if len(ret) == 0 {
		panic("no return value specified for GetMovieFileByPath")
	}

	var r0 *MovieFile
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*MovieFile, error)); ok {
		return rf(ctx, path)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *MovieFile); ok {
		r0 = rf(ctx, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieFile)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_GetMovieFileByPath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMovieFileByPath'
type MockMovieRepository_GetMovieFileByPath_Call struct {
	*mock.Call
}

// GetMovieFileByPath is a helper method to define mock.On call
//   - ctx context.Context
//   - path string
func (_e *MockMovieRepository_Expecter) GetMovieFileByPath(ctx interface{}, path interface{}) *MockMovieRepository_GetMovieFileByPath_Call {
	return &MockMovieRepository_GetMovieFileByPath_Call{Call: _e.mock.On("GetMovieFileByPath", ctx, path)}
}

func (_c *MockMovieRepository_GetMovieFileByPath_Call) Run(run func(ctx context.Context, path string)) *MockMovieRepository_GetMovieFileByPath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockMovieRepository_GetMovieFileByPath_Call) Return(_a0 *MovieFile, _a1 error) *MockMovieRepository_GetMovieFileByPath_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_GetMovieFileByPath_Call) RunAndReturn(run func(context.Context, string) (*MovieFile, error)) *MockMovieRepository_GetMovieFileByPath_Call {
	_c.Call.Return(run)
	return _c
}

// GetMovieFileByRadarrID provides a mock function with given fields: ctx, radarrFileID
func (_m *MockMovieRepository) GetMovieFileByRadarrID(ctx context.Context, radarrFileID int32) (*MovieFile, error) {
	ret := _m.Called(ctx, radarrFileID)

	if len(ret) == 0 {
		panic("no return value specified for GetMovieFileByRadarrID")
	}

	var r0 *MovieFile
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32) (*MovieFile, error)); ok {
		return rf(ctx, radarrFileID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32) *MovieFile); ok {
		r0 = rf(ctx, radarrFileID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieFile)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32) error); ok {
		r1 = rf(ctx, radarrFileID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_GetMovieFileByRadarrID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMovieFileByRadarrID'
type MockMovieRepository_GetMovieFileByRadarrID_Call struct {
	*mock.Call
}

// GetMovieFileByRadarrID is a helper method to define mock.On call
//   - ctx context.Context
//   - radarrFileID int32
func (_e *MockMovieRepository_Expecter) GetMovieFileByRadarrID(ctx interface{}, radarrFileID interface{}) *MockMovieRepository_GetMovieFileByRadarrID_Call {
	return &MockMovieRepository_GetMovieFileByRadarrID_Call{Call: _e.mock.On("GetMovieFileByRadarrID", ctx, radarrFileID)}
}

func (_c *MockMovieRepository_GetMovieFileByRadarrID_Call) Run(run func(ctx context.Context, radarrFileID int32)) *MockMovieRepository_GetMovieFileByRadarrID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_GetMovieFileByRadarrID_Call) Return(_a0 *MovieFile, _a1 error) *MockMovieRepository_GetMovieFileByRadarrID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_GetMovieFileByRadarrID_Call) RunAndReturn(run func(context.Context, int32) (*MovieFile, error)) *MockMovieRepository_GetMovieFileByRadarrID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserMovieStats provides a mock function with given fields: ctx, userID
func (_m *MockMovieRepository) GetUserMovieStats(ctx context.Context, userID uuid.UUID) (*UserMovieStats, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserMovieStats")
	}

	var r0 *UserMovieStats
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*UserMovieStats, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *UserMovieStats); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UserMovieStats)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_GetUserMovieStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserMovieStats'
type MockMovieRepository_GetUserMovieStats_Call struct {
	*mock.Call
}

// GetUserMovieStats is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
func (_e *MockMovieRepository_Expecter) GetUserMovieStats(ctx interface{}, userID interface{}) *MockMovieRepository_GetUserMovieStats_Call {
	return &MockMovieRepository_GetUserMovieStats_Call{Call: _e.mock.On("GetUserMovieStats", ctx, userID)}
}

func (_c *MockMovieRepository_GetUserMovieStats_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockMovieRepository_GetUserMovieStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_GetUserMovieStats_Call) Return(_a0 *UserMovieStats, _a1 error) *MockMovieRepository_GetUserMovieStats_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_GetUserMovieStats_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*UserMovieStats, error)) *MockMovieRepository_GetUserMovieStats_Call {
	_c.Call.Return(run)
	return _c
}

// GetWatchProgress provides a mock function with given fields: ctx, userID, movieID
func (_m *MockMovieRepository) GetWatchProgress(ctx context.Context, userID uuid.UUID, movieID uuid.UUID) (*MovieWatched, error) {
	ret := _m.Called(ctx, userID, movieID)

	if len(ret) == 0 {
		panic("no return value specified for GetWatchProgress")
	}

	var r0 *MovieWatched
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) (*MovieWatched, error)); ok {
		return rf(ctx, userID, movieID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) *MovieWatched); ok {
		r0 = rf(ctx, userID, movieID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieWatched)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID) error); ok {
		r1 = rf(ctx, userID, movieID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_GetWatchProgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWatchProgress'
type MockMovieRepository_GetWatchProgress_Call struct {
	*mock.Call
}

// GetWatchProgress is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - movieID uuid.UUID
func (_e *MockMovieRepository_Expecter) GetWatchProgress(ctx interface{}, userID interface{}, movieID interface{}) *MockMovieRepository_GetWatchProgress_Call {
	return &MockMovieRepository_GetWatchProgress_Call{Call: _e.mock.On("GetWatchProgress", ctx, userID, movieID)}
}

func (_c *MockMovieRepository_GetWatchProgress_Call) Run(run func(ctx context.Context, userID uuid.UUID, movieID uuid.UUID)) *MockMovieRepository_GetWatchProgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_GetWatchProgress_Call) Return(_a0 *MovieWatched, _a1 error) *MockMovieRepository_GetWatchProgress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_GetWatchProgress_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID) (*MovieWatched, error)) *MockMovieRepository_GetWatchProgress_Call {
	_c.Call.Return(run)
	return _c
}

// ListContinueWatching provides a mock function with given fields: ctx, userID, limit
func (_m *MockMovieRepository) ListContinueWatching(ctx context.Context, userID uuid.UUID, limit int32) ([]ContinueWatchingItem, error) {
	ret := _m.Called(ctx, userID, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListContinueWatching")
	}

	var r0 []ContinueWatchingItem
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int32) ([]ContinueWatchingItem, error)); ok {
		return rf(ctx, userID, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int32) []ContinueWatchingItem); ok {
		r0 = rf(ctx, userID, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ContinueWatchingItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, int32) error); ok {
		r1 = rf(ctx, userID, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_ListContinueWatching_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListContinueWatching'
type MockMovieRepository_ListContinueWatching_Call struct {
	*mock.Call
}

// ListContinueWatching is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - limit int32
func (_e *MockMovieRepository_Expecter) ListContinueWatching(ctx interface{}, userID interface{}, limit interface{}) *MockMovieRepository_ListContinueWatching_Call {
	return &MockMovieRepository_ListContinueWatching_Call{Call: _e.mock.On("ListContinueWatching", ctx, userID, limit)}
}

func (_c *MockMovieRepository_ListContinueWatching_Call) Run(run func(ctx context.Context, userID uuid.UUID, limit int32)) *MockMovieRepository_ListContinueWatching_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_ListContinueWatching_Call) Return(_a0 []ContinueWatchingItem, _a1 error) *MockMovieRepository_ListContinueWatching_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_ListContinueWatching_Call) RunAndReturn(run func(context.Context, uuid.UUID, int32) ([]ContinueWatchingItem, error)) *MockMovieRepository_ListContinueWatching_Call {
	_c.Call.Return(run)
	return _c
}

// ListMovieCast provides a mock function with given fields: ctx, movieID, limit, offset
func (_m *MockMovieRepository) ListMovieCast(ctx context.Context, movieID uuid.UUID, limit int32, offset int32) ([]MovieCredit, error) {
	ret := _m.Called(ctx, movieID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListMovieCast")
	}

	var r0 []MovieCredit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int32, int32) ([]MovieCredit, error)); ok {
		return rf(ctx, movieID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int32, int32) []MovieCredit); ok {
		r0 = rf(ctx, movieID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]MovieCredit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, int32, int32) error); ok {
		r1 = rf(ctx, movieID, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_ListMovieCast_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMovieCast'
type MockMovieRepository_ListMovieCast_Call struct {
	*mock.Call
}

// ListMovieCast is a helper method to define mock.On call
//   - ctx context.Context
//   - movieID uuid.UUID
//   - limit int32
//   - offset int32
func (_e *MockMovieRepository_Expecter) ListMovieCast(ctx interface{}, movieID interface{}, limit interface{}, offset interface{}) *MockMovieRepository_ListMovieCast_Call {
	return &MockMovieRepository_ListMovieCast_Call{Call: _e.mock.On("ListMovieCast", ctx, movieID, limit, offset)}
}

func (_c *MockMovieRepository_ListMovieCast_Call) Run(run func(ctx context.Context, movieID uuid.UUID, limit int32, offset int32)) *MockMovieRepository_ListMovieCast_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int32), args[3].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_ListMovieCast_Call) Return(_a0 []MovieCredit, _a1 error) *MockMovieRepository_ListMovieCast_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_ListMovieCast_Call) RunAndReturn(run func(context.Context, uuid.UUID, int32, int32) ([]MovieCredit, error)) *MockMovieRepository_ListMovieCast_Call {
	_c.Call.Return(run)
	return _c
}

// ListMovieCrew provides a mock function with given fields: ctx, movieID, limit, offset
func (_m *MockMovieRepository) ListMovieCrew(ctx context.Context, movieID uuid.UUID, limit int32, offset int32) ([]MovieCredit, error) {
	ret := _m.Called(ctx, movieID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListMovieCrew")
	}

	var r0 []MovieCredit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int32, int32) ([]MovieCredit, error)); ok {
		return rf(ctx, movieID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int32, int32) []MovieCredit); ok {
		r0 = rf(ctx, movieID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]MovieCredit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, int32, int32) error); ok {
		r1 = rf(ctx, movieID, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_ListMovieCrew_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMovieCrew'
type MockMovieRepository_ListMovieCrew_Call struct {
	*mock.Call
}

// ListMovieCrew is a helper method to define mock.On call
//   - ctx context.Context
//   - movieID uuid.UUID
//   - limit int32
//   - offset int32
func (_e *MockMovieRepository_Expecter) ListMovieCrew(ctx interface{}, movieID interface{}, limit interface{}, offset interface{}) *MockMovieRepository_ListMovieCrew_Call {
	return &MockMovieRepository_ListMovieCrew_Call{Call: _e.mock.On("ListMovieCrew", ctx, movieID, limit, offset)}
}

func (_c *MockMovieRepository_ListMovieCrew_Call) Run(run func(ctx context.Context, movieID uuid.UUID, limit int32, offset int32)) *MockMovieRepository_ListMovieCrew_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int32), args[3].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_ListMovieCrew_Call) Return(_a0 []MovieCredit, _a1 error) *MockMovieRepository_ListMovieCrew_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_ListMovieCrew_Call) RunAndReturn(run func(context.Context, uuid.UUID, int32, int32) ([]MovieCredit, error)) *MockMovieRepository_ListMovieCrew_Call {
	_c.Call.Return(run)
	return _c
}

// ListMovieFilesByMovieID provides a mock function with given fields: ctx, movieID
func (_m *MockMovieRepository) ListMovieFilesByMovieID(ctx context.Context, movieID uuid.UUID) ([]MovieFile, error) {
	ret := _m.Called(ctx, movieID)

	if len(ret) == 0 {
		panic("no return value specified for ListMovieFilesByMovieID")
	}

	var r0 []MovieFile
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]MovieFile, error)); ok {
		return rf(ctx, movieID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) []MovieFile); ok {
		r0 = rf(ctx, movieID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]MovieFile)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, movieID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_ListMovieFilesByMovieID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMovieFilesByMovieID'
type MockMovieRepository_ListMovieFilesByMovieID_Call struct {
	*mock.Call
}

// ListMovieFilesByMovieID is a helper method to define mock.On call
//   - ctx context.Context
//   - movieID uuid.UUID
func (_e *MockMovieRepository_Expecter) ListMovieFilesByMovieID(ctx interface{}, movieID interface{}) *MockMovieRepository_ListMovieFilesByMovieID_Call {
	return &MockMovieRepository_ListMovieFilesByMovieID_Call{Call: _e.mock.On("ListMovieFilesByMovieID", ctx, movieID)}
}

func (_c *MockMovieRepository_ListMovieFilesByMovieID_Call) Run(run func(ctx context.Context, movieID uuid.UUID)) *MockMovieRepository_ListMovieFilesByMovieID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_ListMovieFilesByMovieID_Call) Return(_a0 []MovieFile, _a1 error) *MockMovieRepository_ListMovieFilesByMovieID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_ListMovieFilesByMovieID_Call) RunAndReturn(run func(context.Context, uuid.UUID) ([]MovieFile, error)) *MockMovieRepository_ListMovieFilesByMovieID_Call {
	_c.Call.Return(run)
	return _c
}

// ListMovieGenres provides a mock function with given fields: ctx, movieID
func (_m *MockMovieRepository) ListMovieGenres(ctx context.Context, movieID uuid.UUID) ([]MovieGenre, error) {
	ret := _m.Called(ctx, movieID)

	if len(ret) == 0 {
		panic("no return value specified for ListMovieGenres")
	}

	var r0 []MovieGenre
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]MovieGenre, error)); ok {
		return rf(ctx, movieID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) []MovieGenre); ok {
		r0 = rf(ctx, movieID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]MovieGenre)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, movieID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_ListMovieGenres_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMovieGenres'
type MockMovieRepository_ListMovieGenres_Call struct {
	*mock.Call
}

// ListMovieGenres is a helper method to define mock.On call
//   - ctx context.Context
//   - movieID uuid.UUID
func (_e *MockMovieRepository_Expecter) ListMovieGenres(ctx interface{}, movieID interface{}) *MockMovieRepository_ListMovieGenres_Call {
	return &MockMovieRepository_ListMovieGenres_Call{Call: _e.mock.On("ListMovieGenres", ctx, movieID)}
}

func (_c *MockMovieRepository_ListMovieGenres_Call) Run(run func(ctx context.Context, movieID uuid.UUID)) *MockMovieRepository_ListMovieGenres_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_ListMovieGenres_Call) Return(_a0 []MovieGenre, _a1 error) *MockMovieRepository_ListMovieGenres_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_ListMovieGenres_Call) RunAndReturn(run func(context.Context, uuid.UUID) ([]MovieGenre, error)) *MockMovieRepository_ListMovieGenres_Call {
	_c.Call.Return(run)
	return _c
}

// ListMovies provides a mock function with given fields: ctx, filters
func (_m *MockMovieRepository) ListMovies(ctx context.Context, filters ListFilters) ([]Movie, error) {
	ret := _m.Called(ctx, filters)

	if len(ret) == 0 {
		panic("no return value specified for ListMovies")
	}

	var r0 []Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ListFilters) ([]Movie, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ListFilters) []Movie); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ListFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_ListMovies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMovies'
type MockMovieRepository_ListMovies_Call struct {
	*mock.Call
}

// ListMovies is a helper method to define mock.On call
//   - ctx context.Context
//   - filters ListFilters
func (_e *MockMovieRepository_Expecter) ListMovies(ctx interface{}, filters interface{}) *MockMovieRepository_ListMovies_Call {
	return &MockMovieRepository_ListMovies_Call{Call: _e.mock.On("ListMovies", ctx, filters)}
}

func (_c *MockMovieRepository_ListMovies_Call) Run(run func(ctx context.Context, filters ListFilters)) *MockMovieRepository_ListMovies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ListFilters))
	})
	return _c
}

func (_c *MockMovieRepository_ListMovies_Call) Return(_a0 []Movie, _a1 error) *MockMovieRepository_ListMovies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_ListMovies_Call) RunAndReturn(run func(context.Context, ListFilters) ([]Movie, error)) *MockMovieRepository_ListMovies_Call {
	_c.Call.Return(run)
	return _c
}

// ListMoviesByCollection provides a mock function with given fields: ctx, collectionID
func (_m *MockMovieRepository) ListMoviesByCollection(ctx context.Context, collectionID uuid.UUID) ([]Movie, error) {
	ret := _m.Called(ctx, collectionID)

	if len(ret) == 0 {
		panic("no return value specified for ListMoviesByCollection")
	}

	var r0 []Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]Movie, error)); ok {
		return rf(ctx, collectionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) []Movie); ok {
		r0 = rf(ctx, collectionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, collectionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_ListMoviesByCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMoviesByCollection'
type MockMovieRepository_ListMoviesByCollection_Call struct {
	*mock.Call
}

// ListMoviesByCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - collectionID uuid.UUID
func (_e *MockMovieRepository_Expecter) ListMoviesByCollection(ctx interface{}, collectionID interface{}) *MockMovieRepository_ListMoviesByCollection_Call {
	return &MockMovieRepository_ListMoviesByCollection_Call{Call: _e.mock.On("ListMoviesByCollection", ctx, collectionID)}
}

func (_c *MockMovieRepository_ListMoviesByCollection_Call) Run(run func(ctx context.Context, collectionID uuid.UUID)) *MockMovieRepository_ListMoviesByCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_ListMoviesByCollection_Call) Return(_a0 []Movie, _a1 error) *MockMovieRepository_ListMoviesByCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_ListMoviesByCollection_Call) RunAndReturn(run func(context.Context, uuid.UUID) ([]Movie, error)) *MockMovieRepository_ListMoviesByCollection_Call {
	_c.Call.Return(run)
	return _c
}

// ListMoviesByGenre provides a mock function with given fields: ctx, tmdbGenreID, limit, offset
func (_m *MockMovieRepository) ListMoviesByGenre(ctx context.Context, tmdbGenreID int32, limit int32, offset int32) ([]Movie, error) {
	ret := _m.Called(ctx, tmdbGenreID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListMoviesByGenre")
	}

	var r0 []Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, int32, int32) ([]Movie, error)); ok {
		return rf(ctx, tmdbGenreID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, int32, int32) []Movie); ok {
		r0 = rf(ctx, tmdbGenreID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, int32, int32) error); ok {
		r1 = rf(ctx, tmdbGenreID, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_ListMoviesByGenre_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMoviesByGenre'
type MockMovieRepository_ListMoviesByGenre_Call struct {
	*mock.Call
}

// ListMoviesByGenre is a helper method to define mock.On call
//   - ctx context.Context
//   - tmdbGenreID int32
//   - limit int32
//   - offset int32
func (_e *MockMovieRepository_Expecter) ListMoviesByGenre(ctx interface{}, tmdbGenreID interface{}, limit interface{}, offset interface{}) *MockMovieRepository_ListMoviesByGenre_Call {
	return &MockMovieRepository_ListMoviesByGenre_Call{Call: _e.mock.On("ListMoviesByGenre", ctx, tmdbGenreID, limit, offset)}
}

func (_c *MockMovieRepository_ListMoviesByGenre_Call) Run(run func(ctx context.Context, tmdbGenreID int32, limit int32, offset int32)) *MockMovieRepository_ListMoviesByGenre_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(int32), args[3].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_ListMoviesByGenre_Call) Return(_a0 []Movie, _a1 error) *MockMovieRepository_ListMoviesByGenre_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_ListMoviesByGenre_Call) RunAndReturn(run func(context.Context, int32, int32, int32) ([]Movie, error)) *MockMovieRepository_ListMoviesByGenre_Call {
	_c.Call.Return(run)
	return _c
}

// ListMoviesByYear provides a mock function with given fields: ctx, year, limit, offset
func (_m *MockMovieRepository) ListMoviesByYear(ctx context.Context, year int32, limit int32, offset int32) ([]Movie, error) {
	ret := _m.Called(ctx, year, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListMoviesByYear")
	}

	var r0 []Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, int32, int32) ([]Movie, error)); ok {
		return rf(ctx, year, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, int32, int32) []Movie); ok {
		r0 = rf(ctx, year, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, int32, int32) error); ok {
		r1 = rf(ctx, year, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_ListMoviesByYear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMoviesByYear'
type MockMovieRepository_ListMoviesByYear_Call struct {
	*mock.Call
}

// ListMoviesByYear is a helper method to define mock.On call
//   - ctx context.Context
//   - year int32
//   - limit int32
//   - offset int32
func (_e *MockMovieRepository_Expecter) ListMoviesByYear(ctx interface{}, year interface{}, limit interface{}, offset interface{}) *MockMovieRepository_ListMoviesByYear_Call {
	return &MockMovieRepository_ListMoviesByYear_Call{Call: _e.mock.On("ListMoviesByYear", ctx, year, limit, offset)}
}

func (_c *MockMovieRepository_ListMoviesByYear_Call) Run(run func(ctx context.Context, year int32, limit int32, offset int32)) *MockMovieRepository_ListMoviesByYear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(int32), args[3].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_ListMoviesByYear_Call) Return(_a0 []Movie, _a1 error) *MockMovieRepository_ListMoviesByYear_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_ListMoviesByYear_Call) RunAndReturn(run func(context.Context, int32, int32, int32) ([]Movie, error)) *MockMovieRepository_ListMoviesByYear_Call {
	_c.Call.Return(run)
	return _c
}

// ListRecentlyAdded provides a mock function with given fields: ctx, limit, offset
func (_m *MockMovieRepository) ListRecentlyAdded(ctx context.Context, limit int32, offset int32) ([]Movie, error) {
	ret := _m.Called(ctx, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListRecentlyAdded")
	}

	var r0 []Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, int32) ([]Movie, error)); ok {
		return rf(ctx, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, int32) []Movie); ok {
		r0 = rf(ctx, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, int32) error); ok {
		r1 = rf(ctx, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_ListRecentlyAdded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRecentlyAdded'
type MockMovieRepository_ListRecentlyAdded_Call struct {
	*mock.Call
}

// ListRecentlyAdded is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int32
//   - offset int32
func (_e *MockMovieRepository_Expecter) ListRecentlyAdded(ctx interface{}, limit interface{}, offset interface{}) *MockMovieRepository_ListRecentlyAdded_Call {
	return &MockMovieRepository_ListRecentlyAdded_Call{Call: _e.mock.On("ListRecentlyAdded", ctx, limit, offset)}
}

func (_c *MockMovieRepository_ListRecentlyAdded_Call) Run(run func(ctx context.Context, limit int32, offset int32)) *MockMovieRepository_ListRecentlyAdded_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_ListRecentlyAdded_Call) Return(_a0 []Movie, _a1 error) *MockMovieRepository_ListRecentlyAdded_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_ListRecentlyAdded_Call) RunAndReturn(run func(context.Context, int32, int32) ([]Movie, error)) *MockMovieRepository_ListRecentlyAdded_Call {
	_c.Call.Return(run)
	return _c
}

// ListTopRated provides a mock function with given fields: ctx, minVotes, limit, offset
func (_m *MockMovieRepository) ListTopRated(ctx context.Context, minVotes int32, limit int32, offset int32) ([]Movie, error) {
	ret := _m.Called(ctx, minVotes, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListTopRated")
	}

	var r0 []Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, int32, int32) ([]Movie, error)); ok {
		return rf(ctx, minVotes, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, int32, int32) []Movie); ok {
		r0 = rf(ctx, minVotes, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, int32, int32) error); ok {
		r1 = rf(ctx, minVotes, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_ListTopRated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTopRated'
type MockMovieRepository_ListTopRated_Call struct {
	*mock.Call
}

// ListTopRated is a helper method to define mock.On call
//   - ctx context.Context
//   - minVotes int32
//   - limit int32
//   - offset int32
func (_e *MockMovieRepository_Expecter) ListTopRated(ctx interface{}, minVotes interface{}, limit interface{}, offset interface{}) *MockMovieRepository_ListTopRated_Call {
	return &MockMovieRepository_ListTopRated_Call{Call: _e.mock.On("ListTopRated", ctx, minVotes, limit, offset)}
}

func (_c *MockMovieRepository_ListTopRated_Call) Run(run func(ctx context.Context, minVotes int32, limit int32, offset int32)) *MockMovieRepository_ListTopRated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(int32), args[3].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_ListTopRated_Call) Return(_a0 []Movie, _a1 error) *MockMovieRepository_ListTopRated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_ListTopRated_Call) RunAndReturn(run func(context.Context, int32, int32, int32) ([]Movie, error)) *MockMovieRepository_ListTopRated_Call {
	_c.Call.Return(run)
	return _c
}

// ListWatchedMovies provides a mock function with given fields: ctx, userID, limit, offset
func (_m *MockMovieRepository) ListWatchedMovies(ctx context.Context, userID uuid.UUID, limit int32, offset int32) ([]WatchedMovieItem, error) {
	ret := _m.Called(ctx, userID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListWatchedMovies")
	}

	var r0 []WatchedMovieItem
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int32, int32) ([]WatchedMovieItem, error)); ok {
		return rf(ctx, userID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int32, int32) []WatchedMovieItem); ok {
		r0 = rf(ctx, userID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]WatchedMovieItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, int32, int32) error); ok {
		r1 = rf(ctx, userID, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_ListWatchedMovies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWatchedMovies'
type MockMovieRepository_ListWatchedMovies_Call struct {
	*mock.Call
}

// ListWatchedMovies is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - limit int32
//   - offset int32
func (_e *MockMovieRepository_Expecter) ListWatchedMovies(ctx interface{}, userID interface{}, limit interface{}, offset interface{}) *MockMovieRepository_ListWatchedMovies_Call {
	return &MockMovieRepository_ListWatchedMovies_Call{Call: _e.mock.On("ListWatchedMovies", ctx, userID, limit, offset)}
}

func (_c *MockMovieRepository_ListWatchedMovies_Call) Run(run func(ctx context.Context, userID uuid.UUID, limit int32, offset int32)) *MockMovieRepository_ListWatchedMovies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int32), args[3].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_ListWatchedMovies_Call) Return(_a0 []WatchedMovieItem, _a1 error) *MockMovieRepository_ListWatchedMovies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_ListWatchedMovies_Call) RunAndReturn(run func(context.Context, uuid.UUID, int32, int32) ([]WatchedMovieItem, error)) *MockMovieRepository_ListWatchedMovies_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveMovieFromCollection provides a mock function with given fields: ctx, collectionID, movieID
func (_m *MockMovieRepository) RemoveMovieFromCollection(ctx context.Context, collectionID uuid.UUID, movieID uuid.UUID) error {
	ret := _m.Called(ctx, collectionID, movieID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveMovieFromCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) error); ok {
		r0 = rf(ctx, collectionID, movieID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockMovieRepository_RemoveMovieFromCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveMovieFromCollection'
type MockMovieRepository_RemoveMovieFromCollection_Call struct {
	*mock.Call
}

// RemoveMovieFromCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - collectionID uuid.UUID
//   - movieID uuid.UUID
func (_e *MockMovieRepository_Expecter) RemoveMovieFromCollection(ctx interface{}, collectionID interface{}, movieID interface{}) *MockMovieRepository_RemoveMovieFromCollection_Call {
	return &MockMovieRepository_RemoveMovieFromCollection_Call{Call: _e.mock.On("RemoveMovieFromCollection", ctx, collectionID, movieID)}
}

func (_c *MockMovieRepository_RemoveMovieFromCollection_Call) Run(run func(ctx context.Context, collectionID uuid.UUID, movieID uuid.UUID)) *MockMovieRepository_RemoveMovieFromCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *MockMovieRepository_RemoveMovieFromCollection_Call) Return(_a0 error) *MockMovieRepository_RemoveMovieFromCollection_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockMovieRepository_RemoveMovieFromCollection_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID) error) *MockMovieRepository_RemoveMovieFromCollection_Call {
	_c.Call.Return(run)
	return _c
}

// SearchMoviesByTitle provides a mock function with given fields: ctx, query, limit, offset
func (_m *MockMovieRepository) SearchMoviesByTitle(ctx context.Context, query string, limit int32, offset int32) ([]Movie, error) {
	ret := _m.Called(ctx, query, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for SearchMoviesByTitle")
	}

	var r0 []Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int32, int32) ([]Movie, error)); ok {
		return rf(ctx, query, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int32, int32) []Movie); ok {
		r0 = rf(ctx, query, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int32, int32) error); ok {
		r1 = rf(ctx, query, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_SearchMoviesByTitle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchMoviesByTitle'
type MockMovieRepository_SearchMoviesByTitle_Call struct {
	*mock.Call
}

// SearchMoviesByTitle is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - limit int32
//   - offset int32
func (_e *MockMovieRepository_Expecter) SearchMoviesByTitle(ctx interface{}, query interface{}, limit interface{}, offset interface{}) *MockMovieRepository_SearchMoviesByTitle_Call {
	return &MockMovieRepository_SearchMoviesByTitle_Call{Call: _e.mock.On("SearchMoviesByTitle", ctx, query, limit, offset)}
}

func (_c *MockMovieRepository_SearchMoviesByTitle_Call) Run(run func(ctx context.Context, query string, limit int32, offset int32)) *MockMovieRepository_SearchMoviesByTitle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int32), args[3].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_SearchMoviesByTitle_Call) Return(_a0 []Movie, _a1 error) *MockMovieRepository_SearchMoviesByTitle_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_SearchMoviesByTitle_Call) RunAndReturn(run func(context.Context, string, int32, int32) ([]Movie, error)) *MockMovieRepository_SearchMoviesByTitle_Call {
	_c.Call.Return(run)
	return _c
}

// SearchMoviesByTitleAnyLanguage provides a mock function with given fields: ctx, query, limit, offset
func (_m *MockMovieRepository) SearchMoviesByTitleAnyLanguage(ctx context.Context, query string, limit int32, offset int32) ([]Movie, error) {
	ret := _m.Called(ctx, query, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for SearchMoviesByTitleAnyLanguage")
	}

	var r0 []Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int32, int32) ([]Movie, error)); ok {
		return rf(ctx, query, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int32, int32) []Movie); ok {
		r0 = rf(ctx, query, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int32, int32) error); ok {
		r1 = rf(ctx, query, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_SearchMoviesByTitleAnyLanguage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchMoviesByTitleAnyLanguage'
type MockMovieRepository_SearchMoviesByTitleAnyLanguage_Call struct {
	*mock.Call
}

// SearchMoviesByTitleAnyLanguage is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - limit int32
//   - offset int32
func (_e *MockMovieRepository_Expecter) SearchMoviesByTitleAnyLanguage(ctx interface{}, query interface{}, limit interface{}, offset interface{}) *MockMovieRepository_SearchMoviesByTitleAnyLanguage_Call {
	return &MockMovieRepository_SearchMoviesByTitleAnyLanguage_Call{Call: _e.mock.On("SearchMoviesByTitleAnyLanguage", ctx, query, limit, offset)}
}

func (_c *MockMovieRepository_SearchMoviesByTitleAnyLanguage_Call) Run(run func(ctx context.Context, query string, limit int32, offset int32)) *MockMovieRepository_SearchMoviesByTitleAnyLanguage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int32), args[3].(int32))
	})
	return _c
}

func (_c *MockMovieRepository_SearchMoviesByTitleAnyLanguage_Call) Return(_a0 []Movie, _a1 error) *MockMovieRepository_SearchMoviesByTitleAnyLanguage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_SearchMoviesByTitleAnyLanguage_Call) RunAndReturn(run func(context.Context, string, int32, int32) ([]Movie, error)) *MockMovieRepository_SearchMoviesByTitleAnyLanguage_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMovie provides a mock function with given fields: ctx, params
func (_m *MockMovieRepository) UpdateMovie(ctx context.Context, params UpdateMovieParams) (*Movie, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMovie")
	}

	var r0 *Movie
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, UpdateMovieParams) (*Movie, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, UpdateMovieParams) *Movie); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Movie)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, UpdateMovieParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_UpdateMovie_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMovie'
type MockMovieRepository_UpdateMovie_Call struct {
	*mock.Call
}

// UpdateMovie is a helper method to define mock.On call
//   - ctx context.Context
//   - params UpdateMovieParams
func (_e *MockMovieRepository_Expecter) UpdateMovie(ctx interface{}, params interface{}) *MockMovieRepository_UpdateMovie_Call {
	return &MockMovieRepository_UpdateMovie_Call{Call: _e.mock.On("UpdateMovie", ctx, params)}
}

func (_c *MockMovieRepository_UpdateMovie_Call) Run(run func(ctx context.Context, params UpdateMovieParams)) *MockMovieRepository_UpdateMovie_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(UpdateMovieParams))
	})
	return _c
}

func (_c *MockMovieRepository_UpdateMovie_Call) Return(_a0 *Movie, _a1 error) *MockMovieRepository_UpdateMovie_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_UpdateMovie_Call) RunAndReturn(run func(context.Context, UpdateMovieParams) (*Movie, error)) *MockMovieRepository_UpdateMovie_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMovieCollection provides a mock function with given fields: ctx, params
func (_m *MockMovieRepository) UpdateMovieCollection(ctx context.Context, params UpdateMovieCollectionParams) (*MovieCollection, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMovieCollection")
	}

	var r0 *MovieCollection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, UpdateMovieCollectionParams) (*MovieCollection, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, UpdateMovieCollectionParams) *MovieCollection); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieCollection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, UpdateMovieCollectionParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_UpdateMovieCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMovieCollection'
type MockMovieRepository_UpdateMovieCollection_Call struct {
	*mock.Call
}

// UpdateMovieCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - params UpdateMovieCollectionParams
func (_e *MockMovieRepository_Expecter) UpdateMovieCollection(ctx interface{}, params interface{}) *MockMovieRepository_UpdateMovieCollection_Call {
	return &MockMovieRepository_UpdateMovieCollection_Call{Call: _e.mock.On("UpdateMovieCollection", ctx, params)}
}

func (_c *MockMovieRepository_UpdateMovieCollection_Call) Run(run func(ctx context.Context, params UpdateMovieCollectionParams)) *MockMovieRepository_UpdateMovieCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(UpdateMovieCollectionParams))
	})
	return _c
}

func (_c *MockMovieRepository_UpdateMovieCollection_Call) Return(_a0 *MovieCollection, _a1 error) *MockMovieRepository_UpdateMovieCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_UpdateMovieCollection_Call) RunAndReturn(run func(context.Context, UpdateMovieCollectionParams) (*MovieCollection, error)) *MockMovieRepository_UpdateMovieCollection_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMovieFile provides a mock function with given fields: ctx, params
func (_m *MockMovieRepository) UpdateMovieFile(ctx context.Context, params UpdateMovieFileParams) (*MovieFile, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMovieFile")
	}

	var r0 *MovieFile
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, UpdateMovieFileParams) (*MovieFile, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, UpdateMovieFileParams) *MovieFile); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MovieFile)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, UpdateMovieFileParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockMovieRepository_UpdateMovieFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMovieFile'
type MockMovieRepository_UpdateMovieFile_Call struct {
	*mock.Call
}

// UpdateMovieFile is a helper method to define mock.On call
//   - ctx context.Context
//   - params UpdateMovieFileParams
func (_e *MockMovieRepository_Expecter) UpdateMovieFile(ctx interface{}, params interface{}) *MockMovieRepository_UpdateMovieFile_Call {
	return &MockMovieRepository_UpdateMovieFile_Call{Call: _e.mock.On("UpdateMovieFile", ctx, params)}
}

func (_c *MockMovieRepository_UpdateMovieFile_Call) Run(run func(ctx context.Context, params UpdateMovieFileParams)) *MockMovieRepository_UpdateMovieFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(UpdateMovieFileParams))
	})
	return _c
}

func (_c *MockMovieRepository_UpdateMovieFile_Call) Return(_a0 *MovieFile, _a1 error) *MockMovieRepository_UpdateMovieFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockMovieRepository_UpdateMovieFile_Call) RunAndReturn(run func(context.Context, UpdateMovieFileParams) (*MovieFile, error)) *MockMovieRepository_UpdateMovieFile_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMovieRepository creates a new instance of MockMovieRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMovieRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMovieRepository {
	mock := &MockMovieRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
