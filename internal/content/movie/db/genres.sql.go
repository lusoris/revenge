// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: genres.sql

package moviedb

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countMoviesByGenre = `-- name: CountMoviesByGenre :one
SELECT COUNT(*) FROM movie_genre_link WHERE genre_id = $1
`

func (q *Queries) CountMoviesByGenre(ctx context.Context, genreID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMoviesByGenre, genreID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMovieGenres = `-- name: GetMovieGenres :many

SELECT g.id, g.name, g.slug, g.description, g.parent_id, g.external_ids, g.created_at, g.updated_at FROM movie_genres g
JOIN movie_genre_link mg ON g.id = mg.genre_id
WHERE mg.movie_id = $1
ORDER BY g.name ASC
`

// Movie Genre Queries
func (q *Queries) GetMovieGenres(ctx context.Context, movieID uuid.UUID) ([]MovieGenre, error) {
	rows, err := q.db.Query(ctx, getMovieGenres, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieGenre{}
	for rows.Next() {
		var i MovieGenre
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ParentID,
			&i.ExternalIds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkMovieGenre = `-- name: LinkMovieGenre :exec
INSERT INTO movie_genre_link (movie_id, genre_id)
VALUES ($1, $2)
ON CONFLICT (movie_id, genre_id) DO NOTHING
`

type LinkMovieGenreParams struct {
	MovieID uuid.UUID `json:"movieId"`
	GenreID uuid.UUID `json:"genreId"`
}

func (q *Queries) LinkMovieGenre(ctx context.Context, arg LinkMovieGenreParams) error {
	_, err := q.db.Exec(ctx, linkMovieGenre, arg.MovieID, arg.GenreID)
	return err
}

const listGenresWithMovieCounts = `-- name: ListGenresWithMovieCounts :many
SELECT g.id, g.name, g.slug, g.description, g.parent_id, g.external_ids, g.created_at, g.updated_at, COUNT(mg.movie_id) as movie_count
FROM movie_genres g
LEFT JOIN movie_genre_link mg ON g.id = mg.genre_id
GROUP BY g.id
ORDER BY movie_count DESC, g.name ASC
`

type ListGenresWithMovieCountsRow struct {
	ID          uuid.UUID       `json:"id"`
	Name        string          `json:"name"`
	Slug        string          `json:"slug"`
	Description *string         `json:"description"`
	ParentID    pgtype.UUID     `json:"parentId"`
	ExternalIds json.RawMessage `json:"externalIds"`
	CreatedAt   time.Time       `json:"createdAt"`
	UpdatedAt   time.Time       `json:"updatedAt"`
	MovieCount  int64           `json:"movieCount"`
}

func (q *Queries) ListGenresWithMovieCounts(ctx context.Context) ([]ListGenresWithMovieCountsRow, error) {
	rows, err := q.db.Query(ctx, listGenresWithMovieCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGenresWithMovieCountsRow{}
	for rows.Next() {
		var i ListGenresWithMovieCountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ParentID,
			&i.ExternalIds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MovieCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesByGenre = `-- name: ListMoviesByGenre :many
SELECT m.id, m.library_id, m.path, m.container, m.size_bytes, m.runtime_ticks, m.title, m.sort_title, m.original_title, m.tagline, m.overview, m.release_date, m.year, m.content_rating, m.rating_level, m.budget, m.revenue, m.community_rating, m.vote_count, m.critic_rating, m.critic_count, m.poster_path, m.poster_blurhash, m.backdrop_path, m.backdrop_blurhash, m.logo_path, m.tmdb_id, m.imdb_id, m.tvdb_id, m.date_added, m.last_played_at, m.play_count, m.is_locked, m.created_at, m.updated_at, m.collection_id, m.collection_order FROM movies m
JOIN movie_genre_link mg ON m.id = mg.movie_id
WHERE mg.genre_id = $1
ORDER BY m.sort_title ASC
LIMIT $2 OFFSET $3
`

type ListMoviesByGenreParams struct {
	GenreID uuid.UUID `json:"genreId"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListMoviesByGenre(ctx context.Context, arg ListMoviesByGenreParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listMoviesByGenre, arg.GenreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.ReleaseDate,
			&i.Year,
			&i.ContentRating,
			&i.RatingLevel,
			&i.Budget,
			&i.Revenue,
			&i.CommunityRating,
			&i.VoteCount,
			&i.CriticRating,
			&i.CriticCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CollectionID,
			&i.CollectionOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unlinkMovieGenres = `-- name: UnlinkMovieGenres :exec
DELETE FROM movie_genre_link WHERE movie_id = $1
`

func (q *Queries) UnlinkMovieGenres(ctx context.Context, movieID uuid.UUID) error {
	_, err := q.db.Exec(ctx, unlinkMovieGenres, movieID)
	return err
}
