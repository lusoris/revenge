// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_data.sql

package moviedb

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addMovieFavorite = `-- name: AddMovieFavorite :exec
INSERT INTO movie_favorites (user_id, movie_id)
VALUES ($1, $2)
ON CONFLICT (user_id, movie_id) DO NOTHING
`

type AddMovieFavoriteParams struct {
	UserID  uuid.UUID `json:"userId"`
	MovieID uuid.UUID `json:"movieId"`
}

func (q *Queries) AddMovieFavorite(ctx context.Context, arg AddMovieFavoriteParams) error {
	_, err := q.db.Exec(ctx, addMovieFavorite, arg.UserID, arg.MovieID)
	return err
}

const addMovieToWatchlist = `-- name: AddMovieToWatchlist :exec
INSERT INTO movie_watchlist (user_id, movie_id, sort_order)
VALUES ($1, $2, COALESCE($3, (SELECT COALESCE(MAX(sort_order), 0) + 1 FROM movie_watchlist WHERE user_id = $1)))
ON CONFLICT (user_id, movie_id) DO NOTHING
`

type AddMovieToWatchlistParams struct {
	UserID  uuid.UUID   `json:"userId"`
	MovieID uuid.UUID   `json:"movieId"`
	Column3 interface{} `json:"column3"`
}

func (q *Queries) AddMovieToWatchlist(ctx context.Context, arg AddMovieToWatchlistParams) error {
	_, err := q.db.Exec(ctx, addMovieToWatchlist, arg.UserID, arg.MovieID, arg.Column3)
	return err
}

const countUserFavoriteMovies = `-- name: CountUserFavoriteMovies :one
SELECT COUNT(*) FROM movie_favorites WHERE user_id = $1
`

func (q *Queries) CountUserFavoriteMovies(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserFavoriteMovies, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserWatchedMovies = `-- name: CountUserWatchedMovies :one
SELECT COUNT(DISTINCT movie_id) FROM movie_watch_history
WHERE user_id = $1 AND completed = true
`

func (q *Queries) CountUserWatchedMovies(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserWatchedMovies, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserWatchlist = `-- name: CountUserWatchlist :one
SELECT COUNT(*) FROM movie_watchlist WHERE user_id = $1
`

func (q *Queries) CountUserWatchlist(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserWatchlist, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWatchHistory = `-- name: CreateWatchHistory :one
INSERT INTO movie_watch_history (
    user_id, profile_id, movie_id, position_ticks, duration_ticks,
    device_name, device_type, client_name, play_method
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, user_id, profile_id, movie_id, position_ticks, duration_ticks, played_percentage, completed, completed_at, device_name, device_type, client_name, play_method, started_at, last_updated_at
`

type CreateWatchHistoryParams struct {
	UserID        uuid.UUID   `json:"userId"`
	ProfileID     pgtype.UUID `json:"profileId"`
	MovieID       uuid.UUID   `json:"movieId"`
	PositionTicks int64       `json:"positionTicks"`
	DurationTicks *int64      `json:"durationTicks"`
	DeviceName    *string     `json:"deviceName"`
	DeviceType    *string     `json:"deviceType"`
	ClientName    *string     `json:"clientName"`
	PlayMethod    *string     `json:"playMethod"`
}

func (q *Queries) CreateWatchHistory(ctx context.Context, arg CreateWatchHistoryParams) (MovieWatchHistory, error) {
	row := q.db.QueryRow(ctx, createWatchHistory,
		arg.UserID,
		arg.ProfileID,
		arg.MovieID,
		arg.PositionTicks,
		arg.DurationTicks,
		arg.DeviceName,
		arg.DeviceType,
		arg.ClientName,
		arg.PlayMethod,
	)
	var i MovieWatchHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProfileID,
		&i.MovieID,
		&i.PositionTicks,
		&i.DurationTicks,
		&i.PlayedPercentage,
		&i.Completed,
		&i.CompletedAt,
		&i.DeviceName,
		&i.DeviceType,
		&i.ClientName,
		&i.PlayMethod,
		&i.StartedAt,
		&i.LastUpdatedAt,
	)
	return i, err
}

const deleteMovieUserRating = `-- name: DeleteMovieUserRating :exec
DELETE FROM movie_user_ratings
WHERE user_id = $1 AND movie_id = $2
`

type DeleteMovieUserRatingParams struct {
	UserID  uuid.UUID `json:"userId"`
	MovieID uuid.UUID `json:"movieId"`
}

func (q *Queries) DeleteMovieUserRating(ctx context.Context, arg DeleteMovieUserRatingParams) error {
	_, err := q.db.Exec(ctx, deleteMovieUserRating, arg.UserID, arg.MovieID)
	return err
}

const deleteWatchHistory = `-- name: DeleteWatchHistory :exec
DELETE FROM movie_watch_history WHERE id = $1
`

func (q *Queries) DeleteWatchHistory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWatchHistory, id)
	return err
}

const getAverageUserRating = `-- name: GetAverageUserRating :one
SELECT AVG(rating) as avg_rating, COUNT(*) as rating_count
FROM movie_user_ratings
WHERE movie_id = $1
`

type GetAverageUserRatingRow struct {
	AvgRating   float64 `json:"avgRating"`
	RatingCount int64   `json:"ratingCount"`
}

func (q *Queries) GetAverageUserRating(ctx context.Context, movieID uuid.UUID) (GetAverageUserRatingRow, error) {
	row := q.db.QueryRow(ctx, getAverageUserRating, movieID)
	var i GetAverageUserRatingRow
	err := row.Scan(&i.AvgRating, &i.RatingCount)
	return i, err
}

const getCompletedMovieWatchHistory = `-- name: GetCompletedMovieWatchHistory :many
SELECT id, user_id, profile_id, movie_id, position_ticks, duration_ticks, played_percentage, completed, completed_at, device_name, device_type, client_name, play_method, started_at, last_updated_at FROM movie_watch_history
WHERE user_id = $1 AND movie_id = $2 AND completed = true
ORDER BY completed_at DESC
`

type GetCompletedMovieWatchHistoryParams struct {
	UserID  uuid.UUID `json:"userId"`
	MovieID uuid.UUID `json:"movieId"`
}

func (q *Queries) GetCompletedMovieWatchHistory(ctx context.Context, arg GetCompletedMovieWatchHistoryParams) ([]MovieWatchHistory, error) {
	rows, err := q.db.Query(ctx, getCompletedMovieWatchHistory, arg.UserID, arg.MovieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieWatchHistory{}
	for rows.Next() {
		var i MovieWatchHistory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProfileID,
			&i.MovieID,
			&i.PositionTicks,
			&i.DurationTicks,
			&i.PlayedPercentage,
			&i.Completed,
			&i.CompletedAt,
			&i.DeviceName,
			&i.DeviceType,
			&i.ClientName,
			&i.PlayMethod,
			&i.StartedAt,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieExternalRatings = `-- name: GetMovieExternalRatings :many

SELECT movie_id, source, rating, vote_count, certified, last_updated FROM movie_external_ratings
WHERE movie_id = $1
`

// External Ratings
func (q *Queries) GetMovieExternalRatings(ctx context.Context, movieID uuid.UUID) ([]MovieExternalRating, error) {
	rows, err := q.db.Query(ctx, getMovieExternalRatings, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieExternalRating{}
	for rows.Next() {
		var i MovieExternalRating
		if err := rows.Scan(
			&i.MovieID,
			&i.Source,
			&i.Rating,
			&i.VoteCount,
			&i.Certified,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieUserRating = `-- name: GetMovieUserRating :one


SELECT user_id, movie_id, rating, review, created_at, updated_at FROM movie_user_ratings
WHERE user_id = $1 AND movie_id = $2
`

type GetMovieUserRatingParams struct {
	UserID  uuid.UUID `json:"userId"`
	MovieID uuid.UUID `json:"movieId"`
}

// Movie User Data Queries
// User Ratings
func (q *Queries) GetMovieUserRating(ctx context.Context, arg GetMovieUserRatingParams) (MovieUserRating, error) {
	row := q.db.QueryRow(ctx, getMovieUserRating, arg.UserID, arg.MovieID)
	var i MovieUserRating
	err := row.Scan(
		&i.UserID,
		&i.MovieID,
		&i.Rating,
		&i.Review,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMovieWatchHistory = `-- name: GetMovieWatchHistory :one

SELECT id, user_id, profile_id, movie_id, position_ticks, duration_ticks, played_percentage, completed, completed_at, device_name, device_type, client_name, play_method, started_at, last_updated_at FROM movie_watch_history
WHERE user_id = $1 AND movie_id = $2 AND completed = false
ORDER BY last_updated_at DESC
LIMIT 1
`

type GetMovieWatchHistoryParams struct {
	UserID  uuid.UUID `json:"userId"`
	MovieID uuid.UUID `json:"movieId"`
}

// Watch History
func (q *Queries) GetMovieWatchHistory(ctx context.Context, arg GetMovieWatchHistoryParams) (MovieWatchHistory, error) {
	row := q.db.QueryRow(ctx, getMovieWatchHistory, arg.UserID, arg.MovieID)
	var i MovieWatchHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProfileID,
		&i.MovieID,
		&i.PositionTicks,
		&i.DurationTicks,
		&i.PlayedPercentage,
		&i.Completed,
		&i.CompletedAt,
		&i.DeviceName,
		&i.DeviceType,
		&i.ClientName,
		&i.PlayMethod,
		&i.StartedAt,
		&i.LastUpdatedAt,
	)
	return i, err
}

const isMovieFavorite = `-- name: IsMovieFavorite :one

SELECT EXISTS(
    SELECT 1 FROM movie_favorites
    WHERE user_id = $1 AND movie_id = $2
)
`

type IsMovieFavoriteParams struct {
	UserID  uuid.UUID `json:"userId"`
	MovieID uuid.UUID `json:"movieId"`
}

// Favorites
func (q *Queries) IsMovieFavorite(ctx context.Context, arg IsMovieFavoriteParams) (bool, error) {
	row := q.db.QueryRow(ctx, isMovieFavorite, arg.UserID, arg.MovieID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isMovieInWatchlist = `-- name: IsMovieInWatchlist :one

SELECT EXISTS(
    SELECT 1 FROM movie_watchlist
    WHERE user_id = $1 AND movie_id = $2
)
`

type IsMovieInWatchlistParams struct {
	UserID  uuid.UUID `json:"userId"`
	MovieID uuid.UUID `json:"movieId"`
}

// Watchlist
func (q *Queries) IsMovieInWatchlist(ctx context.Context, arg IsMovieInWatchlistParams) (bool, error) {
	row := q.db.QueryRow(ctx, isMovieInWatchlist, arg.UserID, arg.MovieID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isMovieWatched = `-- name: IsMovieWatched :one
SELECT EXISTS(
    SELECT 1 FROM movie_watch_history
    WHERE user_id = $1 AND movie_id = $2 AND completed = true
)
`

type IsMovieWatchedParams struct {
	UserID  uuid.UUID `json:"userId"`
	MovieID uuid.UUID `json:"movieId"`
}

func (q *Queries) IsMovieWatched(ctx context.Context, arg IsMovieWatchedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isMovieWatched, arg.UserID, arg.MovieID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listResumeableMovies = `-- name: ListResumeableMovies :many
SELECT mwh.id, mwh.user_id, mwh.profile_id, mwh.movie_id, mwh.position_ticks, mwh.duration_ticks, mwh.played_percentage, mwh.completed, mwh.completed_at, mwh.device_name, mwh.device_type, mwh.client_name, mwh.play_method, mwh.started_at, mwh.last_updated_at, m.title, m.poster_path, m.runtime_ticks
FROM movie_watch_history mwh
JOIN movies m ON mwh.movie_id = m.id
WHERE mwh.user_id = $1
  AND mwh.completed = false
  AND mwh.played_percentage > 5   -- At least 5% watched
  AND mwh.played_percentage < 90  -- Less than 90% watched
  AND mwh.last_updated_at > NOW() - INTERVAL '30 days'  -- Only show recent activity
ORDER BY mwh.last_updated_at DESC
LIMIT $2
`

type ListResumeableMoviesParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
}

type ListResumeableMoviesRow struct {
	ID               uuid.UUID          `json:"id"`
	UserID           uuid.UUID          `json:"userId"`
	ProfileID        pgtype.UUID        `json:"profileId"`
	MovieID          uuid.UUID          `json:"movieId"`
	PositionTicks    int64              `json:"positionTicks"`
	DurationTicks    *int64             `json:"durationTicks"`
	PlayedPercentage pgtype.Numeric     `json:"playedPercentage"`
	Completed        bool               `json:"completed"`
	CompletedAt      pgtype.Timestamptz `json:"completedAt"`
	DeviceName       *string            `json:"deviceName"`
	DeviceType       *string            `json:"deviceType"`
	ClientName       *string            `json:"clientName"`
	PlayMethod       *string            `json:"playMethod"`
	StartedAt        time.Time          `json:"startedAt"`
	LastUpdatedAt    time.Time          `json:"lastUpdatedAt"`
	Title            string             `json:"title"`
	PosterPath       *string            `json:"posterPath"`
	RuntimeTicks     *int64             `json:"runtimeTicks"`
}

func (q *Queries) ListResumeableMovies(ctx context.Context, arg ListResumeableMoviesParams) ([]ListResumeableMoviesRow, error) {
	rows, err := q.db.Query(ctx, listResumeableMovies, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListResumeableMoviesRow{}
	for rows.Next() {
		var i ListResumeableMoviesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProfileID,
			&i.MovieID,
			&i.PositionTicks,
			&i.DurationTicks,
			&i.PlayedPercentage,
			&i.Completed,
			&i.CompletedAt,
			&i.DeviceName,
			&i.DeviceType,
			&i.ClientName,
			&i.PlayMethod,
			&i.StartedAt,
			&i.LastUpdatedAt,
			&i.Title,
			&i.PosterPath,
			&i.RuntimeTicks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserFavoriteMovies = `-- name: ListUserFavoriteMovies :many
SELECT m.id, m.path, m.container, m.size_bytes, m.runtime_ticks, m.title, m.sort_title, m.original_title, m.tagline, m.overview, m.release_date, m.year, m.content_rating, m.rating_level, m.budget, m.revenue, m.community_rating, m.vote_count, m.critic_rating, m.critic_count, m.poster_path, m.poster_blurhash, m.backdrop_path, m.backdrop_blurhash, m.logo_path, m.tmdb_id, m.imdb_id, m.tvdb_id, m.date_added, m.last_played_at, m.play_count, m.is_locked, m.created_at, m.updated_at, m.collection_id, m.collection_order, m.movie_library_id FROM movies m
JOIN movie_favorites mf ON m.id = mf.movie_id
WHERE mf.user_id = $1
ORDER BY mf.created_at DESC
LIMIT $2 OFFSET $3
`

type ListUserFavoriteMoviesParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListUserFavoriteMovies(ctx context.Context, arg ListUserFavoriteMoviesParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listUserFavoriteMovies, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.ReleaseDate,
			&i.Year,
			&i.ContentRating,
			&i.RatingLevel,
			&i.Budget,
			&i.Revenue,
			&i.CommunityRating,
			&i.VoteCount,
			&i.CriticRating,
			&i.CriticCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CollectionID,
			&i.CollectionOrder,
			&i.MovieLibraryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserMovieRatings = `-- name: ListUserMovieRatings :many
SELECT mur.user_id, mur.movie_id, mur.rating, mur.review, mur.created_at, mur.updated_at, m.title, m.poster_path
FROM movie_user_ratings mur
JOIN movies m ON mur.movie_id = m.id
WHERE mur.user_id = $1
ORDER BY mur.updated_at DESC
LIMIT $2 OFFSET $3
`

type ListUserMovieRatingsParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListUserMovieRatingsRow struct {
	UserID     uuid.UUID      `json:"userId"`
	MovieID    uuid.UUID      `json:"movieId"`
	Rating     pgtype.Numeric `json:"rating"`
	Review     *string        `json:"review"`
	CreatedAt  time.Time      `json:"createdAt"`
	UpdatedAt  time.Time      `json:"updatedAt"`
	Title      string         `json:"title"`
	PosterPath *string        `json:"posterPath"`
}

func (q *Queries) ListUserMovieRatings(ctx context.Context, arg ListUserMovieRatingsParams) ([]ListUserMovieRatingsRow, error) {
	rows, err := q.db.Query(ctx, listUserMovieRatings, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserMovieRatingsRow{}
	for rows.Next() {
		var i ListUserMovieRatingsRow
		if err := rows.Scan(
			&i.UserID,
			&i.MovieID,
			&i.Rating,
			&i.Review,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.PosterPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserWatchHistory = `-- name: ListUserWatchHistory :many
SELECT mwh.id, mwh.user_id, mwh.profile_id, mwh.movie_id, mwh.position_ticks, mwh.duration_ticks, mwh.played_percentage, mwh.completed, mwh.completed_at, mwh.device_name, mwh.device_type, mwh.client_name, mwh.play_method, mwh.started_at, mwh.last_updated_at, m.title, m.poster_path, m.runtime_ticks
FROM movie_watch_history mwh
JOIN movies m ON mwh.movie_id = m.id
WHERE mwh.user_id = $1
ORDER BY mwh.last_updated_at DESC
LIMIT $2 OFFSET $3
`

type ListUserWatchHistoryParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListUserWatchHistoryRow struct {
	ID               uuid.UUID          `json:"id"`
	UserID           uuid.UUID          `json:"userId"`
	ProfileID        pgtype.UUID        `json:"profileId"`
	MovieID          uuid.UUID          `json:"movieId"`
	PositionTicks    int64              `json:"positionTicks"`
	DurationTicks    *int64             `json:"durationTicks"`
	PlayedPercentage pgtype.Numeric     `json:"playedPercentage"`
	Completed        bool               `json:"completed"`
	CompletedAt      pgtype.Timestamptz `json:"completedAt"`
	DeviceName       *string            `json:"deviceName"`
	DeviceType       *string            `json:"deviceType"`
	ClientName       *string            `json:"clientName"`
	PlayMethod       *string            `json:"playMethod"`
	StartedAt        time.Time          `json:"startedAt"`
	LastUpdatedAt    time.Time          `json:"lastUpdatedAt"`
	Title            string             `json:"title"`
	PosterPath       *string            `json:"posterPath"`
	RuntimeTicks     *int64             `json:"runtimeTicks"`
}

func (q *Queries) ListUserWatchHistory(ctx context.Context, arg ListUserWatchHistoryParams) ([]ListUserWatchHistoryRow, error) {
	rows, err := q.db.Query(ctx, listUserWatchHistory, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserWatchHistoryRow{}
	for rows.Next() {
		var i ListUserWatchHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProfileID,
			&i.MovieID,
			&i.PositionTicks,
			&i.DurationTicks,
			&i.PlayedPercentage,
			&i.Completed,
			&i.CompletedAt,
			&i.DeviceName,
			&i.DeviceType,
			&i.ClientName,
			&i.PlayMethod,
			&i.StartedAt,
			&i.LastUpdatedAt,
			&i.Title,
			&i.PosterPath,
			&i.RuntimeTicks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserWatchlist = `-- name: ListUserWatchlist :many
SELECT m.id, m.path, m.container, m.size_bytes, m.runtime_ticks, m.title, m.sort_title, m.original_title, m.tagline, m.overview, m.release_date, m.year, m.content_rating, m.rating_level, m.budget, m.revenue, m.community_rating, m.vote_count, m.critic_rating, m.critic_count, m.poster_path, m.poster_blurhash, m.backdrop_path, m.backdrop_blurhash, m.logo_path, m.tmdb_id, m.imdb_id, m.tvdb_id, m.date_added, m.last_played_at, m.play_count, m.is_locked, m.created_at, m.updated_at, m.collection_id, m.collection_order, m.movie_library_id FROM movies m
JOIN movie_watchlist mw ON m.id = mw.movie_id
WHERE mw.user_id = $1
ORDER BY mw.sort_order ASC, mw.added_at DESC
LIMIT $2 OFFSET $3
`

type ListUserWatchlistParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListUserWatchlist(ctx context.Context, arg ListUserWatchlistParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listUserWatchlist, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.ReleaseDate,
			&i.Year,
			&i.ContentRating,
			&i.RatingLevel,
			&i.Budget,
			&i.Revenue,
			&i.CommunityRating,
			&i.VoteCount,
			&i.CriticRating,
			&i.CriticCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CollectionID,
			&i.CollectionOrder,
			&i.MovieLibraryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markWatchHistoryCompleted = `-- name: MarkWatchHistoryCompleted :exec
UPDATE movie_watch_history SET
    completed = true,
    completed_at = NOW(),
    position_ticks = COALESCE(duration_ticks, position_ticks)
WHERE id = $1
`

func (q *Queries) MarkWatchHistoryCompleted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markWatchHistoryCompleted, id)
	return err
}

const removeMovieFavorite = `-- name: RemoveMovieFavorite :exec
DELETE FROM movie_favorites
WHERE user_id = $1 AND movie_id = $2
`

type RemoveMovieFavoriteParams struct {
	UserID  uuid.UUID `json:"userId"`
	MovieID uuid.UUID `json:"movieId"`
}

func (q *Queries) RemoveMovieFavorite(ctx context.Context, arg RemoveMovieFavoriteParams) error {
	_, err := q.db.Exec(ctx, removeMovieFavorite, arg.UserID, arg.MovieID)
	return err
}

const removeMovieFromWatchlist = `-- name: RemoveMovieFromWatchlist :exec
DELETE FROM movie_watchlist
WHERE user_id = $1 AND movie_id = $2
`

type RemoveMovieFromWatchlistParams struct {
	UserID  uuid.UUID `json:"userId"`
	MovieID uuid.UUID `json:"movieId"`
}

func (q *Queries) RemoveMovieFromWatchlist(ctx context.Context, arg RemoveMovieFromWatchlistParams) error {
	_, err := q.db.Exec(ctx, removeMovieFromWatchlist, arg.UserID, arg.MovieID)
	return err
}

const reorderWatchlist = `-- name: ReorderWatchlist :exec
UPDATE movie_watchlist SET sort_order = $3
WHERE user_id = $1 AND movie_id = $2
`

type ReorderWatchlistParams struct {
	UserID    uuid.UUID `json:"userId"`
	MovieID   uuid.UUID `json:"movieId"`
	SortOrder *int32    `json:"sortOrder"`
}

func (q *Queries) ReorderWatchlist(ctx context.Context, arg ReorderWatchlistParams) error {
	_, err := q.db.Exec(ctx, reorderWatchlist, arg.UserID, arg.MovieID, arg.SortOrder)
	return err
}

const setMovieUserRating = `-- name: SetMovieUserRating :one
INSERT INTO movie_user_ratings (user_id, movie_id, rating, review)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, movie_id) DO UPDATE SET
    rating = $3,
    review = COALESCE($4, movie_user_ratings.review),
    updated_at = NOW()
RETURNING user_id, movie_id, rating, review, created_at, updated_at
`

type SetMovieUserRatingParams struct {
	UserID  uuid.UUID      `json:"userId"`
	MovieID uuid.UUID      `json:"movieId"`
	Rating  pgtype.Numeric `json:"rating"`
	Review  *string        `json:"review"`
}

func (q *Queries) SetMovieUserRating(ctx context.Context, arg SetMovieUserRatingParams) (MovieUserRating, error) {
	row := q.db.QueryRow(ctx, setMovieUserRating,
		arg.UserID,
		arg.MovieID,
		arg.Rating,
		arg.Review,
	)
	var i MovieUserRating
	err := row.Scan(
		&i.UserID,
		&i.MovieID,
		&i.Rating,
		&i.Review,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWatchHistory = `-- name: UpdateWatchHistory :one
UPDATE movie_watch_history SET
    position_ticks = $2,
    duration_ticks = COALESCE($3, duration_ticks),
    last_updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, profile_id, movie_id, position_ticks, duration_ticks, played_percentage, completed, completed_at, device_name, device_type, client_name, play_method, started_at, last_updated_at
`

type UpdateWatchHistoryParams struct {
	ID            uuid.UUID `json:"id"`
	PositionTicks int64     `json:"positionTicks"`
	DurationTicks *int64    `json:"durationTicks"`
}

func (q *Queries) UpdateWatchHistory(ctx context.Context, arg UpdateWatchHistoryParams) (MovieWatchHistory, error) {
	row := q.db.QueryRow(ctx, updateWatchHistory, arg.ID, arg.PositionTicks, arg.DurationTicks)
	var i MovieWatchHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProfileID,
		&i.MovieID,
		&i.PositionTicks,
		&i.DurationTicks,
		&i.PlayedPercentage,
		&i.Completed,
		&i.CompletedAt,
		&i.DeviceName,
		&i.DeviceType,
		&i.ClientName,
		&i.PlayMethod,
		&i.StartedAt,
		&i.LastUpdatedAt,
	)
	return i, err
}

const upsertMovieExternalRating = `-- name: UpsertMovieExternalRating :exec
INSERT INTO movie_external_ratings (movie_id, source, rating, vote_count, certified)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (movie_id, source) DO UPDATE SET
    rating = $3,
    vote_count = $4,
    certified = $5,
    last_updated = NOW()
`

type UpsertMovieExternalRatingParams struct {
	MovieID   uuid.UUID      `json:"movieId"`
	Source    string         `json:"source"`
	Rating    pgtype.Numeric `json:"rating"`
	VoteCount *int32         `json:"voteCount"`
	Certified *bool          `json:"certified"`
}

func (q *Queries) UpsertMovieExternalRating(ctx context.Context, arg UpsertMovieExternalRatingParams) error {
	_, err := q.db.Exec(ctx, upsertMovieExternalRating,
		arg.MovieID,
		arg.Source,
		arg.Rating,
		arg.VoteCount,
		arg.Certified,
	)
	return err
}
