// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: libraries.sql

package moviedb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countMoviesByMovieLibrary = `-- name: CountMoviesByMovieLibrary :one
SELECT COUNT(*) FROM movies WHERE movie_library_id = $1
`

func (q *Queries) CountMoviesByMovieLibrary(ctx context.Context, movieLibraryID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMoviesByMovieLibrary, movieLibraryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMovieLibrary = `-- name: CreateMovieLibrary :one
INSERT INTO movie_libraries (
    name,
    paths,
    scan_enabled,
    scan_interval_hours,
    preferred_language,
    tmdb_enabled,
    imdb_enabled,
    download_trailers,
    download_backdrops,
    download_nfo,
    generate_chapters,
    is_private,
    owner_user_id,
    sort_order,
    icon
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
)
RETURNING id, name, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, tmdb_enabled, imdb_enabled, download_trailers, download_backdrops, download_nfo, generate_chapters, is_private, owner_user_id, sort_order, icon, created_at, updated_at
`

type CreateMovieLibraryParams struct {
	Name              string      `json:"name"`
	Paths             []string    `json:"paths"`
	ScanEnabled       bool        `json:"scanEnabled"`
	ScanIntervalHours int32       `json:"scanIntervalHours"`
	PreferredLanguage *string     `json:"preferredLanguage"`
	TmdbEnabled       bool        `json:"tmdbEnabled"`
	ImdbEnabled       bool        `json:"imdbEnabled"`
	DownloadTrailers  bool        `json:"downloadTrailers"`
	DownloadBackdrops bool        `json:"downloadBackdrops"`
	DownloadNfo       bool        `json:"downloadNfo"`
	GenerateChapters  bool        `json:"generateChapters"`
	IsPrivate         bool        `json:"isPrivate"`
	OwnerUserID       pgtype.UUID `json:"ownerUserId"`
	SortOrder         int32       `json:"sortOrder"`
	Icon              *string     `json:"icon"`
}

func (q *Queries) CreateMovieLibrary(ctx context.Context, arg CreateMovieLibraryParams) (MovieLibrary, error) {
	row := q.db.QueryRow(ctx, createMovieLibrary,
		arg.Name,
		arg.Paths,
		arg.ScanEnabled,
		arg.ScanIntervalHours,
		arg.PreferredLanguage,
		arg.TmdbEnabled,
		arg.ImdbEnabled,
		arg.DownloadTrailers,
		arg.DownloadBackdrops,
		arg.DownloadNfo,
		arg.GenerateChapters,
		arg.IsPrivate,
		arg.OwnerUserID,
		arg.SortOrder,
		arg.Icon,
	)
	var i MovieLibrary
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Paths,
		&i.ScanEnabled,
		&i.ScanIntervalHours,
		&i.LastScanAt,
		&i.LastScanDuration,
		&i.PreferredLanguage,
		&i.TmdbEnabled,
		&i.ImdbEnabled,
		&i.DownloadTrailers,
		&i.DownloadBackdrops,
		&i.DownloadNfo,
		&i.GenerateChapters,
		&i.IsPrivate,
		&i.OwnerUserID,
		&i.SortOrder,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMovieLibrary = `-- name: DeleteMovieLibrary :exec
DELETE FROM movie_libraries WHERE id = $1
`

func (q *Queries) DeleteMovieLibrary(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMovieLibrary, id)
	return err
}

const getMovieLibraryByID = `-- name: GetMovieLibraryByID :one

SELECT id, name, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, tmdb_enabled, imdb_enabled, download_trailers, download_backdrops, download_nfo, generate_chapters, is_private, owner_user_id, sort_order, icon, created_at, updated_at FROM movie_libraries WHERE id = $1
`

// Movie Libraries queries
func (q *Queries) GetMovieLibraryByID(ctx context.Context, id uuid.UUID) (MovieLibrary, error) {
	row := q.db.QueryRow(ctx, getMovieLibraryByID, id)
	var i MovieLibrary
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Paths,
		&i.ScanEnabled,
		&i.ScanIntervalHours,
		&i.LastScanAt,
		&i.LastScanDuration,
		&i.PreferredLanguage,
		&i.TmdbEnabled,
		&i.ImdbEnabled,
		&i.DownloadTrailers,
		&i.DownloadBackdrops,
		&i.DownloadNfo,
		&i.GenerateChapters,
		&i.IsPrivate,
		&i.OwnerUserID,
		&i.SortOrder,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const grantMovieLibraryAccess = `-- name: GrantMovieLibraryAccess :exec
INSERT INTO movie_library_access (library_id, user_id, can_manage)
VALUES ($1, $2, $3)
ON CONFLICT (library_id, user_id)
DO UPDATE SET can_manage = EXCLUDED.can_manage
`

type GrantMovieLibraryAccessParams struct {
	LibraryID uuid.UUID `json:"libraryId"`
	UserID    uuid.UUID `json:"userId"`
	CanManage bool      `json:"canManage"`
}

func (q *Queries) GrantMovieLibraryAccess(ctx context.Context, arg GrantMovieLibraryAccessParams) error {
	_, err := q.db.Exec(ctx, grantMovieLibraryAccess, arg.LibraryID, arg.UserID, arg.CanManage)
	return err
}

const hasMovieLibraryAccess = `-- name: HasMovieLibraryAccess :one
SELECT EXISTS(
    SELECT 1 FROM movie_library_access
    WHERE library_id = $1 AND user_id = $2
) AS has_access
`

type HasMovieLibraryAccessParams struct {
	LibraryID uuid.UUID `json:"libraryId"`
	UserID    uuid.UUID `json:"userId"`
}

func (q *Queries) HasMovieLibraryAccess(ctx context.Context, arg HasMovieLibraryAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasMovieLibraryAccess, arg.LibraryID, arg.UserID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const listAccessibleMovieLibraries = `-- name: ListAccessibleMovieLibraries :many
SELECT ml.id, ml.name, ml.paths, ml.scan_enabled, ml.scan_interval_hours, ml.last_scan_at, ml.last_scan_duration, ml.preferred_language, ml.tmdb_enabled, ml.imdb_enabled, ml.download_trailers, ml.download_backdrops, ml.download_nfo, ml.generate_chapters, ml.is_private, ml.owner_user_id, ml.sort_order, ml.icon, ml.created_at, ml.updated_at FROM movie_libraries ml
LEFT JOIN movie_library_access mla ON mla.library_id = ml.id AND mla.user_id = $1
WHERE ml.is_private = false
   OR ml.owner_user_id = $1
   OR mla.user_id IS NOT NULL
ORDER BY ml.sort_order, ml.name
`

func (q *Queries) ListAccessibleMovieLibraries(ctx context.Context, userID uuid.UUID) ([]MovieLibrary, error) {
	rows, err := q.db.Query(ctx, listAccessibleMovieLibraries, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieLibrary{}
	for rows.Next() {
		var i MovieLibrary
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Paths,
			&i.ScanEnabled,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.LastScanDuration,
			&i.PreferredLanguage,
			&i.TmdbEnabled,
			&i.ImdbEnabled,
			&i.DownloadTrailers,
			&i.DownloadBackdrops,
			&i.DownloadNfo,
			&i.GenerateChapters,
			&i.IsPrivate,
			&i.OwnerUserID,
			&i.SortOrder,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieLibraries = `-- name: ListMovieLibraries :many
SELECT id, name, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, tmdb_enabled, imdb_enabled, download_trailers, download_backdrops, download_nfo, generate_chapters, is_private, owner_user_id, sort_order, icon, created_at, updated_at FROM movie_libraries
ORDER BY sort_order, name
LIMIT $1 OFFSET $2
`

type ListMovieLibrariesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMovieLibraries(ctx context.Context, arg ListMovieLibrariesParams) ([]MovieLibrary, error) {
	rows, err := q.db.Query(ctx, listMovieLibraries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieLibrary{}
	for rows.Next() {
		var i MovieLibrary
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Paths,
			&i.ScanEnabled,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.LastScanDuration,
			&i.PreferredLanguage,
			&i.TmdbEnabled,
			&i.ImdbEnabled,
			&i.DownloadTrailers,
			&i.DownloadBackdrops,
			&i.DownloadNfo,
			&i.GenerateChapters,
			&i.IsPrivate,
			&i.OwnerUserID,
			&i.SortOrder,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieLibrariesByOwner = `-- name: ListMovieLibrariesByOwner :many
SELECT id, name, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, tmdb_enabled, imdb_enabled, download_trailers, download_backdrops, download_nfo, generate_chapters, is_private, owner_user_id, sort_order, icon, created_at, updated_at FROM movie_libraries
WHERE owner_user_id = $1
ORDER BY sort_order, name
`

func (q *Queries) ListMovieLibrariesByOwner(ctx context.Context, ownerUserID pgtype.UUID) ([]MovieLibrary, error) {
	rows, err := q.db.Query(ctx, listMovieLibrariesByOwner, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieLibrary{}
	for rows.Next() {
		var i MovieLibrary
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Paths,
			&i.ScanEnabled,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.LastScanDuration,
			&i.PreferredLanguage,
			&i.TmdbEnabled,
			&i.ImdbEnabled,
			&i.DownloadTrailers,
			&i.DownloadBackdrops,
			&i.DownloadNfo,
			&i.GenerateChapters,
			&i.IsPrivate,
			&i.OwnerUserID,
			&i.SortOrder,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieLibraryAccess = `-- name: ListMovieLibraryAccess :many
SELECT library_id, user_id, can_manage FROM movie_library_access WHERE library_id = $1
`

func (q *Queries) ListMovieLibraryAccess(ctx context.Context, libraryID uuid.UUID) ([]MovieLibraryAccess, error) {
	rows, err := q.db.Query(ctx, listMovieLibraryAccess, libraryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieLibraryAccess{}
	for rows.Next() {
		var i MovieLibraryAccess
		if err := rows.Scan(&i.LibraryID, &i.UserID, &i.CanManage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeMovieLibraryAccess = `-- name: RevokeMovieLibraryAccess :exec
DELETE FROM movie_library_access WHERE library_id = $1 AND user_id = $2
`

type RevokeMovieLibraryAccessParams struct {
	LibraryID uuid.UUID `json:"libraryId"`
	UserID    uuid.UUID `json:"userId"`
}

func (q *Queries) RevokeMovieLibraryAccess(ctx context.Context, arg RevokeMovieLibraryAccessParams) error {
	_, err := q.db.Exec(ctx, revokeMovieLibraryAccess, arg.LibraryID, arg.UserID)
	return err
}

const updateMovieLibrary = `-- name: UpdateMovieLibrary :one
UPDATE movie_libraries
SET
    name = $2,
    paths = $3,
    scan_enabled = $4,
    scan_interval_hours = $5,
    preferred_language = $6,
    tmdb_enabled = $7,
    imdb_enabled = $8,
    download_trailers = $9,
    download_backdrops = $10,
    download_nfo = $11,
    generate_chapters = $12,
    is_private = $13,
    owner_user_id = $14,
    sort_order = $15,
    icon = $16
WHERE id = $1
RETURNING id, name, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, tmdb_enabled, imdb_enabled, download_trailers, download_backdrops, download_nfo, generate_chapters, is_private, owner_user_id, sort_order, icon, created_at, updated_at
`

type UpdateMovieLibraryParams struct {
	ID                uuid.UUID   `json:"id"`
	Name              string      `json:"name"`
	Paths             []string    `json:"paths"`
	ScanEnabled       bool        `json:"scanEnabled"`
	ScanIntervalHours int32       `json:"scanIntervalHours"`
	PreferredLanguage *string     `json:"preferredLanguage"`
	TmdbEnabled       bool        `json:"tmdbEnabled"`
	ImdbEnabled       bool        `json:"imdbEnabled"`
	DownloadTrailers  bool        `json:"downloadTrailers"`
	DownloadBackdrops bool        `json:"downloadBackdrops"`
	DownloadNfo       bool        `json:"downloadNfo"`
	GenerateChapters  bool        `json:"generateChapters"`
	IsPrivate         bool        `json:"isPrivate"`
	OwnerUserID       pgtype.UUID `json:"ownerUserId"`
	SortOrder         int32       `json:"sortOrder"`
	Icon              *string     `json:"icon"`
}

func (q *Queries) UpdateMovieLibrary(ctx context.Context, arg UpdateMovieLibraryParams) (MovieLibrary, error) {
	row := q.db.QueryRow(ctx, updateMovieLibrary,
		arg.ID,
		arg.Name,
		arg.Paths,
		arg.ScanEnabled,
		arg.ScanIntervalHours,
		arg.PreferredLanguage,
		arg.TmdbEnabled,
		arg.ImdbEnabled,
		arg.DownloadTrailers,
		arg.DownloadBackdrops,
		arg.DownloadNfo,
		arg.GenerateChapters,
		arg.IsPrivate,
		arg.OwnerUserID,
		arg.SortOrder,
		arg.Icon,
	)
	var i MovieLibrary
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Paths,
		&i.ScanEnabled,
		&i.ScanIntervalHours,
		&i.LastScanAt,
		&i.LastScanDuration,
		&i.PreferredLanguage,
		&i.TmdbEnabled,
		&i.ImdbEnabled,
		&i.DownloadTrailers,
		&i.DownloadBackdrops,
		&i.DownloadNfo,
		&i.GenerateChapters,
		&i.IsPrivate,
		&i.OwnerUserID,
		&i.SortOrder,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMovieLibraryScanStatus = `-- name: UpdateMovieLibraryScanStatus :exec
UPDATE movie_libraries
SET
    last_scan_at = $2,
    last_scan_duration = $3
WHERE id = $1
`

type UpdateMovieLibraryScanStatusParams struct {
	ID               uuid.UUID          `json:"id"`
	LastScanAt       pgtype.Timestamptz `json:"lastScanAt"`
	LastScanDuration pgtype.Interval    `json:"lastScanDuration"`
}

func (q *Queries) UpdateMovieLibraryScanStatus(ctx context.Context, arg UpdateMovieLibraryScanStatusParams) error {
	_, err := q.db.Exec(ctx, updateMovieLibraryScanStatus, arg.ID, arg.LastScanAt, arg.LastScanDuration)
	return err
}
