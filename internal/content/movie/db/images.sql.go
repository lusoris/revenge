// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: images.sql

package moviedb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createMovieImage = `-- name: CreateMovieImage :one
INSERT INTO movie_images (
    movie_id, image_type, path, blurhash, width, height, aspect_ratio, language, vote_average, vote_count, is_primary, source
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, movie_id, image_type, path, blurhash, width, height, aspect_ratio, language, vote_average, vote_count, is_primary, source, created_at
`

type CreateMovieImageParams struct {
	MovieID     uuid.UUID      `json:"movieId"`
	ImageType   string         `json:"imageType"`
	Path        string         `json:"path"`
	Blurhash    *string        `json:"blurhash"`
	Width       *int32         `json:"width"`
	Height      *int32         `json:"height"`
	AspectRatio pgtype.Numeric `json:"aspectRatio"`
	Language    *string        `json:"language"`
	VoteAverage pgtype.Numeric `json:"voteAverage"`
	VoteCount   *int32         `json:"voteCount"`
	IsPrimary   bool           `json:"isPrimary"`
	Source      string         `json:"source"`
}

func (q *Queries) CreateMovieImage(ctx context.Context, arg CreateMovieImageParams) (MovieImage, error) {
	row := q.db.QueryRow(ctx, createMovieImage,
		arg.MovieID,
		arg.ImageType,
		arg.Path,
		arg.Blurhash,
		arg.Width,
		arg.Height,
		arg.AspectRatio,
		arg.Language,
		arg.VoteAverage,
		arg.VoteCount,
		arg.IsPrimary,
		arg.Source,
	)
	var i MovieImage
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.ImageType,
		&i.Path,
		&i.Blurhash,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
		&i.Language,
		&i.VoteAverage,
		&i.VoteCount,
		&i.IsPrimary,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}

const createMovieVideo = `-- name: CreateMovieVideo :one
INSERT INTO movie_videos (movie_id, video_type, site, key, name, language, size)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, movie_id, video_type, site, key, name, language, size, created_at
`

type CreateMovieVideoParams struct {
	MovieID   uuid.UUID `json:"movieId"`
	VideoType string    `json:"videoType"`
	Site      string    `json:"site"`
	Key       string    `json:"key"`
	Name      *string   `json:"name"`
	Language  *string   `json:"language"`
	Size      *int32    `json:"size"`
}

func (q *Queries) CreateMovieVideo(ctx context.Context, arg CreateMovieVideoParams) (MovieVideo, error) {
	row := q.db.QueryRow(ctx, createMovieVideo,
		arg.MovieID,
		arg.VideoType,
		arg.Site,
		arg.Key,
		arg.Name,
		arg.Language,
		arg.Size,
	)
	var i MovieVideo
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.VideoType,
		&i.Site,
		&i.Key,
		&i.Name,
		&i.Language,
		&i.Size,
		&i.CreatedAt,
	)
	return i, err
}

const deleteMovieImages = `-- name: DeleteMovieImages :exec
DELETE FROM movie_images WHERE movie_id = $1
`

func (q *Queries) DeleteMovieImages(ctx context.Context, movieID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMovieImages, movieID)
	return err
}

const deleteMovieImagesByType = `-- name: DeleteMovieImagesByType :exec
DELETE FROM movie_images WHERE movie_id = $1 AND image_type = $2
`

type DeleteMovieImagesByTypeParams struct {
	MovieID   uuid.UUID `json:"movieId"`
	ImageType string    `json:"imageType"`
}

func (q *Queries) DeleteMovieImagesByType(ctx context.Context, arg DeleteMovieImagesByTypeParams) error {
	_, err := q.db.Exec(ctx, deleteMovieImagesByType, arg.MovieID, arg.ImageType)
	return err
}

const deleteMovieVideos = `-- name: DeleteMovieVideos :exec
DELETE FROM movie_videos WHERE movie_id = $1
`

func (q *Queries) DeleteMovieVideos(ctx context.Context, movieID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMovieVideos, movieID)
	return err
}

const getMovieImages = `-- name: GetMovieImages :many


SELECT id, movie_id, image_type, path, blurhash, width, height, aspect_ratio, language, vote_average, vote_count, is_primary, source, created_at FROM movie_images
WHERE movie_id = $1
ORDER BY is_primary DESC, vote_average DESC NULLS LAST
`

// Movie Images and Videos Queries
// Images
func (q *Queries) GetMovieImages(ctx context.Context, movieID uuid.UUID) ([]MovieImage, error) {
	rows, err := q.db.Query(ctx, getMovieImages, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieImage{}
	for rows.Next() {
		var i MovieImage
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.ImageType,
			&i.Path,
			&i.Blurhash,
			&i.Width,
			&i.Height,
			&i.AspectRatio,
			&i.Language,
			&i.VoteAverage,
			&i.VoteCount,
			&i.IsPrimary,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieImagesByType = `-- name: GetMovieImagesByType :many
SELECT id, movie_id, image_type, path, blurhash, width, height, aspect_ratio, language, vote_average, vote_count, is_primary, source, created_at FROM movie_images
WHERE movie_id = $1 AND image_type = $2
ORDER BY is_primary DESC, vote_average DESC NULLS LAST
`

type GetMovieImagesByTypeParams struct {
	MovieID   uuid.UUID `json:"movieId"`
	ImageType string    `json:"imageType"`
}

func (q *Queries) GetMovieImagesByType(ctx context.Context, arg GetMovieImagesByTypeParams) ([]MovieImage, error) {
	rows, err := q.db.Query(ctx, getMovieImagesByType, arg.MovieID, arg.ImageType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieImage{}
	for rows.Next() {
		var i MovieImage
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.ImageType,
			&i.Path,
			&i.Blurhash,
			&i.Width,
			&i.Height,
			&i.AspectRatio,
			&i.Language,
			&i.VoteAverage,
			&i.VoteCount,
			&i.IsPrimary,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieVideos = `-- name: GetMovieVideos :many

SELECT id, movie_id, video_type, site, key, name, language, size, created_at FROM movie_videos
WHERE movie_id = $1
ORDER BY
    CASE video_type
        WHEN 'trailer' THEN 1
        WHEN 'teaser' THEN 2
        WHEN 'clip' THEN 3
        ELSE 10
    END,
    size DESC
`

// Videos
func (q *Queries) GetMovieVideos(ctx context.Context, movieID uuid.UUID) ([]MovieVideo, error) {
	rows, err := q.db.Query(ctx, getMovieVideos, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieVideo{}
	for rows.Next() {
		var i MovieVideo
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.VideoType,
			&i.Site,
			&i.Key,
			&i.Name,
			&i.Language,
			&i.Size,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieVideosByType = `-- name: GetMovieVideosByType :many
SELECT id, movie_id, video_type, site, key, name, language, size, created_at FROM movie_videos
WHERE movie_id = $1 AND video_type = $2
ORDER BY size DESC
`

type GetMovieVideosByTypeParams struct {
	MovieID   uuid.UUID `json:"movieId"`
	VideoType string    `json:"videoType"`
}

func (q *Queries) GetMovieVideosByType(ctx context.Context, arg GetMovieVideosByTypeParams) ([]MovieVideo, error) {
	rows, err := q.db.Query(ctx, getMovieVideosByType, arg.MovieID, arg.VideoType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieVideo{}
	for rows.Next() {
		var i MovieVideo
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.VideoType,
			&i.Site,
			&i.Key,
			&i.Name,
			&i.Language,
			&i.Size,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryMovieImage = `-- name: GetPrimaryMovieImage :one
SELECT id, movie_id, image_type, path, blurhash, width, height, aspect_ratio, language, vote_average, vote_count, is_primary, source, created_at FROM movie_images
WHERE movie_id = $1 AND image_type = $2 AND is_primary = true
LIMIT 1
`

type GetPrimaryMovieImageParams struct {
	MovieID   uuid.UUID `json:"movieId"`
	ImageType string    `json:"imageType"`
}

func (q *Queries) GetPrimaryMovieImage(ctx context.Context, arg GetPrimaryMovieImageParams) (MovieImage, error) {
	row := q.db.QueryRow(ctx, getPrimaryMovieImage, arg.MovieID, arg.ImageType)
	var i MovieImage
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.ImageType,
		&i.Path,
		&i.Blurhash,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
		&i.Language,
		&i.VoteAverage,
		&i.VoteCount,
		&i.IsPrimary,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}

const setPrimaryMovieImage = `-- name: SetPrimaryMovieImage :exec
UPDATE movie_images SET is_primary = (id = $2)
WHERE movie_id = $1 AND image_type = $3
`

type SetPrimaryMovieImageParams struct {
	MovieID   uuid.UUID `json:"movieId"`
	ID        uuid.UUID `json:"id"`
	ImageType string    `json:"imageType"`
}

func (q *Queries) SetPrimaryMovieImage(ctx context.Context, arg SetPrimaryMovieImageParams) error {
	_, err := q.db.Exec(ctx, setPrimaryMovieImage, arg.MovieID, arg.ID, arg.ImageType)
	return err
}
