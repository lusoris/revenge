// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: credits.sql

package moviedb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countMovieCast = `-- name: CountMovieCast :one
SELECT COUNT(*) FROM movie_credits WHERE movie_id = $1 AND role = 'actor'
`

func (q *Queries) CountMovieCast(ctx context.Context, movieID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMovieCast, movieID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieCrew = `-- name: CountMovieCrew :one
SELECT COUNT(*) FROM movie_credits WHERE movie_id = $1 AND role != 'actor'
`

func (q *Queries) CountMovieCrew(ctx context.Context, movieID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMovieCrew, movieID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMovieCredit = `-- name: CreateMovieCredit :one
INSERT INTO movie_credits (
    movie_id, person_id, role, character_name, department, job, billing_order, is_guest, tmdb_credit_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, movie_id, person_id, role, character_name, department, job, billing_order, is_guest, tmdb_credit_id, created_at
`

type CreateMovieCreditParams struct {
	MovieID       uuid.UUID `json:"movieId"`
	PersonID      uuid.UUID `json:"personId"`
	Role          string    `json:"role"`
	CharacterName *string   `json:"characterName"`
	Department    *string   `json:"department"`
	Job           *string   `json:"job"`
	BillingOrder  int32     `json:"billingOrder"`
	IsGuest       bool      `json:"isGuest"`
	TmdbCreditID  *string   `json:"tmdbCreditId"`
}

func (q *Queries) CreateMovieCredit(ctx context.Context, arg CreateMovieCreditParams) (MovieCredit, error) {
	row := q.db.QueryRow(ctx, createMovieCredit,
		arg.MovieID,
		arg.PersonID,
		arg.Role,
		arg.CharacterName,
		arg.Department,
		arg.Job,
		arg.BillingOrder,
		arg.IsGuest,
		arg.TmdbCreditID,
	)
	var i MovieCredit
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.PersonID,
		&i.Role,
		&i.CharacterName,
		&i.Department,
		&i.Job,
		&i.BillingOrder,
		&i.IsGuest,
		&i.TmdbCreditID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteMovieCredits = `-- name: DeleteMovieCredits :exec
DELETE FROM movie_credits WHERE movie_id = $1
`

func (q *Queries) DeleteMovieCredits(ctx context.Context, movieID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMovieCredits, movieID)
	return err
}

const deleteMovieCreditsByRole = `-- name: DeleteMovieCreditsByRole :exec
DELETE FROM movie_credits WHERE movie_id = $1 AND role = $2
`

type DeleteMovieCreditsByRoleParams struct {
	MovieID uuid.UUID `json:"movieId"`
	Role    string    `json:"role"`
}

func (q *Queries) DeleteMovieCreditsByRole(ctx context.Context, arg DeleteMovieCreditsByRoleParams) error {
	_, err := q.db.Exec(ctx, deleteMovieCreditsByRole, arg.MovieID, arg.Role)
	return err
}

const getMovieCast = `-- name: GetMovieCast :many

SELECT mc.id, mc.movie_id, mc.person_id, mc.role, mc.character_name, mc.department, mc.job, mc.billing_order, mc.is_guest, mc.tmdb_credit_id, mc.created_at, p.name, p.primary_image_url, p.primary_image_blurhash
FROM movie_credits mc
JOIN video_people p ON mc.person_id = p.id
WHERE mc.movie_id = $1 AND mc.role = 'actor'
ORDER BY mc.billing_order ASC
`

type GetMovieCastRow struct {
	ID                   uuid.UUID `json:"id"`
	MovieID              uuid.UUID `json:"movieId"`
	PersonID             uuid.UUID `json:"personId"`
	Role                 string    `json:"role"`
	CharacterName        *string   `json:"characterName"`
	Department           *string   `json:"department"`
	Job                  *string   `json:"job"`
	BillingOrder         int32     `json:"billingOrder"`
	IsGuest              bool      `json:"isGuest"`
	TmdbCreditID         *string   `json:"tmdbCreditId"`
	CreatedAt            time.Time `json:"createdAt"`
	Name                 string    `json:"name"`
	PrimaryImageUrl      *string   `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string   `json:"primaryImageBlurhash"`
}

// Movie Credits Queries
func (q *Queries) GetMovieCast(ctx context.Context, movieID uuid.UUID) ([]GetMovieCastRow, error) {
	rows, err := q.db.Query(ctx, getMovieCast, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMovieCastRow{}
	for rows.Next() {
		var i GetMovieCastRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.IsGuest,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Name,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieCrew = `-- name: GetMovieCrew :many
SELECT mc.id, mc.movie_id, mc.person_id, mc.role, mc.character_name, mc.department, mc.job, mc.billing_order, mc.is_guest, mc.tmdb_credit_id, mc.created_at, p.name, p.primary_image_url, p.primary_image_blurhash
FROM movie_credits mc
JOIN video_people p ON mc.person_id = p.id
WHERE mc.movie_id = $1 AND mc.role != 'actor'
ORDER BY
    CASE mc.role
        WHEN 'director' THEN 1
        WHEN 'writer' THEN 2
        WHEN 'producer' THEN 3
        ELSE 10
    END,
    mc.billing_order ASC
`

type GetMovieCrewRow struct {
	ID                   uuid.UUID `json:"id"`
	MovieID              uuid.UUID `json:"movieId"`
	PersonID             uuid.UUID `json:"personId"`
	Role                 string    `json:"role"`
	CharacterName        *string   `json:"characterName"`
	Department           *string   `json:"department"`
	Job                  *string   `json:"job"`
	BillingOrder         int32     `json:"billingOrder"`
	IsGuest              bool      `json:"isGuest"`
	TmdbCreditID         *string   `json:"tmdbCreditId"`
	CreatedAt            time.Time `json:"createdAt"`
	Name                 string    `json:"name"`
	PrimaryImageUrl      *string   `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string   `json:"primaryImageBlurhash"`
}

func (q *Queries) GetMovieCrew(ctx context.Context, movieID uuid.UUID) ([]GetMovieCrewRow, error) {
	rows, err := q.db.Query(ctx, getMovieCrew, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMovieCrewRow{}
	for rows.Next() {
		var i GetMovieCrewRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.IsGuest,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Name,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieDirectors = `-- name: GetMovieDirectors :many
SELECT mc.id, mc.movie_id, mc.person_id, mc.role, mc.character_name, mc.department, mc.job, mc.billing_order, mc.is_guest, mc.tmdb_credit_id, mc.created_at, p.name, p.primary_image_url, p.primary_image_blurhash
FROM movie_credits mc
JOIN video_people p ON mc.person_id = p.id
WHERE mc.movie_id = $1 AND mc.role = 'director'
ORDER BY mc.billing_order ASC
`

type GetMovieDirectorsRow struct {
	ID                   uuid.UUID `json:"id"`
	MovieID              uuid.UUID `json:"movieId"`
	PersonID             uuid.UUID `json:"personId"`
	Role                 string    `json:"role"`
	CharacterName        *string   `json:"characterName"`
	Department           *string   `json:"department"`
	Job                  *string   `json:"job"`
	BillingOrder         int32     `json:"billingOrder"`
	IsGuest              bool      `json:"isGuest"`
	TmdbCreditID         *string   `json:"tmdbCreditId"`
	CreatedAt            time.Time `json:"createdAt"`
	Name                 string    `json:"name"`
	PrimaryImageUrl      *string   `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string   `json:"primaryImageBlurhash"`
}

func (q *Queries) GetMovieDirectors(ctx context.Context, movieID uuid.UUID) ([]GetMovieDirectorsRow, error) {
	rows, err := q.db.Query(ctx, getMovieDirectors, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMovieDirectorsRow{}
	for rows.Next() {
		var i GetMovieDirectorsRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.IsGuest,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Name,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieWriters = `-- name: GetMovieWriters :many
SELECT mc.id, mc.movie_id, mc.person_id, mc.role, mc.character_name, mc.department, mc.job, mc.billing_order, mc.is_guest, mc.tmdb_credit_id, mc.created_at, p.name, p.primary_image_url, p.primary_image_blurhash
FROM movie_credits mc
JOIN video_people p ON mc.person_id = p.id
WHERE mc.movie_id = $1 AND mc.role = 'writer'
ORDER BY mc.billing_order ASC
`

type GetMovieWritersRow struct {
	ID                   uuid.UUID `json:"id"`
	MovieID              uuid.UUID `json:"movieId"`
	PersonID             uuid.UUID `json:"personId"`
	Role                 string    `json:"role"`
	CharacterName        *string   `json:"characterName"`
	Department           *string   `json:"department"`
	Job                  *string   `json:"job"`
	BillingOrder         int32     `json:"billingOrder"`
	IsGuest              bool      `json:"isGuest"`
	TmdbCreditID         *string   `json:"tmdbCreditId"`
	CreatedAt            time.Time `json:"createdAt"`
	Name                 string    `json:"name"`
	PrimaryImageUrl      *string   `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string   `json:"primaryImageBlurhash"`
}

func (q *Queries) GetMovieWriters(ctx context.Context, movieID uuid.UUID) ([]GetMovieWritersRow, error) {
	rows, err := q.db.Query(ctx, getMovieWriters, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMovieWritersRow{}
	for rows.Next() {
		var i GetMovieWritersRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.IsGuest,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Name,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersonMovieCredits = `-- name: GetPersonMovieCredits :many
SELECT mc.id, mc.movie_id, mc.person_id, mc.role, mc.character_name, mc.department, mc.job, mc.billing_order, mc.is_guest, mc.tmdb_credit_id, mc.created_at, m.title, m.year, m.poster_path, m.poster_blurhash
FROM movie_credits mc
JOIN movies m ON mc.movie_id = m.id
WHERE mc.person_id = $1
ORDER BY m.release_date DESC NULLS LAST
`

type GetPersonMovieCreditsRow struct {
	ID             uuid.UUID `json:"id"`
	MovieID        uuid.UUID `json:"movieId"`
	PersonID       uuid.UUID `json:"personId"`
	Role           string    `json:"role"`
	CharacterName  *string   `json:"characterName"`
	Department     *string   `json:"department"`
	Job            *string   `json:"job"`
	BillingOrder   int32     `json:"billingOrder"`
	IsGuest        bool      `json:"isGuest"`
	TmdbCreditID   *string   `json:"tmdbCreditId"`
	CreatedAt      time.Time `json:"createdAt"`
	Title          string    `json:"title"`
	Year           *int32    `json:"year"`
	PosterPath     *string   `json:"posterPath"`
	PosterBlurhash *string   `json:"posterBlurhash"`
}

func (q *Queries) GetPersonMovieCredits(ctx context.Context, personID uuid.UUID) ([]GetPersonMovieCreditsRow, error) {
	rows, err := q.db.Query(ctx, getPersonMovieCredits, personID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPersonMovieCreditsRow{}
	for rows.Next() {
		var i GetPersonMovieCreditsRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.IsGuest,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Title,
			&i.Year,
			&i.PosterPath,
			&i.PosterBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
