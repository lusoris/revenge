// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package moviedb

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type ActivitySeverity string

const (
	ActivitySeverityInfo     ActivitySeverity = "info"
	ActivitySeverityWarning  ActivitySeverity = "warning"
	ActivitySeverityError    ActivitySeverity = "error"
	ActivitySeverityCritical ActivitySeverity = "critical"
)

func (e *ActivitySeverity) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ActivitySeverity(s)
	case string:
		*e = ActivitySeverity(s)
	default:
		return fmt.Errorf("unsupported scan type for ActivitySeverity: %T", src)
	}
	return nil
}

type NullActivitySeverity struct {
	ActivitySeverity ActivitySeverity `json:"activitySeverity"`
	Valid            bool             `json:"valid"` // Valid is true if ActivitySeverity is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullActivitySeverity) Scan(value interface{}) error {
	if value == nil {
		ns.ActivitySeverity, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ActivitySeverity.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullActivitySeverity) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ActivitySeverity), nil
}

type ActivityType string

const (
	ActivityTypeUserLogin       ActivityType = "user_login"
	ActivityTypeUserLogout      ActivityType = "user_logout"
	ActivityTypeUserCreated     ActivityType = "user_created"
	ActivityTypeUserUpdated     ActivityType = "user_updated"
	ActivityTypeUserDeleted     ActivityType = "user_deleted"
	ActivityTypePasswordChanged ActivityType = "password_changed"
	ActivityTypeSessionCreated  ActivityType = "session_created"
	ActivityTypeSessionExpired  ActivityType = "session_expired"
	ActivityTypeLibraryCreated  ActivityType = "library_created"
	ActivityTypeLibraryUpdated  ActivityType = "library_updated"
	ActivityTypeLibraryDeleted  ActivityType = "library_deleted"
	ActivityTypeLibraryScanned  ActivityType = "library_scanned"
	ActivityTypeContentPlayed   ActivityType = "content_played"
	ActivityTypeContentRated    ActivityType = "content_rated"
	ActivityTypeSettingsChanged ActivityType = "settings_changed"
	ActivityTypeApiError        ActivityType = "api_error"
	ActivityTypeSecurityEvent   ActivityType = "security_event"
)

func (e *ActivityType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ActivityType(s)
	case string:
		*e = ActivityType(s)
	default:
		return fmt.Errorf("unsupported scan type for ActivityType: %T", src)
	}
	return nil
}

type NullActivityType struct {
	ActivityType ActivityType `json:"activityType"`
	Valid        bool         `json:"valid"` // Valid is true if ActivityType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullActivityType) Scan(value interface{}) error {
	if value == nil {
		ns.ActivityType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ActivityType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullActivityType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ActivityType), nil
}

type LibraryType string

const (
	LibraryTypeMovie      LibraryType = "movie"
	LibraryTypeTvshow     LibraryType = "tvshow"
	LibraryTypeMusic      LibraryType = "music"
	LibraryTypeAudiobook  LibraryType = "audiobook"
	LibraryTypeBook       LibraryType = "book"
	LibraryTypePodcast    LibraryType = "podcast"
	LibraryTypePhoto      LibraryType = "photo"
	LibraryTypeLivetv     LibraryType = "livetv"
	LibraryTypeComics     LibraryType = "comics"
	LibraryTypeAdultMovie LibraryType = "adult_movie"
	LibraryTypeAdultScene LibraryType = "adult_scene"
)

func (e *LibraryType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LibraryType(s)
	case string:
		*e = LibraryType(s)
	default:
		return fmt.Errorf("unsupported scan type for LibraryType: %T", src)
	}
	return nil
}

type NullLibraryType struct {
	LibraryType LibraryType `json:"libraryType"`
	Valid       bool        `json:"valid"` // Valid is true if LibraryType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLibraryType) Scan(value interface{}) error {
	if value == nil {
		ns.LibraryType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LibraryType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLibraryType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LibraryType), nil
}

type MovieCreditRole string

const (
	MovieCreditRoleActor              MovieCreditRole = "actor"
	MovieCreditRoleDirector           MovieCreditRole = "director"
	MovieCreditRoleWriter             MovieCreditRole = "writer"
	MovieCreditRoleProducer           MovieCreditRole = "producer"
	MovieCreditRoleExecutiveProducer  MovieCreditRole = "executive_producer"
	MovieCreditRoleComposer           MovieCreditRole = "composer"
	MovieCreditRoleCinematographer    MovieCreditRole = "cinematographer"
	MovieCreditRoleEditor             MovieCreditRole = "editor"
	MovieCreditRoleProductionDesigner MovieCreditRole = "production_designer"
	MovieCreditRoleCostumeDesigner    MovieCreditRole = "costume_designer"
	MovieCreditRoleMakeupArtist       MovieCreditRole = "makeup_artist"
	MovieCreditRoleVisualEffects      MovieCreditRole = "visual_effects"
	MovieCreditRoleStuntCoordinator   MovieCreditRole = "stunt_coordinator"
	MovieCreditRoleSoundDesigner      MovieCreditRole = "sound_designer"
)

func (e *MovieCreditRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MovieCreditRole(s)
	case string:
		*e = MovieCreditRole(s)
	default:
		return fmt.Errorf("unsupported scan type for MovieCreditRole: %T", src)
	}
	return nil
}

type NullMovieCreditRole struct {
	MovieCreditRole MovieCreditRole `json:"movieCreditRole"`
	Valid           bool            `json:"valid"` // Valid is true if MovieCreditRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMovieCreditRole) Scan(value interface{}) error {
	if value == nil {
		ns.MovieCreditRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MovieCreditRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMovieCreditRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MovieCreditRole), nil
}

type MovieImageType string

const (
	MovieImageTypePoster    MovieImageType = "poster"
	MovieImageTypeBackdrop  MovieImageType = "backdrop"
	MovieImageTypeLogo      MovieImageType = "logo"
	MovieImageTypeThumb     MovieImageType = "thumb"
	MovieImageTypeBanner    MovieImageType = "banner"
	MovieImageTypeDisc      MovieImageType = "disc"
	MovieImageTypeClearart  MovieImageType = "clearart"
	MovieImageTypeClearlogo MovieImageType = "clearlogo"
	MovieImageTypeKeyart    MovieImageType = "keyart"
)

func (e *MovieImageType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MovieImageType(s)
	case string:
		*e = MovieImageType(s)
	default:
		return fmt.Errorf("unsupported scan type for MovieImageType: %T", src)
	}
	return nil
}

type NullMovieImageType struct {
	MovieImageType MovieImageType `json:"movieImageType"`
	Valid          bool           `json:"valid"` // Valid is true if MovieImageType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMovieImageType) Scan(value interface{}) error {
	if value == nil {
		ns.MovieImageType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MovieImageType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMovieImageType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MovieImageType), nil
}

type MovieVideoSite string

const (
	MovieVideoSiteYoutube MovieVideoSite = "youtube"
	MovieVideoSiteVimeo   MovieVideoSite = "vimeo"
)

func (e *MovieVideoSite) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MovieVideoSite(s)
	case string:
		*e = MovieVideoSite(s)
	default:
		return fmt.Errorf("unsupported scan type for MovieVideoSite: %T", src)
	}
	return nil
}

type NullMovieVideoSite struct {
	MovieVideoSite MovieVideoSite `json:"movieVideoSite"`
	Valid          bool           `json:"valid"` // Valid is true if MovieVideoSite is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMovieVideoSite) Scan(value interface{}) error {
	if value == nil {
		ns.MovieVideoSite, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MovieVideoSite.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMovieVideoSite) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MovieVideoSite), nil
}

type MovieVideoType string

const (
	MovieVideoTypeTrailer         MovieVideoType = "trailer"
	MovieVideoTypeTeaser          MovieVideoType = "teaser"
	MovieVideoTypeClip            MovieVideoType = "clip"
	MovieVideoTypeFeaturette      MovieVideoType = "featurette"
	MovieVideoTypeBehindTheScenes MovieVideoType = "behind_the_scenes"
	MovieVideoTypeBloopers        MovieVideoType = "bloopers"
)

func (e *MovieVideoType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MovieVideoType(s)
	case string:
		*e = MovieVideoType(s)
	default:
		return fmt.Errorf("unsupported scan type for MovieVideoType: %T", src)
	}
	return nil
}

type NullMovieVideoType struct {
	MovieVideoType MovieVideoType `json:"movieVideoType"`
	Valid          bool           `json:"valid"` // Valid is true if MovieVideoType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMovieVideoType) Scan(value interface{}) error {
	if value == nil {
		ns.MovieVideoType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MovieVideoType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMovieVideoType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MovieVideoType), nil
}

type PermissionCategory string

const (
	PermissionCategorySystem    PermissionCategory = "system"
	PermissionCategoryUsers     PermissionCategory = "users"
	PermissionCategoryLibraries PermissionCategory = "libraries"
	PermissionCategoryContent   PermissionCategory = "content"
	PermissionCategoryPlayback  PermissionCategory = "playback"
	PermissionCategorySocial    PermissionCategory = "social"
	PermissionCategoryAdult     PermissionCategory = "adult"
)

func (e *PermissionCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PermissionCategory(s)
	case string:
		*e = PermissionCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for PermissionCategory: %T", src)
	}
	return nil
}

type NullPermissionCategory struct {
	PermissionCategory PermissionCategory `json:"permissionCategory"`
	Valid              bool               `json:"valid"` // Valid is true if PermissionCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPermissionCategory) Scan(value interface{}) error {
	if value == nil {
		ns.PermissionCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PermissionCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPermissionCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PermissionCategory), nil
}

type RatingSystem string

const (
	RatingSystemMPAA       RatingSystem = "MPAA"
	RatingSystemFSK        RatingSystem = "FSK"
	RatingSystemPEGI       RatingSystem = "PEGI"
	RatingSystemBBFC       RatingSystem = "BBFC"
	RatingSystemACB        RatingSystem = "ACB"
	RatingSystemKIJKWIJZER RatingSystem = "KIJKWIJZER"
)

func (e *RatingSystem) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RatingSystem(s)
	case string:
		*e = RatingSystem(s)
	default:
		return fmt.Errorf("unsupported scan type for RatingSystem: %T", src)
	}
	return nil
}

type NullRatingSystem struct {
	RatingSystem RatingSystem `json:"ratingSystem"`
	Valid        bool         `json:"valid"` // Valid is true if RatingSystem is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRatingSystem) Scan(value interface{}) error {
	if value == nil {
		ns.RatingSystem, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RatingSystem.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRatingSystem) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RatingSystem), nil
}

type UserRole string

const (
	UserRoleAdmin     UserRole = "admin"
	UserRoleModerator UserRole = "moderator"
	UserRoleUser      UserRole = "user"
	UserRoleGuest     UserRole = "guest"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"userRole"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type ActivityLog struct {
	ID        uuid.UUID   `json:"id"`
	UserID    pgtype.UUID `json:"userId"`
	Type      string      `json:"type"`
	Severity  string      `json:"severity"`
	Message   string      `json:"message"`
	Metadata  []byte      `json:"metadata"`
	IpAddress netip.Addr  `json:"ipAddress"`
	UserAgent *string     `json:"userAgent"`
	CreatedAt time.Time   `json:"createdAt"`
}

type ApiKey struct {
	ID         uuid.UUID          `json:"id"`
	UserID     uuid.UUID          `json:"userId"`
	Name       string             `json:"name"`
	KeyHash    string             `json:"keyHash"`
	KeyPrefix  string             `json:"keyPrefix"`
	Scopes     []string           `json:"scopes"`
	LastUsedAt pgtype.Timestamptz `json:"lastUsedAt"`
	UseCount   int64              `json:"useCount"`
	ExpiresAt  pgtype.Timestamptz `json:"expiresAt"`
	CreatedAt  time.Time          `json:"createdAt"`
}

type ContentRating struct {
	ID          uuid.UUID    `json:"id"`
	System      RatingSystem `json:"system"`
	Code        string       `json:"code"`
	DisplayName string       `json:"displayName"`
	Description *string      `json:"description"`
	MinAge      *int32       `json:"minAge"`
	IconUrl     *string      `json:"iconUrl"`
	SortOrder   int32        `json:"sortOrder"`
	CreatedAt   time.Time    `json:"createdAt"`
	UpdatedAt   time.Time    `json:"updatedAt"`
}

type Genre struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	Slug      string    `json:"slug"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

type Library struct {
	ID                uuid.UUID          `json:"id"`
	Name              string             `json:"name"`
	Type              string             `json:"type"`
	Paths             []string           `json:"paths"`
	ScanEnabled       bool               `json:"scanEnabled"`
	ScanIntervalHours int32              `json:"scanIntervalHours"`
	LastScanAt        pgtype.Timestamptz `json:"lastScanAt"`
	LastScanDuration  pgtype.Interval    `json:"lastScanDuration"`
	PreferredLanguage *string            `json:"preferredLanguage"`
	DownloadImages    bool               `json:"downloadImages"`
	DownloadNfo       bool               `json:"downloadNfo"`
	GenerateChapters  bool               `json:"generateChapters"`
	IsPrivate         bool               `json:"isPrivate"`
	OwnerUserID       pgtype.UUID        `json:"ownerUserId"`
	SortOrder         int32              `json:"sortOrder"`
	Icon              *string            `json:"icon"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
}

type LibraryUserAccess struct {
	LibraryID uuid.UUID `json:"libraryId"`
	UserID    uuid.UUID `json:"userId"`
	CanManage bool      `json:"canManage"`
}

type Movie struct {
	ID               uuid.UUID          `json:"id"`
	LibraryID        uuid.UUID          `json:"libraryId"`
	Path             string             `json:"path"`
	Container        *string            `json:"container"`
	SizeBytes        *int64             `json:"sizeBytes"`
	RuntimeTicks     *int64             `json:"runtimeTicks"`
	Title            string             `json:"title"`
	SortTitle        *string            `json:"sortTitle"`
	OriginalTitle    *string            `json:"originalTitle"`
	Tagline          *string            `json:"tagline"`
	Overview         *string            `json:"overview"`
	ReleaseDate      pgtype.Date        `json:"releaseDate"`
	Year             *int32             `json:"year"`
	ContentRating    *string            `json:"contentRating"`
	RatingLevel      *int32             `json:"ratingLevel"`
	Budget           *int64             `json:"budget"`
	Revenue          *int64             `json:"revenue"`
	CommunityRating  pgtype.Numeric     `json:"communityRating"`
	VoteCount        *int32             `json:"voteCount"`
	CriticRating     pgtype.Numeric     `json:"criticRating"`
	CriticCount      *int32             `json:"criticCount"`
	PosterPath       *string            `json:"posterPath"`
	PosterBlurhash   *string            `json:"posterBlurhash"`
	BackdropPath     *string            `json:"backdropPath"`
	BackdropBlurhash *string            `json:"backdropBlurhash"`
	LogoPath         *string            `json:"logoPath"`
	TmdbID           *int32             `json:"tmdbId"`
	ImdbID           *string            `json:"imdbId"`
	TvdbID           *int32             `json:"tvdbId"`
	DateAdded        time.Time          `json:"dateAdded"`
	LastPlayedAt     pgtype.Timestamptz `json:"lastPlayedAt"`
	PlayCount        int32              `json:"playCount"`
	IsLocked         bool               `json:"isLocked"`
	CreatedAt        time.Time          `json:"createdAt"`
	UpdatedAt        time.Time          `json:"updatedAt"`
	CollectionID     pgtype.UUID        `json:"collectionId"`
	CollectionOrder  *int32             `json:"collectionOrder"`
}

type MovieCollection struct {
	ID               uuid.UUID `json:"id"`
	Name             string    `json:"name"`
	SortName         *string   `json:"sortName"`
	Overview         *string   `json:"overview"`
	PosterPath       *string   `json:"posterPath"`
	PosterBlurhash   *string   `json:"posterBlurhash"`
	BackdropPath     *string   `json:"backdropPath"`
	BackdropBlurhash *string   `json:"backdropBlurhash"`
	TmdbID           *int32    `json:"tmdbId"`
	CreatedAt        time.Time `json:"createdAt"`
	UpdatedAt        time.Time `json:"updatedAt"`
}

type MovieCredit struct {
	ID            uuid.UUID `json:"id"`
	MovieID       uuid.UUID `json:"movieId"`
	PersonID      uuid.UUID `json:"personId"`
	Role          string    `json:"role"`
	CharacterName *string   `json:"characterName"`
	Department    *string   `json:"department"`
	Job           *string   `json:"job"`
	BillingOrder  int32     `json:"billingOrder"`
	IsGuest       bool      `json:"isGuest"`
	TmdbCreditID  *string   `json:"tmdbCreditId"`
	CreatedAt     time.Time `json:"createdAt"`
}

type MovieExternalRating struct {
	MovieID     uuid.UUID      `json:"movieId"`
	Source      string         `json:"source"`
	Rating      pgtype.Numeric `json:"rating"`
	VoteCount   *int32         `json:"voteCount"`
	Certified   *bool          `json:"certified"`
	LastUpdated time.Time      `json:"lastUpdated"`
}

type MovieFavorite struct {
	UserID    uuid.UUID `json:"userId"`
	MovieID   uuid.UUID `json:"movieId"`
	CreatedAt time.Time `json:"createdAt"`
}

type MovieGenre struct {
	ID          uuid.UUID       `json:"id"`
	Name        string          `json:"name"`
	Slug        string          `json:"slug"`
	Description *string         `json:"description"`
	ParentID    pgtype.UUID     `json:"parentId"`
	ExternalIds json.RawMessage `json:"externalIds"`
	CreatedAt   time.Time       `json:"createdAt"`
	UpdatedAt   time.Time       `json:"updatedAt"`
}

type MovieGenreLink struct {
	MovieID uuid.UUID `json:"movieId"`
	GenreID uuid.UUID `json:"genreId"`
}

type MovieImage struct {
	ID          uuid.UUID      `json:"id"`
	MovieID     uuid.UUID      `json:"movieId"`
	ImageType   string         `json:"imageType"`
	Path        string         `json:"path"`
	Blurhash    *string        `json:"blurhash"`
	Width       *int32         `json:"width"`
	Height      *int32         `json:"height"`
	AspectRatio pgtype.Numeric `json:"aspectRatio"`
	Language    *string        `json:"language"`
	VoteAverage pgtype.Numeric `json:"voteAverage"`
	VoteCount   *int32         `json:"voteCount"`
	IsPrimary   bool           `json:"isPrimary"`
	Source      string         `json:"source"`
	CreatedAt   time.Time      `json:"createdAt"`
}

type MoviePerson struct {
	ID                   uuid.UUID   `json:"id"`
	Name                 string      `json:"name"`
	SortName             *string     `json:"sortName"`
	OriginalName         *string     `json:"originalName"`
	Biography            *string     `json:"biography"`
	Birthdate            pgtype.Date `json:"birthdate"`
	Deathdate            pgtype.Date `json:"deathdate"`
	Birthplace           *string     `json:"birthplace"`
	Gender               *string     `json:"gender"`
	PrimaryImageUrl      *string     `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string     `json:"primaryImageBlurhash"`
	TmdbID               *int32      `json:"tmdbId"`
	ImdbID               *string     `json:"imdbId"`
	TvdbID               *int32      `json:"tvdbId"`
	CreatedAt            time.Time   `json:"createdAt"`
	UpdatedAt            time.Time   `json:"updatedAt"`
}

type MovieStudio struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	LogoPath  *string   `json:"logoPath"`
	TmdbID    *int32    `json:"tmdbId"`
	CreatedAt time.Time `json:"createdAt"`
}

type MovieStudioLink struct {
	MovieID      uuid.UUID `json:"movieId"`
	StudioID     uuid.UUID `json:"studioId"`
	DisplayOrder int32     `json:"displayOrder"`
}

type MovieUserRating struct {
	UserID    uuid.UUID      `json:"userId"`
	MovieID   uuid.UUID      `json:"movieId"`
	Rating    pgtype.Numeric `json:"rating"`
	Review    *string        `json:"review"`
	CreatedAt time.Time      `json:"createdAt"`
	UpdatedAt time.Time      `json:"updatedAt"`
}

type MovieVideo struct {
	ID        uuid.UUID `json:"id"`
	MovieID   uuid.UUID `json:"movieId"`
	VideoType string    `json:"videoType"`
	Site      string    `json:"site"`
	Key       string    `json:"key"`
	Name      *string   `json:"name"`
	Language  *string   `json:"language"`
	Size      *int32    `json:"size"`
	CreatedAt time.Time `json:"createdAt"`
}

type MovieWatchHistory struct {
	ID               uuid.UUID          `json:"id"`
	UserID           uuid.UUID          `json:"userId"`
	ProfileID        pgtype.UUID        `json:"profileId"`
	MovieID          uuid.UUID          `json:"movieId"`
	PositionTicks    int64              `json:"positionTicks"`
	DurationTicks    *int64             `json:"durationTicks"`
	PlayedPercentage pgtype.Numeric     `json:"playedPercentage"`
	Completed        bool               `json:"completed"`
	CompletedAt      pgtype.Timestamptz `json:"completedAt"`
	DeviceName       *string            `json:"deviceName"`
	DeviceType       *string            `json:"deviceType"`
	ClientName       *string            `json:"clientName"`
	PlayMethod       *string            `json:"playMethod"`
	StartedAt        time.Time          `json:"startedAt"`
	LastUpdatedAt    time.Time          `json:"lastUpdatedAt"`
}

type MovieWatchlist struct {
	UserID    uuid.UUID `json:"userId"`
	MovieID   uuid.UUID `json:"movieId"`
	AddedAt   time.Time `json:"addedAt"`
	SortOrder *int32    `json:"sortOrder"`
}

type OidcProvider struct {
	ID              uuid.UUID       `json:"id"`
	Name            string          `json:"name"`
	Slug            string          `json:"slug"`
	Enabled         bool            `json:"enabled"`
	IssuerUrl       string          `json:"issuerUrl"`
	ClientID        string          `json:"clientId"`
	ClientSecretEnc []byte          `json:"clientSecretEnc"`
	Scopes          []string        `json:"scopes"`
	ClaimMapping    json.RawMessage `json:"claimMapping"`
	RoleMapping     json.RawMessage `json:"roleMapping"`
	AutoProvision   bool            `json:"autoProvision"`
	DefaultRole     string          `json:"defaultRole"`
	CreatedAt       time.Time       `json:"createdAt"`
	UpdatedAt       time.Time       `json:"updatedAt"`
}

type OidcUserLink struct {
	ID          uuid.UUID          `json:"id"`
	UserID      uuid.UUID          `json:"userId"`
	ProviderID  uuid.UUID          `json:"providerId"`
	Subject     string             `json:"subject"`
	Email       *string            `json:"email"`
	Name        *string            `json:"name"`
	Groups      []string           `json:"groups"`
	LinkedAt    time.Time          `json:"linkedAt"`
	LastLoginAt pgtype.Timestamptz `json:"lastLoginAt"`
}

type Permission struct {
	ID          int32     `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Category    string    `json:"category"`
	CreatedAt   time.Time `json:"createdAt"`
}

type Profile struct {
	ID                        uuid.UUID `json:"id"`
	UserID                    uuid.UUID `json:"userId"`
	Name                      string    `json:"name"`
	AvatarUrl                 *string   `json:"avatarUrl"`
	IsDefault                 bool      `json:"isDefault"`
	IsKids                    bool      `json:"isKids"`
	MaxRatingLevel            int32     `json:"maxRatingLevel"`
	AdultEnabled              bool      `json:"adultEnabled"`
	PreferredLanguage         *string   `json:"preferredLanguage"`
	PreferredAudioLanguage    *string   `json:"preferredAudioLanguage"`
	PreferredSubtitleLanguage *string   `json:"preferredSubtitleLanguage"`
	AutoplayNext              *bool     `json:"autoplayNext"`
	AutoplayPreviews          *bool     `json:"autoplayPreviews"`
	CreatedAt                 time.Time `json:"createdAt"`
	UpdatedAt                 time.Time `json:"updatedAt"`
}

type RolePermission struct {
	Role         string `json:"role"`
	PermissionID int32  `json:"permissionId"`
}

type ServerSetting struct {
	Key         string          `json:"key"`
	Value       json.RawMessage `json:"value"`
	Category    string          `json:"category"`
	Description *string         `json:"description"`
	IsPublic    bool            `json:"isPublic"`
	CreatedAt   time.Time       `json:"createdAt"`
	UpdatedAt   time.Time       `json:"updatedAt"`
}

type Session struct {
	ID            uuid.UUID   `json:"id"`
	UserID        uuid.UUID   `json:"userId"`
	ProfileID     pgtype.UUID `json:"profileId"`
	TokenHash     string      `json:"tokenHash"`
	DeviceName    *string     `json:"deviceName"`
	DeviceType    *string     `json:"deviceType"`
	ClientName    *string     `json:"clientName"`
	ClientVersion *string     `json:"clientVersion"`
	IpAddress     netip.Addr  `json:"ipAddress"`
	UserAgent     *string     `json:"userAgent"`
	IsActive      bool        `json:"isActive"`
	LastActivity  time.Time   `json:"lastActivity"`
	ExpiresAt     time.Time   `json:"expiresAt"`
	CreatedAt     time.Time   `json:"createdAt"`
}

type User struct {
	ID                    uuid.UUID          `json:"id"`
	Username              string             `json:"username"`
	Email                 *string            `json:"email"`
	PasswordHash          *string            `json:"passwordHash"`
	IsAdmin               bool               `json:"isAdmin"`
	IsDisabled            bool               `json:"isDisabled"`
	MaxRatingLevel        int32              `json:"maxRatingLevel"`
	AdultEnabled          bool               `json:"adultEnabled"`
	PreferredLanguage     *string            `json:"preferredLanguage"`
	PreferredRatingSystem *string            `json:"preferredRatingSystem"`
	LastLoginAt           pgtype.Timestamptz `json:"lastLoginAt"`
	CreatedAt             time.Time          `json:"createdAt"`
	UpdatedAt             time.Time          `json:"updatedAt"`
	Role                  string             `json:"role"`
}
