// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: movies.sql

package moviedb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countCollections = `-- name: CountCollections :one
SELECT COUNT(*) FROM movie_collections
`

func (q *Queries) CountCollections(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCollections)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovies = `-- name: CountMovies :one
SELECT COUNT(*) FROM movies
`

func (q *Queries) CountMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMoviesByLibrary = `-- name: CountMoviesByLibrary :one
SELECT COUNT(*) FROM movies WHERE movie_library_id = $1
`

func (q *Queries) CountMoviesByLibrary(ctx context.Context, movieLibraryID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMoviesByLibrary, movieLibraryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCollection = `-- name: CreateCollection :one
INSERT INTO movie_collections (name, sort_name, overview, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, tmdb_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, name, sort_name, overview, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, tmdb_id, created_at, updated_at
`

type CreateCollectionParams struct {
	Name             string  `json:"name"`
	SortName         *string `json:"sortName"`
	Overview         *string `json:"overview"`
	PosterPath       *string `json:"posterPath"`
	PosterBlurhash   *string `json:"posterBlurhash"`
	BackdropPath     *string `json:"backdropPath"`
	BackdropBlurhash *string `json:"backdropBlurhash"`
	TmdbID           *int32  `json:"tmdbId"`
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (MovieCollection, error) {
	row := q.db.QueryRow(ctx, createCollection,
		arg.Name,
		arg.SortName,
		arg.Overview,
		arg.PosterPath,
		arg.PosterBlurhash,
		arg.BackdropPath,
		arg.BackdropBlurhash,
		arg.TmdbID,
	)
	var i MovieCollection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SortName,
		&i.Overview,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMovie = `-- name: CreateMovie :one
INSERT INTO movies (
    movie_library_id, path, container, size_bytes, runtime_ticks,
    title, sort_title, original_title, tagline, overview,
    release_date, year, content_rating, rating_level,
    budget, revenue, community_rating, vote_count,
    poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path,
    tmdb_id, imdb_id, tvdb_id,
    collection_id, collection_order
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9, $10,
    $11, $12, $13, $14,
    $15, $16, $17, $18,
    $19, $20, $21, $22, $23,
    $24, $25, $26,
    $27, $28
) RETURNING id, path, container, size_bytes, runtime_ticks, title, sort_title, original_title, tagline, overview, release_date, year, content_rating, rating_level, budget, revenue, community_rating, vote_count, critic_rating, critic_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at, collection_id, collection_order, movie_library_id
`

type CreateMovieParams struct {
	MovieLibraryID   uuid.UUID      `json:"movieLibraryId"`
	Path             string         `json:"path"`
	Container        *string        `json:"container"`
	SizeBytes        *int64         `json:"sizeBytes"`
	RuntimeTicks     *int64         `json:"runtimeTicks"`
	Title            string         `json:"title"`
	SortTitle        *string        `json:"sortTitle"`
	OriginalTitle    *string        `json:"originalTitle"`
	Tagline          *string        `json:"tagline"`
	Overview         *string        `json:"overview"`
	ReleaseDate      pgtype.Date    `json:"releaseDate"`
	Year             *int32         `json:"year"`
	ContentRating    *string        `json:"contentRating"`
	RatingLevel      *int32         `json:"ratingLevel"`
	Budget           *int64         `json:"budget"`
	Revenue          *int64         `json:"revenue"`
	CommunityRating  pgtype.Numeric `json:"communityRating"`
	VoteCount        *int32         `json:"voteCount"`
	PosterPath       *string        `json:"posterPath"`
	PosterBlurhash   *string        `json:"posterBlurhash"`
	BackdropPath     *string        `json:"backdropPath"`
	BackdropBlurhash *string        `json:"backdropBlurhash"`
	LogoPath         *string        `json:"logoPath"`
	TmdbID           *int32         `json:"tmdbId"`
	ImdbID           *string        `json:"imdbId"`
	TvdbID           *int32         `json:"tvdbId"`
	CollectionID     pgtype.UUID    `json:"collectionId"`
	CollectionOrder  *int32         `json:"collectionOrder"`
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (Movie, error) {
	row := q.db.QueryRow(ctx, createMovie,
		arg.MovieLibraryID,
		arg.Path,
		arg.Container,
		arg.SizeBytes,
		arg.RuntimeTicks,
		arg.Title,
		arg.SortTitle,
		arg.OriginalTitle,
		arg.Tagline,
		arg.Overview,
		arg.ReleaseDate,
		arg.Year,
		arg.ContentRating,
		arg.RatingLevel,
		arg.Budget,
		arg.Revenue,
		arg.CommunityRating,
		arg.VoteCount,
		arg.PosterPath,
		arg.PosterBlurhash,
		arg.BackdropPath,
		arg.BackdropBlurhash,
		arg.LogoPath,
		arg.TmdbID,
		arg.ImdbID,
		arg.TvdbID,
		arg.CollectionID,
		arg.CollectionOrder,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.ReleaseDate,
		&i.Year,
		&i.ContentRating,
		&i.RatingLevel,
		&i.Budget,
		&i.Revenue,
		&i.CommunityRating,
		&i.VoteCount,
		&i.CriticRating,
		&i.CriticCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CollectionID,
		&i.CollectionOrder,
		&i.MovieLibraryID,
	)
	return i, err
}

const createStudio = `-- name: CreateStudio :one
INSERT INTO movie_studios (name, logo_path, tmdb_id)
VALUES ($1, $2, $3)
RETURNING id, name, logo_path, tmdb_id, created_at
`

type CreateStudioParams struct {
	Name     string  `json:"name"`
	LogoPath *string `json:"logoPath"`
	TmdbID   *int32  `json:"tmdbId"`
}

func (q *Queries) CreateStudio(ctx context.Context, arg CreateStudioParams) (MovieStudio, error) {
	row := q.db.QueryRow(ctx, createStudio, arg.Name, arg.LogoPath, arg.TmdbID)
	var i MovieStudio
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LogoPath,
		&i.TmdbID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM movie_collections WHERE id = $1
`

func (q *Queries) DeleteCollection(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCollection, id)
	return err
}

const deleteMovie = `-- name: DeleteMovie :exec
DELETE FROM movies WHERE id = $1
`

func (q *Queries) DeleteMovie(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMovie, id)
	return err
}

const deleteMoviesByLibrary = `-- name: DeleteMoviesByLibrary :exec
DELETE FROM movies WHERE movie_library_id = $1
`

func (q *Queries) DeleteMoviesByLibrary(ctx context.Context, movieLibraryID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMoviesByLibrary, movieLibraryID)
	return err
}

const getCollectionByID = `-- name: GetCollectionByID :one

SELECT id, name, sort_name, overview, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, tmdb_id, created_at, updated_at FROM movie_collections WHERE id = $1
`

// Collections
func (q *Queries) GetCollectionByID(ctx context.Context, id uuid.UUID) (MovieCollection, error) {
	row := q.db.QueryRow(ctx, getCollectionByID, id)
	var i MovieCollection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SortName,
		&i.Overview,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCollectionByTmdbID = `-- name: GetCollectionByTmdbID :one
SELECT id, name, sort_name, overview, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, tmdb_id, created_at, updated_at FROM movie_collections WHERE tmdb_id = $1
`

func (q *Queries) GetCollectionByTmdbID(ctx context.Context, tmdbID *int32) (MovieCollection, error) {
	row := q.db.QueryRow(ctx, getCollectionByTmdbID, tmdbID)
	var i MovieCollection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SortName,
		&i.Overview,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMovieByID = `-- name: GetMovieByID :one

SELECT id, path, container, size_bytes, runtime_ticks, title, sort_title, original_title, tagline, overview, release_date, year, content_rating, rating_level, budget, revenue, community_rating, vote_count, critic_rating, critic_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at, collection_id, collection_order, movie_library_id FROM movies WHERE id = $1
`

// Movie Core Queries
func (q *Queries) GetMovieByID(ctx context.Context, id uuid.UUID) (Movie, error) {
	row := q.db.QueryRow(ctx, getMovieByID, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.ReleaseDate,
		&i.Year,
		&i.ContentRating,
		&i.RatingLevel,
		&i.Budget,
		&i.Revenue,
		&i.CommunityRating,
		&i.VoteCount,
		&i.CriticRating,
		&i.CriticCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CollectionID,
		&i.CollectionOrder,
		&i.MovieLibraryID,
	)
	return i, err
}

const getMovieByImdbID = `-- name: GetMovieByImdbID :one
SELECT id, path, container, size_bytes, runtime_ticks, title, sort_title, original_title, tagline, overview, release_date, year, content_rating, rating_level, budget, revenue, community_rating, vote_count, critic_rating, critic_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at, collection_id, collection_order, movie_library_id FROM movies WHERE imdb_id = $1
`

func (q *Queries) GetMovieByImdbID(ctx context.Context, imdbID *string) (Movie, error) {
	row := q.db.QueryRow(ctx, getMovieByImdbID, imdbID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.ReleaseDate,
		&i.Year,
		&i.ContentRating,
		&i.RatingLevel,
		&i.Budget,
		&i.Revenue,
		&i.CommunityRating,
		&i.VoteCount,
		&i.CriticRating,
		&i.CriticCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CollectionID,
		&i.CollectionOrder,
		&i.MovieLibraryID,
	)
	return i, err
}

const getMovieByPath = `-- name: GetMovieByPath :one
SELECT id, path, container, size_bytes, runtime_ticks, title, sort_title, original_title, tagline, overview, release_date, year, content_rating, rating_level, budget, revenue, community_rating, vote_count, critic_rating, critic_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at, collection_id, collection_order, movie_library_id FROM movies WHERE path = $1
`

func (q *Queries) GetMovieByPath(ctx context.Context, path string) (Movie, error) {
	row := q.db.QueryRow(ctx, getMovieByPath, path)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.ReleaseDate,
		&i.Year,
		&i.ContentRating,
		&i.RatingLevel,
		&i.Budget,
		&i.Revenue,
		&i.CommunityRating,
		&i.VoteCount,
		&i.CriticRating,
		&i.CriticCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CollectionID,
		&i.CollectionOrder,
		&i.MovieLibraryID,
	)
	return i, err
}

const getMovieByTmdbID = `-- name: GetMovieByTmdbID :one
SELECT id, path, container, size_bytes, runtime_ticks, title, sort_title, original_title, tagline, overview, release_date, year, content_rating, rating_level, budget, revenue, community_rating, vote_count, critic_rating, critic_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at, collection_id, collection_order, movie_library_id FROM movies WHERE tmdb_id = $1
`

func (q *Queries) GetMovieByTmdbID(ctx context.Context, tmdbID *int32) (Movie, error) {
	row := q.db.QueryRow(ctx, getMovieByTmdbID, tmdbID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.ReleaseDate,
		&i.Year,
		&i.ContentRating,
		&i.RatingLevel,
		&i.Budget,
		&i.Revenue,
		&i.CommunityRating,
		&i.VoteCount,
		&i.CriticRating,
		&i.CriticCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CollectionID,
		&i.CollectionOrder,
		&i.MovieLibraryID,
	)
	return i, err
}

const getStudioByID = `-- name: GetStudioByID :one

SELECT id, name, logo_path, tmdb_id, created_at FROM movie_studios WHERE id = $1
`

// Studios
func (q *Queries) GetStudioByID(ctx context.Context, id uuid.UUID) (MovieStudio, error) {
	row := q.db.QueryRow(ctx, getStudioByID, id)
	var i MovieStudio
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LogoPath,
		&i.TmdbID,
		&i.CreatedAt,
	)
	return i, err
}

const getStudioByTmdbID = `-- name: GetStudioByTmdbID :one
SELECT id, name, logo_path, tmdb_id, created_at FROM movie_studios WHERE tmdb_id = $1
`

func (q *Queries) GetStudioByTmdbID(ctx context.Context, tmdbID *int32) (MovieStudio, error) {
	row := q.db.QueryRow(ctx, getStudioByTmdbID, tmdbID)
	var i MovieStudio
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LogoPath,
		&i.TmdbID,
		&i.CreatedAt,
	)
	return i, err
}

const linkMovieStudio = `-- name: LinkMovieStudio :exec
INSERT INTO movie_studio_link (movie_id, studio_id, display_order)
VALUES ($1, $2, $3)
ON CONFLICT (movie_id, studio_id) DO UPDATE SET display_order = $3
`

type LinkMovieStudioParams struct {
	MovieID      uuid.UUID `json:"movieId"`
	StudioID     uuid.UUID `json:"studioId"`
	DisplayOrder int32     `json:"displayOrder"`
}

func (q *Queries) LinkMovieStudio(ctx context.Context, arg LinkMovieStudioParams) error {
	_, err := q.db.Exec(ctx, linkMovieStudio, arg.MovieID, arg.StudioID, arg.DisplayOrder)
	return err
}

const listCollections = `-- name: ListCollections :many
SELECT id, name, sort_name, overview, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, tmdb_id, created_at, updated_at FROM movie_collections
ORDER BY name ASC
LIMIT $1 OFFSET $2
`

type ListCollectionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCollections(ctx context.Context, arg ListCollectionsParams) ([]MovieCollection, error) {
	rows, err := q.db.Query(ctx, listCollections, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieCollection{}
	for rows.Next() {
		var i MovieCollection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SortName,
			&i.Overview,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.TmdbID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviePaths = `-- name: ListMoviePaths :many
SELECT id, path FROM movies WHERE movie_library_id = $1
`

type ListMoviePathsRow struct {
	ID   uuid.UUID `json:"id"`
	Path string    `json:"path"`
}

func (q *Queries) ListMoviePaths(ctx context.Context, movieLibraryID uuid.UUID) ([]ListMoviePathsRow, error) {
	rows, err := q.db.Query(ctx, listMoviePaths, movieLibraryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMoviePathsRow{}
	for rows.Next() {
		var i ListMoviePathsRow
		if err := rows.Scan(&i.ID, &i.Path); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieStudios = `-- name: ListMovieStudios :many
SELECT s.id, s.name, s.logo_path, s.tmdb_id, s.created_at FROM movie_studios s
JOIN movie_studio_link msl ON s.id = msl.studio_id
WHERE msl.movie_id = $1
ORDER BY msl.display_order ASC
`

func (q *Queries) ListMovieStudios(ctx context.Context, movieID uuid.UUID) ([]MovieStudio, error) {
	rows, err := q.db.Query(ctx, listMovieStudios, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieStudio{}
	for rows.Next() {
		var i MovieStudio
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LogoPath,
			&i.TmdbID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovies = `-- name: ListMovies :many
SELECT id, path, container, size_bytes, runtime_ticks, title, sort_title, original_title, tagline, overview, release_date, year, content_rating, rating_level, budget, revenue, community_rating, vote_count, critic_rating, critic_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at, collection_id, collection_order, movie_library_id FROM movies
ORDER BY
    CASE WHEN $3::text = 'title' AND $4::text = 'asc' THEN sort_title END ASC,
    CASE WHEN $3::text = 'title' AND $4::text = 'desc' THEN sort_title END DESC,
    CASE WHEN $3::text = 'date_added' AND $4::text = 'asc' THEN date_added END ASC,
    CASE WHEN $3::text = 'date_added' AND $4::text = 'desc' THEN date_added END DESC,
    CASE WHEN $3::text = 'release_date' AND $4::text = 'asc' THEN release_date END ASC,
    CASE WHEN $3::text = 'release_date' AND $4::text = 'desc' THEN release_date END DESC,
    CASE WHEN $3::text = 'rating' AND $4::text = 'asc' THEN community_rating END ASC NULLS LAST,
    CASE WHEN $3::text = 'rating' AND $4::text = 'desc' THEN community_rating END DESC NULLS LAST,
    sort_title ASC
LIMIT $1 OFFSET $2
`

type ListMoviesParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	SortBy    string `json:"sortBy"`
	SortOrder string `json:"sortOrder"`
}

func (q *Queries) ListMovies(ctx context.Context, arg ListMoviesParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listMovies,
		arg.Limit,
		arg.Offset,
		arg.SortBy,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.ReleaseDate,
			&i.Year,
			&i.ContentRating,
			&i.RatingLevel,
			&i.Budget,
			&i.Revenue,
			&i.CommunityRating,
			&i.VoteCount,
			&i.CriticRating,
			&i.CriticCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CollectionID,
			&i.CollectionOrder,
			&i.MovieLibraryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesByCollection = `-- name: ListMoviesByCollection :many
SELECT id, path, container, size_bytes, runtime_ticks, title, sort_title, original_title, tagline, overview, release_date, year, content_rating, rating_level, budget, revenue, community_rating, vote_count, critic_rating, critic_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at, collection_id, collection_order, movie_library_id FROM movies
WHERE collection_id = $1
ORDER BY collection_order ASC, release_date ASC
`

func (q *Queries) ListMoviesByCollection(ctx context.Context, collectionID pgtype.UUID) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listMoviesByCollection, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.ReleaseDate,
			&i.Year,
			&i.ContentRating,
			&i.RatingLevel,
			&i.Budget,
			&i.Revenue,
			&i.CommunityRating,
			&i.VoteCount,
			&i.CriticRating,
			&i.CriticCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CollectionID,
			&i.CollectionOrder,
			&i.MovieLibraryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesByLibrary = `-- name: ListMoviesByLibrary :many
SELECT id, path, container, size_bytes, runtime_ticks, title, sort_title, original_title, tagline, overview, release_date, year, content_rating, rating_level, budget, revenue, community_rating, vote_count, critic_rating, critic_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at, collection_id, collection_order, movie_library_id FROM movies
WHERE movie_library_id = $1
ORDER BY
    CASE WHEN $4::text = 'title' AND $5::text = 'asc' THEN sort_title END ASC,
    CASE WHEN $4::text = 'title' AND $5::text = 'desc' THEN sort_title END DESC,
    CASE WHEN $4::text = 'date_added' AND $5::text = 'asc' THEN date_added END ASC,
    CASE WHEN $4::text = 'date_added' AND $5::text = 'desc' THEN date_added END DESC,
    CASE WHEN $4::text = 'release_date' AND $5::text = 'asc' THEN release_date END ASC,
    CASE WHEN $4::text = 'release_date' AND $5::text = 'desc' THEN release_date END DESC,
    CASE WHEN $4::text = 'rating' AND $5::text = 'asc' THEN community_rating END ASC NULLS LAST,
    CASE WHEN $4::text = 'rating' AND $5::text = 'desc' THEN community_rating END DESC NULLS LAST,
    sort_title ASC
LIMIT $2 OFFSET $3
`

type ListMoviesByLibraryParams struct {
	MovieLibraryID uuid.UUID `json:"movieLibraryId"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
	SortBy         string    `json:"sortBy"`
	SortOrder      string    `json:"sortOrder"`
}

func (q *Queries) ListMoviesByLibrary(ctx context.Context, arg ListMoviesByLibraryParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listMoviesByLibrary,
		arg.MovieLibraryID,
		arg.Limit,
		arg.Offset,
		arg.SortBy,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.ReleaseDate,
			&i.Year,
			&i.ContentRating,
			&i.RatingLevel,
			&i.Budget,
			&i.Revenue,
			&i.CommunityRating,
			&i.VoteCount,
			&i.CriticRating,
			&i.CriticCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CollectionID,
			&i.CollectionOrder,
			&i.MovieLibraryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentlyAddedMovies = `-- name: ListRecentlyAddedMovies :many
SELECT id, path, container, size_bytes, runtime_ticks, title, sort_title, original_title, tagline, overview, release_date, year, content_rating, rating_level, budget, revenue, community_rating, vote_count, critic_rating, critic_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at, collection_id, collection_order, movie_library_id FROM movies
WHERE movie_library_id = ANY($2::uuid[])
ORDER BY date_added DESC
LIMIT $1
`

type ListRecentlyAddedMoviesParams struct {
	Limit      int32       `json:"limit"`
	LibraryIds []uuid.UUID `json:"libraryIds"`
}

func (q *Queries) ListRecentlyAddedMovies(ctx context.Context, arg ListRecentlyAddedMoviesParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listRecentlyAddedMovies, arg.Limit, arg.LibraryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.ReleaseDate,
			&i.Year,
			&i.ContentRating,
			&i.RatingLevel,
			&i.Budget,
			&i.Revenue,
			&i.CommunityRating,
			&i.VoteCount,
			&i.CriticRating,
			&i.CriticCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CollectionID,
			&i.CollectionOrder,
			&i.MovieLibraryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentlyPlayedMovies = `-- name: ListRecentlyPlayedMovies :many
SELECT id, path, container, size_bytes, runtime_ticks, title, sort_title, original_title, tagline, overview, release_date, year, content_rating, rating_level, budget, revenue, community_rating, vote_count, critic_rating, critic_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at, collection_id, collection_order, movie_library_id FROM movies
WHERE movie_library_id = ANY($2::uuid[])
  AND last_played_at IS NOT NULL
ORDER BY last_played_at DESC
LIMIT $1
`

type ListRecentlyPlayedMoviesParams struct {
	Limit      int32       `json:"limit"`
	LibraryIds []uuid.UUID `json:"libraryIds"`
}

func (q *Queries) ListRecentlyPlayedMovies(ctx context.Context, arg ListRecentlyPlayedMoviesParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listRecentlyPlayedMovies, arg.Limit, arg.LibraryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.ReleaseDate,
			&i.Year,
			&i.ContentRating,
			&i.RatingLevel,
			&i.Budget,
			&i.Revenue,
			&i.CommunityRating,
			&i.VoteCount,
			&i.CriticRating,
			&i.CriticCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CollectionID,
			&i.CollectionOrder,
			&i.MovieLibraryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudios = `-- name: ListStudios :many
SELECT id, name, logo_path, tmdb_id, created_at FROM movie_studios ORDER BY name ASC LIMIT $1 OFFSET $2
`

type ListStudiosParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListStudios(ctx context.Context, arg ListStudiosParams) ([]MovieStudio, error) {
	rows, err := q.db.Query(ctx, listStudios, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieStudio{}
	for rows.Next() {
		var i MovieStudio
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LogoPath,
			&i.TmdbID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const movieExistsByPath = `-- name: MovieExistsByPath :one
SELECT EXISTS(SELECT 1 FROM movies WHERE path = $1)
`

func (q *Queries) MovieExistsByPath(ctx context.Context, path string) (bool, error) {
	row := q.db.QueryRow(ctx, movieExistsByPath, path)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const movieExistsByTmdbID = `-- name: MovieExistsByTmdbID :one
SELECT EXISTS(SELECT 1 FROM movies WHERE tmdb_id = $1)
`

func (q *Queries) MovieExistsByTmdbID(ctx context.Context, tmdbID *int32) (bool, error) {
	row := q.db.QueryRow(ctx, movieExistsByTmdbID, tmdbID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const searchMovies = `-- name: SearchMovies :many
SELECT id, path, container, size_bytes, runtime_ticks, title, sort_title, original_title, tagline, overview, release_date, year, content_rating, rating_level, budget, revenue, community_rating, vote_count, critic_rating, critic_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at, collection_id, collection_order, movie_library_id FROM movies
WHERE to_tsvector('english', COALESCE(title, '') || ' ' || COALESCE(original_title, '') || ' ' || COALESCE(overview, ''))
      @@ plainto_tsquery('english', $1)
ORDER BY ts_rank(
    to_tsvector('english', COALESCE(title, '') || ' ' || COALESCE(original_title, '') || ' ' || COALESCE(overview, '')),
    plainto_tsquery('english', $1)
) DESC
LIMIT $2 OFFSET $3
`

type SearchMoviesParams struct {
	PlaintoTsquery string `json:"plaintoTsquery"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

func (q *Queries) SearchMovies(ctx context.Context, arg SearchMoviesParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, searchMovies, arg.PlaintoTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.ReleaseDate,
			&i.Year,
			&i.ContentRating,
			&i.RatingLevel,
			&i.Budget,
			&i.Revenue,
			&i.CommunityRating,
			&i.VoteCount,
			&i.CriticRating,
			&i.CriticCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CollectionID,
			&i.CollectionOrder,
			&i.MovieLibraryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unlinkMovieStudios = `-- name: UnlinkMovieStudios :exec
DELETE FROM movie_studio_link WHERE movie_id = $1
`

func (q *Queries) UnlinkMovieStudios(ctx context.Context, movieID uuid.UUID) error {
	_, err := q.db.Exec(ctx, unlinkMovieStudios, movieID)
	return err
}

const updateCollection = `-- name: UpdateCollection :one
UPDATE movie_collections SET
    name = COALESCE($1, name),
    sort_name = COALESCE($2, sort_name),
    overview = COALESCE($3, overview),
    poster_path = COALESCE($4, poster_path),
    poster_blurhash = COALESCE($5, poster_blurhash),
    backdrop_path = COALESCE($6, backdrop_path),
    backdrop_blurhash = COALESCE($7, backdrop_blurhash)
WHERE id = $8
RETURNING id, name, sort_name, overview, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, tmdb_id, created_at, updated_at
`

type UpdateCollectionParams struct {
	Name             *string   `json:"name"`
	SortName         *string   `json:"sortName"`
	Overview         *string   `json:"overview"`
	PosterPath       *string   `json:"posterPath"`
	PosterBlurhash   *string   `json:"posterBlurhash"`
	BackdropPath     *string   `json:"backdropPath"`
	BackdropBlurhash *string   `json:"backdropBlurhash"`
	ID               uuid.UUID `json:"id"`
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) (MovieCollection, error) {
	row := q.db.QueryRow(ctx, updateCollection,
		arg.Name,
		arg.SortName,
		arg.Overview,
		arg.PosterPath,
		arg.PosterBlurhash,
		arg.BackdropPath,
		arg.BackdropBlurhash,
		arg.ID,
	)
	var i MovieCollection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SortName,
		&i.Overview,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.TmdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMovie = `-- name: UpdateMovie :one
UPDATE movies SET
    title = COALESCE($1, title),
    sort_title = COALESCE($2, sort_title),
    original_title = COALESCE($3, original_title),
    tagline = COALESCE($4, tagline),
    overview = COALESCE($5, overview),
    release_date = COALESCE($6, release_date),
    year = COALESCE($7, year),
    content_rating = COALESCE($8, content_rating),
    rating_level = COALESCE($9, rating_level),
    budget = COALESCE($10, budget),
    revenue = COALESCE($11, revenue),
    community_rating = COALESCE($12, community_rating),
    vote_count = COALESCE($13, vote_count),
    poster_path = COALESCE($14, poster_path),
    poster_blurhash = COALESCE($15, poster_blurhash),
    backdrop_path = COALESCE($16, backdrop_path),
    backdrop_blurhash = COALESCE($17, backdrop_blurhash),
    logo_path = COALESCE($18, logo_path),
    tmdb_id = COALESCE($19, tmdb_id),
    imdb_id = COALESCE($20, imdb_id),
    tvdb_id = COALESCE($21, tvdb_id),
    collection_id = $22,
    collection_order = COALESCE($23, collection_order),
    is_locked = COALESCE($24, is_locked)
WHERE id = $25
RETURNING id, path, container, size_bytes, runtime_ticks, title, sort_title, original_title, tagline, overview, release_date, year, content_rating, rating_level, budget, revenue, community_rating, vote_count, critic_rating, critic_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at, collection_id, collection_order, movie_library_id
`

type UpdateMovieParams struct {
	Title            *string        `json:"title"`
	SortTitle        *string        `json:"sortTitle"`
	OriginalTitle    *string        `json:"originalTitle"`
	Tagline          *string        `json:"tagline"`
	Overview         *string        `json:"overview"`
	ReleaseDate      pgtype.Date    `json:"releaseDate"`
	Year             *int32         `json:"year"`
	ContentRating    *string        `json:"contentRating"`
	RatingLevel      *int32         `json:"ratingLevel"`
	Budget           *int64         `json:"budget"`
	Revenue          *int64         `json:"revenue"`
	CommunityRating  pgtype.Numeric `json:"communityRating"`
	VoteCount        *int32         `json:"voteCount"`
	PosterPath       *string        `json:"posterPath"`
	PosterBlurhash   *string        `json:"posterBlurhash"`
	BackdropPath     *string        `json:"backdropPath"`
	BackdropBlurhash *string        `json:"backdropBlurhash"`
	LogoPath         *string        `json:"logoPath"`
	TmdbID           *int32         `json:"tmdbId"`
	ImdbID           *string        `json:"imdbId"`
	TvdbID           *int32         `json:"tvdbId"`
	CollectionID     pgtype.UUID    `json:"collectionId"`
	CollectionOrder  *int32         `json:"collectionOrder"`
	IsLocked         *bool          `json:"isLocked"`
	ID               uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) (Movie, error) {
	row := q.db.QueryRow(ctx, updateMovie,
		arg.Title,
		arg.SortTitle,
		arg.OriginalTitle,
		arg.Tagline,
		arg.Overview,
		arg.ReleaseDate,
		arg.Year,
		arg.ContentRating,
		arg.RatingLevel,
		arg.Budget,
		arg.Revenue,
		arg.CommunityRating,
		arg.VoteCount,
		arg.PosterPath,
		arg.PosterBlurhash,
		arg.BackdropPath,
		arg.BackdropBlurhash,
		arg.LogoPath,
		arg.TmdbID,
		arg.ImdbID,
		arg.TvdbID,
		arg.CollectionID,
		arg.CollectionOrder,
		arg.IsLocked,
		arg.ID,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.ReleaseDate,
		&i.Year,
		&i.ContentRating,
		&i.RatingLevel,
		&i.Budget,
		&i.Revenue,
		&i.CommunityRating,
		&i.VoteCount,
		&i.CriticRating,
		&i.CriticCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CollectionID,
		&i.CollectionOrder,
		&i.MovieLibraryID,
	)
	return i, err
}

const updateMoviePlaybackStats = `-- name: UpdateMoviePlaybackStats :exec
UPDATE movies SET
    last_played_at = NOW(),
    play_count = play_count + 1
WHERE id = $1
`

func (q *Queries) UpdateMoviePlaybackStats(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateMoviePlaybackStats, id)
	return err
}
