// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: movies.sql

package moviedb

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addMovieGenre = `-- name: AddMovieGenre :exec
INSERT INTO
    movie.movie_genres (movie_id, tmdb_genre_id, name)
VALUES ($1, $2, $3) ON CONFLICT (movie_id, tmdb_genre_id) DO NOTHING
`

type AddMovieGenreParams struct {
	MovieID     uuid.UUID `json:"movieId"`
	TmdbGenreID int32     `json:"tmdbGenreId"`
	Name        string    `json:"name"`
}

// Movie Genres Operations
func (q *Queries) AddMovieGenre(ctx context.Context, arg AddMovieGenreParams) error {
	_, err := q.db.Exec(ctx, addMovieGenre, arg.MovieID, arg.TmdbGenreID, arg.Name)
	return err
}

const addMovieToCollection = `-- name: AddMovieToCollection :exec
INSERT INTO
    movie.movie_collection_members (
        collection_id,
        movie_id,
        collection_order
    )
VALUES ($1, $2, $3) ON CONFLICT (collection_id, movie_id) DO
UPDATE
SET
    collection_order = EXCLUDED.collection_order
`

type AddMovieToCollectionParams struct {
	CollectionID    uuid.UUID `json:"collectionId"`
	MovieID         uuid.UUID `json:"movieId"`
	CollectionOrder *int32    `json:"collectionOrder"`
}

func (q *Queries) AddMovieToCollection(ctx context.Context, arg AddMovieToCollectionParams) error {
	_, err := q.db.Exec(ctx, addMovieToCollection, arg.CollectionID, arg.MovieID, arg.CollectionOrder)
	return err
}

const countMovieCast = `-- name: CountMovieCast :one
SELECT COUNT(*)
FROM movie.movie_credits
WHERE
    movie_id = $1
    AND credit_type = 'cast'
    AND deleted_at IS NULL
`

func (q *Queries) CountMovieCast(ctx context.Context, movieID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMovieCast, movieID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieCrew = `-- name: CountMovieCrew :one
SELECT COUNT(*)
FROM movie.movie_credits
WHERE
    movie_id = $1
    AND credit_type = 'crew'
    AND deleted_at IS NULL
`

func (q *Queries) CountMovieCrew(ctx context.Context, movieID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMovieCrew, movieID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovies = `-- name: CountMovies :one
SELECT COUNT(*) FROM movie.movies WHERE deleted_at IS NULL
`

func (q *Queries) CountMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTopRated = `-- name: CountTopRated :one
SELECT COUNT(*)
FROM movie.movies
WHERE
    deleted_at IS NULL
    AND vote_average IS NOT NULL
    AND vote_count > $1
`

func (q *Queries) CountTopRated(ctx context.Context, voteCount *int32) (int64, error) {
	row := q.db.QueryRow(ctx, countTopRated, voteCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMovie = `-- name: CreateMovie :one
INSERT INTO
    movie.movies (
        tmdb_id,
        imdb_id,
        title,
        original_title,
        year,
        release_date,
        runtime,
        overview,
        tagline,
        status,
        original_language,
        titles_i18n,
        taglines_i18n,
        overviews_i18n,
        age_ratings,
        external_ratings,
        poster_path,
        backdrop_path,
        trailer_url,
        vote_average,
        vote_count,
        popularity,
        budget,
        revenue,
        radarr_id,
        metadata_updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16,
        $17,
        $18,
        $19,
        $20,
        $21,
        $22,
        $23,
        $24,
        $25,
        $26
    ) RETURNING id, tmdb_id, imdb_id, title, original_title, year, release_date, runtime, overview, tagline, status, original_language, poster_path, backdrop_path, trailer_url, vote_average, vote_count, popularity, budget, revenue, library_added_at, metadata_updated_at, radarr_id, created_at, updated_at, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, deleted_at, external_ratings
`

type CreateMovieParams struct {
	TmdbID            *int32             `json:"tmdbId"`
	ImdbID            *string            `json:"imdbId"`
	Title             string             `json:"title"`
	OriginalTitle     *string            `json:"originalTitle"`
	Year              *int32             `json:"year"`
	ReleaseDate       pgtype.Date        `json:"releaseDate"`
	Runtime           *int32             `json:"runtime"`
	Overview          *string            `json:"overview"`
	Tagline           *string            `json:"tagline"`
	Status            *string            `json:"status"`
	OriginalLanguage  *string            `json:"originalLanguage"`
	TitlesI18n        []byte             `json:"titlesI18n"`
	TaglinesI18n      []byte             `json:"taglinesI18n"`
	OverviewsI18n     []byte             `json:"overviewsI18n"`
	AgeRatings        []byte             `json:"ageRatings"`
	ExternalRatings   json.RawMessage    `json:"externalRatings"`
	PosterPath        *string            `json:"posterPath"`
	BackdropPath      *string            `json:"backdropPath"`
	TrailerUrl        *string            `json:"trailerUrl"`
	VoteAverage       pgtype.Numeric     `json:"voteAverage"`
	VoteCount         *int32             `json:"voteCount"`
	Popularity        pgtype.Numeric     `json:"popularity"`
	Budget            *int64             `json:"budget"`
	Revenue           *int64             `json:"revenue"`
	RadarrID          *int32             `json:"radarrId"`
	MetadataUpdatedAt pgtype.Timestamptz `json:"metadataUpdatedAt"`
}

// Movie CRUD Operations
func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (Movie, error) {
	row := q.db.QueryRow(ctx, createMovie,
		arg.TmdbID,
		arg.ImdbID,
		arg.Title,
		arg.OriginalTitle,
		arg.Year,
		arg.ReleaseDate,
		arg.Runtime,
		arg.Overview,
		arg.Tagline,
		arg.Status,
		arg.OriginalLanguage,
		arg.TitlesI18n,
		arg.TaglinesI18n,
		arg.OverviewsI18n,
		arg.AgeRatings,
		arg.ExternalRatings,
		arg.PosterPath,
		arg.BackdropPath,
		arg.TrailerUrl,
		arg.VoteAverage,
		arg.VoteCount,
		arg.Popularity,
		arg.Budget,
		arg.Revenue,
		arg.RadarrID,
		arg.MetadataUpdatedAt,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Title,
		&i.OriginalTitle,
		&i.Year,
		&i.ReleaseDate,
		&i.Runtime,
		&i.Overview,
		&i.Tagline,
		&i.Status,
		&i.OriginalLanguage,
		&i.PosterPath,
		&i.BackdropPath,
		&i.TrailerUrl,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.Budget,
		&i.Revenue,
		&i.LibraryAddedAt,
		&i.MetadataUpdatedAt,
		&i.RadarrID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitlesI18n,
		&i.TaglinesI18n,
		&i.OverviewsI18n,
		&i.AgeRatings,
		&i.DeletedAt,
		&i.ExternalRatings,
	)
	return i, err
}

const createMovieCollection = `-- name: CreateMovieCollection :one
INSERT INTO
    movie.movie_collections (
        tmdb_collection_id,
        name,
        overview,
        poster_path,
        backdrop_path
    )
VALUES ($1, $2, $3, $4, $5) RETURNING id, tmdb_collection_id, name, overview, poster_path, backdrop_path, created_at, updated_at, deleted_at
`

type CreateMovieCollectionParams struct {
	TmdbCollectionID *int32  `json:"tmdbCollectionId"`
	Name             string  `json:"name"`
	Overview         *string `json:"overview"`
	PosterPath       *string `json:"posterPath"`
	BackdropPath     *string `json:"backdropPath"`
}

// Movie Collections Operations
func (q *Queries) CreateMovieCollection(ctx context.Context, arg CreateMovieCollectionParams) (MovieCollection, error) {
	row := q.db.QueryRow(ctx, createMovieCollection,
		arg.TmdbCollectionID,
		arg.Name,
		arg.Overview,
		arg.PosterPath,
		arg.BackdropPath,
	)
	var i MovieCollection
	err := row.Scan(
		&i.ID,
		&i.TmdbCollectionID,
		&i.Name,
		&i.Overview,
		&i.PosterPath,
		&i.BackdropPath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createMovieCredit = `-- name: CreateMovieCredit :one
INSERT INTO
    movie.movie_credits (
        movie_id,
        tmdb_person_id,
        name,
        credit_type,
        character,
        job,
        department,
        cast_order,
        profile_path
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
    ) RETURNING id, movie_id, tmdb_person_id, name, profile_path, credit_type, character, cast_order, job, department, created_at, updated_at, deleted_at
`

type CreateMovieCreditParams struct {
	MovieID      uuid.UUID `json:"movieId"`
	TmdbPersonID int32     `json:"tmdbPersonId"`
	Name         string    `json:"name"`
	CreditType   string    `json:"creditType"`
	Character    *string   `json:"character"`
	Job          *string   `json:"job"`
	Department   *string   `json:"department"`
	CastOrder    *int32    `json:"castOrder"`
	ProfilePath  *string   `json:"profilePath"`
}

// Movie Credits Operations
func (q *Queries) CreateMovieCredit(ctx context.Context, arg CreateMovieCreditParams) (MovieCredit, error) {
	row := q.db.QueryRow(ctx, createMovieCredit,
		arg.MovieID,
		arg.TmdbPersonID,
		arg.Name,
		arg.CreditType,
		arg.Character,
		arg.Job,
		arg.Department,
		arg.CastOrder,
		arg.ProfilePath,
	)
	var i MovieCredit
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.TmdbPersonID,
		&i.Name,
		&i.ProfilePath,
		&i.CreditType,
		&i.Character,
		&i.CastOrder,
		&i.Job,
		&i.Department,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createMovieFile = `-- name: CreateMovieFile :one
INSERT INTO
    movie.movie_files (
        movie_id,
        file_path,
        file_size,
        resolution,
        quality_profile,
        video_codec,
        audio_codec,
        container,
        bitrate_kbps,
        audio_languages,
        subtitle_languages,
        radarr_file_id
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12
    ) RETURNING id, movie_id, file_path, file_size, file_name, resolution, quality_profile, video_codec, audio_codec, container, duration_seconds, bitrate_kbps, framerate, dynamic_range, color_space, audio_channels, audio_languages, subtitle_languages, radarr_file_id, last_scanned_at, is_monitored, created_at, updated_at, deleted_at
`

type CreateMovieFileParams struct {
	MovieID           uuid.UUID `json:"movieId"`
	FilePath          string    `json:"filePath"`
	FileSize          int64     `json:"fileSize"`
	Resolution        *string   `json:"resolution"`
	QualityProfile    *string   `json:"qualityProfile"`
	VideoCodec        *string   `json:"videoCodec"`
	AudioCodec        *string   `json:"audioCodec"`
	Container         *string   `json:"container"`
	BitrateKbps       *int32    `json:"bitrateKbps"`
	AudioLanguages    []string  `json:"audioLanguages"`
	SubtitleLanguages []string  `json:"subtitleLanguages"`
	RadarrFileID      *int32    `json:"radarrFileId"`
}

// Movie Files Operations
func (q *Queries) CreateMovieFile(ctx context.Context, arg CreateMovieFileParams) (MovieFile, error) {
	row := q.db.QueryRow(ctx, createMovieFile,
		arg.MovieID,
		arg.FilePath,
		arg.FileSize,
		arg.Resolution,
		arg.QualityProfile,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Container,
		arg.BitrateKbps,
		arg.AudioLanguages,
		arg.SubtitleLanguages,
		arg.RadarrFileID,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.FilePath,
		&i.FileSize,
		&i.FileName,
		&i.Resolution,
		&i.QualityProfile,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Container,
		&i.DurationSeconds,
		&i.BitrateKbps,
		&i.Framerate,
		&i.DynamicRange,
		&i.ColorSpace,
		&i.AudioChannels,
		&i.AudioLanguages,
		&i.SubtitleLanguages,
		&i.RadarrFileID,
		&i.LastScannedAt,
		&i.IsMonitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createOrUpdateWatchProgress = `-- name: CreateOrUpdateWatchProgress :one
INSERT INTO
    movie.movie_watched (
        user_id,
        movie_id,
        progress_seconds,
        duration_seconds,
        is_completed
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (user_id, movie_id) DO
UPDATE
SET
    progress_seconds = EXCLUDED.progress_seconds,
    duration_seconds = EXCLUDED.duration_seconds,
    is_completed = EXCLUDED.is_completed,
    watch_count = CASE
        WHEN EXCLUDED.is_completed
        AND NOT movie_watched.is_completed THEN movie_watched.watch_count + 1
        ELSE movie_watched.watch_count
    END,
    last_watched_at = NOW() RETURNING id, user_id, movie_id, progress_seconds, duration_seconds, progress_percent, is_completed, last_watched_at, completed_at, watch_count, created_at, updated_at
`

type CreateOrUpdateWatchProgressParams struct {
	UserID          uuid.UUID `json:"userId"`
	MovieID         uuid.UUID `json:"movieId"`
	ProgressSeconds int32     `json:"progressSeconds"`
	DurationSeconds *int32    `json:"durationSeconds"`
	IsCompleted     *bool     `json:"isCompleted"`
}

// Movie Watch Progress Operations
func (q *Queries) CreateOrUpdateWatchProgress(ctx context.Context, arg CreateOrUpdateWatchProgressParams) (MovieWatched, error) {
	row := q.db.QueryRow(ctx, createOrUpdateWatchProgress,
		arg.UserID,
		arg.MovieID,
		arg.ProgressSeconds,
		arg.DurationSeconds,
		arg.IsCompleted,
	)
	var i MovieWatched
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MovieID,
		&i.ProgressSeconds,
		&i.DurationSeconds,
		&i.ProgressPercent,
		&i.IsCompleted,
		&i.LastWatchedAt,
		&i.CompletedAt,
		&i.WatchCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMovie = `-- name: DeleteMovie :exec
UPDATE movie.movies SET deleted_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteMovie(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMovie, id)
	return err
}

const deleteMovieCredits = `-- name: DeleteMovieCredits :exec
UPDATE movie.movie_credits
SET
    deleted_at = NOW()
WHERE
    movie_id = $1
`

func (q *Queries) DeleteMovieCredits(ctx context.Context, movieID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMovieCredits, movieID)
	return err
}

const deleteMovieFile = `-- name: DeleteMovieFile :exec
UPDATE movie.movie_files SET deleted_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteMovieFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMovieFile, id)
	return err
}

const deleteMovieGenres = `-- name: DeleteMovieGenres :exec
DELETE FROM movie.movie_genres WHERE movie_id = $1
`

func (q *Queries) DeleteMovieGenres(ctx context.Context, movieID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMovieGenres, movieID)
	return err
}

const deleteWatchProgress = `-- name: DeleteWatchProgress :exec
DELETE FROM movie.movie_watched
WHERE
    user_id = $1
    AND movie_id = $2
`

type DeleteWatchProgressParams struct {
	UserID  uuid.UUID `json:"userId"`
	MovieID uuid.UUID `json:"movieId"`
}

func (q *Queries) DeleteWatchProgress(ctx context.Context, arg DeleteWatchProgressParams) error {
	_, err := q.db.Exec(ctx, deleteWatchProgress, arg.UserID, arg.MovieID)
	return err
}

const getCollectionForMovie = `-- name: GetCollectionForMovie :one
SELECT c.id, c.tmdb_collection_id, c.name, c.overview, c.poster_path, c.backdrop_path, c.created_at, c.updated_at, c.deleted_at
FROM movie.movie_collections c
    JOIN movie.movie_collection_members mcm ON c.id = mcm.collection_id
WHERE
    mcm.movie_id = $1
    AND c.deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetCollectionForMovie(ctx context.Context, movieID uuid.UUID) (MovieCollection, error) {
	row := q.db.QueryRow(ctx, getCollectionForMovie, movieID)
	var i MovieCollection
	err := row.Scan(
		&i.ID,
		&i.TmdbCollectionID,
		&i.Name,
		&i.Overview,
		&i.PosterPath,
		&i.BackdropPath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMovie = `-- name: GetMovie :one
SELECT id, tmdb_id, imdb_id, title, original_title, year, release_date, runtime, overview, tagline, status, original_language, poster_path, backdrop_path, trailer_url, vote_average, vote_count, popularity, budget, revenue, library_added_at, metadata_updated_at, radarr_id, created_at, updated_at, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, deleted_at, external_ratings FROM movie.movies WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetMovie(ctx context.Context, id uuid.UUID) (Movie, error) {
	row := q.db.QueryRow(ctx, getMovie, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Title,
		&i.OriginalTitle,
		&i.Year,
		&i.ReleaseDate,
		&i.Runtime,
		&i.Overview,
		&i.Tagline,
		&i.Status,
		&i.OriginalLanguage,
		&i.PosterPath,
		&i.BackdropPath,
		&i.TrailerUrl,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.Budget,
		&i.Revenue,
		&i.LibraryAddedAt,
		&i.MetadataUpdatedAt,
		&i.RadarrID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitlesI18n,
		&i.TaglinesI18n,
		&i.OverviewsI18n,
		&i.AgeRatings,
		&i.DeletedAt,
		&i.ExternalRatings,
	)
	return i, err
}

const getMovieByIMDbID = `-- name: GetMovieByIMDbID :one
SELECT id, tmdb_id, imdb_id, title, original_title, year, release_date, runtime, overview, tagline, status, original_language, poster_path, backdrop_path, trailer_url, vote_average, vote_count, popularity, budget, revenue, library_added_at, metadata_updated_at, radarr_id, created_at, updated_at, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, deleted_at, external_ratings
FROM movie.movies
WHERE
    imdb_id = $1
    AND deleted_at IS NULL
`

func (q *Queries) GetMovieByIMDbID(ctx context.Context, imdbID *string) (Movie, error) {
	row := q.db.QueryRow(ctx, getMovieByIMDbID, imdbID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Title,
		&i.OriginalTitle,
		&i.Year,
		&i.ReleaseDate,
		&i.Runtime,
		&i.Overview,
		&i.Tagline,
		&i.Status,
		&i.OriginalLanguage,
		&i.PosterPath,
		&i.BackdropPath,
		&i.TrailerUrl,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.Budget,
		&i.Revenue,
		&i.LibraryAddedAt,
		&i.MetadataUpdatedAt,
		&i.RadarrID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitlesI18n,
		&i.TaglinesI18n,
		&i.OverviewsI18n,
		&i.AgeRatings,
		&i.DeletedAt,
		&i.ExternalRatings,
	)
	return i, err
}

const getMovieByRadarrID = `-- name: GetMovieByRadarrID :one
SELECT id, tmdb_id, imdb_id, title, original_title, year, release_date, runtime, overview, tagline, status, original_language, poster_path, backdrop_path, trailer_url, vote_average, vote_count, popularity, budget, revenue, library_added_at, metadata_updated_at, radarr_id, created_at, updated_at, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, deleted_at, external_ratings
FROM movie.movies
WHERE
    radarr_id = $1
    AND deleted_at IS NULL
`

func (q *Queries) GetMovieByRadarrID(ctx context.Context, radarrID *int32) (Movie, error) {
	row := q.db.QueryRow(ctx, getMovieByRadarrID, radarrID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Title,
		&i.OriginalTitle,
		&i.Year,
		&i.ReleaseDate,
		&i.Runtime,
		&i.Overview,
		&i.Tagline,
		&i.Status,
		&i.OriginalLanguage,
		&i.PosterPath,
		&i.BackdropPath,
		&i.TrailerUrl,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.Budget,
		&i.Revenue,
		&i.LibraryAddedAt,
		&i.MetadataUpdatedAt,
		&i.RadarrID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitlesI18n,
		&i.TaglinesI18n,
		&i.OverviewsI18n,
		&i.AgeRatings,
		&i.DeletedAt,
		&i.ExternalRatings,
	)
	return i, err
}

const getMovieByTMDbID = `-- name: GetMovieByTMDbID :one
SELECT id, tmdb_id, imdb_id, title, original_title, year, release_date, runtime, overview, tagline, status, original_language, poster_path, backdrop_path, trailer_url, vote_average, vote_count, popularity, budget, revenue, library_added_at, metadata_updated_at, radarr_id, created_at, updated_at, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, deleted_at, external_ratings
FROM movie.movies
WHERE
    tmdb_id = $1
    AND deleted_at IS NULL
`

func (q *Queries) GetMovieByTMDbID(ctx context.Context, tmdbID *int32) (Movie, error) {
	row := q.db.QueryRow(ctx, getMovieByTMDbID, tmdbID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Title,
		&i.OriginalTitle,
		&i.Year,
		&i.ReleaseDate,
		&i.Runtime,
		&i.Overview,
		&i.Tagline,
		&i.Status,
		&i.OriginalLanguage,
		&i.PosterPath,
		&i.BackdropPath,
		&i.TrailerUrl,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.Budget,
		&i.Revenue,
		&i.LibraryAddedAt,
		&i.MetadataUpdatedAt,
		&i.RadarrID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitlesI18n,
		&i.TaglinesI18n,
		&i.OverviewsI18n,
		&i.AgeRatings,
		&i.DeletedAt,
		&i.ExternalRatings,
	)
	return i, err
}

const getMovieCollection = `-- name: GetMovieCollection :one
SELECT id, tmdb_collection_id, name, overview, poster_path, backdrop_path, created_at, updated_at, deleted_at
FROM movie.movie_collections
WHERE
    id = $1
    AND deleted_at IS NULL
`

func (q *Queries) GetMovieCollection(ctx context.Context, id uuid.UUID) (MovieCollection, error) {
	row := q.db.QueryRow(ctx, getMovieCollection, id)
	var i MovieCollection
	err := row.Scan(
		&i.ID,
		&i.TmdbCollectionID,
		&i.Name,
		&i.Overview,
		&i.PosterPath,
		&i.BackdropPath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMovieCollectionByTMDbID = `-- name: GetMovieCollectionByTMDbID :one
SELECT id, tmdb_collection_id, name, overview, poster_path, backdrop_path, created_at, updated_at, deleted_at
FROM movie.movie_collections
WHERE
    tmdb_collection_id = $1
    AND deleted_at IS NULL
`

func (q *Queries) GetMovieCollectionByTMDbID(ctx context.Context, tmdbCollectionID *int32) (MovieCollection, error) {
	row := q.db.QueryRow(ctx, getMovieCollectionByTMDbID, tmdbCollectionID)
	var i MovieCollection
	err := row.Scan(
		&i.ID,
		&i.TmdbCollectionID,
		&i.Name,
		&i.Overview,
		&i.PosterPath,
		&i.BackdropPath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMovieFile = `-- name: GetMovieFile :one
SELECT id, movie_id, file_path, file_size, file_name, resolution, quality_profile, video_codec, audio_codec, container, duration_seconds, bitrate_kbps, framerate, dynamic_range, color_space, audio_channels, audio_languages, subtitle_languages, radarr_file_id, last_scanned_at, is_monitored, created_at, updated_at, deleted_at
FROM movie.movie_files
WHERE
    id = $1
    AND deleted_at IS NULL
`

func (q *Queries) GetMovieFile(ctx context.Context, id uuid.UUID) (MovieFile, error) {
	row := q.db.QueryRow(ctx, getMovieFile, id)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.FilePath,
		&i.FileSize,
		&i.FileName,
		&i.Resolution,
		&i.QualityProfile,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Container,
		&i.DurationSeconds,
		&i.BitrateKbps,
		&i.Framerate,
		&i.DynamicRange,
		&i.ColorSpace,
		&i.AudioChannels,
		&i.AudioLanguages,
		&i.SubtitleLanguages,
		&i.RadarrFileID,
		&i.LastScannedAt,
		&i.IsMonitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMovieFileByPath = `-- name: GetMovieFileByPath :one
SELECT id, movie_id, file_path, file_size, file_name, resolution, quality_profile, video_codec, audio_codec, container, duration_seconds, bitrate_kbps, framerate, dynamic_range, color_space, audio_channels, audio_languages, subtitle_languages, radarr_file_id, last_scanned_at, is_monitored, created_at, updated_at, deleted_at
FROM movie.movie_files
WHERE
    file_path = $1
    AND deleted_at IS NULL
`

func (q *Queries) GetMovieFileByPath(ctx context.Context, filePath string) (MovieFile, error) {
	row := q.db.QueryRow(ctx, getMovieFileByPath, filePath)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.FilePath,
		&i.FileSize,
		&i.FileName,
		&i.Resolution,
		&i.QualityProfile,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Container,
		&i.DurationSeconds,
		&i.BitrateKbps,
		&i.Framerate,
		&i.DynamicRange,
		&i.ColorSpace,
		&i.AudioChannels,
		&i.AudioLanguages,
		&i.SubtitleLanguages,
		&i.RadarrFileID,
		&i.LastScannedAt,
		&i.IsMonitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMovieFileByRadarrID = `-- name: GetMovieFileByRadarrID :one
SELECT id, movie_id, file_path, file_size, file_name, resolution, quality_profile, video_codec, audio_codec, container, duration_seconds, bitrate_kbps, framerate, dynamic_range, color_space, audio_channels, audio_languages, subtitle_languages, radarr_file_id, last_scanned_at, is_monitored, created_at, updated_at, deleted_at
FROM movie.movie_files
WHERE
    radarr_file_id = $1
    AND deleted_at IS NULL
`

func (q *Queries) GetMovieFileByRadarrID(ctx context.Context, radarrFileID *int32) (MovieFile, error) {
	row := q.db.QueryRow(ctx, getMovieFileByRadarrID, radarrFileID)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.FilePath,
		&i.FileSize,
		&i.FileName,
		&i.Resolution,
		&i.QualityProfile,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Container,
		&i.DurationSeconds,
		&i.BitrateKbps,
		&i.Framerate,
		&i.DynamicRange,
		&i.ColorSpace,
		&i.AudioChannels,
		&i.AudioLanguages,
		&i.SubtitleLanguages,
		&i.RadarrFileID,
		&i.LastScannedAt,
		&i.IsMonitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserMovieStats = `-- name: GetUserMovieStats :one
SELECT
    COUNT(*) FILTER (WHERE is_completed) as watched_count,
    COUNT(*) FILTER (WHERE NOT is_completed AND progress_percent > 5) as in_progress_count,
    COALESCE(SUM(watch_count), 0)::bigint as total_watches
FROM movie.movie_watched
WHERE user_id = $1
`

type GetUserMovieStatsRow struct {
	WatchedCount    int64 `json:"watchedCount"`
	InProgressCount int64 `json:"inProgressCount"`
	TotalWatches    int64 `json:"totalWatches"`
}

func (q *Queries) GetUserMovieStats(ctx context.Context, userID uuid.UUID) (GetUserMovieStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserMovieStats, userID)
	var i GetUserMovieStatsRow
	err := row.Scan(&i.WatchedCount, &i.InProgressCount, &i.TotalWatches)
	return i, err
}

const getWatchProgress = `-- name: GetWatchProgress :one
SELECT id, user_id, movie_id, progress_seconds, duration_seconds, progress_percent, is_completed, last_watched_at, completed_at, watch_count, created_at, updated_at
FROM movie.movie_watched
WHERE
    user_id = $1
    AND movie_id = $2
`

type GetWatchProgressParams struct {
	UserID  uuid.UUID `json:"userId"`
	MovieID uuid.UUID `json:"movieId"`
}

func (q *Queries) GetWatchProgress(ctx context.Context, arg GetWatchProgressParams) (MovieWatched, error) {
	row := q.db.QueryRow(ctx, getWatchProgress, arg.UserID, arg.MovieID)
	var i MovieWatched
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MovieID,
		&i.ProgressSeconds,
		&i.DurationSeconds,
		&i.ProgressPercent,
		&i.IsCompleted,
		&i.LastWatchedAt,
		&i.CompletedAt,
		&i.WatchCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listContinueWatching = `-- name: ListContinueWatching :many
SELECT m.id, m.tmdb_id, m.imdb_id, m.title, m.original_title, m.year, m.release_date, m.runtime, m.overview, m.tagline, m.status, m.original_language, m.poster_path, m.backdrop_path, m.trailer_url, m.vote_average, m.vote_count, m.popularity, m.budget, m.revenue, m.library_added_at, m.metadata_updated_at, m.radarr_id, m.created_at, m.updated_at, m.titles_i18n, m.taglines_i18n, m.overviews_i18n, m.age_ratings, m.deleted_at, m.external_ratings, mw.progress_seconds, mw.duration_seconds, mw.progress_percent, mw.last_watched_at
FROM movie.movies m
    JOIN movie.movie_watched mw ON m.id = mw.movie_id
WHERE
    mw.user_id = $1
    AND mw.is_completed = FALSE
    AND mw.progress_percent > 5
    AND m.deleted_at IS NULL
ORDER BY mw.last_watched_at DESC
LIMIT $2
`

type ListContinueWatchingParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
}

type ListContinueWatchingRow struct {
	ID                uuid.UUID          `json:"id"`
	TmdbID            *int32             `json:"tmdbId"`
	ImdbID            *string            `json:"imdbId"`
	Title             string             `json:"title"`
	OriginalTitle     *string            `json:"originalTitle"`
	Year              *int32             `json:"year"`
	ReleaseDate       pgtype.Date        `json:"releaseDate"`
	Runtime           *int32             `json:"runtime"`
	Overview          *string            `json:"overview"`
	Tagline           *string            `json:"tagline"`
	Status            *string            `json:"status"`
	OriginalLanguage  *string            `json:"originalLanguage"`
	PosterPath        *string            `json:"posterPath"`
	BackdropPath      *string            `json:"backdropPath"`
	TrailerUrl        *string            `json:"trailerUrl"`
	VoteAverage       pgtype.Numeric     `json:"voteAverage"`
	VoteCount         *int32             `json:"voteCount"`
	Popularity        pgtype.Numeric     `json:"popularity"`
	Budget            *int64             `json:"budget"`
	Revenue           *int64             `json:"revenue"`
	LibraryAddedAt    time.Time          `json:"libraryAddedAt"`
	MetadataUpdatedAt pgtype.Timestamptz `json:"metadataUpdatedAt"`
	RadarrID          *int32             `json:"radarrId"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
	TitlesI18n        []byte             `json:"titlesI18n"`
	TaglinesI18n      []byte             `json:"taglinesI18n"`
	OverviewsI18n     []byte             `json:"overviewsI18n"`
	AgeRatings        []byte             `json:"ageRatings"`
	DeletedAt         pgtype.Timestamptz `json:"deletedAt"`
	ExternalRatings   json.RawMessage    `json:"externalRatings"`
	ProgressSeconds   int32              `json:"progressSeconds"`
	DurationSeconds   *int32             `json:"durationSeconds"`
	ProgressPercent   pgtype.Numeric     `json:"progressPercent"`
	LastWatchedAt     time.Time          `json:"lastWatchedAt"`
}

func (q *Queries) ListContinueWatching(ctx context.Context, arg ListContinueWatchingParams) ([]ListContinueWatchingRow, error) {
	rows, err := q.db.Query(ctx, listContinueWatching, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContinueWatchingRow{}
	for rows.Next() {
		var i ListContinueWatchingRow
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Overview,
			&i.Tagline,
			&i.Status,
			&i.OriginalLanguage,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TrailerUrl,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.Budget,
			&i.Revenue,
			&i.LibraryAddedAt,
			&i.MetadataUpdatedAt,
			&i.RadarrID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.DeletedAt,
			&i.ExternalRatings,
			&i.ProgressSeconds,
			&i.DurationSeconds,
			&i.ProgressPercent,
			&i.LastWatchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieCast = `-- name: ListMovieCast :many
SELECT id, movie_id, tmdb_person_id, name, profile_path, credit_type, character, cast_order, job, department, created_at, updated_at, deleted_at
FROM movie.movie_credits
WHERE
    movie_id = $1
    AND credit_type = 'cast'
    AND deleted_at IS NULL
ORDER BY cast_order ASC NULLS LAST
LIMIT $2
OFFSET $3
`

type ListMovieCastParams struct {
	MovieID uuid.UUID `json:"movieId"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListMovieCast(ctx context.Context, arg ListMovieCastParams) ([]MovieCredit, error) {
	rows, err := q.db.Query(ctx, listMovieCast, arg.MovieID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieCredit{}
	for rows.Next() {
		var i MovieCredit
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.TmdbPersonID,
			&i.Name,
			&i.ProfilePath,
			&i.CreditType,
			&i.Character,
			&i.CastOrder,
			&i.Job,
			&i.Department,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieCrew = `-- name: ListMovieCrew :many
SELECT id, movie_id, tmdb_person_id, name, profile_path, credit_type, character, cast_order, job, department, created_at, updated_at, deleted_at
FROM movie.movie_credits
WHERE
    movie_id = $1
    AND credit_type = 'crew'
    AND deleted_at IS NULL
ORDER BY
    CASE department
        WHEN 'Directing' THEN 1
        WHEN 'Writing' THEN 2
        WHEN 'Production' THEN 3
        ELSE 99
    END,
    name ASC
LIMIT $2
OFFSET $3
`

type ListMovieCrewParams struct {
	MovieID uuid.UUID `json:"movieId"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListMovieCrew(ctx context.Context, arg ListMovieCrewParams) ([]MovieCredit, error) {
	rows, err := q.db.Query(ctx, listMovieCrew, arg.MovieID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieCredit{}
	for rows.Next() {
		var i MovieCredit
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.TmdbPersonID,
			&i.Name,
			&i.ProfilePath,
			&i.CreditType,
			&i.Character,
			&i.CastOrder,
			&i.Job,
			&i.Department,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieFilesByMovieID = `-- name: ListMovieFilesByMovieID :many
SELECT id, movie_id, file_path, file_size, file_name, resolution, quality_profile, video_codec, audio_codec, container, duration_seconds, bitrate_kbps, framerate, dynamic_range, color_space, audio_channels, audio_languages, subtitle_languages, radarr_file_id, last_scanned_at, is_monitored, created_at, updated_at, deleted_at
FROM movie.movie_files
WHERE
    movie_id = $1
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListMovieFilesByMovieID(ctx context.Context, movieID uuid.UUID) ([]MovieFile, error) {
	rows, err := q.db.Query(ctx, listMovieFilesByMovieID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieFile{}
	for rows.Next() {
		var i MovieFile
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.FilePath,
			&i.FileSize,
			&i.FileName,
			&i.Resolution,
			&i.QualityProfile,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Container,
			&i.DurationSeconds,
			&i.BitrateKbps,
			&i.Framerate,
			&i.DynamicRange,
			&i.ColorSpace,
			&i.AudioChannels,
			&i.AudioLanguages,
			&i.SubtitleLanguages,
			&i.RadarrFileID,
			&i.LastScannedAt,
			&i.IsMonitored,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieGenres = `-- name: ListMovieGenres :many
SELECT id, movie_id, tmdb_genre_id, name, created_at
FROM movie.movie_genres
WHERE
    movie_id = $1
ORDER BY name ASC
`

func (q *Queries) ListMovieGenres(ctx context.Context, movieID uuid.UUID) ([]MovieGenre, error) {
	rows, err := q.db.Query(ctx, listMovieGenres, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovieGenre{}
	for rows.Next() {
		var i MovieGenre
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.TmdbGenreID,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovies = `-- name: ListMovies :many
SELECT id, tmdb_id, imdb_id, title, original_title, year, release_date, runtime, overview, tagline, status, original_language, poster_path, backdrop_path, trailer_url, vote_average, vote_count, popularity, budget, revenue, library_added_at, metadata_updated_at, radarr_id, created_at, updated_at, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, deleted_at, external_ratings FROM movie.movies
WHERE deleted_at IS NULL
ORDER BY
    CASE WHEN $3::text = 'title' THEN title END ASC,
    CASE WHEN $3::text = 'year' THEN year END DESC,
    CASE WHEN $3::text = 'added' THEN library_added_at END DESC,
    CASE WHEN $3::text = 'rating' THEN vote_average END DESC,
    library_added_at DESC
LIMIT $1 OFFSET $2
`

type ListMoviesParams struct {
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
	OrderBy *string `json:"orderBy"`
}

func (q *Queries) ListMovies(ctx context.Context, arg ListMoviesParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listMovies, arg.Limit, arg.Offset, arg.OrderBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Overview,
			&i.Tagline,
			&i.Status,
			&i.OriginalLanguage,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TrailerUrl,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.Budget,
			&i.Revenue,
			&i.LibraryAddedAt,
			&i.MetadataUpdatedAt,
			&i.RadarrID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.DeletedAt,
			&i.ExternalRatings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesByCollection = `-- name: ListMoviesByCollection :many
SELECT m.id, m.tmdb_id, m.imdb_id, m.title, m.original_title, m.year, m.release_date, m.runtime, m.overview, m.tagline, m.status, m.original_language, m.poster_path, m.backdrop_path, m.trailer_url, m.vote_average, m.vote_count, m.popularity, m.budget, m.revenue, m.library_added_at, m.metadata_updated_at, m.radarr_id, m.created_at, m.updated_at, m.titles_i18n, m.taglines_i18n, m.overviews_i18n, m.age_ratings, m.deleted_at, m.external_ratings
FROM movie.movies m
    JOIN movie.movie_collection_members mcm ON m.id = mcm.movie_id
WHERE
    mcm.collection_id = $1
    AND m.deleted_at IS NULL
ORDER BY mcm.collection_order ASC NULLS LAST, m.year ASC
`

func (q *Queries) ListMoviesByCollection(ctx context.Context, collectionID uuid.UUID) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listMoviesByCollection, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Overview,
			&i.Tagline,
			&i.Status,
			&i.OriginalLanguage,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TrailerUrl,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.Budget,
			&i.Revenue,
			&i.LibraryAddedAt,
			&i.MetadataUpdatedAt,
			&i.RadarrID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.DeletedAt,
			&i.ExternalRatings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesByGenre = `-- name: ListMoviesByGenre :many
SELECT m.id, m.tmdb_id, m.imdb_id, m.title, m.original_title, m.year, m.release_date, m.runtime, m.overview, m.tagline, m.status, m.original_language, m.poster_path, m.backdrop_path, m.trailer_url, m.vote_average, m.vote_count, m.popularity, m.budget, m.revenue, m.library_added_at, m.metadata_updated_at, m.radarr_id, m.created_at, m.updated_at, m.titles_i18n, m.taglines_i18n, m.overviews_i18n, m.age_ratings, m.deleted_at, m.external_ratings
FROM movie.movies m
    JOIN movie.movie_genres mg ON m.id = mg.movie_id
WHERE
    mg.tmdb_genre_id = $1
    AND m.deleted_at IS NULL
ORDER BY m.vote_average DESC NULLS LAST, m.title ASC
LIMIT $2
OFFSET
    $3
`

type ListMoviesByGenreParams struct {
	TmdbGenreID int32 `json:"tmdbGenreId"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

func (q *Queries) ListMoviesByGenre(ctx context.Context, arg ListMoviesByGenreParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listMoviesByGenre, arg.TmdbGenreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Overview,
			&i.Tagline,
			&i.Status,
			&i.OriginalLanguage,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TrailerUrl,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.Budget,
			&i.Revenue,
			&i.LibraryAddedAt,
			&i.MetadataUpdatedAt,
			&i.RadarrID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.DeletedAt,
			&i.ExternalRatings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesByYear = `-- name: ListMoviesByYear :many
SELECT id, tmdb_id, imdb_id, title, original_title, year, release_date, runtime, overview, tagline, status, original_language, poster_path, backdrop_path, trailer_url, vote_average, vote_count, popularity, budget, revenue, library_added_at, metadata_updated_at, radarr_id, created_at, updated_at, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, deleted_at, external_ratings
FROM movie.movies
WHERE
    deleted_at IS NULL
    AND year = $1
ORDER BY vote_average DESC NULLS LAST, title ASC
LIMIT $2
OFFSET
    $3
`

type ListMoviesByYearParams struct {
	Year   *int32 `json:"year"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListMoviesByYear(ctx context.Context, arg ListMoviesByYearParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listMoviesByYear, arg.Year, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Overview,
			&i.Tagline,
			&i.Status,
			&i.OriginalLanguage,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TrailerUrl,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.Budget,
			&i.Revenue,
			&i.LibraryAddedAt,
			&i.MetadataUpdatedAt,
			&i.RadarrID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.DeletedAt,
			&i.ExternalRatings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentlyAdded = `-- name: ListRecentlyAdded :many
SELECT id, tmdb_id, imdb_id, title, original_title, year, release_date, runtime, overview, tagline, status, original_language, poster_path, backdrop_path, trailer_url, vote_average, vote_count, popularity, budget, revenue, library_added_at, metadata_updated_at, radarr_id, created_at, updated_at, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, deleted_at, external_ratings
FROM movie.movies
WHERE
    deleted_at IS NULL
ORDER BY library_added_at DESC
LIMIT $1
OFFSET
    $2
`

type ListRecentlyAddedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListRecentlyAdded(ctx context.Context, arg ListRecentlyAddedParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listRecentlyAdded, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Overview,
			&i.Tagline,
			&i.Status,
			&i.OriginalLanguage,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TrailerUrl,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.Budget,
			&i.Revenue,
			&i.LibraryAddedAt,
			&i.MetadataUpdatedAt,
			&i.RadarrID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.DeletedAt,
			&i.ExternalRatings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopRated = `-- name: ListTopRated :many
SELECT id, tmdb_id, imdb_id, title, original_title, year, release_date, runtime, overview, tagline, status, original_language, poster_path, backdrop_path, trailer_url, vote_average, vote_count, popularity, budget, revenue, library_added_at, metadata_updated_at, radarr_id, created_at, updated_at, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, deleted_at, external_ratings
FROM movie.movies
WHERE
    deleted_at IS NULL
    AND vote_average IS NOT NULL
    AND vote_count > $1
ORDER BY vote_average DESC, vote_count DESC
LIMIT $2
OFFSET
    $3
`

type ListTopRatedParams struct {
	VoteCount *int32 `json:"voteCount"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListTopRated(ctx context.Context, arg ListTopRatedParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listTopRated, arg.VoteCount, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Overview,
			&i.Tagline,
			&i.Status,
			&i.OriginalLanguage,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TrailerUrl,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.Budget,
			&i.Revenue,
			&i.LibraryAddedAt,
			&i.MetadataUpdatedAt,
			&i.RadarrID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.DeletedAt,
			&i.ExternalRatings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWatchedMovies = `-- name: ListWatchedMovies :many
SELECT m.id, m.tmdb_id, m.imdb_id, m.title, m.original_title, m.year, m.release_date, m.runtime, m.overview, m.tagline, m.status, m.original_language, m.poster_path, m.backdrop_path, m.trailer_url, m.vote_average, m.vote_count, m.popularity, m.budget, m.revenue, m.library_added_at, m.metadata_updated_at, m.radarr_id, m.created_at, m.updated_at, m.titles_i18n, m.taglines_i18n, m.overviews_i18n, m.age_ratings, m.deleted_at, m.external_ratings, mw.watch_count, mw.last_watched_at
FROM movie.movies m
    JOIN movie.movie_watched mw ON m.id = mw.movie_id
WHERE
    mw.user_id = $1
    AND mw.is_completed = TRUE
    AND m.deleted_at IS NULL
ORDER BY mw.last_watched_at DESC
LIMIT $2
OFFSET
    $3
`

type ListWatchedMoviesParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListWatchedMoviesRow struct {
	ID                uuid.UUID          `json:"id"`
	TmdbID            *int32             `json:"tmdbId"`
	ImdbID            *string            `json:"imdbId"`
	Title             string             `json:"title"`
	OriginalTitle     *string            `json:"originalTitle"`
	Year              *int32             `json:"year"`
	ReleaseDate       pgtype.Date        `json:"releaseDate"`
	Runtime           *int32             `json:"runtime"`
	Overview          *string            `json:"overview"`
	Tagline           *string            `json:"tagline"`
	Status            *string            `json:"status"`
	OriginalLanguage  *string            `json:"originalLanguage"`
	PosterPath        *string            `json:"posterPath"`
	BackdropPath      *string            `json:"backdropPath"`
	TrailerUrl        *string            `json:"trailerUrl"`
	VoteAverage       pgtype.Numeric     `json:"voteAverage"`
	VoteCount         *int32             `json:"voteCount"`
	Popularity        pgtype.Numeric     `json:"popularity"`
	Budget            *int64             `json:"budget"`
	Revenue           *int64             `json:"revenue"`
	LibraryAddedAt    time.Time          `json:"libraryAddedAt"`
	MetadataUpdatedAt pgtype.Timestamptz `json:"metadataUpdatedAt"`
	RadarrID          *int32             `json:"radarrId"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
	TitlesI18n        []byte             `json:"titlesI18n"`
	TaglinesI18n      []byte             `json:"taglinesI18n"`
	OverviewsI18n     []byte             `json:"overviewsI18n"`
	AgeRatings        []byte             `json:"ageRatings"`
	DeletedAt         pgtype.Timestamptz `json:"deletedAt"`
	ExternalRatings   json.RawMessage    `json:"externalRatings"`
	WatchCount        *int32             `json:"watchCount"`
	LastWatchedAt     time.Time          `json:"lastWatchedAt"`
}

func (q *Queries) ListWatchedMovies(ctx context.Context, arg ListWatchedMoviesParams) ([]ListWatchedMoviesRow, error) {
	rows, err := q.db.Query(ctx, listWatchedMovies, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWatchedMoviesRow{}
	for rows.Next() {
		var i ListWatchedMoviesRow
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Overview,
			&i.Tagline,
			&i.Status,
			&i.OriginalLanguage,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TrailerUrl,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.Budget,
			&i.Revenue,
			&i.LibraryAddedAt,
			&i.MetadataUpdatedAt,
			&i.RadarrID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.DeletedAt,
			&i.ExternalRatings,
			&i.WatchCount,
			&i.LastWatchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMovieFromCollection = `-- name: RemoveMovieFromCollection :exec
DELETE FROM movie.movie_collection_members
WHERE
    collection_id = $1
    AND movie_id = $2
`

type RemoveMovieFromCollectionParams struct {
	CollectionID uuid.UUID `json:"collectionId"`
	MovieID      uuid.UUID `json:"movieId"`
}

func (q *Queries) RemoveMovieFromCollection(ctx context.Context, arg RemoveMovieFromCollectionParams) error {
	_, err := q.db.Exec(ctx, removeMovieFromCollection, arg.CollectionID, arg.MovieID)
	return err
}

const searchMoviesByTitle = `-- name: SearchMoviesByTitle :many
SELECT id, tmdb_id, imdb_id, title, original_title, year, release_date, runtime, overview, tagline, status, original_language, poster_path, backdrop_path, trailer_url, vote_average, vote_count, popularity, budget, revenue, library_added_at, metadata_updated_at, radarr_id, created_at, updated_at, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, deleted_at, external_ratings
FROM movie.movies
WHERE
    deleted_at IS NULL
    AND (
        title % $1
        OR original_title % $1
    )
ORDER BY similarity (title, $1) DESC, similarity (original_title, $1) DESC
LIMIT $2
OFFSET
    $3
`

type SearchMoviesByTitleParams struct {
	Title  string `json:"title"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) SearchMoviesByTitle(ctx context.Context, arg SearchMoviesByTitleParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, searchMoviesByTitle, arg.Title, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Overview,
			&i.Tagline,
			&i.Status,
			&i.OriginalLanguage,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TrailerUrl,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.Budget,
			&i.Revenue,
			&i.LibraryAddedAt,
			&i.MetadataUpdatedAt,
			&i.RadarrID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.DeletedAt,
			&i.ExternalRatings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMoviesByTitleAnyLanguage = `-- name: SearchMoviesByTitleAnyLanguage :many
SELECT id, tmdb_id, imdb_id, title, original_title, year, release_date, runtime, overview, tagline, status, original_language, poster_path, backdrop_path, trailer_url, vote_average, vote_count, popularity, budget, revenue, library_added_at, metadata_updated_at, radarr_id, created_at, updated_at, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, deleted_at, external_ratings
FROM movie.movies
WHERE
    deleted_at IS NULL
    AND (
        title ILIKE '%' || $1 || '%'
        OR original_title ILIKE '%' || $1 || '%'
        OR EXISTS (
            SELECT 1
            FROM jsonb_each_text (titles_i18n)
            WHERE
                value ILIKE '%' || $1 || '%'
        )
    )
ORDER BY
    CASE
        WHEN title ILIKE $1 THEN 1
        WHEN original_title ILIKE $1 THEN 2
        WHEN title ILIKE $1 || '%' THEN 3
        ELSE 4
    END,
    vote_average DESC NULLS LAST
LIMIT $2
OFFSET
    $3
`

type SearchMoviesByTitleAnyLanguageParams struct {
	Column1 *string `json:"column1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

func (q *Queries) SearchMoviesByTitleAnyLanguage(ctx context.Context, arg SearchMoviesByTitleAnyLanguageParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, searchMoviesByTitleAnyLanguage, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Overview,
			&i.Tagline,
			&i.Status,
			&i.OriginalLanguage,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TrailerUrl,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.Budget,
			&i.Revenue,
			&i.LibraryAddedAt,
			&i.MetadataUpdatedAt,
			&i.RadarrID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.DeletedAt,
			&i.ExternalRatings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMovie = `-- name: UpdateMovie :one
UPDATE movie.movies
SET
    tmdb_id = COALESCE(
        $1,
        tmdb_id
    ),
    imdb_id = COALESCE(
        $2,
        imdb_id
    ),
    title = COALESCE($3, title),
    original_title = COALESCE(
        $4,
        original_title
    ),
    year = COALESCE($5, year),
    release_date = COALESCE(
        $6,
        release_date
    ),
    runtime = COALESCE(
        $7,
        runtime
    ),
    overview = COALESCE(
        $8,
        overview
    ),
    tagline = COALESCE(
        $9,
        tagline
    ),
    status = COALESCE($10, status),
    original_language = COALESCE(
        $11,
        original_language
    ),
    titles_i18n = COALESCE(
        $12,
        titles_i18n
    ),
    taglines_i18n = COALESCE(
        $13,
        taglines_i18n
    ),
    overviews_i18n = COALESCE(
        $14,
        overviews_i18n
    ),
    age_ratings = COALESCE(
        $15,
        age_ratings
    ),
    external_ratings = COALESCE(
        $16,
        external_ratings
    ),
    poster_path = COALESCE(
        $17,
        poster_path
    ),
    backdrop_path = COALESCE(
        $18,
        backdrop_path
    ),
    trailer_url = COALESCE(
        $19,
        trailer_url
    ),
    vote_average = COALESCE(
        $20,
        vote_average
    ),
    vote_count = COALESCE(
        $21,
        vote_count
    ),
    popularity = COALESCE(
        $22,
        popularity
    ),
    budget = COALESCE($23, budget),
    revenue = COALESCE(
        $24,
        revenue
    ),
    radarr_id = COALESCE(
        $25,
        radarr_id
    ),
    metadata_updated_at = COALESCE(
        $26,
        metadata_updated_at
    )
WHERE
    id = $27
    AND deleted_at IS NULL RETURNING id, tmdb_id, imdb_id, title, original_title, year, release_date, runtime, overview, tagline, status, original_language, poster_path, backdrop_path, trailer_url, vote_average, vote_count, popularity, budget, revenue, library_added_at, metadata_updated_at, radarr_id, created_at, updated_at, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, deleted_at, external_ratings
`

type UpdateMovieParams struct {
	TmdbID            *int32             `json:"tmdbId"`
	ImdbID            *string            `json:"imdbId"`
	Title             *string            `json:"title"`
	OriginalTitle     *string            `json:"originalTitle"`
	Year              *int32             `json:"year"`
	ReleaseDate       pgtype.Date        `json:"releaseDate"`
	Runtime           *int32             `json:"runtime"`
	Overview          *string            `json:"overview"`
	Tagline           *string            `json:"tagline"`
	Status            *string            `json:"status"`
	OriginalLanguage  *string            `json:"originalLanguage"`
	TitlesI18n        []byte             `json:"titlesI18n"`
	TaglinesI18n      []byte             `json:"taglinesI18n"`
	OverviewsI18n     []byte             `json:"overviewsI18n"`
	AgeRatings        []byte             `json:"ageRatings"`
	ExternalRatings   []byte             `json:"externalRatings"`
	PosterPath        *string            `json:"posterPath"`
	BackdropPath      *string            `json:"backdropPath"`
	TrailerUrl        *string            `json:"trailerUrl"`
	VoteAverage       pgtype.Numeric     `json:"voteAverage"`
	VoteCount         *int32             `json:"voteCount"`
	Popularity        pgtype.Numeric     `json:"popularity"`
	Budget            *int64             `json:"budget"`
	Revenue           *int64             `json:"revenue"`
	RadarrID          *int32             `json:"radarrId"`
	MetadataUpdatedAt pgtype.Timestamptz `json:"metadataUpdatedAt"`
	ID                uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) (Movie, error) {
	row := q.db.QueryRow(ctx, updateMovie,
		arg.TmdbID,
		arg.ImdbID,
		arg.Title,
		arg.OriginalTitle,
		arg.Year,
		arg.ReleaseDate,
		arg.Runtime,
		arg.Overview,
		arg.Tagline,
		arg.Status,
		arg.OriginalLanguage,
		arg.TitlesI18n,
		arg.TaglinesI18n,
		arg.OverviewsI18n,
		arg.AgeRatings,
		arg.ExternalRatings,
		arg.PosterPath,
		arg.BackdropPath,
		arg.TrailerUrl,
		arg.VoteAverage,
		arg.VoteCount,
		arg.Popularity,
		arg.Budget,
		arg.Revenue,
		arg.RadarrID,
		arg.MetadataUpdatedAt,
		arg.ID,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Title,
		&i.OriginalTitle,
		&i.Year,
		&i.ReleaseDate,
		&i.Runtime,
		&i.Overview,
		&i.Tagline,
		&i.Status,
		&i.OriginalLanguage,
		&i.PosterPath,
		&i.BackdropPath,
		&i.TrailerUrl,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.Budget,
		&i.Revenue,
		&i.LibraryAddedAt,
		&i.MetadataUpdatedAt,
		&i.RadarrID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitlesI18n,
		&i.TaglinesI18n,
		&i.OverviewsI18n,
		&i.AgeRatings,
		&i.DeletedAt,
		&i.ExternalRatings,
	)
	return i, err
}

const updateMovieCollection = `-- name: UpdateMovieCollection :one
UPDATE movie.movie_collections
SET
    tmdb_collection_id = COALESCE(
        $1,
        tmdb_collection_id
    ),
    name = COALESCE($2, name),
    overview = COALESCE(
        $3,
        overview
    ),
    poster_path = COALESCE(
        $4,
        poster_path
    ),
    backdrop_path = COALESCE(
        $5,
        backdrop_path
    )
WHERE
    id = $6
    AND deleted_at IS NULL RETURNING id, tmdb_collection_id, name, overview, poster_path, backdrop_path, created_at, updated_at, deleted_at
`

type UpdateMovieCollectionParams struct {
	TmdbCollectionID *int32    `json:"tmdbCollectionId"`
	Name             *string   `json:"name"`
	Overview         *string   `json:"overview"`
	PosterPath       *string   `json:"posterPath"`
	BackdropPath     *string   `json:"backdropPath"`
	ID               uuid.UUID `json:"id"`
}

func (q *Queries) UpdateMovieCollection(ctx context.Context, arg UpdateMovieCollectionParams) (MovieCollection, error) {
	row := q.db.QueryRow(ctx, updateMovieCollection,
		arg.TmdbCollectionID,
		arg.Name,
		arg.Overview,
		arg.PosterPath,
		arg.BackdropPath,
		arg.ID,
	)
	var i MovieCollection
	err := row.Scan(
		&i.ID,
		&i.TmdbCollectionID,
		&i.Name,
		&i.Overview,
		&i.PosterPath,
		&i.BackdropPath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateMovieFile = `-- name: UpdateMovieFile :one
UPDATE movie.movie_files
SET
    file_path = COALESCE(
        $1,
        file_path
    ),
    file_size = COALESCE(
        $2,
        file_size
    ),
    resolution = COALESCE(
        $3,
        resolution
    ),
    quality_profile = COALESCE(
        $4,
        quality_profile
    ),
    video_codec = COALESCE(
        $5,
        video_codec
    ),
    audio_codec = COALESCE(
        $6,
        audio_codec
    ),
    container = COALESCE(
        $7,
        container
    ),
    bitrate_kbps = COALESCE(
        $8,
        bitrate_kbps
    ),
    audio_languages = COALESCE(
        $9,
        audio_languages
    ),
    subtitle_languages = COALESCE(
        $10,
        subtitle_languages
    ),
    radarr_file_id = COALESCE(
        $11,
        radarr_file_id
    )
WHERE
    id = $12
    AND deleted_at IS NULL RETURNING id, movie_id, file_path, file_size, file_name, resolution, quality_profile, video_codec, audio_codec, container, duration_seconds, bitrate_kbps, framerate, dynamic_range, color_space, audio_channels, audio_languages, subtitle_languages, radarr_file_id, last_scanned_at, is_monitored, created_at, updated_at, deleted_at
`

type UpdateMovieFileParams struct {
	FilePath          *string   `json:"filePath"`
	FileSize          *int64    `json:"fileSize"`
	Resolution        *string   `json:"resolution"`
	QualityProfile    *string   `json:"qualityProfile"`
	VideoCodec        *string   `json:"videoCodec"`
	AudioCodec        *string   `json:"audioCodec"`
	Container         *string   `json:"container"`
	BitrateKbps       *int32    `json:"bitrateKbps"`
	AudioLanguages    []string  `json:"audioLanguages"`
	SubtitleLanguages []string  `json:"subtitleLanguages"`
	RadarrFileID      *int32    `json:"radarrFileId"`
	ID                uuid.UUID `json:"id"`
}

func (q *Queries) UpdateMovieFile(ctx context.Context, arg UpdateMovieFileParams) (MovieFile, error) {
	row := q.db.QueryRow(ctx, updateMovieFile,
		arg.FilePath,
		arg.FileSize,
		arg.Resolution,
		arg.QualityProfile,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Container,
		arg.BitrateKbps,
		arg.AudioLanguages,
		arg.SubtitleLanguages,
		arg.RadarrFileID,
		arg.ID,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.FilePath,
		&i.FileSize,
		&i.FileName,
		&i.Resolution,
		&i.QualityProfile,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Container,
		&i.DurationSeconds,
		&i.BitrateKbps,
		&i.Framerate,
		&i.DynamicRange,
		&i.ColorSpace,
		&i.AudioChannels,
		&i.AudioLanguages,
		&i.SubtitleLanguages,
		&i.RadarrFileID,
		&i.LastScannedAt,
		&i.IsMonitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
