// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: episode_files.sql

package tvshowdb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEpisodeFile = `-- name: CreateEpisodeFile :one
INSERT INTO tvshow.episode_files (
    episode_id, file_path, file_name, file_size,
    container, resolution, quality_profile,
    video_codec, audio_codec, bitrate_kbps, duration_seconds,
    audio_languages, subtitle_languages,
    sonarr_file_id
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7,
    $8, $9, $10, $11,
    $12, $13,
    $14
)
RETURNING id, episode_id, file_path, file_name, file_size, container, resolution, quality_profile, video_codec, audio_codec, bitrate_kbps, duration_seconds, audio_languages, subtitle_languages, sonarr_file_id, created_at, updated_at
`

type CreateEpisodeFileParams struct {
	EpisodeID         uuid.UUID      `json:"episodeId"`
	FilePath          string         `json:"filePath"`
	FileName          string         `json:"fileName"`
	FileSize          int64          `json:"fileSize"`
	Container         *string        `json:"container"`
	Resolution        *string        `json:"resolution"`
	QualityProfile    *string        `json:"qualityProfile"`
	VideoCodec        *string        `json:"videoCodec"`
	AudioCodec        *string        `json:"audioCodec"`
	BitrateKbps       *int32         `json:"bitrateKbps"`
	DurationSeconds   pgtype.Numeric `json:"durationSeconds"`
	AudioLanguages    []string       `json:"audioLanguages"`
	SubtitleLanguages []string       `json:"subtitleLanguages"`
	SonarrFileID      *int32         `json:"sonarrFileId"`
}

func (q *Queries) CreateEpisodeFile(ctx context.Context, arg CreateEpisodeFileParams) (TvshowEpisodeFile, error) {
	row := q.db.QueryRow(ctx, createEpisodeFile,
		arg.EpisodeID,
		arg.FilePath,
		arg.FileName,
		arg.FileSize,
		arg.Container,
		arg.Resolution,
		arg.QualityProfile,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.BitrateKbps,
		arg.DurationSeconds,
		arg.AudioLanguages,
		arg.SubtitleLanguages,
		arg.SonarrFileID,
	)
	var i TvshowEpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.FilePath,
		&i.FileName,
		&i.FileSize,
		&i.Container,
		&i.Resolution,
		&i.QualityProfile,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.BitrateKbps,
		&i.DurationSeconds,
		&i.AudioLanguages,
		&i.SubtitleLanguages,
		&i.SonarrFileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEpisodeFile = `-- name: DeleteEpisodeFile :exec
DELETE FROM tvshow.episode_files WHERE id = $1
`

func (q *Queries) DeleteEpisodeFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisodeFile, id)
	return err
}

const deleteEpisodeFilesByEpisode = `-- name: DeleteEpisodeFilesByEpisode :exec
DELETE FROM tvshow.episode_files WHERE episode_id = $1
`

func (q *Queries) DeleteEpisodeFilesByEpisode(ctx context.Context, episodeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisodeFilesByEpisode, episodeID)
	return err
}

const getEpisodeFile = `-- name: GetEpisodeFile :one
SELECT id, episode_id, file_path, file_name, file_size, container, resolution, quality_profile, video_codec, audio_codec, bitrate_kbps, duration_seconds, audio_languages, subtitle_languages, sonarr_file_id, created_at, updated_at FROM tvshow.episode_files WHERE id = $1
`

func (q *Queries) GetEpisodeFile(ctx context.Context, id uuid.UUID) (TvshowEpisodeFile, error) {
	row := q.db.QueryRow(ctx, getEpisodeFile, id)
	var i TvshowEpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.FilePath,
		&i.FileName,
		&i.FileSize,
		&i.Container,
		&i.Resolution,
		&i.QualityProfile,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.BitrateKbps,
		&i.DurationSeconds,
		&i.AudioLanguages,
		&i.SubtitleLanguages,
		&i.SonarrFileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEpisodeFileByPath = `-- name: GetEpisodeFileByPath :one
SELECT id, episode_id, file_path, file_name, file_size, container, resolution, quality_profile, video_codec, audio_codec, bitrate_kbps, duration_seconds, audio_languages, subtitle_languages, sonarr_file_id, created_at, updated_at FROM tvshow.episode_files WHERE file_path = $1
`

func (q *Queries) GetEpisodeFileByPath(ctx context.Context, filePath string) (TvshowEpisodeFile, error) {
	row := q.db.QueryRow(ctx, getEpisodeFileByPath, filePath)
	var i TvshowEpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.FilePath,
		&i.FileName,
		&i.FileSize,
		&i.Container,
		&i.Resolution,
		&i.QualityProfile,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.BitrateKbps,
		&i.DurationSeconds,
		&i.AudioLanguages,
		&i.SubtitleLanguages,
		&i.SonarrFileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEpisodeFileBySonarrID = `-- name: GetEpisodeFileBySonarrID :one
SELECT id, episode_id, file_path, file_name, file_size, container, resolution, quality_profile, video_codec, audio_codec, bitrate_kbps, duration_seconds, audio_languages, subtitle_languages, sonarr_file_id, created_at, updated_at FROM tvshow.episode_files WHERE sonarr_file_id = $1
`

func (q *Queries) GetEpisodeFileBySonarrID(ctx context.Context, sonarrFileID *int32) (TvshowEpisodeFile, error) {
	row := q.db.QueryRow(ctx, getEpisodeFileBySonarrID, sonarrFileID)
	var i TvshowEpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.FilePath,
		&i.FileName,
		&i.FileSize,
		&i.Container,
		&i.Resolution,
		&i.QualityProfile,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.BitrateKbps,
		&i.DurationSeconds,
		&i.AudioLanguages,
		&i.SubtitleLanguages,
		&i.SonarrFileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEpisodeFilesByEpisode = `-- name: ListEpisodeFilesByEpisode :many
SELECT id, episode_id, file_path, file_name, file_size, container, resolution, quality_profile, video_codec, audio_codec, bitrate_kbps, duration_seconds, audio_languages, subtitle_languages, sonarr_file_id, created_at, updated_at FROM tvshow.episode_files
WHERE episode_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListEpisodeFilesByEpisode(ctx context.Context, episodeID uuid.UUID) ([]TvshowEpisodeFile, error) {
	rows, err := q.db.Query(ctx, listEpisodeFilesByEpisode, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowEpisodeFile{}
	for rows.Next() {
		var i TvshowEpisodeFile
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.FilePath,
			&i.FileName,
			&i.FileSize,
			&i.Container,
			&i.Resolution,
			&i.QualityProfile,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.BitrateKbps,
			&i.DurationSeconds,
			&i.AudioLanguages,
			&i.SubtitleLanguages,
			&i.SonarrFileID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEpisodeFile = `-- name: UpdateEpisodeFile :one
UPDATE tvshow.episode_files SET
    file_path = COALESCE($1, file_path),
    file_name = COALESCE($2, file_name),
    file_size = COALESCE($3, file_size),
    container = COALESCE($4, container),
    resolution = COALESCE($5, resolution),
    quality_profile = COALESCE($6, quality_profile),
    video_codec = COALESCE($7, video_codec),
    audio_codec = COALESCE($8, audio_codec),
    bitrate_kbps = COALESCE($9, bitrate_kbps),
    duration_seconds = COALESCE($10, duration_seconds),
    audio_languages = COALESCE($11, audio_languages),
    subtitle_languages = COALESCE($12, subtitle_languages),
    sonarr_file_id = COALESCE($13, sonarr_file_id)
WHERE id = $14
RETURNING id, episode_id, file_path, file_name, file_size, container, resolution, quality_profile, video_codec, audio_codec, bitrate_kbps, duration_seconds, audio_languages, subtitle_languages, sonarr_file_id, created_at, updated_at
`

type UpdateEpisodeFileParams struct {
	FilePath          *string        `json:"filePath"`
	FileName          *string        `json:"fileName"`
	FileSize          *int64         `json:"fileSize"`
	Container         *string        `json:"container"`
	Resolution        *string        `json:"resolution"`
	QualityProfile    *string        `json:"qualityProfile"`
	VideoCodec        *string        `json:"videoCodec"`
	AudioCodec        *string        `json:"audioCodec"`
	BitrateKbps       *int32         `json:"bitrateKbps"`
	DurationSeconds   pgtype.Numeric `json:"durationSeconds"`
	AudioLanguages    []string       `json:"audioLanguages"`
	SubtitleLanguages []string       `json:"subtitleLanguages"`
	SonarrFileID      *int32         `json:"sonarrFileId"`
	ID                uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateEpisodeFile(ctx context.Context, arg UpdateEpisodeFileParams) (TvshowEpisodeFile, error) {
	row := q.db.QueryRow(ctx, updateEpisodeFile,
		arg.FilePath,
		arg.FileName,
		arg.FileSize,
		arg.Container,
		arg.Resolution,
		arg.QualityProfile,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.BitrateKbps,
		arg.DurationSeconds,
		arg.AudioLanguages,
		arg.SubtitleLanguages,
		arg.SonarrFileID,
		arg.ID,
	)
	var i TvshowEpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.FilePath,
		&i.FileName,
		&i.FileSize,
		&i.Container,
		&i.Resolution,
		&i.QualityProfile,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.BitrateKbps,
		&i.DurationSeconds,
		&i.AudioLanguages,
		&i.SubtitleLanguages,
		&i.SonarrFileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
