// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: seasons.sql

package tvshowdb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countSeasons = `-- name: CountSeasons :one
SELECT COUNT(*) FROM seasons WHERE series_id = $1 AND season_number > 0
`

func (q *Queries) CountSeasons(ctx context.Context, seriesID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSeasons, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSpecialSeasons = `-- name: CountSpecialSeasons :one
SELECT COUNT(*) FROM seasons WHERE series_id = $1 AND season_number = 0
`

func (q *Queries) CountSpecialSeasons(ctx context.Context, seriesID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSpecialSeasons, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSeason = `-- name: CreateSeason :one
INSERT INTO seasons (
    series_id, season_number, name, overview,
    air_date, year,
    poster_path, poster_blurhash,
    tmdb_id, tvdb_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, series_id, season_number, name, overview, air_date, year, episode_count, poster_path, poster_blurhash, tmdb_id, tvdb_id, created_at, updated_at
`

type CreateSeasonParams struct {
	SeriesID       uuid.UUID   `json:"seriesId"`
	SeasonNumber   int32       `json:"seasonNumber"`
	Name           *string     `json:"name"`
	Overview       *string     `json:"overview"`
	AirDate        pgtype.Date `json:"airDate"`
	Year           *int32      `json:"year"`
	PosterPath     *string     `json:"posterPath"`
	PosterBlurhash *string     `json:"posterBlurhash"`
	TmdbID         *int32      `json:"tmdbId"`
	TvdbID         *int32      `json:"tvdbId"`
}

func (q *Queries) CreateSeason(ctx context.Context, arg CreateSeasonParams) (Season, error) {
	row := q.db.QueryRow(ctx, createSeason,
		arg.SeriesID,
		arg.SeasonNumber,
		arg.Name,
		arg.Overview,
		arg.AirDate,
		arg.Year,
		arg.PosterPath,
		arg.PosterBlurhash,
		arg.TmdbID,
		arg.TvdbID,
	)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Name,
		&i.Overview,
		&i.AirDate,
		&i.Year,
		&i.EpisodeCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.TmdbID,
		&i.TvdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSeason = `-- name: DeleteSeason :exec
DELETE FROM seasons WHERE id = $1
`

func (q *Queries) DeleteSeason(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeason, id)
	return err
}

const deleteSeasonsBySeries = `-- name: DeleteSeasonsBySeries :exec
DELETE FROM seasons WHERE series_id = $1
`

func (q *Queries) DeleteSeasonsBySeries(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeasonsBySeries, seriesID)
	return err
}

const getOrCreateSeason = `-- name: GetOrCreateSeason :one
INSERT INTO seasons (series_id, season_number, name)
VALUES ($1, $2, COALESCE($3, 'Season ' || $2::text))
ON CONFLICT (series_id, season_number) DO UPDATE SET updated_at = NOW()
RETURNING id, series_id, season_number, name, overview, air_date, year, episode_count, poster_path, poster_blurhash, tmdb_id, tvdb_id, created_at, updated_at
`

type GetOrCreateSeasonParams struct {
	SeriesID     uuid.UUID   `json:"seriesId"`
	SeasonNumber int32       `json:"seasonNumber"`
	Column3      interface{} `json:"column3"`
}

func (q *Queries) GetOrCreateSeason(ctx context.Context, arg GetOrCreateSeasonParams) (Season, error) {
	row := q.db.QueryRow(ctx, getOrCreateSeason, arg.SeriesID, arg.SeasonNumber, arg.Column3)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Name,
		&i.Overview,
		&i.AirDate,
		&i.Year,
		&i.EpisodeCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.TmdbID,
		&i.TvdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeasonByID = `-- name: GetSeasonByID :one

SELECT id, series_id, season_number, name, overview, air_date, year, episode_count, poster_path, poster_blurhash, tmdb_id, tvdb_id, created_at, updated_at FROM seasons WHERE id = $1
`

// Season Queries
func (q *Queries) GetSeasonByID(ctx context.Context, id uuid.UUID) (Season, error) {
	row := q.db.QueryRow(ctx, getSeasonByID, id)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Name,
		&i.Overview,
		&i.AirDate,
		&i.Year,
		&i.EpisodeCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.TmdbID,
		&i.TvdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeasonByNumber = `-- name: GetSeasonByNumber :one
SELECT id, series_id, season_number, name, overview, air_date, year, episode_count, poster_path, poster_blurhash, tmdb_id, tvdb_id, created_at, updated_at FROM seasons WHERE series_id = $1 AND season_number = $2
`

type GetSeasonByNumberParams struct {
	SeriesID     uuid.UUID `json:"seriesId"`
	SeasonNumber int32     `json:"seasonNumber"`
}

func (q *Queries) GetSeasonByNumber(ctx context.Context, arg GetSeasonByNumberParams) (Season, error) {
	row := q.db.QueryRow(ctx, getSeasonByNumber, arg.SeriesID, arg.SeasonNumber)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Name,
		&i.Overview,
		&i.AirDate,
		&i.Year,
		&i.EpisodeCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.TmdbID,
		&i.TvdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeasonByTmdbID = `-- name: GetSeasonByTmdbID :one
SELECT id, series_id, season_number, name, overview, air_date, year, episode_count, poster_path, poster_blurhash, tmdb_id, tvdb_id, created_at, updated_at FROM seasons WHERE series_id = $1 AND tmdb_id = $2
`

type GetSeasonByTmdbIDParams struct {
	SeriesID uuid.UUID `json:"seriesId"`
	TmdbID   *int32    `json:"tmdbId"`
}

func (q *Queries) GetSeasonByTmdbID(ctx context.Context, arg GetSeasonByTmdbIDParams) (Season, error) {
	row := q.db.QueryRow(ctx, getSeasonByTmdbID, arg.SeriesID, arg.TmdbID)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Name,
		&i.Overview,
		&i.AirDate,
		&i.Year,
		&i.EpisodeCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.TmdbID,
		&i.TvdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSeasons = `-- name: ListSeasons :many
SELECT id, series_id, season_number, name, overview, air_date, year, episode_count, poster_path, poster_blurhash, tmdb_id, tvdb_id, created_at, updated_at FROM seasons
WHERE series_id = $1
ORDER BY season_number ASC
`

func (q *Queries) ListSeasons(ctx context.Context, seriesID uuid.UUID) ([]Season, error) {
	rows, err := q.db.Query(ctx, listSeasons, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Season{}
	for rows.Next() {
		var i Season
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.Name,
			&i.Overview,
			&i.AirDate,
			&i.Year,
			&i.EpisodeCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.TmdbID,
			&i.TvdbID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeasonsWithSpecials = `-- name: ListSeasonsWithSpecials :many
SELECT id, series_id, season_number, name, overview, air_date, year, episode_count, poster_path, poster_blurhash, tmdb_id, tvdb_id, created_at, updated_at FROM seasons
WHERE series_id = $1
ORDER BY
    CASE WHEN season_number = 0 THEN 1 ELSE 0 END,
    season_number ASC
`

func (q *Queries) ListSeasonsWithSpecials(ctx context.Context, seriesID uuid.UUID) ([]Season, error) {
	rows, err := q.db.Query(ctx, listSeasonsWithSpecials, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Season{}
	for rows.Next() {
		var i Season
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.Name,
			&i.Overview,
			&i.AirDate,
			&i.Year,
			&i.EpisodeCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.TmdbID,
			&i.TvdbID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const seasonExistsByNumber = `-- name: SeasonExistsByNumber :one
SELECT EXISTS(SELECT 1 FROM seasons WHERE series_id = $1 AND season_number = $2)
`

type SeasonExistsByNumberParams struct {
	SeriesID     uuid.UUID `json:"seriesId"`
	SeasonNumber int32     `json:"seasonNumber"`
}

func (q *Queries) SeasonExistsByNumber(ctx context.Context, arg SeasonExistsByNumberParams) (bool, error) {
	row := q.db.QueryRow(ctx, seasonExistsByNumber, arg.SeriesID, arg.SeasonNumber)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateSeason = `-- name: UpdateSeason :one
UPDATE seasons SET
    name = COALESCE($1, name),
    overview = COALESCE($2, overview),
    air_date = COALESCE($3, air_date),
    year = COALESCE($4, year),
    poster_path = COALESCE($5, poster_path),
    poster_blurhash = COALESCE($6, poster_blurhash),
    tmdb_id = COALESCE($7, tmdb_id),
    tvdb_id = COALESCE($8, tvdb_id)
WHERE id = $9
RETURNING id, series_id, season_number, name, overview, air_date, year, episode_count, poster_path, poster_blurhash, tmdb_id, tvdb_id, created_at, updated_at
`

type UpdateSeasonParams struct {
	Name           *string     `json:"name"`
	Overview       *string     `json:"overview"`
	AirDate        pgtype.Date `json:"airDate"`
	Year           *int32      `json:"year"`
	PosterPath     *string     `json:"posterPath"`
	PosterBlurhash *string     `json:"posterBlurhash"`
	TmdbID         *int32      `json:"tmdbId"`
	TvdbID         *int32      `json:"tvdbId"`
	ID             uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateSeason(ctx context.Context, arg UpdateSeasonParams) (Season, error) {
	row := q.db.QueryRow(ctx, updateSeason,
		arg.Name,
		arg.Overview,
		arg.AirDate,
		arg.Year,
		arg.PosterPath,
		arg.PosterBlurhash,
		arg.TmdbID,
		arg.TvdbID,
		arg.ID,
	)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Name,
		&i.Overview,
		&i.AirDate,
		&i.Year,
		&i.EpisodeCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.TmdbID,
		&i.TvdbID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
