// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: credits.sql

package tvshowdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countEpisodeGuestStars = `-- name: CountEpisodeGuestStars :one
SELECT COUNT(*) FROM episode_credits WHERE episode_id = $1 AND role = 'actor' AND is_guest = true
`

func (q *Queries) CountEpisodeGuestStars(ctx context.Context, episodeID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEpisodeGuestStars, episodeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSeriesCast = `-- name: CountSeriesCast :one
SELECT COUNT(*) FROM series_credits WHERE series_id = $1 AND role = 'actor'
`

func (q *Queries) CountSeriesCast(ctx context.Context, seriesID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSeriesCast, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSeriesCrew = `-- name: CountSeriesCrew :one
SELECT COUNT(*) FROM series_credits WHERE series_id = $1 AND role != 'actor'
`

func (q *Queries) CountSeriesCrew(ctx context.Context, seriesID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSeriesCrew, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEpisodeCredit = `-- name: CreateEpisodeCredit :one
INSERT INTO episode_credits (
    episode_id, person_id, role, character_name, department, job, billing_order, is_guest, tmdb_credit_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, episode_id, person_id, role, character_name, department, job, billing_order, is_guest, tmdb_credit_id, created_at
`

type CreateEpisodeCreditParams struct {
	EpisodeID     uuid.UUID `json:"episodeId"`
	PersonID      uuid.UUID `json:"personId"`
	Role          string    `json:"role"`
	CharacterName *string   `json:"characterName"`
	Department    *string   `json:"department"`
	Job           *string   `json:"job"`
	BillingOrder  int32     `json:"billingOrder"`
	IsGuest       bool      `json:"isGuest"`
	TmdbCreditID  *string   `json:"tmdbCreditId"`
}

func (q *Queries) CreateEpisodeCredit(ctx context.Context, arg CreateEpisodeCreditParams) (EpisodeCredit, error) {
	row := q.db.QueryRow(ctx, createEpisodeCredit,
		arg.EpisodeID,
		arg.PersonID,
		arg.Role,
		arg.CharacterName,
		arg.Department,
		arg.Job,
		arg.BillingOrder,
		arg.IsGuest,
		arg.TmdbCreditID,
	)
	var i EpisodeCredit
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.PersonID,
		&i.Role,
		&i.CharacterName,
		&i.Department,
		&i.Job,
		&i.BillingOrder,
		&i.IsGuest,
		&i.TmdbCreditID,
		&i.CreatedAt,
	)
	return i, err
}

const createSeriesCredit = `-- name: CreateSeriesCredit :one
INSERT INTO series_credits (
    series_id, person_id, role, character_name, department, job, billing_order, tmdb_credit_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, series_id, person_id, role, character_name, department, job, billing_order, tmdb_credit_id, created_at
`

type CreateSeriesCreditParams struct {
	SeriesID      uuid.UUID `json:"seriesId"`
	PersonID      uuid.UUID `json:"personId"`
	Role          string    `json:"role"`
	CharacterName *string   `json:"characterName"`
	Department    *string   `json:"department"`
	Job           *string   `json:"job"`
	BillingOrder  int32     `json:"billingOrder"`
	TmdbCreditID  *string   `json:"tmdbCreditId"`
}

func (q *Queries) CreateSeriesCredit(ctx context.Context, arg CreateSeriesCreditParams) (SeriesCredit, error) {
	row := q.db.QueryRow(ctx, createSeriesCredit,
		arg.SeriesID,
		arg.PersonID,
		arg.Role,
		arg.CharacterName,
		arg.Department,
		arg.Job,
		arg.BillingOrder,
		arg.TmdbCreditID,
	)
	var i SeriesCredit
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.PersonID,
		&i.Role,
		&i.CharacterName,
		&i.Department,
		&i.Job,
		&i.BillingOrder,
		&i.TmdbCreditID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEpisodeCredits = `-- name: DeleteEpisodeCredits :exec
DELETE FROM episode_credits WHERE episode_id = $1
`

func (q *Queries) DeleteEpisodeCredits(ctx context.Context, episodeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisodeCredits, episodeID)
	return err
}

const deleteEpisodeCreditsBySeries = `-- name: DeleteEpisodeCreditsBySeries :exec
DELETE FROM episode_credits WHERE episode_id IN (SELECT id FROM episodes WHERE series_id = $1)
`

func (q *Queries) DeleteEpisodeCreditsBySeries(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisodeCreditsBySeries, seriesID)
	return err
}

const deleteSeriesCredits = `-- name: DeleteSeriesCredits :exec
DELETE FROM series_credits WHERE series_id = $1
`

func (q *Queries) DeleteSeriesCredits(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeriesCredits, seriesID)
	return err
}

const deleteSeriesCreditsByRole = `-- name: DeleteSeriesCreditsByRole :exec
DELETE FROM series_credits WHERE series_id = $1 AND role = $2
`

type DeleteSeriesCreditsByRoleParams struct {
	SeriesID uuid.UUID `json:"seriesId"`
	Role     string    `json:"role"`
}

func (q *Queries) DeleteSeriesCreditsByRole(ctx context.Context, arg DeleteSeriesCreditsByRoleParams) error {
	_, err := q.db.Exec(ctx, deleteSeriesCreditsByRole, arg.SeriesID, arg.Role)
	return err
}

const getEpisodeCast = `-- name: GetEpisodeCast :many

SELECT ec.id, ec.episode_id, ec.person_id, ec.role, ec.character_name, ec.department, ec.job, ec.billing_order, ec.is_guest, ec.tmdb_credit_id, ec.created_at, p.name, p.primary_image_url, p.primary_image_blurhash
FROM episode_credits ec
JOIN video_people p ON ec.person_id = p.id
WHERE ec.episode_id = $1 AND ec.role = 'actor'
ORDER BY ec.is_guest ASC, ec.billing_order ASC
`

type GetEpisodeCastRow struct {
	ID                   uuid.UUID `json:"id"`
	EpisodeID            uuid.UUID `json:"episodeId"`
	PersonID             uuid.UUID `json:"personId"`
	Role                 string    `json:"role"`
	CharacterName        *string   `json:"characterName"`
	Department           *string   `json:"department"`
	Job                  *string   `json:"job"`
	BillingOrder         int32     `json:"billingOrder"`
	IsGuest              bool      `json:"isGuest"`
	TmdbCreditID         *string   `json:"tmdbCreditId"`
	CreatedAt            time.Time `json:"createdAt"`
	Name                 string    `json:"name"`
	PrimaryImageUrl      *string   `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string   `json:"primaryImageBlurhash"`
}

// Episode Cast & Crew (Guest Stars, Episode Directors, Writers)
func (q *Queries) GetEpisodeCast(ctx context.Context, episodeID uuid.UUID) ([]GetEpisodeCastRow, error) {
	rows, err := q.db.Query(ctx, getEpisodeCast, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEpisodeCastRow{}
	for rows.Next() {
		var i GetEpisodeCastRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.IsGuest,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Name,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodeCrew = `-- name: GetEpisodeCrew :many
SELECT ec.id, ec.episode_id, ec.person_id, ec.role, ec.character_name, ec.department, ec.job, ec.billing_order, ec.is_guest, ec.tmdb_credit_id, ec.created_at, p.name, p.primary_image_url, p.primary_image_blurhash
FROM episode_credits ec
JOIN video_people p ON ec.person_id = p.id
WHERE ec.episode_id = $1 AND ec.role != 'actor'
ORDER BY
    CASE ec.role
        WHEN 'director' THEN 1
        WHEN 'writer' THEN 2
        ELSE 10
    END,
    ec.billing_order ASC
`

type GetEpisodeCrewRow struct {
	ID                   uuid.UUID `json:"id"`
	EpisodeID            uuid.UUID `json:"episodeId"`
	PersonID             uuid.UUID `json:"personId"`
	Role                 string    `json:"role"`
	CharacterName        *string   `json:"characterName"`
	Department           *string   `json:"department"`
	Job                  *string   `json:"job"`
	BillingOrder         int32     `json:"billingOrder"`
	IsGuest              bool      `json:"isGuest"`
	TmdbCreditID         *string   `json:"tmdbCreditId"`
	CreatedAt            time.Time `json:"createdAt"`
	Name                 string    `json:"name"`
	PrimaryImageUrl      *string   `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string   `json:"primaryImageBlurhash"`
}

func (q *Queries) GetEpisodeCrew(ctx context.Context, episodeID uuid.UUID) ([]GetEpisodeCrewRow, error) {
	rows, err := q.db.Query(ctx, getEpisodeCrew, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEpisodeCrewRow{}
	for rows.Next() {
		var i GetEpisodeCrewRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.IsGuest,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Name,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodeDirectors = `-- name: GetEpisodeDirectors :many
SELECT ec.id, ec.episode_id, ec.person_id, ec.role, ec.character_name, ec.department, ec.job, ec.billing_order, ec.is_guest, ec.tmdb_credit_id, ec.created_at, p.name, p.primary_image_url, p.primary_image_blurhash
FROM episode_credits ec
JOIN video_people p ON ec.person_id = p.id
WHERE ec.episode_id = $1 AND ec.role = 'director'
ORDER BY ec.billing_order ASC
`

type GetEpisodeDirectorsRow struct {
	ID                   uuid.UUID `json:"id"`
	EpisodeID            uuid.UUID `json:"episodeId"`
	PersonID             uuid.UUID `json:"personId"`
	Role                 string    `json:"role"`
	CharacterName        *string   `json:"characterName"`
	Department           *string   `json:"department"`
	Job                  *string   `json:"job"`
	BillingOrder         int32     `json:"billingOrder"`
	IsGuest              bool      `json:"isGuest"`
	TmdbCreditID         *string   `json:"tmdbCreditId"`
	CreatedAt            time.Time `json:"createdAt"`
	Name                 string    `json:"name"`
	PrimaryImageUrl      *string   `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string   `json:"primaryImageBlurhash"`
}

func (q *Queries) GetEpisodeDirectors(ctx context.Context, episodeID uuid.UUID) ([]GetEpisodeDirectorsRow, error) {
	rows, err := q.db.Query(ctx, getEpisodeDirectors, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEpisodeDirectorsRow{}
	for rows.Next() {
		var i GetEpisodeDirectorsRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.IsGuest,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Name,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodeGuestStars = `-- name: GetEpisodeGuestStars :many
SELECT ec.id, ec.episode_id, ec.person_id, ec.role, ec.character_name, ec.department, ec.job, ec.billing_order, ec.is_guest, ec.tmdb_credit_id, ec.created_at, p.name, p.primary_image_url, p.primary_image_blurhash
FROM episode_credits ec
JOIN video_people p ON ec.person_id = p.id
WHERE ec.episode_id = $1 AND ec.role = 'actor' AND ec.is_guest = true
ORDER BY ec.billing_order ASC
`

type GetEpisodeGuestStarsRow struct {
	ID                   uuid.UUID `json:"id"`
	EpisodeID            uuid.UUID `json:"episodeId"`
	PersonID             uuid.UUID `json:"personId"`
	Role                 string    `json:"role"`
	CharacterName        *string   `json:"characterName"`
	Department           *string   `json:"department"`
	Job                  *string   `json:"job"`
	BillingOrder         int32     `json:"billingOrder"`
	IsGuest              bool      `json:"isGuest"`
	TmdbCreditID         *string   `json:"tmdbCreditId"`
	CreatedAt            time.Time `json:"createdAt"`
	Name                 string    `json:"name"`
	PrimaryImageUrl      *string   `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string   `json:"primaryImageBlurhash"`
}

func (q *Queries) GetEpisodeGuestStars(ctx context.Context, episodeID uuid.UUID) ([]GetEpisodeGuestStarsRow, error) {
	rows, err := q.db.Query(ctx, getEpisodeGuestStars, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEpisodeGuestStarsRow{}
	for rows.Next() {
		var i GetEpisodeGuestStarsRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.IsGuest,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Name,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodeWriters = `-- name: GetEpisodeWriters :many
SELECT ec.id, ec.episode_id, ec.person_id, ec.role, ec.character_name, ec.department, ec.job, ec.billing_order, ec.is_guest, ec.tmdb_credit_id, ec.created_at, p.name, p.primary_image_url, p.primary_image_blurhash
FROM episode_credits ec
JOIN video_people p ON ec.person_id = p.id
WHERE ec.episode_id = $1 AND ec.role = 'writer'
ORDER BY ec.billing_order ASC
`

type GetEpisodeWritersRow struct {
	ID                   uuid.UUID `json:"id"`
	EpisodeID            uuid.UUID `json:"episodeId"`
	PersonID             uuid.UUID `json:"personId"`
	Role                 string    `json:"role"`
	CharacterName        *string   `json:"characterName"`
	Department           *string   `json:"department"`
	Job                  *string   `json:"job"`
	BillingOrder         int32     `json:"billingOrder"`
	IsGuest              bool      `json:"isGuest"`
	TmdbCreditID         *string   `json:"tmdbCreditId"`
	CreatedAt            time.Time `json:"createdAt"`
	Name                 string    `json:"name"`
	PrimaryImageUrl      *string   `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string   `json:"primaryImageBlurhash"`
}

func (q *Queries) GetEpisodeWriters(ctx context.Context, episodeID uuid.UUID) ([]GetEpisodeWritersRow, error) {
	rows, err := q.db.Query(ctx, getEpisodeWriters, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEpisodeWritersRow{}
	for rows.Next() {
		var i GetEpisodeWritersRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.IsGuest,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Name,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersonEpisodeCredits = `-- name: GetPersonEpisodeCredits :many
SELECT ec.id, ec.episode_id, ec.person_id, ec.role, ec.character_name, ec.department, ec.job, ec.billing_order, ec.is_guest, ec.tmdb_credit_id, ec.created_at, e.title as episode_title, e.season_number, e.episode_number,
       s.id as series_id, s.title as series_title, s.poster_path as series_poster
FROM episode_credits ec
JOIN episodes e ON ec.episode_id = e.id
JOIN series s ON e.series_id = s.id
WHERE ec.person_id = $1
ORDER BY e.air_date DESC NULLS LAST
`

type GetPersonEpisodeCreditsRow struct {
	ID            uuid.UUID `json:"id"`
	EpisodeID     uuid.UUID `json:"episodeId"`
	PersonID      uuid.UUID `json:"personId"`
	Role          string    `json:"role"`
	CharacterName *string   `json:"characterName"`
	Department    *string   `json:"department"`
	Job           *string   `json:"job"`
	BillingOrder  int32     `json:"billingOrder"`
	IsGuest       bool      `json:"isGuest"`
	TmdbCreditID  *string   `json:"tmdbCreditId"`
	CreatedAt     time.Time `json:"createdAt"`
	EpisodeTitle  string    `json:"episodeTitle"`
	SeasonNumber  int32     `json:"seasonNumber"`
	EpisodeNumber int32     `json:"episodeNumber"`
	SeriesID      uuid.UUID `json:"seriesId"`
	SeriesTitle   string    `json:"seriesTitle"`
	SeriesPoster  *string   `json:"seriesPoster"`
}

func (q *Queries) GetPersonEpisodeCredits(ctx context.Context, personID uuid.UUID) ([]GetPersonEpisodeCreditsRow, error) {
	rows, err := q.db.Query(ctx, getPersonEpisodeCredits, personID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPersonEpisodeCreditsRow{}
	for rows.Next() {
		var i GetPersonEpisodeCreditsRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.IsGuest,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.EpisodeTitle,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.SeriesID,
			&i.SeriesTitle,
			&i.SeriesPoster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersonSeriesCredits = `-- name: GetPersonSeriesCredits :many
SELECT sc.id, sc.series_id, sc.person_id, sc.role, sc.character_name, sc.department, sc.job, sc.billing_order, sc.tmdb_credit_id, sc.created_at, s.title, s.year, s.poster_path, s.poster_blurhash
FROM series_credits sc
JOIN series s ON sc.series_id = s.id
WHERE sc.person_id = $1
ORDER BY s.first_air_date DESC NULLS LAST
`

type GetPersonSeriesCreditsRow struct {
	ID             uuid.UUID `json:"id"`
	SeriesID       uuid.UUID `json:"seriesId"`
	PersonID       uuid.UUID `json:"personId"`
	Role           string    `json:"role"`
	CharacterName  *string   `json:"characterName"`
	Department     *string   `json:"department"`
	Job            *string   `json:"job"`
	BillingOrder   int32     `json:"billingOrder"`
	TmdbCreditID   *string   `json:"tmdbCreditId"`
	CreatedAt      time.Time `json:"createdAt"`
	Title          string    `json:"title"`
	Year           *int32    `json:"year"`
	PosterPath     *string   `json:"posterPath"`
	PosterBlurhash *string   `json:"posterBlurhash"`
}

func (q *Queries) GetPersonSeriesCredits(ctx context.Context, personID uuid.UUID) ([]GetPersonSeriesCreditsRow, error) {
	rows, err := q.db.Query(ctx, getPersonSeriesCredits, personID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPersonSeriesCreditsRow{}
	for rows.Next() {
		var i GetPersonSeriesCreditsRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Title,
			&i.Year,
			&i.PosterPath,
			&i.PosterBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeriesCast = `-- name: GetSeriesCast :many


SELECT sc.id, sc.series_id, sc.person_id, sc.role, sc.character_name, sc.department, sc.job, sc.billing_order, sc.tmdb_credit_id, sc.created_at, p.name, p.primary_image_url, p.primary_image_blurhash
FROM series_credits sc
JOIN video_people p ON sc.person_id = p.id
WHERE sc.series_id = $1 AND sc.role = 'actor'
ORDER BY sc.billing_order ASC
`

type GetSeriesCastRow struct {
	ID                   uuid.UUID `json:"id"`
	SeriesID             uuid.UUID `json:"seriesId"`
	PersonID             uuid.UUID `json:"personId"`
	Role                 string    `json:"role"`
	CharacterName        *string   `json:"characterName"`
	Department           *string   `json:"department"`
	Job                  *string   `json:"job"`
	BillingOrder         int32     `json:"billingOrder"`
	TmdbCreditID         *string   `json:"tmdbCreditId"`
	CreatedAt            time.Time `json:"createdAt"`
	Name                 string    `json:"name"`
	PrimaryImageUrl      *string   `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string   `json:"primaryImageBlurhash"`
}

// TV Show Credits Queries
// Uses shared video_people table
// Series Cast & Crew
func (q *Queries) GetSeriesCast(ctx context.Context, seriesID uuid.UUID) ([]GetSeriesCastRow, error) {
	rows, err := q.db.Query(ctx, getSeriesCast, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSeriesCastRow{}
	for rows.Next() {
		var i GetSeriesCastRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Name,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeriesCreators = `-- name: GetSeriesCreators :many
SELECT sc.id, sc.series_id, sc.person_id, sc.role, sc.character_name, sc.department, sc.job, sc.billing_order, sc.tmdb_credit_id, sc.created_at, p.name, p.primary_image_url, p.primary_image_blurhash
FROM series_credits sc
JOIN video_people p ON sc.person_id = p.id
WHERE sc.series_id = $1 AND sc.role IN ('creator', 'showrunner')
ORDER BY sc.billing_order ASC
`

type GetSeriesCreatorsRow struct {
	ID                   uuid.UUID `json:"id"`
	SeriesID             uuid.UUID `json:"seriesId"`
	PersonID             uuid.UUID `json:"personId"`
	Role                 string    `json:"role"`
	CharacterName        *string   `json:"characterName"`
	Department           *string   `json:"department"`
	Job                  *string   `json:"job"`
	BillingOrder         int32     `json:"billingOrder"`
	TmdbCreditID         *string   `json:"tmdbCreditId"`
	CreatedAt            time.Time `json:"createdAt"`
	Name                 string    `json:"name"`
	PrimaryImageUrl      *string   `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string   `json:"primaryImageBlurhash"`
}

func (q *Queries) GetSeriesCreators(ctx context.Context, seriesID uuid.UUID) ([]GetSeriesCreatorsRow, error) {
	rows, err := q.db.Query(ctx, getSeriesCreators, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSeriesCreatorsRow{}
	for rows.Next() {
		var i GetSeriesCreatorsRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Name,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeriesCrew = `-- name: GetSeriesCrew :many
SELECT sc.id, sc.series_id, sc.person_id, sc.role, sc.character_name, sc.department, sc.job, sc.billing_order, sc.tmdb_credit_id, sc.created_at, p.name, p.primary_image_url, p.primary_image_blurhash
FROM series_credits sc
JOIN video_people p ON sc.person_id = p.id
WHERE sc.series_id = $1 AND sc.role != 'actor'
ORDER BY
    CASE sc.role
        WHEN 'creator' THEN 1
        WHEN 'showrunner' THEN 2
        WHEN 'executive_producer' THEN 3
        WHEN 'director' THEN 4
        WHEN 'writer' THEN 5
        WHEN 'producer' THEN 6
        ELSE 10
    END,
    sc.billing_order ASC
`

type GetSeriesCrewRow struct {
	ID                   uuid.UUID `json:"id"`
	SeriesID             uuid.UUID `json:"seriesId"`
	PersonID             uuid.UUID `json:"personId"`
	Role                 string    `json:"role"`
	CharacterName        *string   `json:"characterName"`
	Department           *string   `json:"department"`
	Job                  *string   `json:"job"`
	BillingOrder         int32     `json:"billingOrder"`
	TmdbCreditID         *string   `json:"tmdbCreditId"`
	CreatedAt            time.Time `json:"createdAt"`
	Name                 string    `json:"name"`
	PrimaryImageUrl      *string   `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string   `json:"primaryImageBlurhash"`
}

func (q *Queries) GetSeriesCrew(ctx context.Context, seriesID uuid.UUID) ([]GetSeriesCrewRow, error) {
	rows, err := q.db.Query(ctx, getSeriesCrew, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSeriesCrewRow{}
	for rows.Next() {
		var i GetSeriesCrewRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.PersonID,
			&i.Role,
			&i.CharacterName,
			&i.Department,
			&i.Job,
			&i.BillingOrder,
			&i.TmdbCreditID,
			&i.CreatedAt,
			&i.Name,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
