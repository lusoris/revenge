// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: credits.sql

package tvshowdb

import (
	"context"

	"github.com/google/uuid"
)

const countSeriesCast = `-- name: CountSeriesCast :one
SELECT COUNT(*)
FROM tvshow.series_credits
WHERE
    series_id = $1
    AND credit_type = 'cast'
`

func (q *Queries) CountSeriesCast(ctx context.Context, seriesID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSeriesCast, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSeriesCrew = `-- name: CountSeriesCrew :one
SELECT COUNT(*)
FROM tvshow.series_credits
WHERE
    series_id = $1
    AND credit_type = 'crew'
`

func (q *Queries) CountSeriesCrew(ctx context.Context, seriesID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSeriesCrew, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEpisodeCredit = `-- name: CreateEpisodeCredit :one
INSERT INTO
    tvshow.episode_credits (
        episode_id,
        tmdb_person_id,
        name,
        credit_type,
        character,
        cast_order,
        job,
        department,
        profile_path
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
    ) RETURNING id, episode_id, tmdb_person_id, name, credit_type, character, cast_order, job, department, profile_path, created_at, updated_at
`

type CreateEpisodeCreditParams struct {
	EpisodeID    uuid.UUID `json:"episodeId"`
	TmdbPersonID int32     `json:"tmdbPersonId"`
	Name         string    `json:"name"`
	CreditType   string    `json:"creditType"`
	Character    *string   `json:"character"`
	CastOrder    *int32    `json:"castOrder"`
	Job          *string   `json:"job"`
	Department   *string   `json:"department"`
	ProfilePath  *string   `json:"profilePath"`
}

func (q *Queries) CreateEpisodeCredit(ctx context.Context, arg CreateEpisodeCreditParams) (TvshowEpisodeCredit, error) {
	row := q.db.QueryRow(ctx, createEpisodeCredit,
		arg.EpisodeID,
		arg.TmdbPersonID,
		arg.Name,
		arg.CreditType,
		arg.Character,
		arg.CastOrder,
		arg.Job,
		arg.Department,
		arg.ProfilePath,
	)
	var i TvshowEpisodeCredit
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.TmdbPersonID,
		&i.Name,
		&i.CreditType,
		&i.Character,
		&i.CastOrder,
		&i.Job,
		&i.Department,
		&i.ProfilePath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSeriesCredit = `-- name: CreateSeriesCredit :one
INSERT INTO
    tvshow.series_credits (
        series_id,
        tmdb_person_id,
        name,
        credit_type,
        character,
        cast_order,
        job,
        department,
        profile_path
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
    ) RETURNING id, series_id, tmdb_person_id, name, credit_type, character, cast_order, job, department, profile_path, created_at, updated_at
`

type CreateSeriesCreditParams struct {
	SeriesID     uuid.UUID `json:"seriesId"`
	TmdbPersonID int32     `json:"tmdbPersonId"`
	Name         string    `json:"name"`
	CreditType   string    `json:"creditType"`
	Character    *string   `json:"character"`
	CastOrder    *int32    `json:"castOrder"`
	Job          *string   `json:"job"`
	Department   *string   `json:"department"`
	ProfilePath  *string   `json:"profilePath"`
}

func (q *Queries) CreateSeriesCredit(ctx context.Context, arg CreateSeriesCreditParams) (TvshowSeriesCredit, error) {
	row := q.db.QueryRow(ctx, createSeriesCredit,
		arg.SeriesID,
		arg.TmdbPersonID,
		arg.Name,
		arg.CreditType,
		arg.Character,
		arg.CastOrder,
		arg.Job,
		arg.Department,
		arg.ProfilePath,
	)
	var i TvshowSeriesCredit
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.TmdbPersonID,
		&i.Name,
		&i.CreditType,
		&i.Character,
		&i.CastOrder,
		&i.Job,
		&i.Department,
		&i.ProfilePath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEpisodeCredits = `-- name: DeleteEpisodeCredits :exec
DELETE FROM tvshow.episode_credits WHERE episode_id = $1
`

func (q *Queries) DeleteEpisodeCredits(ctx context.Context, episodeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisodeCredits, episodeID)
	return err
}

const deleteSeriesCredits = `-- name: DeleteSeriesCredits :exec
DELETE FROM tvshow.series_credits WHERE series_id = $1
`

func (q *Queries) DeleteSeriesCredits(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeriesCredits, seriesID)
	return err
}

const listEpisodeCrew = `-- name: ListEpisodeCrew :many
SELECT id, episode_id, tmdb_person_id, name, credit_type, character, cast_order, job, department, profile_path, created_at, updated_at
FROM tvshow.episode_credits
WHERE
    episode_id = $1
    AND credit_type = 'crew'
ORDER BY department ASC, name ASC
`

func (q *Queries) ListEpisodeCrew(ctx context.Context, episodeID uuid.UUID) ([]TvshowEpisodeCredit, error) {
	rows, err := q.db.Query(ctx, listEpisodeCrew, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowEpisodeCredit{}
	for rows.Next() {
		var i TvshowEpisodeCredit
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.TmdbPersonID,
			&i.Name,
			&i.CreditType,
			&i.Character,
			&i.CastOrder,
			&i.Job,
			&i.Department,
			&i.ProfilePath,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeGuestStars = `-- name: ListEpisodeGuestStars :many

SELECT id, episode_id, tmdb_person_id, name, credit_type, character, cast_order, job, department, profile_path, created_at, updated_at
FROM tvshow.episode_credits
WHERE
    episode_id = $1
    AND credit_type = 'guest_star'
ORDER BY cast_order ASC NULLS LAST, name ASC
`

// Episode Credits (Guest Stars)
func (q *Queries) ListEpisodeGuestStars(ctx context.Context, episodeID uuid.UUID) ([]TvshowEpisodeCredit, error) {
	rows, err := q.db.Query(ctx, listEpisodeGuestStars, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowEpisodeCredit{}
	for rows.Next() {
		var i TvshowEpisodeCredit
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.TmdbPersonID,
			&i.Name,
			&i.CreditType,
			&i.Character,
			&i.CastOrder,
			&i.Job,
			&i.Department,
			&i.ProfilePath,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesCast = `-- name: ListSeriesCast :many

SELECT id, series_id, tmdb_person_id, name, credit_type, character, cast_order, job, department, profile_path, created_at, updated_at
FROM tvshow.series_credits
WHERE
    series_id = $1
    AND credit_type = 'cast'
ORDER BY cast_order ASC NULLS LAST, name ASC
LIMIT $2
OFFSET
    $3
`

type ListSeriesCastParams struct {
	SeriesID uuid.UUID `json:"seriesId"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

// Series Credits
func (q *Queries) ListSeriesCast(ctx context.Context, arg ListSeriesCastParams) ([]TvshowSeriesCredit, error) {
	rows, err := q.db.Query(ctx, listSeriesCast, arg.SeriesID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowSeriesCredit{}
	for rows.Next() {
		var i TvshowSeriesCredit
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.TmdbPersonID,
			&i.Name,
			&i.CreditType,
			&i.Character,
			&i.CastOrder,
			&i.Job,
			&i.Department,
			&i.ProfilePath,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesCrew = `-- name: ListSeriesCrew :many
SELECT id, series_id, tmdb_person_id, name, credit_type, character, cast_order, job, department, profile_path, created_at, updated_at
FROM tvshow.series_credits
WHERE
    series_id = $1
    AND credit_type = 'crew'
ORDER BY department ASC, name ASC
LIMIT $2
OFFSET
    $3
`

type ListSeriesCrewParams struct {
	SeriesID uuid.UUID `json:"seriesId"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListSeriesCrew(ctx context.Context, arg ListSeriesCrewParams) ([]TvshowSeriesCredit, error) {
	rows, err := q.db.Query(ctx, listSeriesCrew, arg.SeriesID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowSeriesCredit{}
	for rows.Next() {
		var i TvshowSeriesCredit
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.TmdbPersonID,
			&i.Name,
			&i.CreditType,
			&i.Character,
			&i.CastOrder,
			&i.Job,
			&i.Department,
			&i.ProfilePath,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
