// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: libraries.sql

package tvshowdb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countSeriesByTVLibrary = `-- name: CountSeriesByTVLibrary :one
SELECT COUNT(*) FROM series WHERE tv_library_id = $1
`

func (q *Queries) CountSeriesByTVLibrary(ctx context.Context, tvLibraryID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSeriesByTVLibrary, tvLibraryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTVLibrary = `-- name: CreateTVLibrary :one
INSERT INTO tv_libraries (
    name,
    paths,
    scan_enabled,
    scan_interval_hours,
    preferred_language,
    tmdb_enabled,
    tvdb_enabled,
    download_backdrops,
    download_nfo,
    generate_chapters,
    season_folder_format,
    episode_naming_format,
    auto_add_missing,
    is_private,
    owner_user_id,
    sort_order,
    icon
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
)
RETURNING id, name, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, tmdb_enabled, tvdb_enabled, download_backdrops, download_nfo, generate_chapters, season_folder_format, episode_naming_format, auto_add_missing, is_private, owner_user_id, sort_order, icon, created_at, updated_at
`

type CreateTVLibraryParams struct {
	Name                string      `json:"name"`
	Paths               []string    `json:"paths"`
	ScanEnabled         bool        `json:"scanEnabled"`
	ScanIntervalHours   int32       `json:"scanIntervalHours"`
	PreferredLanguage   *string     `json:"preferredLanguage"`
	TmdbEnabled         bool        `json:"tmdbEnabled"`
	TvdbEnabled         bool        `json:"tvdbEnabled"`
	DownloadBackdrops   bool        `json:"downloadBackdrops"`
	DownloadNfo         bool        `json:"downloadNfo"`
	GenerateChapters    bool        `json:"generateChapters"`
	SeasonFolderFormat  *string     `json:"seasonFolderFormat"`
	EpisodeNamingFormat *string     `json:"episodeNamingFormat"`
	AutoAddMissing      bool        `json:"autoAddMissing"`
	IsPrivate           bool        `json:"isPrivate"`
	OwnerUserID         pgtype.UUID `json:"ownerUserId"`
	SortOrder           int32       `json:"sortOrder"`
	Icon                *string     `json:"icon"`
}

func (q *Queries) CreateTVLibrary(ctx context.Context, arg CreateTVLibraryParams) (TvLibrary, error) {
	row := q.db.QueryRow(ctx, createTVLibrary,
		arg.Name,
		arg.Paths,
		arg.ScanEnabled,
		arg.ScanIntervalHours,
		arg.PreferredLanguage,
		arg.TmdbEnabled,
		arg.TvdbEnabled,
		arg.DownloadBackdrops,
		arg.DownloadNfo,
		arg.GenerateChapters,
		arg.SeasonFolderFormat,
		arg.EpisodeNamingFormat,
		arg.AutoAddMissing,
		arg.IsPrivate,
		arg.OwnerUserID,
		arg.SortOrder,
		arg.Icon,
	)
	var i TvLibrary
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Paths,
		&i.ScanEnabled,
		&i.ScanIntervalHours,
		&i.LastScanAt,
		&i.LastScanDuration,
		&i.PreferredLanguage,
		&i.TmdbEnabled,
		&i.TvdbEnabled,
		&i.DownloadBackdrops,
		&i.DownloadNfo,
		&i.GenerateChapters,
		&i.SeasonFolderFormat,
		&i.EpisodeNamingFormat,
		&i.AutoAddMissing,
		&i.IsPrivate,
		&i.OwnerUserID,
		&i.SortOrder,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTVLibrary = `-- name: DeleteTVLibrary :exec
DELETE FROM tv_libraries WHERE id = $1
`

func (q *Queries) DeleteTVLibrary(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTVLibrary, id)
	return err
}

const getTVLibraryByID = `-- name: GetTVLibraryByID :one

SELECT id, name, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, tmdb_enabled, tvdb_enabled, download_backdrops, download_nfo, generate_chapters, season_folder_format, episode_naming_format, auto_add_missing, is_private, owner_user_id, sort_order, icon, created_at, updated_at FROM tv_libraries WHERE id = $1
`

// TV Libraries queries
func (q *Queries) GetTVLibraryByID(ctx context.Context, id uuid.UUID) (TvLibrary, error) {
	row := q.db.QueryRow(ctx, getTVLibraryByID, id)
	var i TvLibrary
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Paths,
		&i.ScanEnabled,
		&i.ScanIntervalHours,
		&i.LastScanAt,
		&i.LastScanDuration,
		&i.PreferredLanguage,
		&i.TmdbEnabled,
		&i.TvdbEnabled,
		&i.DownloadBackdrops,
		&i.DownloadNfo,
		&i.GenerateChapters,
		&i.SeasonFolderFormat,
		&i.EpisodeNamingFormat,
		&i.AutoAddMissing,
		&i.IsPrivate,
		&i.OwnerUserID,
		&i.SortOrder,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const grantTVLibraryAccess = `-- name: GrantTVLibraryAccess :exec
INSERT INTO tv_library_access (library_id, user_id, can_manage)
VALUES ($1, $2, $3)
ON CONFLICT (library_id, user_id)
DO UPDATE SET can_manage = EXCLUDED.can_manage
`

type GrantTVLibraryAccessParams struct {
	LibraryID uuid.UUID `json:"libraryId"`
	UserID    uuid.UUID `json:"userId"`
	CanManage bool      `json:"canManage"`
}

func (q *Queries) GrantTVLibraryAccess(ctx context.Context, arg GrantTVLibraryAccessParams) error {
	_, err := q.db.Exec(ctx, grantTVLibraryAccess, arg.LibraryID, arg.UserID, arg.CanManage)
	return err
}

const hasTVLibraryAccess = `-- name: HasTVLibraryAccess :one
SELECT EXISTS(
    SELECT 1 FROM tv_library_access
    WHERE library_id = $1 AND user_id = $2
) AS has_access
`

type HasTVLibraryAccessParams struct {
	LibraryID uuid.UUID `json:"libraryId"`
	UserID    uuid.UUID `json:"userId"`
}

func (q *Queries) HasTVLibraryAccess(ctx context.Context, arg HasTVLibraryAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasTVLibraryAccess, arg.LibraryID, arg.UserID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const listAccessibleTVLibraries = `-- name: ListAccessibleTVLibraries :many
SELECT tl.id, tl.name, tl.paths, tl.scan_enabled, tl.scan_interval_hours, tl.last_scan_at, tl.last_scan_duration, tl.preferred_language, tl.tmdb_enabled, tl.tvdb_enabled, tl.download_backdrops, tl.download_nfo, tl.generate_chapters, tl.season_folder_format, tl.episode_naming_format, tl.auto_add_missing, tl.is_private, tl.owner_user_id, tl.sort_order, tl.icon, tl.created_at, tl.updated_at FROM tv_libraries tl
LEFT JOIN tv_library_access tla ON tla.library_id = tl.id AND tla.user_id = $1
WHERE tl.is_private = false
   OR tl.owner_user_id = $1
   OR tla.user_id IS NOT NULL
ORDER BY tl.sort_order, tl.name
`

func (q *Queries) ListAccessibleTVLibraries(ctx context.Context, userID uuid.UUID) ([]TvLibrary, error) {
	rows, err := q.db.Query(ctx, listAccessibleTVLibraries, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvLibrary{}
	for rows.Next() {
		var i TvLibrary
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Paths,
			&i.ScanEnabled,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.LastScanDuration,
			&i.PreferredLanguage,
			&i.TmdbEnabled,
			&i.TvdbEnabled,
			&i.DownloadBackdrops,
			&i.DownloadNfo,
			&i.GenerateChapters,
			&i.SeasonFolderFormat,
			&i.EpisodeNamingFormat,
			&i.AutoAddMissing,
			&i.IsPrivate,
			&i.OwnerUserID,
			&i.SortOrder,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTVLibraries = `-- name: ListTVLibraries :many
SELECT id, name, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, tmdb_enabled, tvdb_enabled, download_backdrops, download_nfo, generate_chapters, season_folder_format, episode_naming_format, auto_add_missing, is_private, owner_user_id, sort_order, icon, created_at, updated_at FROM tv_libraries
ORDER BY sort_order, name
LIMIT $1 OFFSET $2
`

type ListTVLibrariesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTVLibraries(ctx context.Context, arg ListTVLibrariesParams) ([]TvLibrary, error) {
	rows, err := q.db.Query(ctx, listTVLibraries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvLibrary{}
	for rows.Next() {
		var i TvLibrary
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Paths,
			&i.ScanEnabled,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.LastScanDuration,
			&i.PreferredLanguage,
			&i.TmdbEnabled,
			&i.TvdbEnabled,
			&i.DownloadBackdrops,
			&i.DownloadNfo,
			&i.GenerateChapters,
			&i.SeasonFolderFormat,
			&i.EpisodeNamingFormat,
			&i.AutoAddMissing,
			&i.IsPrivate,
			&i.OwnerUserID,
			&i.SortOrder,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTVLibrariesByOwner = `-- name: ListTVLibrariesByOwner :many
SELECT id, name, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, tmdb_enabled, tvdb_enabled, download_backdrops, download_nfo, generate_chapters, season_folder_format, episode_naming_format, auto_add_missing, is_private, owner_user_id, sort_order, icon, created_at, updated_at FROM tv_libraries
WHERE owner_user_id = $1
ORDER BY sort_order, name
`

func (q *Queries) ListTVLibrariesByOwner(ctx context.Context, ownerUserID pgtype.UUID) ([]TvLibrary, error) {
	rows, err := q.db.Query(ctx, listTVLibrariesByOwner, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvLibrary{}
	for rows.Next() {
		var i TvLibrary
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Paths,
			&i.ScanEnabled,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.LastScanDuration,
			&i.PreferredLanguage,
			&i.TmdbEnabled,
			&i.TvdbEnabled,
			&i.DownloadBackdrops,
			&i.DownloadNfo,
			&i.GenerateChapters,
			&i.SeasonFolderFormat,
			&i.EpisodeNamingFormat,
			&i.AutoAddMissing,
			&i.IsPrivate,
			&i.OwnerUserID,
			&i.SortOrder,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTVLibraryAccess = `-- name: ListTVLibraryAccess :many
SELECT library_id, user_id, can_manage FROM tv_library_access WHERE library_id = $1
`

func (q *Queries) ListTVLibraryAccess(ctx context.Context, libraryID uuid.UUID) ([]TvLibraryAccess, error) {
	rows, err := q.db.Query(ctx, listTVLibraryAccess, libraryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvLibraryAccess{}
	for rows.Next() {
		var i TvLibraryAccess
		if err := rows.Scan(&i.LibraryID, &i.UserID, &i.CanManage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeTVLibraryAccess = `-- name: RevokeTVLibraryAccess :exec
DELETE FROM tv_library_access WHERE library_id = $1 AND user_id = $2
`

type RevokeTVLibraryAccessParams struct {
	LibraryID uuid.UUID `json:"libraryId"`
	UserID    uuid.UUID `json:"userId"`
}

func (q *Queries) RevokeTVLibraryAccess(ctx context.Context, arg RevokeTVLibraryAccessParams) error {
	_, err := q.db.Exec(ctx, revokeTVLibraryAccess, arg.LibraryID, arg.UserID)
	return err
}

const updateTVLibrary = `-- name: UpdateTVLibrary :one
UPDATE tv_libraries
SET
    name = $2,
    paths = $3,
    scan_enabled = $4,
    scan_interval_hours = $5,
    preferred_language = $6,
    tmdb_enabled = $7,
    tvdb_enabled = $8,
    download_backdrops = $9,
    download_nfo = $10,
    generate_chapters = $11,
    season_folder_format = $12,
    episode_naming_format = $13,
    auto_add_missing = $14,
    is_private = $15,
    owner_user_id = $16,
    sort_order = $17,
    icon = $18
WHERE id = $1
RETURNING id, name, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, tmdb_enabled, tvdb_enabled, download_backdrops, download_nfo, generate_chapters, season_folder_format, episode_naming_format, auto_add_missing, is_private, owner_user_id, sort_order, icon, created_at, updated_at
`

type UpdateTVLibraryParams struct {
	ID                  uuid.UUID   `json:"id"`
	Name                string      `json:"name"`
	Paths               []string    `json:"paths"`
	ScanEnabled         bool        `json:"scanEnabled"`
	ScanIntervalHours   int32       `json:"scanIntervalHours"`
	PreferredLanguage   *string     `json:"preferredLanguage"`
	TmdbEnabled         bool        `json:"tmdbEnabled"`
	TvdbEnabled         bool        `json:"tvdbEnabled"`
	DownloadBackdrops   bool        `json:"downloadBackdrops"`
	DownloadNfo         bool        `json:"downloadNfo"`
	GenerateChapters    bool        `json:"generateChapters"`
	SeasonFolderFormat  *string     `json:"seasonFolderFormat"`
	EpisodeNamingFormat *string     `json:"episodeNamingFormat"`
	AutoAddMissing      bool        `json:"autoAddMissing"`
	IsPrivate           bool        `json:"isPrivate"`
	OwnerUserID         pgtype.UUID `json:"ownerUserId"`
	SortOrder           int32       `json:"sortOrder"`
	Icon                *string     `json:"icon"`
}

func (q *Queries) UpdateTVLibrary(ctx context.Context, arg UpdateTVLibraryParams) (TvLibrary, error) {
	row := q.db.QueryRow(ctx, updateTVLibrary,
		arg.ID,
		arg.Name,
		arg.Paths,
		arg.ScanEnabled,
		arg.ScanIntervalHours,
		arg.PreferredLanguage,
		arg.TmdbEnabled,
		arg.TvdbEnabled,
		arg.DownloadBackdrops,
		arg.DownloadNfo,
		arg.GenerateChapters,
		arg.SeasonFolderFormat,
		arg.EpisodeNamingFormat,
		arg.AutoAddMissing,
		arg.IsPrivate,
		arg.OwnerUserID,
		arg.SortOrder,
		arg.Icon,
	)
	var i TvLibrary
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Paths,
		&i.ScanEnabled,
		&i.ScanIntervalHours,
		&i.LastScanAt,
		&i.LastScanDuration,
		&i.PreferredLanguage,
		&i.TmdbEnabled,
		&i.TvdbEnabled,
		&i.DownloadBackdrops,
		&i.DownloadNfo,
		&i.GenerateChapters,
		&i.SeasonFolderFormat,
		&i.EpisodeNamingFormat,
		&i.AutoAddMissing,
		&i.IsPrivate,
		&i.OwnerUserID,
		&i.SortOrder,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTVLibraryScanStatus = `-- name: UpdateTVLibraryScanStatus :exec
UPDATE tv_libraries
SET
    last_scan_at = $2,
    last_scan_duration = $3
WHERE id = $1
`

type UpdateTVLibraryScanStatusParams struct {
	ID               uuid.UUID          `json:"id"`
	LastScanAt       pgtype.Timestamptz `json:"lastScanAt"`
	LastScanDuration pgtype.Interval    `json:"lastScanDuration"`
}

func (q *Queries) UpdateTVLibraryScanStatus(ctx context.Context, arg UpdateTVLibraryScanStatusParams) error {
	_, err := q.db.Exec(ctx, updateTVLibraryScanStatus, arg.ID, arg.LastScanAt, arg.LastScanDuration)
	return err
}
