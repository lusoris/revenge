// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_data.sql

package tvshowdb

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addSeriesFavorite = `-- name: AddSeriesFavorite :exec
INSERT INTO series_favorites (user_id, series_id)
VALUES ($1, $2)
ON CONFLICT (user_id, series_id) DO NOTHING
`

type AddSeriesFavoriteParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

func (q *Queries) AddSeriesFavorite(ctx context.Context, arg AddSeriesFavoriteParams) error {
	_, err := q.db.Exec(ctx, addSeriesFavorite, arg.UserID, arg.SeriesID)
	return err
}

const addSeriesToWatchlist = `-- name: AddSeriesToWatchlist :exec
INSERT INTO series_watchlist (user_id, series_id, sort_order)
VALUES ($1, $2, COALESCE($3, (SELECT COALESCE(MAX(sort_order), 0) + 1 FROM series_watchlist WHERE user_id = $1)))
ON CONFLICT (user_id, series_id) DO NOTHING
`

type AddSeriesToWatchlistParams struct {
	UserID   uuid.UUID   `json:"userId"`
	SeriesID uuid.UUID   `json:"seriesId"`
	Column3  interface{} `json:"column3"`
}

func (q *Queries) AddSeriesToWatchlist(ctx context.Context, arg AddSeriesToWatchlistParams) error {
	_, err := q.db.Exec(ctx, addSeriesToWatchlist, arg.UserID, arg.SeriesID, arg.Column3)
	return err
}

const countUserFavoriteSeries = `-- name: CountUserFavoriteSeries :one
SELECT COUNT(*) FROM series_favorites WHERE user_id = $1
`

func (q *Queries) CountUserFavoriteSeries(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserFavoriteSeries, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserSeriesWatchlist = `-- name: CountUserSeriesWatchlist :one
SELECT COUNT(*) FROM series_watchlist WHERE user_id = $1
`

func (q *Queries) CountUserSeriesWatchlist(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserSeriesWatchlist, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserWatchedEpisodes = `-- name: CountUserWatchedEpisodes :one
SELECT COUNT(DISTINCT episode_id) FROM episode_watch_history
WHERE user_id = $1 AND completed = true
`

func (q *Queries) CountUserWatchedEpisodes(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserWatchedEpisodes, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserWatchedEpisodesBySeries = `-- name: CountUserWatchedEpisodesBySeries :one
SELECT COUNT(DISTINCT ewh.episode_id) FROM episode_watch_history ewh
JOIN episodes e ON ewh.episode_id = e.id
WHERE ewh.user_id = $1 AND e.series_id = $2 AND ewh.completed = true
`

type CountUserWatchedEpisodesBySeriesParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

func (q *Queries) CountUserWatchedEpisodesBySeries(ctx context.Context, arg CountUserWatchedEpisodesBySeriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUserWatchedEpisodesBySeries, arg.UserID, arg.SeriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEpisodeWatchHistory = `-- name: CreateEpisodeWatchHistory :one
INSERT INTO episode_watch_history (
    user_id, profile_id, episode_id, position_ticks, duration_ticks,
    device_name, device_type, client_name, play_method
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, user_id, profile_id, episode_id, position_ticks, duration_ticks, played_percentage, completed, completed_at, device_name, device_type, client_name, play_method, started_at, last_updated_at
`

type CreateEpisodeWatchHistoryParams struct {
	UserID        uuid.UUID   `json:"userId"`
	ProfileID     pgtype.UUID `json:"profileId"`
	EpisodeID     uuid.UUID   `json:"episodeId"`
	PositionTicks int64       `json:"positionTicks"`
	DurationTicks *int64      `json:"durationTicks"`
	DeviceName    *string     `json:"deviceName"`
	DeviceType    *string     `json:"deviceType"`
	ClientName    *string     `json:"clientName"`
	PlayMethod    *string     `json:"playMethod"`
}

func (q *Queries) CreateEpisodeWatchHistory(ctx context.Context, arg CreateEpisodeWatchHistoryParams) (EpisodeWatchHistory, error) {
	row := q.db.QueryRow(ctx, createEpisodeWatchHistory,
		arg.UserID,
		arg.ProfileID,
		arg.EpisodeID,
		arg.PositionTicks,
		arg.DurationTicks,
		arg.DeviceName,
		arg.DeviceType,
		arg.ClientName,
		arg.PlayMethod,
	)
	var i EpisodeWatchHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProfileID,
		&i.EpisodeID,
		&i.PositionTicks,
		&i.DurationTicks,
		&i.PlayedPercentage,
		&i.Completed,
		&i.CompletedAt,
		&i.DeviceName,
		&i.DeviceType,
		&i.ClientName,
		&i.PlayMethod,
		&i.StartedAt,
		&i.LastUpdatedAt,
	)
	return i, err
}

const deleteEpisodeUserRating = `-- name: DeleteEpisodeUserRating :exec
DELETE FROM episode_user_ratings
WHERE user_id = $1 AND episode_id = $2
`

type DeleteEpisodeUserRatingParams struct {
	UserID    uuid.UUID `json:"userId"`
	EpisodeID uuid.UUID `json:"episodeId"`
}

func (q *Queries) DeleteEpisodeUserRating(ctx context.Context, arg DeleteEpisodeUserRatingParams) error {
	_, err := q.db.Exec(ctx, deleteEpisodeUserRating, arg.UserID, arg.EpisodeID)
	return err
}

const deleteEpisodeWatchHistory = `-- name: DeleteEpisodeWatchHistory :exec
DELETE FROM episode_watch_history WHERE id = $1
`

func (q *Queries) DeleteEpisodeWatchHistory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisodeWatchHistory, id)
	return err
}

const deleteSeriesUserRating = `-- name: DeleteSeriesUserRating :exec
DELETE FROM series_user_ratings
WHERE user_id = $1 AND series_id = $2
`

type DeleteSeriesUserRatingParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

func (q *Queries) DeleteSeriesUserRating(ctx context.Context, arg DeleteSeriesUserRatingParams) error {
	_, err := q.db.Exec(ctx, deleteSeriesUserRating, arg.UserID, arg.SeriesID)
	return err
}

const deleteSeriesWatchProgress = `-- name: DeleteSeriesWatchProgress :exec
DELETE FROM series_watch_progress
WHERE user_id = $1 AND series_id = $2
`

type DeleteSeriesWatchProgressParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

func (q *Queries) DeleteSeriesWatchProgress(ctx context.Context, arg DeleteSeriesWatchProgressParams) error {
	_, err := q.db.Exec(ctx, deleteSeriesWatchProgress, arg.UserID, arg.SeriesID)
	return err
}

const getAverageSeriesUserRating = `-- name: GetAverageSeriesUserRating :one
SELECT AVG(rating) as avg_rating, COUNT(*) as rating_count
FROM series_user_ratings
WHERE series_id = $1
`

type GetAverageSeriesUserRatingRow struct {
	AvgRating   float64 `json:"avgRating"`
	RatingCount int64   `json:"ratingCount"`
}

func (q *Queries) GetAverageSeriesUserRating(ctx context.Context, seriesID uuid.UUID) (GetAverageSeriesUserRatingRow, error) {
	row := q.db.QueryRow(ctx, getAverageSeriesUserRating, seriesID)
	var i GetAverageSeriesUserRatingRow
	err := row.Scan(&i.AvgRating, &i.RatingCount)
	return i, err
}

const getCompletedEpisodeWatchHistory = `-- name: GetCompletedEpisodeWatchHistory :many
SELECT id, user_id, profile_id, episode_id, position_ticks, duration_ticks, played_percentage, completed, completed_at, device_name, device_type, client_name, play_method, started_at, last_updated_at FROM episode_watch_history
WHERE user_id = $1 AND episode_id = $2 AND completed = true
ORDER BY completed_at DESC
`

type GetCompletedEpisodeWatchHistoryParams struct {
	UserID    uuid.UUID `json:"userId"`
	EpisodeID uuid.UUID `json:"episodeId"`
}

func (q *Queries) GetCompletedEpisodeWatchHistory(ctx context.Context, arg GetCompletedEpisodeWatchHistoryParams) ([]EpisodeWatchHistory, error) {
	rows, err := q.db.Query(ctx, getCompletedEpisodeWatchHistory, arg.UserID, arg.EpisodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EpisodeWatchHistory{}
	for rows.Next() {
		var i EpisodeWatchHistory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProfileID,
			&i.EpisodeID,
			&i.PositionTicks,
			&i.DurationTicks,
			&i.PlayedPercentage,
			&i.Completed,
			&i.CompletedAt,
			&i.DeviceName,
			&i.DeviceType,
			&i.ClientName,
			&i.PlayMethod,
			&i.StartedAt,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodeUserRating = `-- name: GetEpisodeUserRating :one

SELECT user_id, episode_id, rating, created_at, updated_at FROM episode_user_ratings
WHERE user_id = $1 AND episode_id = $2
`

type GetEpisodeUserRatingParams struct {
	UserID    uuid.UUID `json:"userId"`
	EpisodeID uuid.UUID `json:"episodeId"`
}

// Episode User Ratings
func (q *Queries) GetEpisodeUserRating(ctx context.Context, arg GetEpisodeUserRatingParams) (EpisodeUserRating, error) {
	row := q.db.QueryRow(ctx, getEpisodeUserRating, arg.UserID, arg.EpisodeID)
	var i EpisodeUserRating
	err := row.Scan(
		&i.UserID,
		&i.EpisodeID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEpisodeWatchHistory = `-- name: GetEpisodeWatchHistory :one

SELECT id, user_id, profile_id, episode_id, position_ticks, duration_ticks, played_percentage, completed, completed_at, device_name, device_type, client_name, play_method, started_at, last_updated_at FROM episode_watch_history
WHERE user_id = $1 AND episode_id = $2 AND completed = false
ORDER BY last_updated_at DESC
LIMIT 1
`

type GetEpisodeWatchHistoryParams struct {
	UserID    uuid.UUID `json:"userId"`
	EpisodeID uuid.UUID `json:"episodeId"`
}

// Episode Watch History
func (q *Queries) GetEpisodeWatchHistory(ctx context.Context, arg GetEpisodeWatchHistoryParams) (EpisodeWatchHistory, error) {
	row := q.db.QueryRow(ctx, getEpisodeWatchHistory, arg.UserID, arg.EpisodeID)
	var i EpisodeWatchHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProfileID,
		&i.EpisodeID,
		&i.PositionTicks,
		&i.DurationTicks,
		&i.PlayedPercentage,
		&i.Completed,
		&i.CompletedAt,
		&i.DeviceName,
		&i.DeviceType,
		&i.ClientName,
		&i.PlayMethod,
		&i.StartedAt,
		&i.LastUpdatedAt,
	)
	return i, err
}

const getSeriesExternalRatings = `-- name: GetSeriesExternalRatings :many

SELECT series_id, source, rating, vote_count, certified, last_updated FROM series_external_ratings
WHERE series_id = $1
`

// Series External Ratings
func (q *Queries) GetSeriesExternalRatings(ctx context.Context, seriesID uuid.UUID) ([]SeriesExternalRating, error) {
	rows, err := q.db.Query(ctx, getSeriesExternalRatings, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SeriesExternalRating{}
	for rows.Next() {
		var i SeriesExternalRating
		if err := rows.Scan(
			&i.SeriesID,
			&i.Source,
			&i.Rating,
			&i.VoteCount,
			&i.Certified,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeriesUserRating = `-- name: GetSeriesUserRating :one


SELECT user_id, series_id, rating, review, created_at, updated_at FROM series_user_ratings
WHERE user_id = $1 AND series_id = $2
`

type GetSeriesUserRatingParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

// TV Show User Data Queries
// Series User Ratings
func (q *Queries) GetSeriesUserRating(ctx context.Context, arg GetSeriesUserRatingParams) (SeriesUserRating, error) {
	row := q.db.QueryRow(ctx, getSeriesUserRating, arg.UserID, arg.SeriesID)
	var i SeriesUserRating
	err := row.Scan(
		&i.UserID,
		&i.SeriesID,
		&i.Rating,
		&i.Review,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeriesWatchProgress = `-- name: GetSeriesWatchProgress :one

SELECT user_id, series_id, last_episode_id, last_season_number, last_episode_number, total_episodes, watched_episodes, progress_percentage, is_watching, started_at, last_watched_at, completed_at FROM series_watch_progress
WHERE user_id = $1 AND series_id = $2
`

type GetSeriesWatchProgressParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

// Series Watch Progress (Continue Watching)
func (q *Queries) GetSeriesWatchProgress(ctx context.Context, arg GetSeriesWatchProgressParams) (SeriesWatchProgress, error) {
	row := q.db.QueryRow(ctx, getSeriesWatchProgress, arg.UserID, arg.SeriesID)
	var i SeriesWatchProgress
	err := row.Scan(
		&i.UserID,
		&i.SeriesID,
		&i.LastEpisodeID,
		&i.LastSeasonNumber,
		&i.LastEpisodeNumber,
		&i.TotalEpisodes,
		&i.WatchedEpisodes,
		&i.ProgressPercentage,
		&i.IsWatching,
		&i.StartedAt,
		&i.LastWatchedAt,
		&i.CompletedAt,
	)
	return i, err
}

const isEpisodeWatched = `-- name: IsEpisodeWatched :one
SELECT EXISTS(
    SELECT 1 FROM episode_watch_history
    WHERE user_id = $1 AND episode_id = $2 AND completed = true
)
`

type IsEpisodeWatchedParams struct {
	UserID    uuid.UUID `json:"userId"`
	EpisodeID uuid.UUID `json:"episodeId"`
}

func (q *Queries) IsEpisodeWatched(ctx context.Context, arg IsEpisodeWatchedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isEpisodeWatched, arg.UserID, arg.EpisodeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isSeriesFavorite = `-- name: IsSeriesFavorite :one

SELECT EXISTS(
    SELECT 1 FROM series_favorites
    WHERE user_id = $1 AND series_id = $2
)
`

type IsSeriesFavoriteParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

// Series Favorites
func (q *Queries) IsSeriesFavorite(ctx context.Context, arg IsSeriesFavoriteParams) (bool, error) {
	row := q.db.QueryRow(ctx, isSeriesFavorite, arg.UserID, arg.SeriesID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isSeriesInWatchlist = `-- name: IsSeriesInWatchlist :one

SELECT EXISTS(
    SELECT 1 FROM series_watchlist
    WHERE user_id = $1 AND series_id = $2
)
`

type IsSeriesInWatchlistParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

// Series Watchlist
func (q *Queries) IsSeriesInWatchlist(ctx context.Context, arg IsSeriesInWatchlistParams) (bool, error) {
	row := q.db.QueryRow(ctx, isSeriesInWatchlist, arg.UserID, arg.SeriesID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listCompletedSeries = `-- name: ListCompletedSeries :many
SELECT swp.user_id, swp.series_id, swp.last_episode_id, swp.last_season_number, swp.last_episode_number, swp.total_episodes, swp.watched_episodes, swp.progress_percentage, swp.is_watching, swp.started_at, swp.last_watched_at, swp.completed_at, s.title, s.poster_path
FROM series_watch_progress swp
JOIN series s ON swp.series_id = s.id
WHERE swp.user_id = $1
  AND swp.completed_at IS NOT NULL
ORDER BY swp.completed_at DESC
LIMIT $2 OFFSET $3
`

type ListCompletedSeriesParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListCompletedSeriesRow struct {
	UserID             uuid.UUID          `json:"userId"`
	SeriesID           uuid.UUID          `json:"seriesId"`
	LastEpisodeID      pgtype.UUID        `json:"lastEpisodeId"`
	LastSeasonNumber   *int32             `json:"lastSeasonNumber"`
	LastEpisodeNumber  *int32             `json:"lastEpisodeNumber"`
	TotalEpisodes      int32              `json:"totalEpisodes"`
	WatchedEpisodes    int32              `json:"watchedEpisodes"`
	ProgressPercentage pgtype.Numeric     `json:"progressPercentage"`
	IsWatching         bool               `json:"isWatching"`
	StartedAt          pgtype.Timestamptz `json:"startedAt"`
	LastWatchedAt      pgtype.Timestamptz `json:"lastWatchedAt"`
	CompletedAt        pgtype.Timestamptz `json:"completedAt"`
	Title              string             `json:"title"`
	PosterPath         *string            `json:"posterPath"`
}

func (q *Queries) ListCompletedSeries(ctx context.Context, arg ListCompletedSeriesParams) ([]ListCompletedSeriesRow, error) {
	rows, err := q.db.Query(ctx, listCompletedSeries, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCompletedSeriesRow{}
	for rows.Next() {
		var i ListCompletedSeriesRow
		if err := rows.Scan(
			&i.UserID,
			&i.SeriesID,
			&i.LastEpisodeID,
			&i.LastSeasonNumber,
			&i.LastEpisodeNumber,
			&i.TotalEpisodes,
			&i.WatchedEpisodes,
			&i.ProgressPercentage,
			&i.IsWatching,
			&i.StartedAt,
			&i.LastWatchedAt,
			&i.CompletedAt,
			&i.Title,
			&i.PosterPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContinueWatchingSeries = `-- name: ListContinueWatchingSeries :many
SELECT swp.user_id, swp.series_id, swp.last_episode_id, swp.last_season_number, swp.last_episode_number, swp.total_episodes, swp.watched_episodes, swp.progress_percentage, swp.is_watching, swp.started_at, swp.last_watched_at, swp.completed_at, s.title, s.poster_path, s.backdrop_path,
       e.id as next_episode_id, e.title as next_episode_title,
       e.season_number as next_season, e.episode_number as next_episode,
       e.still_path as next_episode_still
FROM series_watch_progress swp
JOIN series s ON swp.series_id = s.id
LEFT JOIN episodes e ON e.id = swp.last_episode_id
WHERE swp.user_id = $1
  AND swp.is_watching = true
  AND swp.last_watched_at > NOW() - INTERVAL '30 days'  -- Only show recent activity
ORDER BY swp.last_watched_at DESC
LIMIT $2
`

type ListContinueWatchingSeriesParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
}

type ListContinueWatchingSeriesRow struct {
	UserID             uuid.UUID          `json:"userId"`
	SeriesID           uuid.UUID          `json:"seriesId"`
	LastEpisodeID      pgtype.UUID        `json:"lastEpisodeId"`
	LastSeasonNumber   *int32             `json:"lastSeasonNumber"`
	LastEpisodeNumber  *int32             `json:"lastEpisodeNumber"`
	TotalEpisodes      int32              `json:"totalEpisodes"`
	WatchedEpisodes    int32              `json:"watchedEpisodes"`
	ProgressPercentage pgtype.Numeric     `json:"progressPercentage"`
	IsWatching         bool               `json:"isWatching"`
	StartedAt          pgtype.Timestamptz `json:"startedAt"`
	LastWatchedAt      pgtype.Timestamptz `json:"lastWatchedAt"`
	CompletedAt        pgtype.Timestamptz `json:"completedAt"`
	Title              string             `json:"title"`
	PosterPath         *string            `json:"posterPath"`
	BackdropPath       *string            `json:"backdropPath"`
	NextEpisodeID      pgtype.UUID        `json:"nextEpisodeId"`
	NextEpisodeTitle   *string            `json:"nextEpisodeTitle"`
	NextSeason         *int32             `json:"nextSeason"`
	NextEpisode        *int32             `json:"nextEpisode"`
	NextEpisodeStill   *string            `json:"nextEpisodeStill"`
}

func (q *Queries) ListContinueWatchingSeries(ctx context.Context, arg ListContinueWatchingSeriesParams) ([]ListContinueWatchingSeriesRow, error) {
	rows, err := q.db.Query(ctx, listContinueWatchingSeries, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContinueWatchingSeriesRow{}
	for rows.Next() {
		var i ListContinueWatchingSeriesRow
		if err := rows.Scan(
			&i.UserID,
			&i.SeriesID,
			&i.LastEpisodeID,
			&i.LastSeasonNumber,
			&i.LastEpisodeNumber,
			&i.TotalEpisodes,
			&i.WatchedEpisodes,
			&i.ProgressPercentage,
			&i.IsWatching,
			&i.StartedAt,
			&i.LastWatchedAt,
			&i.CompletedAt,
			&i.Title,
			&i.PosterPath,
			&i.BackdropPath,
			&i.NextEpisodeID,
			&i.NextEpisodeTitle,
			&i.NextSeason,
			&i.NextEpisode,
			&i.NextEpisodeStill,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResumeableEpisodes = `-- name: ListResumeableEpisodes :many
SELECT ewh.id, ewh.user_id, ewh.profile_id, ewh.episode_id, ewh.position_ticks, ewh.duration_ticks, ewh.played_percentage, ewh.completed, ewh.completed_at, ewh.device_name, ewh.device_type, ewh.client_name, ewh.play_method, ewh.started_at, ewh.last_updated_at, e.title as episode_title, e.season_number, e.episode_number, e.runtime_ticks, e.still_path,
       s.id as series_id, s.title as series_title, s.poster_path as series_poster
FROM episode_watch_history ewh
JOIN episodes e ON ewh.episode_id = e.id
JOIN series s ON e.series_id = s.id
WHERE ewh.user_id = $1
  AND ewh.completed = false
  AND ewh.played_percentage > 5
  AND ewh.played_percentage < 90
  AND ewh.last_updated_at > NOW() - INTERVAL '30 days'  -- Only show recent activity
ORDER BY ewh.last_updated_at DESC
LIMIT $2
`

type ListResumeableEpisodesParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
}

type ListResumeableEpisodesRow struct {
	ID               uuid.UUID          `json:"id"`
	UserID           uuid.UUID          `json:"userId"`
	ProfileID        pgtype.UUID        `json:"profileId"`
	EpisodeID        uuid.UUID          `json:"episodeId"`
	PositionTicks    int64              `json:"positionTicks"`
	DurationTicks    *int64             `json:"durationTicks"`
	PlayedPercentage pgtype.Numeric     `json:"playedPercentage"`
	Completed        bool               `json:"completed"`
	CompletedAt      pgtype.Timestamptz `json:"completedAt"`
	DeviceName       *string            `json:"deviceName"`
	DeviceType       *string            `json:"deviceType"`
	ClientName       *string            `json:"clientName"`
	PlayMethod       *string            `json:"playMethod"`
	StartedAt        time.Time          `json:"startedAt"`
	LastUpdatedAt    time.Time          `json:"lastUpdatedAt"`
	EpisodeTitle     string             `json:"episodeTitle"`
	SeasonNumber     int32              `json:"seasonNumber"`
	EpisodeNumber    int32              `json:"episodeNumber"`
	RuntimeTicks     *int64             `json:"runtimeTicks"`
	StillPath        *string            `json:"stillPath"`
	SeriesID         uuid.UUID          `json:"seriesId"`
	SeriesTitle      string             `json:"seriesTitle"`
	SeriesPoster     *string            `json:"seriesPoster"`
}

func (q *Queries) ListResumeableEpisodes(ctx context.Context, arg ListResumeableEpisodesParams) ([]ListResumeableEpisodesRow, error) {
	rows, err := q.db.Query(ctx, listResumeableEpisodes, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListResumeableEpisodesRow{}
	for rows.Next() {
		var i ListResumeableEpisodesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProfileID,
			&i.EpisodeID,
			&i.PositionTicks,
			&i.DurationTicks,
			&i.PlayedPercentage,
			&i.Completed,
			&i.CompletedAt,
			&i.DeviceName,
			&i.DeviceType,
			&i.ClientName,
			&i.PlayMethod,
			&i.StartedAt,
			&i.LastUpdatedAt,
			&i.EpisodeTitle,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.RuntimeTicks,
			&i.StillPath,
			&i.SeriesID,
			&i.SeriesTitle,
			&i.SeriesPoster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserEpisodeWatchHistory = `-- name: ListUserEpisodeWatchHistory :many
SELECT ewh.id, ewh.user_id, ewh.profile_id, ewh.episode_id, ewh.position_ticks, ewh.duration_ticks, ewh.played_percentage, ewh.completed, ewh.completed_at, ewh.device_name, ewh.device_type, ewh.client_name, ewh.play_method, ewh.started_at, ewh.last_updated_at, e.title as episode_title, e.season_number, e.episode_number, e.runtime_ticks,
       s.id as series_id, s.title as series_title, s.poster_path as series_poster
FROM episode_watch_history ewh
JOIN episodes e ON ewh.episode_id = e.id
JOIN series s ON e.series_id = s.id
WHERE ewh.user_id = $1
ORDER BY ewh.last_updated_at DESC
LIMIT $2 OFFSET $3
`

type ListUserEpisodeWatchHistoryParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListUserEpisodeWatchHistoryRow struct {
	ID               uuid.UUID          `json:"id"`
	UserID           uuid.UUID          `json:"userId"`
	ProfileID        pgtype.UUID        `json:"profileId"`
	EpisodeID        uuid.UUID          `json:"episodeId"`
	PositionTicks    int64              `json:"positionTicks"`
	DurationTicks    *int64             `json:"durationTicks"`
	PlayedPercentage pgtype.Numeric     `json:"playedPercentage"`
	Completed        bool               `json:"completed"`
	CompletedAt      pgtype.Timestamptz `json:"completedAt"`
	DeviceName       *string            `json:"deviceName"`
	DeviceType       *string            `json:"deviceType"`
	ClientName       *string            `json:"clientName"`
	PlayMethod       *string            `json:"playMethod"`
	StartedAt        time.Time          `json:"startedAt"`
	LastUpdatedAt    time.Time          `json:"lastUpdatedAt"`
	EpisodeTitle     string             `json:"episodeTitle"`
	SeasonNumber     int32              `json:"seasonNumber"`
	EpisodeNumber    int32              `json:"episodeNumber"`
	RuntimeTicks     *int64             `json:"runtimeTicks"`
	SeriesID         uuid.UUID          `json:"seriesId"`
	SeriesTitle      string             `json:"seriesTitle"`
	SeriesPoster     *string            `json:"seriesPoster"`
}

func (q *Queries) ListUserEpisodeWatchHistory(ctx context.Context, arg ListUserEpisodeWatchHistoryParams) ([]ListUserEpisodeWatchHistoryRow, error) {
	rows, err := q.db.Query(ctx, listUserEpisodeWatchHistory, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserEpisodeWatchHistoryRow{}
	for rows.Next() {
		var i ListUserEpisodeWatchHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProfileID,
			&i.EpisodeID,
			&i.PositionTicks,
			&i.DurationTicks,
			&i.PlayedPercentage,
			&i.Completed,
			&i.CompletedAt,
			&i.DeviceName,
			&i.DeviceType,
			&i.ClientName,
			&i.PlayMethod,
			&i.StartedAt,
			&i.LastUpdatedAt,
			&i.EpisodeTitle,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.RuntimeTicks,
			&i.SeriesID,
			&i.SeriesTitle,
			&i.SeriesPoster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserFavoriteSeries = `-- name: ListUserFavoriteSeries :many
SELECT s.id, s.title, s.sort_title, s.original_title, s.tagline, s.overview, s.first_air_date, s.last_air_date, s.year, s.status, s.type, s.content_rating, s.rating_level, s.community_rating, s.vote_count, s.season_count, s.episode_count, s.special_count, s.poster_path, s.poster_blurhash, s.backdrop_path, s.backdrop_blurhash, s.logo_path, s.tmdb_id, s.imdb_id, s.tvdb_id, s.network_name, s.network_logo_path, s.date_added, s.last_played_at, s.is_locked, s.created_at, s.updated_at, s.tv_library_id FROM series s
JOIN series_favorites sf ON s.id = sf.series_id
WHERE sf.user_id = $1
ORDER BY sf.created_at DESC
LIMIT $2 OFFSET $3
`

type ListUserFavoriteSeriesParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListUserFavoriteSeries(ctx context.Context, arg ListUserFavoriteSeriesParams) ([]Series, error) {
	rows, err := q.db.Query(ctx, listUserFavoriteSeries, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.Year,
			&i.Status,
			&i.Type,
			&i.ContentRating,
			&i.RatingLevel,
			&i.CommunityRating,
			&i.VoteCount,
			&i.SeasonCount,
			&i.EpisodeCount,
			&i.SpecialCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.NetworkName,
			&i.NetworkLogoPath,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TvLibraryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSeriesRatings = `-- name: ListUserSeriesRatings :many
SELECT sur.user_id, sur.series_id, sur.rating, sur.review, sur.created_at, sur.updated_at, s.title, s.poster_path
FROM series_user_ratings sur
JOIN series s ON sur.series_id = s.id
WHERE sur.user_id = $1
ORDER BY sur.updated_at DESC
LIMIT $2 OFFSET $3
`

type ListUserSeriesRatingsParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListUserSeriesRatingsRow struct {
	UserID     uuid.UUID      `json:"userId"`
	SeriesID   uuid.UUID      `json:"seriesId"`
	Rating     pgtype.Numeric `json:"rating"`
	Review     *string        `json:"review"`
	CreatedAt  time.Time      `json:"createdAt"`
	UpdatedAt  time.Time      `json:"updatedAt"`
	Title      string         `json:"title"`
	PosterPath *string        `json:"posterPath"`
}

func (q *Queries) ListUserSeriesRatings(ctx context.Context, arg ListUserSeriesRatingsParams) ([]ListUserSeriesRatingsRow, error) {
	rows, err := q.db.Query(ctx, listUserSeriesRatings, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSeriesRatingsRow{}
	for rows.Next() {
		var i ListUserSeriesRatingsRow
		if err := rows.Scan(
			&i.UserID,
			&i.SeriesID,
			&i.Rating,
			&i.Review,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.PosterPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSeriesWatchlist = `-- name: ListUserSeriesWatchlist :many
SELECT s.id, s.title, s.sort_title, s.original_title, s.tagline, s.overview, s.first_air_date, s.last_air_date, s.year, s.status, s.type, s.content_rating, s.rating_level, s.community_rating, s.vote_count, s.season_count, s.episode_count, s.special_count, s.poster_path, s.poster_blurhash, s.backdrop_path, s.backdrop_blurhash, s.logo_path, s.tmdb_id, s.imdb_id, s.tvdb_id, s.network_name, s.network_logo_path, s.date_added, s.last_played_at, s.is_locked, s.created_at, s.updated_at, s.tv_library_id FROM series s
JOIN series_watchlist sw ON s.id = sw.series_id
WHERE sw.user_id = $1
ORDER BY sw.sort_order ASC, sw.added_at DESC
LIMIT $2 OFFSET $3
`

type ListUserSeriesWatchlistParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListUserSeriesWatchlist(ctx context.Context, arg ListUserSeriesWatchlistParams) ([]Series, error) {
	rows, err := q.db.Query(ctx, listUserSeriesWatchlist, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.Year,
			&i.Status,
			&i.Type,
			&i.ContentRating,
			&i.RatingLevel,
			&i.CommunityRating,
			&i.VoteCount,
			&i.SeasonCount,
			&i.EpisodeCount,
			&i.SpecialCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.NetworkName,
			&i.NetworkLogoPath,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TvLibraryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEpisodeWatchHistoryCompleted = `-- name: MarkEpisodeWatchHistoryCompleted :exec
UPDATE episode_watch_history SET
    completed = true,
    completed_at = NOW(),
    position_ticks = COALESCE(duration_ticks, position_ticks)
WHERE id = $1
`

func (q *Queries) MarkEpisodeWatchHistoryCompleted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markEpisodeWatchHistoryCompleted, id)
	return err
}

const removeSeriesFavorite = `-- name: RemoveSeriesFavorite :exec
DELETE FROM series_favorites
WHERE user_id = $1 AND series_id = $2
`

type RemoveSeriesFavoriteParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

func (q *Queries) RemoveSeriesFavorite(ctx context.Context, arg RemoveSeriesFavoriteParams) error {
	_, err := q.db.Exec(ctx, removeSeriesFavorite, arg.UserID, arg.SeriesID)
	return err
}

const removeSeriesFromWatchlist = `-- name: RemoveSeriesFromWatchlist :exec
DELETE FROM series_watchlist
WHERE user_id = $1 AND series_id = $2
`

type RemoveSeriesFromWatchlistParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

func (q *Queries) RemoveSeriesFromWatchlist(ctx context.Context, arg RemoveSeriesFromWatchlistParams) error {
	_, err := q.db.Exec(ctx, removeSeriesFromWatchlist, arg.UserID, arg.SeriesID)
	return err
}

const reorderSeriesWatchlist = `-- name: ReorderSeriesWatchlist :exec
UPDATE series_watchlist SET sort_order = $3
WHERE user_id = $1 AND series_id = $2
`

type ReorderSeriesWatchlistParams struct {
	UserID    uuid.UUID `json:"userId"`
	SeriesID  uuid.UUID `json:"seriesId"`
	SortOrder *int32    `json:"sortOrder"`
}

func (q *Queries) ReorderSeriesWatchlist(ctx context.Context, arg ReorderSeriesWatchlistParams) error {
	_, err := q.db.Exec(ctx, reorderSeriesWatchlist, arg.UserID, arg.SeriesID, arg.SortOrder)
	return err
}

const setEpisodeUserRating = `-- name: SetEpisodeUserRating :one
INSERT INTO episode_user_ratings (user_id, episode_id, rating)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, episode_id) DO UPDATE SET
    rating = $3,
    updated_at = NOW()
RETURNING user_id, episode_id, rating, created_at, updated_at
`

type SetEpisodeUserRatingParams struct {
	UserID    uuid.UUID      `json:"userId"`
	EpisodeID uuid.UUID      `json:"episodeId"`
	Rating    pgtype.Numeric `json:"rating"`
}

func (q *Queries) SetEpisodeUserRating(ctx context.Context, arg SetEpisodeUserRatingParams) (EpisodeUserRating, error) {
	row := q.db.QueryRow(ctx, setEpisodeUserRating, arg.UserID, arg.EpisodeID, arg.Rating)
	var i EpisodeUserRating
	err := row.Scan(
		&i.UserID,
		&i.EpisodeID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setSeriesUserRating = `-- name: SetSeriesUserRating :one
INSERT INTO series_user_ratings (user_id, series_id, rating, review)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, series_id) DO UPDATE SET
    rating = $3,
    review = COALESCE($4, series_user_ratings.review),
    updated_at = NOW()
RETURNING user_id, series_id, rating, review, created_at, updated_at
`

type SetSeriesUserRatingParams struct {
	UserID   uuid.UUID      `json:"userId"`
	SeriesID uuid.UUID      `json:"seriesId"`
	Rating   pgtype.Numeric `json:"rating"`
	Review   *string        `json:"review"`
}

func (q *Queries) SetSeriesUserRating(ctx context.Context, arg SetSeriesUserRatingParams) (SeriesUserRating, error) {
	row := q.db.QueryRow(ctx, setSeriesUserRating,
		arg.UserID,
		arg.SeriesID,
		arg.Rating,
		arg.Review,
	)
	var i SeriesUserRating
	err := row.Scan(
		&i.UserID,
		&i.SeriesID,
		&i.Rating,
		&i.Review,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEpisodeWatchHistory = `-- name: UpdateEpisodeWatchHistory :one
UPDATE episode_watch_history SET
    position_ticks = $2,
    duration_ticks = COALESCE($3, duration_ticks),
    last_updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, profile_id, episode_id, position_ticks, duration_ticks, played_percentage, completed, completed_at, device_name, device_type, client_name, play_method, started_at, last_updated_at
`

type UpdateEpisodeWatchHistoryParams struct {
	ID            uuid.UUID `json:"id"`
	PositionTicks int64     `json:"positionTicks"`
	DurationTicks *int64    `json:"durationTicks"`
}

func (q *Queries) UpdateEpisodeWatchHistory(ctx context.Context, arg UpdateEpisodeWatchHistoryParams) (EpisodeWatchHistory, error) {
	row := q.db.QueryRow(ctx, updateEpisodeWatchHistory, arg.ID, arg.PositionTicks, arg.DurationTicks)
	var i EpisodeWatchHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProfileID,
		&i.EpisodeID,
		&i.PositionTicks,
		&i.DurationTicks,
		&i.PlayedPercentage,
		&i.Completed,
		&i.CompletedAt,
		&i.DeviceName,
		&i.DeviceType,
		&i.ClientName,
		&i.PlayMethod,
		&i.StartedAt,
		&i.LastUpdatedAt,
	)
	return i, err
}

const updateSeriesWatchProgress = `-- name: UpdateSeriesWatchProgress :one
INSERT INTO series_watch_progress (
    user_id, series_id, last_episode_id, last_season_number, last_episode_number,
    total_episodes, watched_episodes, is_watching, started_at, last_watched_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
ON CONFLICT (user_id, series_id) DO UPDATE SET
    last_episode_id = EXCLUDED.last_episode_id,
    last_season_number = EXCLUDED.last_season_number,
    last_episode_number = EXCLUDED.last_episode_number,
    total_episodes = EXCLUDED.total_episodes,
    watched_episodes = EXCLUDED.watched_episodes,
    is_watching = EXCLUDED.is_watching,
    last_watched_at = NOW()
RETURNING user_id, series_id, last_episode_id, last_season_number, last_episode_number, total_episodes, watched_episodes, progress_percentage, is_watching, started_at, last_watched_at, completed_at
`

type UpdateSeriesWatchProgressParams struct {
	UserID            uuid.UUID          `json:"userId"`
	SeriesID          uuid.UUID          `json:"seriesId"`
	LastEpisodeID     pgtype.UUID        `json:"lastEpisodeId"`
	LastSeasonNumber  *int32             `json:"lastSeasonNumber"`
	LastEpisodeNumber *int32             `json:"lastEpisodeNumber"`
	TotalEpisodes     int32              `json:"totalEpisodes"`
	WatchedEpisodes   int32              `json:"watchedEpisodes"`
	IsWatching        bool               `json:"isWatching"`
	StartedAt         pgtype.Timestamptz `json:"startedAt"`
}

func (q *Queries) UpdateSeriesWatchProgress(ctx context.Context, arg UpdateSeriesWatchProgressParams) (SeriesWatchProgress, error) {
	row := q.db.QueryRow(ctx, updateSeriesWatchProgress,
		arg.UserID,
		arg.SeriesID,
		arg.LastEpisodeID,
		arg.LastSeasonNumber,
		arg.LastEpisodeNumber,
		arg.TotalEpisodes,
		arg.WatchedEpisodes,
		arg.IsWatching,
		arg.StartedAt,
	)
	var i SeriesWatchProgress
	err := row.Scan(
		&i.UserID,
		&i.SeriesID,
		&i.LastEpisodeID,
		&i.LastSeasonNumber,
		&i.LastEpisodeNumber,
		&i.TotalEpisodes,
		&i.WatchedEpisodes,
		&i.ProgressPercentage,
		&i.IsWatching,
		&i.StartedAt,
		&i.LastWatchedAt,
		&i.CompletedAt,
	)
	return i, err
}

const upsertSeriesExternalRating = `-- name: UpsertSeriesExternalRating :exec
INSERT INTO series_external_ratings (series_id, source, rating, vote_count, certified)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (series_id, source) DO UPDATE SET
    rating = $3,
    vote_count = $4,
    certified = $5,
    last_updated = NOW()
`

type UpsertSeriesExternalRatingParams struct {
	SeriesID  uuid.UUID      `json:"seriesId"`
	Source    string         `json:"source"`
	Rating    pgtype.Numeric `json:"rating"`
	VoteCount *int32         `json:"voteCount"`
	Certified *bool          `json:"certified"`
}

func (q *Queries) UpsertSeriesExternalRating(ctx context.Context, arg UpsertSeriesExternalRatingParams) error {
	_, err := q.db.Exec(ctx, upsertSeriesExternalRating,
		arg.SeriesID,
		arg.Source,
		arg.Rating,
		arg.VoteCount,
		arg.Certified,
	)
	return err
}
