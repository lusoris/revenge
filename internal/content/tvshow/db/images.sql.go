// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: images.sql

package tvshowdb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEpisodeImage = `-- name: CreateEpisodeImage :one
INSERT INTO episode_images (
    episode_id, image_type, url, local_path,
    width, height, aspect_ratio,
    vote_average, vote_count, blurhash,
    provider, provider_id, is_primary
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, episode_id, image_type, url, local_path, width, height, aspect_ratio, vote_average, vote_count, blurhash, provider, provider_id, is_primary, created_at
`

type CreateEpisodeImageParams struct {
	EpisodeID   uuid.UUID      `json:"episodeId"`
	ImageType   string         `json:"imageType"`
	Url         string         `json:"url"`
	LocalPath   *string        `json:"localPath"`
	Width       *int32         `json:"width"`
	Height      *int32         `json:"height"`
	AspectRatio pgtype.Numeric `json:"aspectRatio"`
	VoteAverage pgtype.Numeric `json:"voteAverage"`
	VoteCount   *int32         `json:"voteCount"`
	Blurhash    *string        `json:"blurhash"`
	Provider    *string        `json:"provider"`
	ProviderID  *string        `json:"providerId"`
	IsPrimary   bool           `json:"isPrimary"`
}

func (q *Queries) CreateEpisodeImage(ctx context.Context, arg CreateEpisodeImageParams) (EpisodeImage, error) {
	row := q.db.QueryRow(ctx, createEpisodeImage,
		arg.EpisodeID,
		arg.ImageType,
		arg.Url,
		arg.LocalPath,
		arg.Width,
		arg.Height,
		arg.AspectRatio,
		arg.VoteAverage,
		arg.VoteCount,
		arg.Blurhash,
		arg.Provider,
		arg.ProviderID,
		arg.IsPrimary,
	)
	var i EpisodeImage
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.ImageType,
		&i.Url,
		&i.LocalPath,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Blurhash,
		&i.Provider,
		&i.ProviderID,
		&i.IsPrimary,
		&i.CreatedAt,
	)
	return i, err
}

const createSeasonImage = `-- name: CreateSeasonImage :one
INSERT INTO season_images (
    season_id, image_type, url, local_path,
    width, height, aspect_ratio,
    language, vote_average, vote_count, blurhash,
    provider, provider_id, is_primary
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id, season_id, image_type, url, local_path, width, height, aspect_ratio, language, vote_average, vote_count, blurhash, provider, provider_id, is_primary, created_at
`

type CreateSeasonImageParams struct {
	SeasonID    uuid.UUID      `json:"seasonId"`
	ImageType   string         `json:"imageType"`
	Url         string         `json:"url"`
	LocalPath   *string        `json:"localPath"`
	Width       *int32         `json:"width"`
	Height      *int32         `json:"height"`
	AspectRatio pgtype.Numeric `json:"aspectRatio"`
	Language    *string        `json:"language"`
	VoteAverage pgtype.Numeric `json:"voteAverage"`
	VoteCount   *int32         `json:"voteCount"`
	Blurhash    *string        `json:"blurhash"`
	Provider    *string        `json:"provider"`
	ProviderID  *string        `json:"providerId"`
	IsPrimary   bool           `json:"isPrimary"`
}

func (q *Queries) CreateSeasonImage(ctx context.Context, arg CreateSeasonImageParams) (SeasonImage, error) {
	row := q.db.QueryRow(ctx, createSeasonImage,
		arg.SeasonID,
		arg.ImageType,
		arg.Url,
		arg.LocalPath,
		arg.Width,
		arg.Height,
		arg.AspectRatio,
		arg.Language,
		arg.VoteAverage,
		arg.VoteCount,
		arg.Blurhash,
		arg.Provider,
		arg.ProviderID,
		arg.IsPrimary,
	)
	var i SeasonImage
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.ImageType,
		&i.Url,
		&i.LocalPath,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
		&i.Language,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Blurhash,
		&i.Provider,
		&i.ProviderID,
		&i.IsPrimary,
		&i.CreatedAt,
	)
	return i, err
}

const createSeriesImage = `-- name: CreateSeriesImage :one
INSERT INTO series_images (
    series_id, image_type, url, local_path,
    width, height, aspect_ratio,
    language, vote_average, vote_count, blurhash,
    provider, provider_id, is_primary
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id, series_id, image_type, url, local_path, width, height, aspect_ratio, language, vote_average, vote_count, blurhash, provider, provider_id, is_primary, created_at
`

type CreateSeriesImageParams struct {
	SeriesID    uuid.UUID      `json:"seriesId"`
	ImageType   string         `json:"imageType"`
	Url         string         `json:"url"`
	LocalPath   *string        `json:"localPath"`
	Width       *int32         `json:"width"`
	Height      *int32         `json:"height"`
	AspectRatio pgtype.Numeric `json:"aspectRatio"`
	Language    *string        `json:"language"`
	VoteAverage pgtype.Numeric `json:"voteAverage"`
	VoteCount   *int32         `json:"voteCount"`
	Blurhash    *string        `json:"blurhash"`
	Provider    *string        `json:"provider"`
	ProviderID  *string        `json:"providerId"`
	IsPrimary   bool           `json:"isPrimary"`
}

func (q *Queries) CreateSeriesImage(ctx context.Context, arg CreateSeriesImageParams) (SeriesImage, error) {
	row := q.db.QueryRow(ctx, createSeriesImage,
		arg.SeriesID,
		arg.ImageType,
		arg.Url,
		arg.LocalPath,
		arg.Width,
		arg.Height,
		arg.AspectRatio,
		arg.Language,
		arg.VoteAverage,
		arg.VoteCount,
		arg.Blurhash,
		arg.Provider,
		arg.ProviderID,
		arg.IsPrimary,
	)
	var i SeriesImage
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.ImageType,
		&i.Url,
		&i.LocalPath,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
		&i.Language,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Blurhash,
		&i.Provider,
		&i.ProviderID,
		&i.IsPrimary,
		&i.CreatedAt,
	)
	return i, err
}

const createSeriesVideo = `-- name: CreateSeriesVideo :one
INSERT INTO series_videos (
    series_id, video_type, name, key, site, size, language, is_official, tmdb_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, series_id, video_type, name, key, site, size, language, is_official, tmdb_id, created_at
`

type CreateSeriesVideoParams struct {
	SeriesID   uuid.UUID `json:"seriesId"`
	VideoType  string    `json:"videoType"`
	Name       *string   `json:"name"`
	Key        *string   `json:"key"`
	Site       *string   `json:"site"`
	Size       *int32    `json:"size"`
	Language   *string   `json:"language"`
	IsOfficial bool      `json:"isOfficial"`
	TmdbID     *string   `json:"tmdbId"`
}

func (q *Queries) CreateSeriesVideo(ctx context.Context, arg CreateSeriesVideoParams) (SeriesVideo, error) {
	row := q.db.QueryRow(ctx, createSeriesVideo,
		arg.SeriesID,
		arg.VideoType,
		arg.Name,
		arg.Key,
		arg.Site,
		arg.Size,
		arg.Language,
		arg.IsOfficial,
		arg.TmdbID,
	)
	var i SeriesVideo
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.VideoType,
		&i.Name,
		&i.Key,
		&i.Site,
		&i.Size,
		&i.Language,
		&i.IsOfficial,
		&i.TmdbID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEpisodeImages = `-- name: DeleteEpisodeImages :exec
DELETE FROM episode_images WHERE episode_id = $1
`

func (q *Queries) DeleteEpisodeImages(ctx context.Context, episodeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisodeImages, episodeID)
	return err
}

const deleteEpisodeImagesBySeries = `-- name: DeleteEpisodeImagesBySeries :exec
DELETE FROM episode_images WHERE episode_id IN (SELECT id FROM episodes WHERE series_id = $1)
`

func (q *Queries) DeleteEpisodeImagesBySeries(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisodeImagesBySeries, seriesID)
	return err
}

const deleteSeasonImages = `-- name: DeleteSeasonImages :exec
DELETE FROM season_images WHERE season_id = $1
`

func (q *Queries) DeleteSeasonImages(ctx context.Context, seasonID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeasonImages, seasonID)
	return err
}

const deleteSeasonImagesBySeries = `-- name: DeleteSeasonImagesBySeries :exec
DELETE FROM season_images WHERE season_id IN (SELECT id FROM seasons WHERE series_id = $1)
`

func (q *Queries) DeleteSeasonImagesBySeries(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeasonImagesBySeries, seriesID)
	return err
}

const deleteSeriesImages = `-- name: DeleteSeriesImages :exec
DELETE FROM series_images WHERE series_id = $1
`

func (q *Queries) DeleteSeriesImages(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeriesImages, seriesID)
	return err
}

const deleteSeriesImagesByType = `-- name: DeleteSeriesImagesByType :exec
DELETE FROM series_images WHERE series_id = $1 AND image_type = $2
`

type DeleteSeriesImagesByTypeParams struct {
	SeriesID  uuid.UUID `json:"seriesId"`
	ImageType string    `json:"imageType"`
}

func (q *Queries) DeleteSeriesImagesByType(ctx context.Context, arg DeleteSeriesImagesByTypeParams) error {
	_, err := q.db.Exec(ctx, deleteSeriesImagesByType, arg.SeriesID, arg.ImageType)
	return err
}

const deleteSeriesVideos = `-- name: DeleteSeriesVideos :exec
DELETE FROM series_videos WHERE series_id = $1
`

func (q *Queries) DeleteSeriesVideos(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeriesVideos, seriesID)
	return err
}

const getEpisodeImages = `-- name: GetEpisodeImages :many

SELECT id, episode_id, image_type, url, local_path, width, height, aspect_ratio, vote_average, vote_count, blurhash, provider, provider_id, is_primary, created_at FROM episode_images
WHERE episode_id = $1
ORDER BY is_primary DESC, vote_average DESC NULLS LAST
`

// Episode Images
func (q *Queries) GetEpisodeImages(ctx context.Context, episodeID uuid.UUID) ([]EpisodeImage, error) {
	rows, err := q.db.Query(ctx, getEpisodeImages, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EpisodeImage{}
	for rows.Next() {
		var i EpisodeImage
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.ImageType,
			&i.Url,
			&i.LocalPath,
			&i.Width,
			&i.Height,
			&i.AspectRatio,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Blurhash,
			&i.Provider,
			&i.ProviderID,
			&i.IsPrimary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryEpisodeImage = `-- name: GetPrimaryEpisodeImage :one
SELECT id, episode_id, image_type, url, local_path, width, height, aspect_ratio, vote_average, vote_count, blurhash, provider, provider_id, is_primary, created_at FROM episode_images
WHERE episode_id = $1 AND is_primary = true
LIMIT 1
`

func (q *Queries) GetPrimaryEpisodeImage(ctx context.Context, episodeID uuid.UUID) (EpisodeImage, error) {
	row := q.db.QueryRow(ctx, getPrimaryEpisodeImage, episodeID)
	var i EpisodeImage
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.ImageType,
		&i.Url,
		&i.LocalPath,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Blurhash,
		&i.Provider,
		&i.ProviderID,
		&i.IsPrimary,
		&i.CreatedAt,
	)
	return i, err
}

const getPrimarySeasonImage = `-- name: GetPrimarySeasonImage :one
SELECT id, season_id, image_type, url, local_path, width, height, aspect_ratio, language, vote_average, vote_count, blurhash, provider, provider_id, is_primary, created_at FROM season_images
WHERE season_id = $1 AND image_type = $2 AND is_primary = true
LIMIT 1
`

type GetPrimarySeasonImageParams struct {
	SeasonID  uuid.UUID `json:"seasonId"`
	ImageType string    `json:"imageType"`
}

func (q *Queries) GetPrimarySeasonImage(ctx context.Context, arg GetPrimarySeasonImageParams) (SeasonImage, error) {
	row := q.db.QueryRow(ctx, getPrimarySeasonImage, arg.SeasonID, arg.ImageType)
	var i SeasonImage
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.ImageType,
		&i.Url,
		&i.LocalPath,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
		&i.Language,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Blurhash,
		&i.Provider,
		&i.ProviderID,
		&i.IsPrimary,
		&i.CreatedAt,
	)
	return i, err
}

const getPrimarySeriesImage = `-- name: GetPrimarySeriesImage :one
SELECT id, series_id, image_type, url, local_path, width, height, aspect_ratio, language, vote_average, vote_count, blurhash, provider, provider_id, is_primary, created_at FROM series_images
WHERE series_id = $1 AND image_type = $2 AND is_primary = true
LIMIT 1
`

type GetPrimarySeriesImageParams struct {
	SeriesID  uuid.UUID `json:"seriesId"`
	ImageType string    `json:"imageType"`
}

func (q *Queries) GetPrimarySeriesImage(ctx context.Context, arg GetPrimarySeriesImageParams) (SeriesImage, error) {
	row := q.db.QueryRow(ctx, getPrimarySeriesImage, arg.SeriesID, arg.ImageType)
	var i SeriesImage
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.ImageType,
		&i.Url,
		&i.LocalPath,
		&i.Width,
		&i.Height,
		&i.AspectRatio,
		&i.Language,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Blurhash,
		&i.Provider,
		&i.ProviderID,
		&i.IsPrimary,
		&i.CreatedAt,
	)
	return i, err
}

const getSeasonImages = `-- name: GetSeasonImages :many

SELECT id, season_id, image_type, url, local_path, width, height, aspect_ratio, language, vote_average, vote_count, blurhash, provider, provider_id, is_primary, created_at FROM season_images
WHERE season_id = $1
ORDER BY is_primary DESC, vote_average DESC NULLS LAST
`

// Season Images
func (q *Queries) GetSeasonImages(ctx context.Context, seasonID uuid.UUID) ([]SeasonImage, error) {
	rows, err := q.db.Query(ctx, getSeasonImages, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SeasonImage{}
	for rows.Next() {
		var i SeasonImage
		if err := rows.Scan(
			&i.ID,
			&i.SeasonID,
			&i.ImageType,
			&i.Url,
			&i.LocalPath,
			&i.Width,
			&i.Height,
			&i.AspectRatio,
			&i.Language,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Blurhash,
			&i.Provider,
			&i.ProviderID,
			&i.IsPrimary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeasonImagesByType = `-- name: GetSeasonImagesByType :many
SELECT id, season_id, image_type, url, local_path, width, height, aspect_ratio, language, vote_average, vote_count, blurhash, provider, provider_id, is_primary, created_at FROM season_images
WHERE season_id = $1 AND image_type = $2
ORDER BY is_primary DESC, vote_average DESC NULLS LAST
`

type GetSeasonImagesByTypeParams struct {
	SeasonID  uuid.UUID `json:"seasonId"`
	ImageType string    `json:"imageType"`
}

func (q *Queries) GetSeasonImagesByType(ctx context.Context, arg GetSeasonImagesByTypeParams) ([]SeasonImage, error) {
	rows, err := q.db.Query(ctx, getSeasonImagesByType, arg.SeasonID, arg.ImageType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SeasonImage{}
	for rows.Next() {
		var i SeasonImage
		if err := rows.Scan(
			&i.ID,
			&i.SeasonID,
			&i.ImageType,
			&i.Url,
			&i.LocalPath,
			&i.Width,
			&i.Height,
			&i.AspectRatio,
			&i.Language,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Blurhash,
			&i.Provider,
			&i.ProviderID,
			&i.IsPrimary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeriesImages = `-- name: GetSeriesImages :many


SELECT id, series_id, image_type, url, local_path, width, height, aspect_ratio, language, vote_average, vote_count, blurhash, provider, provider_id, is_primary, created_at FROM series_images
WHERE series_id = $1
ORDER BY is_primary DESC, vote_average DESC NULLS LAST
`

// TV Show Images and Videos Queries
// Series Images
func (q *Queries) GetSeriesImages(ctx context.Context, seriesID uuid.UUID) ([]SeriesImage, error) {
	rows, err := q.db.Query(ctx, getSeriesImages, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SeriesImage{}
	for rows.Next() {
		var i SeriesImage
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.ImageType,
			&i.Url,
			&i.LocalPath,
			&i.Width,
			&i.Height,
			&i.AspectRatio,
			&i.Language,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Blurhash,
			&i.Provider,
			&i.ProviderID,
			&i.IsPrimary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeriesImagesByType = `-- name: GetSeriesImagesByType :many
SELECT id, series_id, image_type, url, local_path, width, height, aspect_ratio, language, vote_average, vote_count, blurhash, provider, provider_id, is_primary, created_at FROM series_images
WHERE series_id = $1 AND image_type = $2
ORDER BY is_primary DESC, vote_average DESC NULLS LAST
`

type GetSeriesImagesByTypeParams struct {
	SeriesID  uuid.UUID `json:"seriesId"`
	ImageType string    `json:"imageType"`
}

func (q *Queries) GetSeriesImagesByType(ctx context.Context, arg GetSeriesImagesByTypeParams) ([]SeriesImage, error) {
	rows, err := q.db.Query(ctx, getSeriesImagesByType, arg.SeriesID, arg.ImageType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SeriesImage{}
	for rows.Next() {
		var i SeriesImage
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.ImageType,
			&i.Url,
			&i.LocalPath,
			&i.Width,
			&i.Height,
			&i.AspectRatio,
			&i.Language,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Blurhash,
			&i.Provider,
			&i.ProviderID,
			&i.IsPrimary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeriesVideos = `-- name: GetSeriesVideos :many

SELECT id, series_id, video_type, name, key, site, size, language, is_official, tmdb_id, created_at FROM series_videos
WHERE series_id = $1
ORDER BY
    CASE video_type
        WHEN 'trailer' THEN 1
        WHEN 'teaser' THEN 2
        WHEN 'featurette' THEN 3
        WHEN 'behind_the_scenes' THEN 4
        ELSE 10
    END,
    size DESC
`

// Series Videos (trailers, etc.)
func (q *Queries) GetSeriesVideos(ctx context.Context, seriesID uuid.UUID) ([]SeriesVideo, error) {
	rows, err := q.db.Query(ctx, getSeriesVideos, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SeriesVideo{}
	for rows.Next() {
		var i SeriesVideo
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.VideoType,
			&i.Name,
			&i.Key,
			&i.Site,
			&i.Size,
			&i.Language,
			&i.IsOfficial,
			&i.TmdbID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeriesVideosByType = `-- name: GetSeriesVideosByType :many
SELECT id, series_id, video_type, name, key, site, size, language, is_official, tmdb_id, created_at FROM series_videos
WHERE series_id = $1 AND video_type = $2
ORDER BY size DESC
`

type GetSeriesVideosByTypeParams struct {
	SeriesID  uuid.UUID `json:"seriesId"`
	VideoType string    `json:"videoType"`
}

func (q *Queries) GetSeriesVideosByType(ctx context.Context, arg GetSeriesVideosByTypeParams) ([]SeriesVideo, error) {
	rows, err := q.db.Query(ctx, getSeriesVideosByType, arg.SeriesID, arg.VideoType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SeriesVideo{}
	for rows.Next() {
		var i SeriesVideo
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.VideoType,
			&i.Name,
			&i.Key,
			&i.Site,
			&i.Size,
			&i.Language,
			&i.IsOfficial,
			&i.TmdbID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPrimaryEpisodeImage = `-- name: SetPrimaryEpisodeImage :exec
UPDATE episode_images SET is_primary = (id = $2)
WHERE episode_id = $1
`

type SetPrimaryEpisodeImageParams struct {
	EpisodeID uuid.UUID `json:"episodeId"`
	ID        uuid.UUID `json:"id"`
}

func (q *Queries) SetPrimaryEpisodeImage(ctx context.Context, arg SetPrimaryEpisodeImageParams) error {
	_, err := q.db.Exec(ctx, setPrimaryEpisodeImage, arg.EpisodeID, arg.ID)
	return err
}

const setPrimarySeasonImage = `-- name: SetPrimarySeasonImage :exec
UPDATE season_images SET is_primary = (id = $2)
WHERE season_id = $1 AND image_type = $3
`

type SetPrimarySeasonImageParams struct {
	SeasonID  uuid.UUID `json:"seasonId"`
	ID        uuid.UUID `json:"id"`
	ImageType string    `json:"imageType"`
}

func (q *Queries) SetPrimarySeasonImage(ctx context.Context, arg SetPrimarySeasonImageParams) error {
	_, err := q.db.Exec(ctx, setPrimarySeasonImage, arg.SeasonID, arg.ID, arg.ImageType)
	return err
}

const setPrimarySeriesImage = `-- name: SetPrimarySeriesImage :exec
UPDATE series_images SET is_primary = (id = $2)
WHERE series_id = $1 AND image_type = $3
`

type SetPrimarySeriesImageParams struct {
	SeriesID  uuid.UUID `json:"seriesId"`
	ID        uuid.UUID `json:"id"`
	ImageType string    `json:"imageType"`
}

func (q *Queries) SetPrimarySeriesImage(ctx context.Context, arg SetPrimarySeriesImageParams) error {
	_, err := q.db.Exec(ctx, setPrimarySeriesImage, arg.SeriesID, arg.ID, arg.ImageType)
	return err
}
