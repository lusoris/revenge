// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: genres.sql

package tvshowdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countSeriesByGenre = `-- name: CountSeriesByGenre :one
SELECT COUNT(*) FROM series_genre_link WHERE genre_id = $1
`

func (q *Queries) CountSeriesByGenre(ctx context.Context, genreID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSeriesByGenre, genreID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTVShowGenre = `-- name: CreateTVShowGenre :one
INSERT INTO tvshow_genres (name, tmdb_id)
VALUES ($1, $2)
RETURNING id, name, tmdb_id, created_at
`

type CreateTVShowGenreParams struct {
	Name   string `json:"name"`
	TmdbID *int32 `json:"tmdbId"`
}

func (q *Queries) CreateTVShowGenre(ctx context.Context, arg CreateTVShowGenreParams) (TvshowGenre, error) {
	row := q.db.QueryRow(ctx, createTVShowGenre, arg.Name, arg.TmdbID)
	var i TvshowGenre
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TmdbID,
		&i.CreatedAt,
	)
	return i, err
}

const getOrCreateTVShowGenre = `-- name: GetOrCreateTVShowGenre :one
INSERT INTO tvshow_genres (name, tmdb_id)
VALUES ($1, $2)
ON CONFLICT (name) DO UPDATE SET tmdb_id = COALESCE(EXCLUDED.tmdb_id, tvshow_genres.tmdb_id)
RETURNING id, name, tmdb_id, created_at
`

type GetOrCreateTVShowGenreParams struct {
	Name   string `json:"name"`
	TmdbID *int32 `json:"tmdbId"`
}

func (q *Queries) GetOrCreateTVShowGenre(ctx context.Context, arg GetOrCreateTVShowGenreParams) (TvshowGenre, error) {
	row := q.db.QueryRow(ctx, getOrCreateTVShowGenre, arg.Name, arg.TmdbID)
	var i TvshowGenre
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TmdbID,
		&i.CreatedAt,
	)
	return i, err
}

const getSeriesGenres = `-- name: GetSeriesGenres :many

SELECT g.id, g.name, g.tmdb_id, g.created_at FROM tvshow_genres g
JOIN series_genre_link sg ON g.id = sg.genre_id
WHERE sg.series_id = $1
ORDER BY g.name ASC
`

// TV Show Genre Queries
func (q *Queries) GetSeriesGenres(ctx context.Context, seriesID uuid.UUID) ([]TvshowGenre, error) {
	rows, err := q.db.Query(ctx, getSeriesGenres, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowGenre{}
	for rows.Next() {
		var i TvshowGenre
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TmdbID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTVShowGenreByID = `-- name: GetTVShowGenreByID :one
SELECT id, name, tmdb_id, created_at FROM tvshow_genres WHERE id = $1
`

func (q *Queries) GetTVShowGenreByID(ctx context.Context, id uuid.UUID) (TvshowGenre, error) {
	row := q.db.QueryRow(ctx, getTVShowGenreByID, id)
	var i TvshowGenre
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TmdbID,
		&i.CreatedAt,
	)
	return i, err
}

const getTVShowGenreByName = `-- name: GetTVShowGenreByName :one
SELECT id, name, tmdb_id, created_at FROM tvshow_genres WHERE name = $1
`

func (q *Queries) GetTVShowGenreByName(ctx context.Context, name string) (TvshowGenre, error) {
	row := q.db.QueryRow(ctx, getTVShowGenreByName, name)
	var i TvshowGenre
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TmdbID,
		&i.CreatedAt,
	)
	return i, err
}

const getTVShowGenreByTmdbID = `-- name: GetTVShowGenreByTmdbID :one
SELECT id, name, tmdb_id, created_at FROM tvshow_genres WHERE tmdb_id = $1
`

func (q *Queries) GetTVShowGenreByTmdbID(ctx context.Context, tmdbID *int32) (TvshowGenre, error) {
	row := q.db.QueryRow(ctx, getTVShowGenreByTmdbID, tmdbID)
	var i TvshowGenre
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TmdbID,
		&i.CreatedAt,
	)
	return i, err
}

const linkSeriesGenre = `-- name: LinkSeriesGenre :exec
INSERT INTO series_genre_link (series_id, genre_id)
VALUES ($1, $2)
ON CONFLICT (series_id, genre_id) DO NOTHING
`

type LinkSeriesGenreParams struct {
	SeriesID uuid.UUID `json:"seriesId"`
	GenreID  uuid.UUID `json:"genreId"`
}

func (q *Queries) LinkSeriesGenre(ctx context.Context, arg LinkSeriesGenreParams) error {
	_, err := q.db.Exec(ctx, linkSeriesGenre, arg.SeriesID, arg.GenreID)
	return err
}

const listSeriesByGenre = `-- name: ListSeriesByGenre :many
SELECT s.id, s.library_id, s.title, s.sort_title, s.original_title, s.tagline, s.overview, s.first_air_date, s.last_air_date, s.year, s.status, s.type, s.content_rating, s.rating_level, s.community_rating, s.vote_count, s.season_count, s.episode_count, s.special_count, s.poster_path, s.poster_blurhash, s.backdrop_path, s.backdrop_blurhash, s.logo_path, s.tmdb_id, s.imdb_id, s.tvdb_id, s.network_name, s.network_logo_path, s.date_added, s.last_played_at, s.is_locked, s.created_at, s.updated_at FROM series s
JOIN series_genre_link sg ON s.id = sg.series_id
WHERE sg.genre_id = $1
ORDER BY s.sort_title ASC
LIMIT $2 OFFSET $3
`

type ListSeriesByGenreParams struct {
	GenreID uuid.UUID `json:"genreId"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListSeriesByGenre(ctx context.Context, arg ListSeriesByGenreParams) ([]Series, error) {
	rows, err := q.db.Query(ctx, listSeriesByGenre, arg.GenreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.Year,
			&i.Status,
			&i.Type,
			&i.ContentRating,
			&i.RatingLevel,
			&i.CommunityRating,
			&i.VoteCount,
			&i.SeasonCount,
			&i.EpisodeCount,
			&i.SpecialCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.NetworkName,
			&i.NetworkLogoPath,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTVShowGenres = `-- name: ListTVShowGenres :many
SELECT id, name, tmdb_id, created_at FROM tvshow_genres ORDER BY name ASC
`

func (q *Queries) ListTVShowGenres(ctx context.Context) ([]TvshowGenre, error) {
	rows, err := q.db.Query(ctx, listTVShowGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowGenre{}
	for rows.Next() {
		var i TvshowGenre
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TmdbID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTVShowGenresWithCounts = `-- name: ListTVShowGenresWithCounts :many
SELECT g.id, g.name, g.tmdb_id, g.created_at, COUNT(sg.series_id) as series_count
FROM tvshow_genres g
LEFT JOIN series_genre_link sg ON g.id = sg.genre_id
GROUP BY g.id
ORDER BY series_count DESC, g.name ASC
`

type ListTVShowGenresWithCountsRow struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	TmdbID      *int32    `json:"tmdbId"`
	CreatedAt   time.Time `json:"createdAt"`
	SeriesCount int64     `json:"seriesCount"`
}

func (q *Queries) ListTVShowGenresWithCounts(ctx context.Context) ([]ListTVShowGenresWithCountsRow, error) {
	rows, err := q.db.Query(ctx, listTVShowGenresWithCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTVShowGenresWithCountsRow{}
	for rows.Next() {
		var i ListTVShowGenresWithCountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TmdbID,
			&i.CreatedAt,
			&i.SeriesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unlinkSeriesGenres = `-- name: UnlinkSeriesGenres :exec
DELETE FROM series_genre_link WHERE series_id = $1
`

func (q *Queries) UnlinkSeriesGenres(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, unlinkSeriesGenres, seriesID)
	return err
}
