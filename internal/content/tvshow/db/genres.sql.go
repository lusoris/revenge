// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: genres.sql

package tvshowdb

import (
	"context"

	"github.com/google/uuid"
)

const addSeriesGenre = `-- name: AddSeriesGenre :exec
INSERT INTO
    tvshow.series_genres (
        series_id,
        slug,
        name
    )
VALUES ($1, $2, $3) ON CONFLICT (series_id, slug) DO NOTHING
`

type AddSeriesGenreParams struct {
	SeriesID uuid.UUID `json:"seriesId"`
	Slug     string    `json:"slug"`
	Name     string    `json:"name"`
}

func (q *Queries) AddSeriesGenre(ctx context.Context, arg AddSeriesGenreParams) error {
	_, err := q.db.Exec(ctx, addSeriesGenre, arg.SeriesID, arg.Slug, arg.Name)
	return err
}

const deleteSeriesGenres = `-- name: DeleteSeriesGenres :exec
DELETE FROM tvshow.series_genres WHERE series_id = $1
`

func (q *Queries) DeleteSeriesGenres(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeriesGenres, seriesID)
	return err
}

const listDistinctSeriesGenres = `-- name: ListDistinctSeriesGenres :many
SELECT slug, name, COUNT(DISTINCT series_id)::bigint AS item_count
FROM tvshow.series_genres
GROUP BY slug, name
ORDER BY name ASC
`

type ListDistinctSeriesGenresRow struct {
	Slug      string `json:"slug"`
	Name      string `json:"name"`
	ItemCount int64  `json:"itemCount"`
}

func (q *Queries) ListDistinctSeriesGenres(ctx context.Context) ([]ListDistinctSeriesGenresRow, error) {
	rows, err := q.db.Query(ctx, listDistinctSeriesGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDistinctSeriesGenresRow{}
	for rows.Next() {
		var i ListDistinctSeriesGenresRow
		if err := rows.Scan(&i.Slug, &i.Name, &i.ItemCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesByGenre = `-- name: ListSeriesByGenre :many
SELECT s.id, s.tmdb_id, s.tvdb_id, s.imdb_id, s.sonarr_id, s.title, s.tagline, s.overview, s.titles_i18n, s.taglines_i18n, s.overviews_i18n, s.age_ratings, s.original_language, s.original_title, s.status, s.type, s.first_air_date, s.last_air_date, s.vote_average, s.vote_count, s.popularity, s.poster_path, s.backdrop_path, s.total_seasons, s.total_episodes, s.trailer_url, s.homepage, s.metadata_updated_at, s.created_at, s.updated_at, s.external_ratings
FROM tvshow.series s
    JOIN tvshow.series_genres sg ON s.id = sg.series_id
WHERE
    sg.slug = $1
ORDER BY s.popularity DESC NULLS LAST
LIMIT $2
OFFSET
    $3
`

type ListSeriesByGenreParams struct {
	Slug   string `json:"slug"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListSeriesByGenre(ctx context.Context, arg ListSeriesByGenreParams) ([]TvshowSeries, error) {
	rows, err := q.db.Query(ctx, listSeriesByGenre, arg.Slug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowSeries{}
	for rows.Next() {
		var i TvshowSeries
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SonarrID,
			&i.Title,
			&i.Tagline,
			&i.Overview,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.OriginalLanguage,
			&i.OriginalTitle,
			&i.Status,
			&i.Type,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TotalSeasons,
			&i.TotalEpisodes,
			&i.TrailerUrl,
			&i.Homepage,
			&i.MetadataUpdatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExternalRatings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesGenres = `-- name: ListSeriesGenres :many
SELECT id, series_id, name, created_at, slug
FROM tvshow.series_genres
WHERE
    series_id = $1
ORDER BY name ASC
`

func (q *Queries) ListSeriesGenres(ctx context.Context, seriesID uuid.UUID) ([]TvshowSeriesGenre, error) {
	rows, err := q.db.Query(ctx, listSeriesGenres, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowSeriesGenre{}
	for rows.Next() {
		var i TvshowSeriesGenre
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.Name,
			&i.CreatedAt,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
