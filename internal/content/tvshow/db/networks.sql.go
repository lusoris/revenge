// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: networks.sql

package tvshowdb

import (
	"context"

	"github.com/google/uuid"
)

const addSeriesNetwork = `-- name: AddSeriesNetwork :exec
INSERT INTO tvshow.series_networks (series_id, network_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddSeriesNetworkParams struct {
	SeriesID  uuid.UUID `json:"seriesId"`
	NetworkID uuid.UUID `json:"networkId"`
}

func (q *Queries) AddSeriesNetwork(ctx context.Context, arg AddSeriesNetworkParams) error {
	_, err := q.db.Exec(ctx, addSeriesNetwork, arg.SeriesID, arg.NetworkID)
	return err
}

const createNetwork = `-- name: CreateNetwork :one
INSERT INTO tvshow.networks (tmdb_id, name, logo_path, origin_country)
VALUES ($1, $2, $3, $4)
ON CONFLICT (tmdb_id) DO UPDATE SET
    name = EXCLUDED.name,
    logo_path = EXCLUDED.logo_path,
    origin_country = EXCLUDED.origin_country
RETURNING id, tmdb_id, name, logo_path, origin_country, created_at
`

type CreateNetworkParams struct {
	TmdbID        int32   `json:"tmdbId"`
	Name          string  `json:"name"`
	LogoPath      *string `json:"logoPath"`
	OriginCountry *string `json:"originCountry"`
}

func (q *Queries) CreateNetwork(ctx context.Context, arg CreateNetworkParams) (TvshowNetwork, error) {
	row := q.db.QueryRow(ctx, createNetwork,
		arg.TmdbID,
		arg.Name,
		arg.LogoPath,
		arg.OriginCountry,
	)
	var i TvshowNetwork
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.Name,
		&i.LogoPath,
		&i.OriginCountry,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSeriesNetworks = `-- name: DeleteSeriesNetworks :exec
DELETE FROM tvshow.series_networks WHERE series_id = $1
`

func (q *Queries) DeleteSeriesNetworks(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeriesNetworks, seriesID)
	return err
}

const getNetwork = `-- name: GetNetwork :one
SELECT id, tmdb_id, name, logo_path, origin_country, created_at FROM tvshow.networks WHERE id = $1
`

func (q *Queries) GetNetwork(ctx context.Context, id uuid.UUID) (TvshowNetwork, error) {
	row := q.db.QueryRow(ctx, getNetwork, id)
	var i TvshowNetwork
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.Name,
		&i.LogoPath,
		&i.OriginCountry,
		&i.CreatedAt,
	)
	return i, err
}

const getNetworkByTMDbID = `-- name: GetNetworkByTMDbID :one
SELECT id, tmdb_id, name, logo_path, origin_country, created_at FROM tvshow.networks WHERE tmdb_id = $1
`

func (q *Queries) GetNetworkByTMDbID(ctx context.Context, tmdbID int32) (TvshowNetwork, error) {
	row := q.db.QueryRow(ctx, getNetworkByTMDbID, tmdbID)
	var i TvshowNetwork
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.Name,
		&i.LogoPath,
		&i.OriginCountry,
		&i.CreatedAt,
	)
	return i, err
}

const listNetworksBySeries = `-- name: ListNetworksBySeries :many
SELECT n.id, n.tmdb_id, n.name, n.logo_path, n.origin_country, n.created_at FROM tvshow.networks n
JOIN tvshow.series_networks sn ON n.id = sn.network_id
WHERE sn.series_id = $1
ORDER BY n.name ASC
`

func (q *Queries) ListNetworksBySeries(ctx context.Context, seriesID uuid.UUID) ([]TvshowNetwork, error) {
	rows, err := q.db.Query(ctx, listNetworksBySeries, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowNetwork{}
	for rows.Next() {
		var i TvshowNetwork
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.Name,
			&i.LogoPath,
			&i.OriginCountry,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesByNetwork = `-- name: ListSeriesByNetwork :many
SELECT s.id, s.tmdb_id, s.tvdb_id, s.imdb_id, s.sonarr_id, s.title, s.tagline, s.overview, s.titles_i18n, s.taglines_i18n, s.overviews_i18n, s.age_ratings, s.original_language, s.original_title, s.status, s.type, s.first_air_date, s.last_air_date, s.vote_average, s.vote_count, s.popularity, s.poster_path, s.backdrop_path, s.total_seasons, s.total_episodes, s.trailer_url, s.homepage, s.metadata_updated_at, s.created_at, s.updated_at FROM tvshow.series s
JOIN tvshow.series_networks sn ON s.id = sn.series_id
WHERE sn.network_id = $1
ORDER BY s.first_air_date DESC NULLS LAST
LIMIT $2 OFFSET $3
`

type ListSeriesByNetworkParams struct {
	NetworkID uuid.UUID `json:"networkId"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) ListSeriesByNetwork(ctx context.Context, arg ListSeriesByNetworkParams) ([]TvshowSeries, error) {
	rows, err := q.db.Query(ctx, listSeriesByNetwork, arg.NetworkID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowSeries{}
	for rows.Next() {
		var i TvshowSeries
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SonarrID,
			&i.Title,
			&i.Tagline,
			&i.Overview,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.OriginalLanguage,
			&i.OriginalTitle,
			&i.Status,
			&i.Type,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TotalSeasons,
			&i.TotalEpisodes,
			&i.TrailerUrl,
			&i.Homepage,
			&i.MetadataUpdatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
