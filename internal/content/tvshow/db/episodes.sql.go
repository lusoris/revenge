// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: episodes.sql

package tvshowdb

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countEpisodesBySeason = `-- name: CountEpisodesBySeason :one
SELECT COUNT(*) FROM tvshow.episodes WHERE season_id = $1
`

func (q *Queries) CountEpisodesBySeason(ctx context.Context, seasonID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEpisodesBySeason, seasonID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodesBySeries = `-- name: CountEpisodesBySeries :one
SELECT COUNT(*) FROM tvshow.episodes WHERE series_id = $1
`

func (q *Queries) CountEpisodesBySeries(ctx context.Context, seriesID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEpisodesBySeries, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEpisode = `-- name: CreateEpisode :one
INSERT INTO tvshow.episodes (
    series_id, season_id, tmdb_id, tvdb_id, imdb_id,
    season_number, episode_number,
    title, overview,
    titles_i18n, overviews_i18n,
    air_date, runtime,
    vote_average, vote_count,
    still_path, production_code
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7,
    $8, $9,
    $10, $11,
    $12, $13,
    $14, $15,
    $16, $17
)
RETURNING id, series_id, season_id, tmdb_id, tvdb_id, imdb_id, season_number, episode_number, title, overview, titles_i18n, overviews_i18n, air_date, runtime, vote_average, vote_count, still_path, production_code, created_at, updated_at
`

type CreateEpisodeParams struct {
	SeriesID       uuid.UUID       `json:"seriesId"`
	SeasonID       uuid.UUID       `json:"seasonId"`
	TmdbID         *int32          `json:"tmdbId"`
	TvdbID         *int32          `json:"tvdbId"`
	ImdbID         *string         `json:"imdbId"`
	SeasonNumber   int32           `json:"seasonNumber"`
	EpisodeNumber  int32           `json:"episodeNumber"`
	Title          string          `json:"title"`
	Overview       *string         `json:"overview"`
	TitlesI18n     json.RawMessage `json:"titlesI18n"`
	OverviewsI18n  json.RawMessage `json:"overviewsI18n"`
	AirDate        pgtype.Date     `json:"airDate"`
	Runtime        *int32          `json:"runtime"`
	VoteAverage    pgtype.Numeric  `json:"voteAverage"`
	VoteCount      *int32          `json:"voteCount"`
	StillPath      *string         `json:"stillPath"`
	ProductionCode *string         `json:"productionCode"`
}

func (q *Queries) CreateEpisode(ctx context.Context, arg CreateEpisodeParams) (TvshowEpisode, error) {
	row := q.db.QueryRow(ctx, createEpisode,
		arg.SeriesID,
		arg.SeasonID,
		arg.TmdbID,
		arg.TvdbID,
		arg.ImdbID,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.Title,
		arg.Overview,
		arg.TitlesI18n,
		arg.OverviewsI18n,
		arg.AirDate,
		arg.Runtime,
		arg.VoteAverage,
		arg.VoteCount,
		arg.StillPath,
		arg.ProductionCode,
	)
	var i TvshowEpisode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.TitlesI18n,
		&i.OverviewsI18n,
		&i.AirDate,
		&i.Runtime,
		&i.VoteAverage,
		&i.VoteCount,
		&i.StillPath,
		&i.ProductionCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEpisode = `-- name: DeleteEpisode :exec
DELETE FROM tvshow.episodes WHERE id = $1
`

func (q *Queries) DeleteEpisode(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisode, id)
	return err
}

const deleteEpisodesBySeason = `-- name: DeleteEpisodesBySeason :exec
DELETE FROM tvshow.episodes WHERE season_id = $1
`

func (q *Queries) DeleteEpisodesBySeason(ctx context.Context, seasonID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisodesBySeason, seasonID)
	return err
}

const deleteEpisodesBySeries = `-- name: DeleteEpisodesBySeries :exec
DELETE FROM tvshow.episodes WHERE series_id = $1
`

func (q *Queries) DeleteEpisodesBySeries(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisodesBySeries, seriesID)
	return err
}

const getEpisode = `-- name: GetEpisode :one
SELECT id, series_id, season_id, tmdb_id, tvdb_id, imdb_id, season_number, episode_number, title, overview, titles_i18n, overviews_i18n, air_date, runtime, vote_average, vote_count, still_path, production_code, created_at, updated_at FROM tvshow.episodes WHERE id = $1
`

func (q *Queries) GetEpisode(ctx context.Context, id uuid.UUID) (TvshowEpisode, error) {
	row := q.db.QueryRow(ctx, getEpisode, id)
	var i TvshowEpisode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.TitlesI18n,
		&i.OverviewsI18n,
		&i.AirDate,
		&i.Runtime,
		&i.VoteAverage,
		&i.VoteCount,
		&i.StillPath,
		&i.ProductionCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEpisodeByNumber = `-- name: GetEpisodeByNumber :one
SELECT id, series_id, season_id, tmdb_id, tvdb_id, imdb_id, season_number, episode_number, title, overview, titles_i18n, overviews_i18n, air_date, runtime, vote_average, vote_count, still_path, production_code, created_at, updated_at FROM tvshow.episodes
WHERE series_id = $1 AND season_number = $2 AND episode_number = $3
`

type GetEpisodeByNumberParams struct {
	SeriesID      uuid.UUID `json:"seriesId"`
	SeasonNumber  int32     `json:"seasonNumber"`
	EpisodeNumber int32     `json:"episodeNumber"`
}

func (q *Queries) GetEpisodeByNumber(ctx context.Context, arg GetEpisodeByNumberParams) (TvshowEpisode, error) {
	row := q.db.QueryRow(ctx, getEpisodeByNumber, arg.SeriesID, arg.SeasonNumber, arg.EpisodeNumber)
	var i TvshowEpisode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.TitlesI18n,
		&i.OverviewsI18n,
		&i.AirDate,
		&i.Runtime,
		&i.VoteAverage,
		&i.VoteCount,
		&i.StillPath,
		&i.ProductionCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEpisodeByTMDbID = `-- name: GetEpisodeByTMDbID :one
SELECT id, series_id, season_id, tmdb_id, tvdb_id, imdb_id, season_number, episode_number, title, overview, titles_i18n, overviews_i18n, air_date, runtime, vote_average, vote_count, still_path, production_code, created_at, updated_at FROM tvshow.episodes WHERE tmdb_id = $1
`

func (q *Queries) GetEpisodeByTMDbID(ctx context.Context, tmdbID *int32) (TvshowEpisode, error) {
	row := q.db.QueryRow(ctx, getEpisodeByTMDbID, tmdbID)
	var i TvshowEpisode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.TitlesI18n,
		&i.OverviewsI18n,
		&i.AirDate,
		&i.Runtime,
		&i.VoteAverage,
		&i.VoteCount,
		&i.StillPath,
		&i.ProductionCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEpisodesBySeason = `-- name: ListEpisodesBySeason :many
SELECT id, series_id, season_id, tmdb_id, tvdb_id, imdb_id, season_number, episode_number, title, overview, titles_i18n, overviews_i18n, air_date, runtime, vote_average, vote_count, still_path, production_code, created_at, updated_at FROM tvshow.episodes
WHERE season_id = $1
ORDER BY episode_number ASC
`

func (q *Queries) ListEpisodesBySeason(ctx context.Context, seasonID uuid.UUID) ([]TvshowEpisode, error) {
	rows, err := q.db.Query(ctx, listEpisodesBySeason, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowEpisode{}
	for rows.Next() {
		var i TvshowEpisode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.TitlesI18n,
			&i.OverviewsI18n,
			&i.AirDate,
			&i.Runtime,
			&i.VoteAverage,
			&i.VoteCount,
			&i.StillPath,
			&i.ProductionCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesBySeasonNumber = `-- name: ListEpisodesBySeasonNumber :many
SELECT id, series_id, season_id, tmdb_id, tvdb_id, imdb_id, season_number, episode_number, title, overview, titles_i18n, overviews_i18n, air_date, runtime, vote_average, vote_count, still_path, production_code, created_at, updated_at FROM tvshow.episodes
WHERE series_id = $1 AND season_number = $2
ORDER BY episode_number ASC
`

type ListEpisodesBySeasonNumberParams struct {
	SeriesID     uuid.UUID `json:"seriesId"`
	SeasonNumber int32     `json:"seasonNumber"`
}

func (q *Queries) ListEpisodesBySeasonNumber(ctx context.Context, arg ListEpisodesBySeasonNumberParams) ([]TvshowEpisode, error) {
	rows, err := q.db.Query(ctx, listEpisodesBySeasonNumber, arg.SeriesID, arg.SeasonNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowEpisode{}
	for rows.Next() {
		var i TvshowEpisode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.TitlesI18n,
			&i.OverviewsI18n,
			&i.AirDate,
			&i.Runtime,
			&i.VoteAverage,
			&i.VoteCount,
			&i.StillPath,
			&i.ProductionCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesBySeries = `-- name: ListEpisodesBySeries :many
SELECT id, series_id, season_id, tmdb_id, tvdb_id, imdb_id, season_number, episode_number, title, overview, titles_i18n, overviews_i18n, air_date, runtime, vote_average, vote_count, still_path, production_code, created_at, updated_at FROM tvshow.episodes
WHERE series_id = $1
ORDER BY season_number ASC, episode_number ASC
`

func (q *Queries) ListEpisodesBySeries(ctx context.Context, seriesID uuid.UUID) ([]TvshowEpisode, error) {
	rows, err := q.db.Query(ctx, listEpisodesBySeries, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowEpisode{}
	for rows.Next() {
		var i TvshowEpisode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.TitlesI18n,
			&i.OverviewsI18n,
			&i.AirDate,
			&i.Runtime,
			&i.VoteAverage,
			&i.VoteCount,
			&i.StillPath,
			&i.ProductionCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentEpisodes = `-- name: ListRecentEpisodes :many
SELECT e.id, e.series_id, e.season_id, e.tmdb_id, e.tvdb_id, e.imdb_id, e.season_number, e.episode_number, e.title, e.overview, e.titles_i18n, e.overviews_i18n, e.air_date, e.runtime, e.vote_average, e.vote_count, e.still_path, e.production_code, e.created_at, e.updated_at, s.title as series_title, s.poster_path as series_poster_path
FROM tvshow.episodes e
JOIN tvshow.series s ON e.series_id = s.id
WHERE e.air_date IS NOT NULL AND e.air_date <= CURRENT_DATE
ORDER BY e.air_date DESC
LIMIT $1 OFFSET $2
`

type ListRecentEpisodesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListRecentEpisodesRow struct {
	ID               uuid.UUID       `json:"id"`
	SeriesID         uuid.UUID       `json:"seriesId"`
	SeasonID         uuid.UUID       `json:"seasonId"`
	TmdbID           *int32          `json:"tmdbId"`
	TvdbID           *int32          `json:"tvdbId"`
	ImdbID           *string         `json:"imdbId"`
	SeasonNumber     int32           `json:"seasonNumber"`
	EpisodeNumber    int32           `json:"episodeNumber"`
	Title            string          `json:"title"`
	Overview         *string         `json:"overview"`
	TitlesI18n       json.RawMessage `json:"titlesI18n"`
	OverviewsI18n    json.RawMessage `json:"overviewsI18n"`
	AirDate          pgtype.Date     `json:"airDate"`
	Runtime          *int32          `json:"runtime"`
	VoteAverage      pgtype.Numeric  `json:"voteAverage"`
	VoteCount        *int32          `json:"voteCount"`
	StillPath        *string         `json:"stillPath"`
	ProductionCode   *string         `json:"productionCode"`
	CreatedAt        time.Time       `json:"createdAt"`
	UpdatedAt        time.Time       `json:"updatedAt"`
	SeriesTitle      string          `json:"seriesTitle"`
	SeriesPosterPath *string         `json:"seriesPosterPath"`
}

func (q *Queries) ListRecentEpisodes(ctx context.Context, arg ListRecentEpisodesParams) ([]ListRecentEpisodesRow, error) {
	rows, err := q.db.Query(ctx, listRecentEpisodes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentEpisodesRow{}
	for rows.Next() {
		var i ListRecentEpisodesRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.TitlesI18n,
			&i.OverviewsI18n,
			&i.AirDate,
			&i.Runtime,
			&i.VoteAverage,
			&i.VoteCount,
			&i.StillPath,
			&i.ProductionCode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeriesTitle,
			&i.SeriesPosterPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingEpisodes = `-- name: ListUpcomingEpisodes :many
SELECT e.id, e.series_id, e.season_id, e.tmdb_id, e.tvdb_id, e.imdb_id, e.season_number, e.episode_number, e.title, e.overview, e.titles_i18n, e.overviews_i18n, e.air_date, e.runtime, e.vote_average, e.vote_count, e.still_path, e.production_code, e.created_at, e.updated_at, s.title as series_title, s.poster_path as series_poster_path
FROM tvshow.episodes e
JOIN tvshow.series s ON e.series_id = s.id
WHERE e.air_date IS NOT NULL AND e.air_date > CURRENT_DATE
ORDER BY e.air_date ASC
LIMIT $1 OFFSET $2
`

type ListUpcomingEpisodesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUpcomingEpisodesRow struct {
	ID               uuid.UUID       `json:"id"`
	SeriesID         uuid.UUID       `json:"seriesId"`
	SeasonID         uuid.UUID       `json:"seasonId"`
	TmdbID           *int32          `json:"tmdbId"`
	TvdbID           *int32          `json:"tvdbId"`
	ImdbID           *string         `json:"imdbId"`
	SeasonNumber     int32           `json:"seasonNumber"`
	EpisodeNumber    int32           `json:"episodeNumber"`
	Title            string          `json:"title"`
	Overview         *string         `json:"overview"`
	TitlesI18n       json.RawMessage `json:"titlesI18n"`
	OverviewsI18n    json.RawMessage `json:"overviewsI18n"`
	AirDate          pgtype.Date     `json:"airDate"`
	Runtime          *int32          `json:"runtime"`
	VoteAverage      pgtype.Numeric  `json:"voteAverage"`
	VoteCount        *int32          `json:"voteCount"`
	StillPath        *string         `json:"stillPath"`
	ProductionCode   *string         `json:"productionCode"`
	CreatedAt        time.Time       `json:"createdAt"`
	UpdatedAt        time.Time       `json:"updatedAt"`
	SeriesTitle      string          `json:"seriesTitle"`
	SeriesPosterPath *string         `json:"seriesPosterPath"`
}

func (q *Queries) ListUpcomingEpisodes(ctx context.Context, arg ListUpcomingEpisodesParams) ([]ListUpcomingEpisodesRow, error) {
	rows, err := q.db.Query(ctx, listUpcomingEpisodes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUpcomingEpisodesRow{}
	for rows.Next() {
		var i ListUpcomingEpisodesRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.TitlesI18n,
			&i.OverviewsI18n,
			&i.AirDate,
			&i.Runtime,
			&i.VoteAverage,
			&i.VoteCount,
			&i.StillPath,
			&i.ProductionCode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeriesTitle,
			&i.SeriesPosterPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEpisode = `-- name: UpdateEpisode :one
UPDATE tvshow.episodes SET
    tmdb_id = COALESCE($1, tmdb_id),
    tvdb_id = COALESCE($2, tvdb_id),
    imdb_id = COALESCE($3, imdb_id),
    title = COALESCE($4, title),
    overview = COALESCE($5, overview),
    titles_i18n = COALESCE($6, titles_i18n),
    overviews_i18n = COALESCE($7, overviews_i18n),
    air_date = COALESCE($8, air_date),
    runtime = COALESCE($9, runtime),
    vote_average = COALESCE($10, vote_average),
    vote_count = COALESCE($11, vote_count),
    still_path = COALESCE($12, still_path),
    production_code = COALESCE($13, production_code)
WHERE id = $14
RETURNING id, series_id, season_id, tmdb_id, tvdb_id, imdb_id, season_number, episode_number, title, overview, titles_i18n, overviews_i18n, air_date, runtime, vote_average, vote_count, still_path, production_code, created_at, updated_at
`

type UpdateEpisodeParams struct {
	TmdbID         *int32         `json:"tmdbId"`
	TvdbID         *int32         `json:"tvdbId"`
	ImdbID         *string        `json:"imdbId"`
	Title          *string        `json:"title"`
	Overview       *string        `json:"overview"`
	TitlesI18n     []byte         `json:"titlesI18n"`
	OverviewsI18n  []byte         `json:"overviewsI18n"`
	AirDate        pgtype.Date    `json:"airDate"`
	Runtime        *int32         `json:"runtime"`
	VoteAverage    pgtype.Numeric `json:"voteAverage"`
	VoteCount      *int32         `json:"voteCount"`
	StillPath      *string        `json:"stillPath"`
	ProductionCode *string        `json:"productionCode"`
	ID             uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateEpisode(ctx context.Context, arg UpdateEpisodeParams) (TvshowEpisode, error) {
	row := q.db.QueryRow(ctx, updateEpisode,
		arg.TmdbID,
		arg.TvdbID,
		arg.ImdbID,
		arg.Title,
		arg.Overview,
		arg.TitlesI18n,
		arg.OverviewsI18n,
		arg.AirDate,
		arg.Runtime,
		arg.VoteAverage,
		arg.VoteCount,
		arg.StillPath,
		arg.ProductionCode,
		arg.ID,
	)
	var i TvshowEpisode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.TitlesI18n,
		&i.OverviewsI18n,
		&i.AirDate,
		&i.Runtime,
		&i.VoteAverage,
		&i.VoteCount,
		&i.StillPath,
		&i.ProductionCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertEpisode = `-- name: UpsertEpisode :one
INSERT INTO tvshow.episodes (
    series_id, season_id, tmdb_id, tvdb_id, imdb_id,
    season_number, episode_number,
    title, overview,
    titles_i18n, overviews_i18n,
    air_date, runtime,
    vote_average, vote_count,
    still_path, production_code
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7,
    $8, $9,
    $10, $11,
    $12, $13,
    $14, $15,
    $16, $17
)
ON CONFLICT (series_id, season_number, episode_number) DO UPDATE SET
    tmdb_id = EXCLUDED.tmdb_id,
    tvdb_id = EXCLUDED.tvdb_id,
    imdb_id = EXCLUDED.imdb_id,
    title = EXCLUDED.title,
    overview = EXCLUDED.overview,
    titles_i18n = EXCLUDED.titles_i18n,
    overviews_i18n = EXCLUDED.overviews_i18n,
    air_date = EXCLUDED.air_date,
    runtime = EXCLUDED.runtime,
    vote_average = EXCLUDED.vote_average,
    vote_count = EXCLUDED.vote_count,
    still_path = EXCLUDED.still_path,
    production_code = EXCLUDED.production_code
RETURNING id, series_id, season_id, tmdb_id, tvdb_id, imdb_id, season_number, episode_number, title, overview, titles_i18n, overviews_i18n, air_date, runtime, vote_average, vote_count, still_path, production_code, created_at, updated_at
`

type UpsertEpisodeParams struct {
	SeriesID       uuid.UUID       `json:"seriesId"`
	SeasonID       uuid.UUID       `json:"seasonId"`
	TmdbID         *int32          `json:"tmdbId"`
	TvdbID         *int32          `json:"tvdbId"`
	ImdbID         *string         `json:"imdbId"`
	SeasonNumber   int32           `json:"seasonNumber"`
	EpisodeNumber  int32           `json:"episodeNumber"`
	Title          string          `json:"title"`
	Overview       *string         `json:"overview"`
	TitlesI18n     json.RawMessage `json:"titlesI18n"`
	OverviewsI18n  json.RawMessage `json:"overviewsI18n"`
	AirDate        pgtype.Date     `json:"airDate"`
	Runtime        *int32          `json:"runtime"`
	VoteAverage    pgtype.Numeric  `json:"voteAverage"`
	VoteCount      *int32          `json:"voteCount"`
	StillPath      *string         `json:"stillPath"`
	ProductionCode *string         `json:"productionCode"`
}

func (q *Queries) UpsertEpisode(ctx context.Context, arg UpsertEpisodeParams) (TvshowEpisode, error) {
	row := q.db.QueryRow(ctx, upsertEpisode,
		arg.SeriesID,
		arg.SeasonID,
		arg.TmdbID,
		arg.TvdbID,
		arg.ImdbID,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.Title,
		arg.Overview,
		arg.TitlesI18n,
		arg.OverviewsI18n,
		arg.AirDate,
		arg.Runtime,
		arg.VoteAverage,
		arg.VoteCount,
		arg.StillPath,
		arg.ProductionCode,
	)
	var i TvshowEpisode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.TitlesI18n,
		&i.OverviewsI18n,
		&i.AirDate,
		&i.Runtime,
		&i.VoteAverage,
		&i.VoteCount,
		&i.StillPath,
		&i.ProductionCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
