// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: episodes.sql

package tvshowdb

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countEpisodes = `-- name: CountEpisodes :one
SELECT COUNT(*) FROM episodes WHERE series_id = $1
`

func (q *Queries) CountEpisodes(ctx context.Context, seriesID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEpisodes, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodesBySeason = `-- name: CountEpisodesBySeason :one
SELECT COUNT(*) FROM episodes WHERE season_id = $1
`

func (q *Queries) CountEpisodesBySeason(ctx context.Context, seasonID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEpisodesBySeason, seasonID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSpecialEpisodes = `-- name: CountSpecialEpisodes :one
SELECT COUNT(*) FROM episodes WHERE series_id = $1 AND season_number = 0
`

func (q *Queries) CountSpecialEpisodes(ctx context.Context, seriesID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSpecialEpisodes, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEpisode = `-- name: CreateEpisode :one
INSERT INTO episodes (
    series_id, season_id, path, container, size_bytes, runtime_ticks,
    season_number, episode_number, absolute_number,
    title, overview, production_code,
    air_date, air_date_utc,
    community_rating, vote_count,
    still_path, still_blurhash,
    tmdb_id, imdb_id, tvdb_id
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9,
    $10, $11, $12,
    $13, $14,
    $15, $16,
    $17, $18,
    $19, $20, $21
) RETURNING id, series_id, season_id, path, container, size_bytes, runtime_ticks, season_number, episode_number, absolute_number, title, overview, production_code, air_date, air_date_utc, community_rating, vote_count, still_path, still_blurhash, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at
`

type CreateEpisodeParams struct {
	SeriesID        uuid.UUID          `json:"seriesId"`
	SeasonID        uuid.UUID          `json:"seasonId"`
	Path            string             `json:"path"`
	Container       *string            `json:"container"`
	SizeBytes       *int64             `json:"sizeBytes"`
	RuntimeTicks    *int64             `json:"runtimeTicks"`
	SeasonNumber    int32              `json:"seasonNumber"`
	EpisodeNumber   int32              `json:"episodeNumber"`
	AbsoluteNumber  *int32             `json:"absoluteNumber"`
	Title           string             `json:"title"`
	Overview        *string            `json:"overview"`
	ProductionCode  *string            `json:"productionCode"`
	AirDate         pgtype.Date        `json:"airDate"`
	AirDateUtc      pgtype.Timestamptz `json:"airDateUtc"`
	CommunityRating pgtype.Numeric     `json:"communityRating"`
	VoteCount       *int32             `json:"voteCount"`
	StillPath       *string            `json:"stillPath"`
	StillBlurhash   *string            `json:"stillBlurhash"`
	TmdbID          *int32             `json:"tmdbId"`
	ImdbID          *string            `json:"imdbId"`
	TvdbID          *int32             `json:"tvdbId"`
}

func (q *Queries) CreateEpisode(ctx context.Context, arg CreateEpisodeParams) (Episode, error) {
	row := q.db.QueryRow(ctx, createEpisode,
		arg.SeriesID,
		arg.SeasonID,
		arg.Path,
		arg.Container,
		arg.SizeBytes,
		arg.RuntimeTicks,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.AbsoluteNumber,
		arg.Title,
		arg.Overview,
		arg.ProductionCode,
		arg.AirDate,
		arg.AirDateUtc,
		arg.CommunityRating,
		arg.VoteCount,
		arg.StillPath,
		arg.StillBlurhash,
		arg.TmdbID,
		arg.ImdbID,
		arg.TvdbID,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.AbsoluteNumber,
		&i.Title,
		&i.Overview,
		&i.ProductionCode,
		&i.AirDate,
		&i.AirDateUtc,
		&i.CommunityRating,
		&i.VoteCount,
		&i.StillPath,
		&i.StillBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEpisode = `-- name: DeleteEpisode :exec
DELETE FROM episodes WHERE id = $1
`

func (q *Queries) DeleteEpisode(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisode, id)
	return err
}

const deleteEpisodesBySeason = `-- name: DeleteEpisodesBySeason :exec
DELETE FROM episodes WHERE season_id = $1
`

func (q *Queries) DeleteEpisodesBySeason(ctx context.Context, seasonID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisodesBySeason, seasonID)
	return err
}

const deleteEpisodesBySeries = `-- name: DeleteEpisodesBySeries :exec
DELETE FROM episodes WHERE series_id = $1
`

func (q *Queries) DeleteEpisodesBySeries(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisodesBySeries, seriesID)
	return err
}

const episodeExistsByNumber = `-- name: EpisodeExistsByNumber :one
SELECT EXISTS(SELECT 1 FROM episodes WHERE series_id = $1 AND season_number = $2 AND episode_number = $3)
`

type EpisodeExistsByNumberParams struct {
	SeriesID      uuid.UUID `json:"seriesId"`
	SeasonNumber  int32     `json:"seasonNumber"`
	EpisodeNumber int32     `json:"episodeNumber"`
}

func (q *Queries) EpisodeExistsByNumber(ctx context.Context, arg EpisodeExistsByNumberParams) (bool, error) {
	row := q.db.QueryRow(ctx, episodeExistsByNumber, arg.SeriesID, arg.SeasonNumber, arg.EpisodeNumber)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const episodeExistsByPath = `-- name: EpisodeExistsByPath :one
SELECT EXISTS(SELECT 1 FROM episodes WHERE path = $1)
`

func (q *Queries) EpisodeExistsByPath(ctx context.Context, path string) (bool, error) {
	row := q.db.QueryRow(ctx, episodeExistsByPath, path)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getEpisodeByAbsoluteNumber = `-- name: GetEpisodeByAbsoluteNumber :one
SELECT id, series_id, season_id, path, container, size_bytes, runtime_ticks, season_number, episode_number, absolute_number, title, overview, production_code, air_date, air_date_utc, community_rating, vote_count, still_path, still_blurhash, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at FROM episodes
WHERE series_id = $1 AND absolute_number = $2
`

type GetEpisodeByAbsoluteNumberParams struct {
	SeriesID       uuid.UUID `json:"seriesId"`
	AbsoluteNumber *int32    `json:"absoluteNumber"`
}

func (q *Queries) GetEpisodeByAbsoluteNumber(ctx context.Context, arg GetEpisodeByAbsoluteNumberParams) (Episode, error) {
	row := q.db.QueryRow(ctx, getEpisodeByAbsoluteNumber, arg.SeriesID, arg.AbsoluteNumber)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.AbsoluteNumber,
		&i.Title,
		&i.Overview,
		&i.ProductionCode,
		&i.AirDate,
		&i.AirDateUtc,
		&i.CommunityRating,
		&i.VoteCount,
		&i.StillPath,
		&i.StillBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEpisodeByID = `-- name: GetEpisodeByID :one

SELECT id, series_id, season_id, path, container, size_bytes, runtime_ticks, season_number, episode_number, absolute_number, title, overview, production_code, air_date, air_date_utc, community_rating, vote_count, still_path, still_blurhash, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at FROM episodes WHERE id = $1
`

// Episode Queries
func (q *Queries) GetEpisodeByID(ctx context.Context, id uuid.UUID) (Episode, error) {
	row := q.db.QueryRow(ctx, getEpisodeByID, id)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.AbsoluteNumber,
		&i.Title,
		&i.Overview,
		&i.ProductionCode,
		&i.AirDate,
		&i.AirDateUtc,
		&i.CommunityRating,
		&i.VoteCount,
		&i.StillPath,
		&i.StillBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEpisodeByNumber = `-- name: GetEpisodeByNumber :one
SELECT id, series_id, season_id, path, container, size_bytes, runtime_ticks, season_number, episode_number, absolute_number, title, overview, production_code, air_date, air_date_utc, community_rating, vote_count, still_path, still_blurhash, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at FROM episodes
WHERE series_id = $1 AND season_number = $2 AND episode_number = $3
`

type GetEpisodeByNumberParams struct {
	SeriesID      uuid.UUID `json:"seriesId"`
	SeasonNumber  int32     `json:"seasonNumber"`
	EpisodeNumber int32     `json:"episodeNumber"`
}

func (q *Queries) GetEpisodeByNumber(ctx context.Context, arg GetEpisodeByNumberParams) (Episode, error) {
	row := q.db.QueryRow(ctx, getEpisodeByNumber, arg.SeriesID, arg.SeasonNumber, arg.EpisodeNumber)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.AbsoluteNumber,
		&i.Title,
		&i.Overview,
		&i.ProductionCode,
		&i.AirDate,
		&i.AirDateUtc,
		&i.CommunityRating,
		&i.VoteCount,
		&i.StillPath,
		&i.StillBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEpisodeByPath = `-- name: GetEpisodeByPath :one
SELECT id, series_id, season_id, path, container, size_bytes, runtime_ticks, season_number, episode_number, absolute_number, title, overview, production_code, air_date, air_date_utc, community_rating, vote_count, still_path, still_blurhash, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at FROM episodes WHERE path = $1
`

func (q *Queries) GetEpisodeByPath(ctx context.Context, path string) (Episode, error) {
	row := q.db.QueryRow(ctx, getEpisodeByPath, path)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.AbsoluteNumber,
		&i.Title,
		&i.Overview,
		&i.ProductionCode,
		&i.AirDate,
		&i.AirDateUtc,
		&i.CommunityRating,
		&i.VoteCount,
		&i.StillPath,
		&i.StillBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEpisodeByTmdbID = `-- name: GetEpisodeByTmdbID :one
SELECT id, series_id, season_id, path, container, size_bytes, runtime_ticks, season_number, episode_number, absolute_number, title, overview, production_code, air_date, air_date_utc, community_rating, vote_count, still_path, still_blurhash, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at FROM episodes WHERE series_id = $1 AND tmdb_id = $2
`

type GetEpisodeByTmdbIDParams struct {
	SeriesID uuid.UUID `json:"seriesId"`
	TmdbID   *int32    `json:"tmdbId"`
}

func (q *Queries) GetEpisodeByTmdbID(ctx context.Context, arg GetEpisodeByTmdbIDParams) (Episode, error) {
	row := q.db.QueryRow(ctx, getEpisodeByTmdbID, arg.SeriesID, arg.TmdbID)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.AbsoluteNumber,
		&i.Title,
		&i.Overview,
		&i.ProductionCode,
		&i.AirDate,
		&i.AirDateUtc,
		&i.CommunityRating,
		&i.VoteCount,
		&i.StillPath,
		&i.StillBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNextEpisode = `-- name: GetNextEpisode :one
SELECT id, series_id, season_id, path, container, size_bytes, runtime_ticks, season_number, episode_number, absolute_number, title, overview, production_code, air_date, air_date_utc, community_rating, vote_count, still_path, still_blurhash, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at FROM episodes
WHERE series_id = $1
  AND (season_number > $2 OR (season_number = $2 AND episode_number > $3))
  AND season_number > 0
ORDER BY season_number ASC, episode_number ASC
LIMIT 1
`

type GetNextEpisodeParams struct {
	SeriesID      uuid.UUID `json:"seriesId"`
	SeasonNumber  int32     `json:"seasonNumber"`
	EpisodeNumber int32     `json:"episodeNumber"`
}

func (q *Queries) GetNextEpisode(ctx context.Context, arg GetNextEpisodeParams) (Episode, error) {
	row := q.db.QueryRow(ctx, getNextEpisode, arg.SeriesID, arg.SeasonNumber, arg.EpisodeNumber)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.AbsoluteNumber,
		&i.Title,
		&i.Overview,
		&i.ProductionCode,
		&i.AirDate,
		&i.AirDateUtc,
		&i.CommunityRating,
		&i.VoteCount,
		&i.StillPath,
		&i.StillBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPreviousEpisode = `-- name: GetPreviousEpisode :one
SELECT id, series_id, season_id, path, container, size_bytes, runtime_ticks, season_number, episode_number, absolute_number, title, overview, production_code, air_date, air_date_utc, community_rating, vote_count, still_path, still_blurhash, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at FROM episodes
WHERE series_id = $1
  AND (season_number < $2 OR (season_number = $2 AND episode_number < $3))
  AND season_number > 0
ORDER BY season_number DESC, episode_number DESC
LIMIT 1
`

type GetPreviousEpisodeParams struct {
	SeriesID      uuid.UUID `json:"seriesId"`
	SeasonNumber  int32     `json:"seasonNumber"`
	EpisodeNumber int32     `json:"episodeNumber"`
}

func (q *Queries) GetPreviousEpisode(ctx context.Context, arg GetPreviousEpisodeParams) (Episode, error) {
	row := q.db.QueryRow(ctx, getPreviousEpisode, arg.SeriesID, arg.SeasonNumber, arg.EpisodeNumber)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.AbsoluteNumber,
		&i.Title,
		&i.Overview,
		&i.ProductionCode,
		&i.AirDate,
		&i.AirDateUtc,
		&i.CommunityRating,
		&i.VoteCount,
		&i.StillPath,
		&i.StillBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEpisodePaths = `-- name: ListEpisodePaths :many
SELECT id, path FROM episodes
WHERE series_id IN (SELECT id FROM series WHERE tv_library_id = $1)
`

type ListEpisodePathsRow struct {
	ID   uuid.UUID `json:"id"`
	Path string    `json:"path"`
}

func (q *Queries) ListEpisodePaths(ctx context.Context, tvLibraryID uuid.UUID) ([]ListEpisodePathsRow, error) {
	rows, err := q.db.Query(ctx, listEpisodePaths, tvLibraryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEpisodePathsRow{}
	for rows.Next() {
		var i ListEpisodePathsRow
		if err := rows.Scan(&i.ID, &i.Path); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodes = `-- name: ListEpisodes :many
SELECT id, series_id, season_id, path, container, size_bytes, runtime_ticks, season_number, episode_number, absolute_number, title, overview, production_code, air_date, air_date_utc, community_rating, vote_count, still_path, still_blurhash, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at FROM episodes
WHERE series_id = $1
ORDER BY season_number ASC, episode_number ASC
`

func (q *Queries) ListEpisodes(ctx context.Context, seriesID uuid.UUID) ([]Episode, error) {
	rows, err := q.db.Query(ctx, listEpisodes, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.AbsoluteNumber,
			&i.Title,
			&i.Overview,
			&i.ProductionCode,
			&i.AirDate,
			&i.AirDateUtc,
			&i.CommunityRating,
			&i.VoteCount,
			&i.StillPath,
			&i.StillBlurhash,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesBySeason = `-- name: ListEpisodesBySeason :many
SELECT id, series_id, season_id, path, container, size_bytes, runtime_ticks, season_number, episode_number, absolute_number, title, overview, production_code, air_date, air_date_utc, community_rating, vote_count, still_path, still_blurhash, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at FROM episodes
WHERE season_id = $1
ORDER BY episode_number ASC
`

func (q *Queries) ListEpisodesBySeason(ctx context.Context, seasonID uuid.UUID) ([]Episode, error) {
	rows, err := q.db.Query(ctx, listEpisodesBySeason, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.AbsoluteNumber,
			&i.Title,
			&i.Overview,
			&i.ProductionCode,
			&i.AirDate,
			&i.AirDateUtc,
			&i.CommunityRating,
			&i.VoteCount,
			&i.StillPath,
			&i.StillBlurhash,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesBySeasonNumber = `-- name: ListEpisodesBySeasonNumber :many
SELECT id, series_id, season_id, path, container, size_bytes, runtime_ticks, season_number, episode_number, absolute_number, title, overview, production_code, air_date, air_date_utc, community_rating, vote_count, still_path, still_blurhash, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at FROM episodes
WHERE series_id = $1 AND season_number = $2
ORDER BY episode_number ASC
`

type ListEpisodesBySeasonNumberParams struct {
	SeriesID     uuid.UUID `json:"seriesId"`
	SeasonNumber int32     `json:"seasonNumber"`
}

func (q *Queries) ListEpisodesBySeasonNumber(ctx context.Context, arg ListEpisodesBySeasonNumberParams) ([]Episode, error) {
	rows, err := q.db.Query(ctx, listEpisodesBySeasonNumber, arg.SeriesID, arg.SeasonNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.AbsoluteNumber,
			&i.Title,
			&i.Overview,
			&i.ProductionCode,
			&i.AirDate,
			&i.AirDateUtc,
			&i.CommunityRating,
			&i.VoteCount,
			&i.StillPath,
			&i.StillBlurhash,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentlyAddedEpisodes = `-- name: ListRecentlyAddedEpisodes :many
SELECT e.id, e.series_id, e.season_id, e.path, e.container, e.size_bytes, e.runtime_ticks, e.season_number, e.episode_number, e.absolute_number, e.title, e.overview, e.production_code, e.air_date, e.air_date_utc, e.community_rating, e.vote_count, e.still_path, e.still_blurhash, e.tmdb_id, e.imdb_id, e.tvdb_id, e.date_added, e.last_played_at, e.play_count, e.is_locked, e.created_at, e.updated_at, s.title as series_title, s.poster_path as series_poster
FROM episodes e
JOIN series s ON e.series_id = s.id
WHERE s.library_id = ANY($2::uuid[])
ORDER BY e.date_added DESC
LIMIT $1
`

type ListRecentlyAddedEpisodesParams struct {
	Limit      int32       `json:"limit"`
	LibraryIds []uuid.UUID `json:"libraryIds"`
}

type ListRecentlyAddedEpisodesRow struct {
	ID              uuid.UUID          `json:"id"`
	SeriesID        uuid.UUID          `json:"seriesId"`
	SeasonID        uuid.UUID          `json:"seasonId"`
	Path            string             `json:"path"`
	Container       *string            `json:"container"`
	SizeBytes       *int64             `json:"sizeBytes"`
	RuntimeTicks    *int64             `json:"runtimeTicks"`
	SeasonNumber    int32              `json:"seasonNumber"`
	EpisodeNumber   int32              `json:"episodeNumber"`
	AbsoluteNumber  *int32             `json:"absoluteNumber"`
	Title           string             `json:"title"`
	Overview        *string            `json:"overview"`
	ProductionCode  *string            `json:"productionCode"`
	AirDate         pgtype.Date        `json:"airDate"`
	AirDateUtc      pgtype.Timestamptz `json:"airDateUtc"`
	CommunityRating pgtype.Numeric     `json:"communityRating"`
	VoteCount       *int32             `json:"voteCount"`
	StillPath       *string            `json:"stillPath"`
	StillBlurhash   *string            `json:"stillBlurhash"`
	TmdbID          *int32             `json:"tmdbId"`
	ImdbID          *string            `json:"imdbId"`
	TvdbID          *int32             `json:"tvdbId"`
	DateAdded       time.Time          `json:"dateAdded"`
	LastPlayedAt    pgtype.Timestamptz `json:"lastPlayedAt"`
	PlayCount       int32              `json:"playCount"`
	IsLocked        bool               `json:"isLocked"`
	CreatedAt       time.Time          `json:"createdAt"`
	UpdatedAt       time.Time          `json:"updatedAt"`
	SeriesTitle     string             `json:"seriesTitle"`
	SeriesPoster    *string            `json:"seriesPoster"`
}

func (q *Queries) ListRecentlyAddedEpisodes(ctx context.Context, arg ListRecentlyAddedEpisodesParams) ([]ListRecentlyAddedEpisodesRow, error) {
	rows, err := q.db.Query(ctx, listRecentlyAddedEpisodes, arg.Limit, arg.LibraryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentlyAddedEpisodesRow{}
	for rows.Next() {
		var i ListRecentlyAddedEpisodesRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.AbsoluteNumber,
			&i.Title,
			&i.Overview,
			&i.ProductionCode,
			&i.AirDate,
			&i.AirDateUtc,
			&i.CommunityRating,
			&i.VoteCount,
			&i.StillPath,
			&i.StillBlurhash,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeriesTitle,
			&i.SeriesPoster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentlyAiredEpisodes = `-- name: ListRecentlyAiredEpisodes :many
SELECT e.id, e.series_id, e.season_id, e.path, e.container, e.size_bytes, e.runtime_ticks, e.season_number, e.episode_number, e.absolute_number, e.title, e.overview, e.production_code, e.air_date, e.air_date_utc, e.community_rating, e.vote_count, e.still_path, e.still_blurhash, e.tmdb_id, e.imdb_id, e.tvdb_id, e.date_added, e.last_played_at, e.play_count, e.is_locked, e.created_at, e.updated_at, s.title as series_title, s.poster_path as series_poster
FROM episodes e
JOIN series s ON e.series_id = s.id
WHERE s.library_id = ANY($2::uuid[])
  AND e.air_date IS NOT NULL
  AND e.air_date <= CURRENT_DATE
ORDER BY e.air_date DESC
LIMIT $1
`

type ListRecentlyAiredEpisodesParams struct {
	Limit      int32       `json:"limit"`
	LibraryIds []uuid.UUID `json:"libraryIds"`
}

type ListRecentlyAiredEpisodesRow struct {
	ID              uuid.UUID          `json:"id"`
	SeriesID        uuid.UUID          `json:"seriesId"`
	SeasonID        uuid.UUID          `json:"seasonId"`
	Path            string             `json:"path"`
	Container       *string            `json:"container"`
	SizeBytes       *int64             `json:"sizeBytes"`
	RuntimeTicks    *int64             `json:"runtimeTicks"`
	SeasonNumber    int32              `json:"seasonNumber"`
	EpisodeNumber   int32              `json:"episodeNumber"`
	AbsoluteNumber  *int32             `json:"absoluteNumber"`
	Title           string             `json:"title"`
	Overview        *string            `json:"overview"`
	ProductionCode  *string            `json:"productionCode"`
	AirDate         pgtype.Date        `json:"airDate"`
	AirDateUtc      pgtype.Timestamptz `json:"airDateUtc"`
	CommunityRating pgtype.Numeric     `json:"communityRating"`
	VoteCount       *int32             `json:"voteCount"`
	StillPath       *string            `json:"stillPath"`
	StillBlurhash   *string            `json:"stillBlurhash"`
	TmdbID          *int32             `json:"tmdbId"`
	ImdbID          *string            `json:"imdbId"`
	TvdbID          *int32             `json:"tvdbId"`
	DateAdded       time.Time          `json:"dateAdded"`
	LastPlayedAt    pgtype.Timestamptz `json:"lastPlayedAt"`
	PlayCount       int32              `json:"playCount"`
	IsLocked        bool               `json:"isLocked"`
	CreatedAt       time.Time          `json:"createdAt"`
	UpdatedAt       time.Time          `json:"updatedAt"`
	SeriesTitle     string             `json:"seriesTitle"`
	SeriesPoster    *string            `json:"seriesPoster"`
}

func (q *Queries) ListRecentlyAiredEpisodes(ctx context.Context, arg ListRecentlyAiredEpisodesParams) ([]ListRecentlyAiredEpisodesRow, error) {
	rows, err := q.db.Query(ctx, listRecentlyAiredEpisodes, arg.Limit, arg.LibraryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentlyAiredEpisodesRow{}
	for rows.Next() {
		var i ListRecentlyAiredEpisodesRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.AbsoluteNumber,
			&i.Title,
			&i.Overview,
			&i.ProductionCode,
			&i.AirDate,
			&i.AirDateUtc,
			&i.CommunityRating,
			&i.VoteCount,
			&i.StillPath,
			&i.StillBlurhash,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeriesTitle,
			&i.SeriesPoster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingEpisodes = `-- name: ListUpcomingEpisodes :many
SELECT e.id, e.series_id, e.season_id, e.path, e.container, e.size_bytes, e.runtime_ticks, e.season_number, e.episode_number, e.absolute_number, e.title, e.overview, e.production_code, e.air_date, e.air_date_utc, e.community_rating, e.vote_count, e.still_path, e.still_blurhash, e.tmdb_id, e.imdb_id, e.tvdb_id, e.date_added, e.last_played_at, e.play_count, e.is_locked, e.created_at, e.updated_at, s.title as series_title, s.poster_path as series_poster
FROM episodes e
JOIN series s ON e.series_id = s.id
WHERE s.library_id = ANY($2::uuid[])
  AND e.air_date IS NOT NULL
  AND e.air_date > CURRENT_DATE
ORDER BY e.air_date ASC
LIMIT $1
`

type ListUpcomingEpisodesParams struct {
	Limit      int32       `json:"limit"`
	LibraryIds []uuid.UUID `json:"libraryIds"`
}

type ListUpcomingEpisodesRow struct {
	ID              uuid.UUID          `json:"id"`
	SeriesID        uuid.UUID          `json:"seriesId"`
	SeasonID        uuid.UUID          `json:"seasonId"`
	Path            string             `json:"path"`
	Container       *string            `json:"container"`
	SizeBytes       *int64             `json:"sizeBytes"`
	RuntimeTicks    *int64             `json:"runtimeTicks"`
	SeasonNumber    int32              `json:"seasonNumber"`
	EpisodeNumber   int32              `json:"episodeNumber"`
	AbsoluteNumber  *int32             `json:"absoluteNumber"`
	Title           string             `json:"title"`
	Overview        *string            `json:"overview"`
	ProductionCode  *string            `json:"productionCode"`
	AirDate         pgtype.Date        `json:"airDate"`
	AirDateUtc      pgtype.Timestamptz `json:"airDateUtc"`
	CommunityRating pgtype.Numeric     `json:"communityRating"`
	VoteCount       *int32             `json:"voteCount"`
	StillPath       *string            `json:"stillPath"`
	StillBlurhash   *string            `json:"stillBlurhash"`
	TmdbID          *int32             `json:"tmdbId"`
	ImdbID          *string            `json:"imdbId"`
	TvdbID          *int32             `json:"tvdbId"`
	DateAdded       time.Time          `json:"dateAdded"`
	LastPlayedAt    pgtype.Timestamptz `json:"lastPlayedAt"`
	PlayCount       int32              `json:"playCount"`
	IsLocked        bool               `json:"isLocked"`
	CreatedAt       time.Time          `json:"createdAt"`
	UpdatedAt       time.Time          `json:"updatedAt"`
	SeriesTitle     string             `json:"seriesTitle"`
	SeriesPoster    *string            `json:"seriesPoster"`
}

func (q *Queries) ListUpcomingEpisodes(ctx context.Context, arg ListUpcomingEpisodesParams) ([]ListUpcomingEpisodesRow, error) {
	rows, err := q.db.Query(ctx, listUpcomingEpisodes, arg.Limit, arg.LibraryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUpcomingEpisodesRow{}
	for rows.Next() {
		var i ListUpcomingEpisodesRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonID,
			&i.Path,
			&i.Container,
			&i.SizeBytes,
			&i.RuntimeTicks,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.AbsoluteNumber,
			&i.Title,
			&i.Overview,
			&i.ProductionCode,
			&i.AirDate,
			&i.AirDateUtc,
			&i.CommunityRating,
			&i.VoteCount,
			&i.StillPath,
			&i.StillBlurhash,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeriesTitle,
			&i.SeriesPoster,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEpisode = `-- name: UpdateEpisode :one
UPDATE episodes SET
    season_id = COALESCE($1, season_id),
    container = COALESCE($2, container),
    size_bytes = COALESCE($3, size_bytes),
    runtime_ticks = COALESCE($4, runtime_ticks),
    season_number = COALESCE($5, season_number),
    episode_number = COALESCE($6, episode_number),
    absolute_number = COALESCE($7, absolute_number),
    title = COALESCE($8, title),
    overview = COALESCE($9, overview),
    production_code = COALESCE($10, production_code),
    air_date = COALESCE($11, air_date),
    air_date_utc = COALESCE($12, air_date_utc),
    community_rating = COALESCE($13, community_rating),
    vote_count = COALESCE($14, vote_count),
    still_path = COALESCE($15, still_path),
    still_blurhash = COALESCE($16, still_blurhash),
    tmdb_id = COALESCE($17, tmdb_id),
    imdb_id = COALESCE($18, imdb_id),
    tvdb_id = COALESCE($19, tvdb_id),
    is_locked = COALESCE($20, is_locked)
WHERE id = $21
RETURNING id, series_id, season_id, path, container, size_bytes, runtime_ticks, season_number, episode_number, absolute_number, title, overview, production_code, air_date, air_date_utc, community_rating, vote_count, still_path, still_blurhash, tmdb_id, imdb_id, tvdb_id, date_added, last_played_at, play_count, is_locked, created_at, updated_at
`

type UpdateEpisodeParams struct {
	SeasonID        pgtype.UUID        `json:"seasonId"`
	Container       *string            `json:"container"`
	SizeBytes       *int64             `json:"sizeBytes"`
	RuntimeTicks    *int64             `json:"runtimeTicks"`
	SeasonNumber    *int32             `json:"seasonNumber"`
	EpisodeNumber   *int32             `json:"episodeNumber"`
	AbsoluteNumber  *int32             `json:"absoluteNumber"`
	Title           *string            `json:"title"`
	Overview        *string            `json:"overview"`
	ProductionCode  *string            `json:"productionCode"`
	AirDate         pgtype.Date        `json:"airDate"`
	AirDateUtc      pgtype.Timestamptz `json:"airDateUtc"`
	CommunityRating pgtype.Numeric     `json:"communityRating"`
	VoteCount       *int32             `json:"voteCount"`
	StillPath       *string            `json:"stillPath"`
	StillBlurhash   *string            `json:"stillBlurhash"`
	TmdbID          *int32             `json:"tmdbId"`
	ImdbID          *string            `json:"imdbId"`
	TvdbID          *int32             `json:"tvdbId"`
	IsLocked        *bool              `json:"isLocked"`
	ID              uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateEpisode(ctx context.Context, arg UpdateEpisodeParams) (Episode, error) {
	row := q.db.QueryRow(ctx, updateEpisode,
		arg.SeasonID,
		arg.Container,
		arg.SizeBytes,
		arg.RuntimeTicks,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.AbsoluteNumber,
		arg.Title,
		arg.Overview,
		arg.ProductionCode,
		arg.AirDate,
		arg.AirDateUtc,
		arg.CommunityRating,
		arg.VoteCount,
		arg.StillPath,
		arg.StillBlurhash,
		arg.TmdbID,
		arg.ImdbID,
		arg.TvdbID,
		arg.IsLocked,
		arg.ID,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.Path,
		&i.Container,
		&i.SizeBytes,
		&i.RuntimeTicks,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.AbsoluteNumber,
		&i.Title,
		&i.Overview,
		&i.ProductionCode,
		&i.AirDate,
		&i.AirDateUtc,
		&i.CommunityRating,
		&i.VoteCount,
		&i.StillPath,
		&i.StillBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEpisodePlaybackStats = `-- name: UpdateEpisodePlaybackStats :exec
UPDATE episodes SET
    last_played_at = NOW(),
    play_count = play_count + 1
WHERE id = $1
`

func (q *Queries) UpdateEpisodePlaybackStats(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateEpisodePlaybackStats, id)
	return err
}
