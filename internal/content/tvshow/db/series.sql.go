// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: series.sql

package tvshowdb

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countSeries = `-- name: CountSeries :one
SELECT COUNT(*) FROM tvshow.series
`

func (q *Queries) CountSeries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSeries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSeries = `-- name: CreateSeries :one
INSERT INTO tvshow.series (
    tmdb_id, tvdb_id, imdb_id, sonarr_id,
    title, tagline, overview,
    titles_i18n, taglines_i18n, overviews_i18n, age_ratings,
    original_language, original_title,
    status, type, first_air_date, last_air_date,
    vote_average, vote_count, popularity,
    poster_path, backdrop_path,
    total_seasons, total_episodes,
    trailer_url, homepage,
    metadata_updated_at
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7,
    $8, $9, $10, $11,
    $12, $13,
    $14, $15, $16, $17,
    $18, $19, $20,
    $21, $22,
    $23, $24,
    $25, $26,
    $27
)
RETURNING id, tmdb_id, tvdb_id, imdb_id, sonarr_id, title, tagline, overview, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, original_language, original_title, status, type, first_air_date, last_air_date, vote_average, vote_count, popularity, poster_path, backdrop_path, total_seasons, total_episodes, trailer_url, homepage, metadata_updated_at, created_at, updated_at
`

type CreateSeriesParams struct {
	TmdbID            *int32             `json:"tmdbId"`
	TvdbID            *int32             `json:"tvdbId"`
	ImdbID            *string            `json:"imdbId"`
	SonarrID          *int32             `json:"sonarrId"`
	Title             string             `json:"title"`
	Tagline           *string            `json:"tagline"`
	Overview          *string            `json:"overview"`
	TitlesI18n        json.RawMessage    `json:"titlesI18n"`
	TaglinesI18n      json.RawMessage    `json:"taglinesI18n"`
	OverviewsI18n     json.RawMessage    `json:"overviewsI18n"`
	AgeRatings        json.RawMessage    `json:"ageRatings"`
	OriginalLanguage  string             `json:"originalLanguage"`
	OriginalTitle     *string            `json:"originalTitle"`
	Status            *string            `json:"status"`
	Type              *string            `json:"type"`
	FirstAirDate      pgtype.Date        `json:"firstAirDate"`
	LastAirDate       pgtype.Date        `json:"lastAirDate"`
	VoteAverage       pgtype.Numeric     `json:"voteAverage"`
	VoteCount         *int32             `json:"voteCount"`
	Popularity        pgtype.Numeric     `json:"popularity"`
	PosterPath        *string            `json:"posterPath"`
	BackdropPath      *string            `json:"backdropPath"`
	TotalSeasons      int32              `json:"totalSeasons"`
	TotalEpisodes     int32              `json:"totalEpisodes"`
	TrailerUrl        *string            `json:"trailerUrl"`
	Homepage          *string            `json:"homepage"`
	MetadataUpdatedAt pgtype.Timestamptz `json:"metadataUpdatedAt"`
}

func (q *Queries) CreateSeries(ctx context.Context, arg CreateSeriesParams) (TvshowSeries, error) {
	row := q.db.QueryRow(ctx, createSeries,
		arg.TmdbID,
		arg.TvdbID,
		arg.ImdbID,
		arg.SonarrID,
		arg.Title,
		arg.Tagline,
		arg.Overview,
		arg.TitlesI18n,
		arg.TaglinesI18n,
		arg.OverviewsI18n,
		arg.AgeRatings,
		arg.OriginalLanguage,
		arg.OriginalTitle,
		arg.Status,
		arg.Type,
		arg.FirstAirDate,
		arg.LastAirDate,
		arg.VoteAverage,
		arg.VoteCount,
		arg.Popularity,
		arg.PosterPath,
		arg.BackdropPath,
		arg.TotalSeasons,
		arg.TotalEpisodes,
		arg.TrailerUrl,
		arg.Homepage,
		arg.MetadataUpdatedAt,
	)
	var i TvshowSeries
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SonarrID,
		&i.Title,
		&i.Tagline,
		&i.Overview,
		&i.TitlesI18n,
		&i.TaglinesI18n,
		&i.OverviewsI18n,
		&i.AgeRatings,
		&i.OriginalLanguage,
		&i.OriginalTitle,
		&i.Status,
		&i.Type,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.PosterPath,
		&i.BackdropPath,
		&i.TotalSeasons,
		&i.TotalEpisodes,
		&i.TrailerUrl,
		&i.Homepage,
		&i.MetadataUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSeries = `-- name: DeleteSeries :exec
DELETE FROM tvshow.series WHERE id = $1
`

func (q *Queries) DeleteSeries(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeries, id)
	return err
}

const getSeries = `-- name: GetSeries :one
SELECT id, tmdb_id, tvdb_id, imdb_id, sonarr_id, title, tagline, overview, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, original_language, original_title, status, type, first_air_date, last_air_date, vote_average, vote_count, popularity, poster_path, backdrop_path, total_seasons, total_episodes, trailer_url, homepage, metadata_updated_at, created_at, updated_at FROM tvshow.series WHERE id = $1
`

func (q *Queries) GetSeries(ctx context.Context, id uuid.UUID) (TvshowSeries, error) {
	row := q.db.QueryRow(ctx, getSeries, id)
	var i TvshowSeries
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SonarrID,
		&i.Title,
		&i.Tagline,
		&i.Overview,
		&i.TitlesI18n,
		&i.TaglinesI18n,
		&i.OverviewsI18n,
		&i.AgeRatings,
		&i.OriginalLanguage,
		&i.OriginalTitle,
		&i.Status,
		&i.Type,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.PosterPath,
		&i.BackdropPath,
		&i.TotalSeasons,
		&i.TotalEpisodes,
		&i.TrailerUrl,
		&i.Homepage,
		&i.MetadataUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeriesBySonarrID = `-- name: GetSeriesBySonarrID :one
SELECT id, tmdb_id, tvdb_id, imdb_id, sonarr_id, title, tagline, overview, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, original_language, original_title, status, type, first_air_date, last_air_date, vote_average, vote_count, popularity, poster_path, backdrop_path, total_seasons, total_episodes, trailer_url, homepage, metadata_updated_at, created_at, updated_at FROM tvshow.series WHERE sonarr_id = $1
`

func (q *Queries) GetSeriesBySonarrID(ctx context.Context, sonarrID *int32) (TvshowSeries, error) {
	row := q.db.QueryRow(ctx, getSeriesBySonarrID, sonarrID)
	var i TvshowSeries
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SonarrID,
		&i.Title,
		&i.Tagline,
		&i.Overview,
		&i.TitlesI18n,
		&i.TaglinesI18n,
		&i.OverviewsI18n,
		&i.AgeRatings,
		&i.OriginalLanguage,
		&i.OriginalTitle,
		&i.Status,
		&i.Type,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.PosterPath,
		&i.BackdropPath,
		&i.TotalSeasons,
		&i.TotalEpisodes,
		&i.TrailerUrl,
		&i.Homepage,
		&i.MetadataUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeriesByTMDbID = `-- name: GetSeriesByTMDbID :one
SELECT id, tmdb_id, tvdb_id, imdb_id, sonarr_id, title, tagline, overview, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, original_language, original_title, status, type, first_air_date, last_air_date, vote_average, vote_count, popularity, poster_path, backdrop_path, total_seasons, total_episodes, trailer_url, homepage, metadata_updated_at, created_at, updated_at FROM tvshow.series WHERE tmdb_id = $1
`

func (q *Queries) GetSeriesByTMDbID(ctx context.Context, tmdbID *int32) (TvshowSeries, error) {
	row := q.db.QueryRow(ctx, getSeriesByTMDbID, tmdbID)
	var i TvshowSeries
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SonarrID,
		&i.Title,
		&i.Tagline,
		&i.Overview,
		&i.TitlesI18n,
		&i.TaglinesI18n,
		&i.OverviewsI18n,
		&i.AgeRatings,
		&i.OriginalLanguage,
		&i.OriginalTitle,
		&i.Status,
		&i.Type,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.PosterPath,
		&i.BackdropPath,
		&i.TotalSeasons,
		&i.TotalEpisodes,
		&i.TrailerUrl,
		&i.Homepage,
		&i.MetadataUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeriesByTVDbID = `-- name: GetSeriesByTVDbID :one
SELECT id, tmdb_id, tvdb_id, imdb_id, sonarr_id, title, tagline, overview, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, original_language, original_title, status, type, first_air_date, last_air_date, vote_average, vote_count, popularity, poster_path, backdrop_path, total_seasons, total_episodes, trailer_url, homepage, metadata_updated_at, created_at, updated_at FROM tvshow.series WHERE tvdb_id = $1
`

func (q *Queries) GetSeriesByTVDbID(ctx context.Context, tvdbID *int32) (TvshowSeries, error) {
	row := q.db.QueryRow(ctx, getSeriesByTVDbID, tvdbID)
	var i TvshowSeries
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SonarrID,
		&i.Title,
		&i.Tagline,
		&i.Overview,
		&i.TitlesI18n,
		&i.TaglinesI18n,
		&i.OverviewsI18n,
		&i.AgeRatings,
		&i.OriginalLanguage,
		&i.OriginalTitle,
		&i.Status,
		&i.Type,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.PosterPath,
		&i.BackdropPath,
		&i.TotalSeasons,
		&i.TotalEpisodes,
		&i.TrailerUrl,
		&i.Homepage,
		&i.MetadataUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRecentlyAddedSeries = `-- name: ListRecentlyAddedSeries :many
SELECT id, tmdb_id, tvdb_id, imdb_id, sonarr_id, title, tagline, overview, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, original_language, original_title, status, type, first_air_date, last_air_date, vote_average, vote_count, popularity, poster_path, backdrop_path, total_seasons, total_episodes, trailer_url, homepage, metadata_updated_at, created_at, updated_at FROM tvshow.series
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListRecentlyAddedSeriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListRecentlyAddedSeries(ctx context.Context, arg ListRecentlyAddedSeriesParams) ([]TvshowSeries, error) {
	rows, err := q.db.Query(ctx, listRecentlyAddedSeries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowSeries{}
	for rows.Next() {
		var i TvshowSeries
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SonarrID,
			&i.Title,
			&i.Tagline,
			&i.Overview,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.OriginalLanguage,
			&i.OriginalTitle,
			&i.Status,
			&i.Type,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TotalSeasons,
			&i.TotalEpisodes,
			&i.TrailerUrl,
			&i.Homepage,
			&i.MetadataUpdatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeries = `-- name: ListSeries :many
SELECT id, tmdb_id, tvdb_id, imdb_id, sonarr_id, title, tagline, overview, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, original_language, original_title, status, type, first_air_date, last_air_date, vote_average, vote_count, popularity, poster_path, backdrop_path, total_seasons, total_episodes, trailer_url, homepage, metadata_updated_at, created_at, updated_at FROM tvshow.series
ORDER BY
    CASE WHEN $3::text = 'title' AND $4::text = 'asc' THEN title END ASC,
    CASE WHEN $3::text = 'title' AND $4::text = 'desc' THEN title END DESC,
    CASE WHEN $3::text = 'first_air_date' AND $4::text = 'asc' THEN first_air_date END ASC,
    CASE WHEN $3::text = 'first_air_date' AND $4::text = 'desc' THEN first_air_date END DESC,
    CASE WHEN $3::text = 'created_at' AND $4::text = 'asc' THEN created_at END ASC,
    CASE WHEN $3::text = 'created_at' AND $4::text = 'desc' THEN created_at END DESC,
    created_at DESC
LIMIT $1 OFFSET $2
`

type ListSeriesParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	SortBy    string `json:"sortBy"`
	SortOrder string `json:"sortOrder"`
}

func (q *Queries) ListSeries(ctx context.Context, arg ListSeriesParams) ([]TvshowSeries, error) {
	rows, err := q.db.Query(ctx, listSeries,
		arg.Limit,
		arg.Offset,
		arg.SortBy,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowSeries{}
	for rows.Next() {
		var i TvshowSeries
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SonarrID,
			&i.Title,
			&i.Tagline,
			&i.Overview,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.OriginalLanguage,
			&i.OriginalTitle,
			&i.Status,
			&i.Type,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TotalSeasons,
			&i.TotalEpisodes,
			&i.TrailerUrl,
			&i.Homepage,
			&i.MetadataUpdatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesByStatus = `-- name: ListSeriesByStatus :many
SELECT id, tmdb_id, tvdb_id, imdb_id, sonarr_id, title, tagline, overview, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, original_language, original_title, status, type, first_air_date, last_air_date, vote_average, vote_count, popularity, poster_path, backdrop_path, total_seasons, total_episodes, trailer_url, homepage, metadata_updated_at, created_at, updated_at FROM tvshow.series
WHERE status = $1
ORDER BY first_air_date DESC
LIMIT $2 OFFSET $3
`

type ListSeriesByStatusParams struct {
	Status *string `json:"status"`
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
}

func (q *Queries) ListSeriesByStatus(ctx context.Context, arg ListSeriesByStatusParams) ([]TvshowSeries, error) {
	rows, err := q.db.Query(ctx, listSeriesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowSeries{}
	for rows.Next() {
		var i TvshowSeries
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SonarrID,
			&i.Title,
			&i.Tagline,
			&i.Overview,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.OriginalLanguage,
			&i.OriginalTitle,
			&i.Status,
			&i.Type,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TotalSeasons,
			&i.TotalEpisodes,
			&i.TrailerUrl,
			&i.Homepage,
			&i.MetadataUpdatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSeriesByTitle = `-- name: SearchSeriesByTitle :many
SELECT id, tmdb_id, tvdb_id, imdb_id, sonarr_id, title, tagline, overview, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, original_language, original_title, status, type, first_air_date, last_air_date, vote_average, vote_count, popularity, poster_path, backdrop_path, total_seasons, total_episodes, trailer_url, homepage, metadata_updated_at, created_at, updated_at FROM tvshow.series
WHERE title ILIKE '%' || $1 || '%'
   OR original_title ILIKE '%' || $1 || '%'
ORDER BY
    CASE
        WHEN LOWER(title) = LOWER($1) THEN 0
        WHEN LOWER(title) LIKE LOWER($1) || '%' THEN 1
        ELSE 2
    END,
    popularity DESC NULLS LAST
LIMIT $2 OFFSET $3
`

type SearchSeriesByTitleParams struct {
	Column1 *string `json:"column1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

func (q *Queries) SearchSeriesByTitle(ctx context.Context, arg SearchSeriesByTitleParams) ([]TvshowSeries, error) {
	rows, err := q.db.Query(ctx, searchSeriesByTitle, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowSeries{}
	for rows.Next() {
		var i TvshowSeries
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SonarrID,
			&i.Title,
			&i.Tagline,
			&i.Overview,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.OriginalLanguage,
			&i.OriginalTitle,
			&i.Status,
			&i.Type,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TotalSeasons,
			&i.TotalEpisodes,
			&i.TrailerUrl,
			&i.Homepage,
			&i.MetadataUpdatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSeriesByTitleAnyLanguage = `-- name: SearchSeriesByTitleAnyLanguage :many
SELECT id, tmdb_id, tvdb_id, imdb_id, sonarr_id, title, tagline, overview, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, original_language, original_title, status, type, first_air_date, last_air_date, vote_average, vote_count, popularity, poster_path, backdrop_path, total_seasons, total_episodes, trailer_url, homepage, metadata_updated_at, created_at, updated_at FROM tvshow.series
WHERE title ILIKE '%' || $1 || '%'
   OR original_title ILIKE '%' || $1 || '%'
   OR titles_i18n::text ILIKE '%' || $1 || '%'
ORDER BY
    CASE
        WHEN LOWER(title) = LOWER($1) THEN 0
        WHEN LOWER(title) LIKE LOWER($1) || '%' THEN 1
        ELSE 2
    END,
    popularity DESC NULLS LAST
LIMIT $2 OFFSET $3
`

type SearchSeriesByTitleAnyLanguageParams struct {
	Column1 *string `json:"column1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

func (q *Queries) SearchSeriesByTitleAnyLanguage(ctx context.Context, arg SearchSeriesByTitleAnyLanguageParams) ([]TvshowSeries, error) {
	rows, err := q.db.Query(ctx, searchSeriesByTitleAnyLanguage, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TvshowSeries{}
	for rows.Next() {
		var i TvshowSeries
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SonarrID,
			&i.Title,
			&i.Tagline,
			&i.Overview,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.OriginalLanguage,
			&i.OriginalTitle,
			&i.Status,
			&i.Type,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TotalSeasons,
			&i.TotalEpisodes,
			&i.TrailerUrl,
			&i.Homepage,
			&i.MetadataUpdatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSeries = `-- name: UpdateSeries :one
UPDATE tvshow.series SET
    tmdb_id = COALESCE($1, tmdb_id),
    tvdb_id = COALESCE($2, tvdb_id),
    imdb_id = COALESCE($3, imdb_id),
    sonarr_id = COALESCE($4, sonarr_id),
    title = COALESCE($5, title),
    tagline = COALESCE($6, tagline),
    overview = COALESCE($7, overview),
    titles_i18n = COALESCE($8, titles_i18n),
    taglines_i18n = COALESCE($9, taglines_i18n),
    overviews_i18n = COALESCE($10, overviews_i18n),
    age_ratings = COALESCE($11, age_ratings),
    original_language = COALESCE($12, original_language),
    original_title = COALESCE($13, original_title),
    status = COALESCE($14, status),
    type = COALESCE($15, type),
    first_air_date = COALESCE($16, first_air_date),
    last_air_date = COALESCE($17, last_air_date),
    vote_average = COALESCE($18, vote_average),
    vote_count = COALESCE($19, vote_count),
    popularity = COALESCE($20, popularity),
    poster_path = COALESCE($21, poster_path),
    backdrop_path = COALESCE($22, backdrop_path),
    total_seasons = COALESCE($23, total_seasons),
    total_episodes = COALESCE($24, total_episodes),
    trailer_url = COALESCE($25, trailer_url),
    homepage = COALESCE($26, homepage),
    metadata_updated_at = COALESCE($27, metadata_updated_at)
WHERE id = $28
RETURNING id, tmdb_id, tvdb_id, imdb_id, sonarr_id, title, tagline, overview, titles_i18n, taglines_i18n, overviews_i18n, age_ratings, original_language, original_title, status, type, first_air_date, last_air_date, vote_average, vote_count, popularity, poster_path, backdrop_path, total_seasons, total_episodes, trailer_url, homepage, metadata_updated_at, created_at, updated_at
`

type UpdateSeriesParams struct {
	TmdbID            *int32             `json:"tmdbId"`
	TvdbID            *int32             `json:"tvdbId"`
	ImdbID            *string            `json:"imdbId"`
	SonarrID          *int32             `json:"sonarrId"`
	Title             *string            `json:"title"`
	Tagline           *string            `json:"tagline"`
	Overview          *string            `json:"overview"`
	TitlesI18n        []byte             `json:"titlesI18n"`
	TaglinesI18n      []byte             `json:"taglinesI18n"`
	OverviewsI18n     []byte             `json:"overviewsI18n"`
	AgeRatings        []byte             `json:"ageRatings"`
	OriginalLanguage  *string            `json:"originalLanguage"`
	OriginalTitle     *string            `json:"originalTitle"`
	Status            *string            `json:"status"`
	Type              *string            `json:"type"`
	FirstAirDate      pgtype.Date        `json:"firstAirDate"`
	LastAirDate       pgtype.Date        `json:"lastAirDate"`
	VoteAverage       pgtype.Numeric     `json:"voteAverage"`
	VoteCount         *int32             `json:"voteCount"`
	Popularity        pgtype.Numeric     `json:"popularity"`
	PosterPath        *string            `json:"posterPath"`
	BackdropPath      *string            `json:"backdropPath"`
	TotalSeasons      *int32             `json:"totalSeasons"`
	TotalEpisodes     *int32             `json:"totalEpisodes"`
	TrailerUrl        *string            `json:"trailerUrl"`
	Homepage          *string            `json:"homepage"`
	MetadataUpdatedAt pgtype.Timestamptz `json:"metadataUpdatedAt"`
	ID                uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateSeries(ctx context.Context, arg UpdateSeriesParams) (TvshowSeries, error) {
	row := q.db.QueryRow(ctx, updateSeries,
		arg.TmdbID,
		arg.TvdbID,
		arg.ImdbID,
		arg.SonarrID,
		arg.Title,
		arg.Tagline,
		arg.Overview,
		arg.TitlesI18n,
		arg.TaglinesI18n,
		arg.OverviewsI18n,
		arg.AgeRatings,
		arg.OriginalLanguage,
		arg.OriginalTitle,
		arg.Status,
		arg.Type,
		arg.FirstAirDate,
		arg.LastAirDate,
		arg.VoteAverage,
		arg.VoteCount,
		arg.Popularity,
		arg.PosterPath,
		arg.BackdropPath,
		arg.TotalSeasons,
		arg.TotalEpisodes,
		arg.TrailerUrl,
		arg.Homepage,
		arg.MetadataUpdatedAt,
		arg.ID,
	)
	var i TvshowSeries
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SonarrID,
		&i.Title,
		&i.Tagline,
		&i.Overview,
		&i.TitlesI18n,
		&i.TaglinesI18n,
		&i.OverviewsI18n,
		&i.AgeRatings,
		&i.OriginalLanguage,
		&i.OriginalTitle,
		&i.Status,
		&i.Type,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.PosterPath,
		&i.BackdropPath,
		&i.TotalSeasons,
		&i.TotalEpisodes,
		&i.TrailerUrl,
		&i.Homepage,
		&i.MetadataUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSeriesStats = `-- name: UpdateSeriesStats :exec
UPDATE tvshow.series SET
    total_seasons = (SELECT COUNT(*) FROM tvshow.seasons se WHERE se.series_id = $1),
    total_episodes = (SELECT COUNT(*) FROM tvshow.episodes ep WHERE ep.series_id = $1)
WHERE id = $1
`

func (q *Queries) UpdateSeriesStats(ctx context.Context, seriesID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateSeriesStats, seriesID)
	return err
}
