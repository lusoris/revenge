// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: series.sql

package tvshowdb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countSeries = `-- name: CountSeries :one
SELECT COUNT(*) FROM series
`

func (q *Queries) CountSeries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSeries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSeriesByLibrary = `-- name: CountSeriesByLibrary :one
SELECT COUNT(*) FROM series WHERE library_id = $1
`

func (q *Queries) CountSeriesByLibrary(ctx context.Context, libraryID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSeriesByLibrary, libraryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSeries = `-- name: CreateSeries :one
INSERT INTO series (
    library_id, title, sort_title, original_title, tagline, overview,
    first_air_date, last_air_date, year, status, type,
    content_rating, rating_level, community_rating, vote_count,
    poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path,
    tmdb_id, imdb_id, tvdb_id,
    network_name, network_logo_path
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11,
    $12, $13, $14, $15,
    $16, $17, $18, $19, $20,
    $21, $22, $23,
    $24, $25
) RETURNING id, library_id, title, sort_title, original_title, tagline, overview, first_air_date, last_air_date, year, status, type, content_rating, rating_level, community_rating, vote_count, season_count, episode_count, special_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, network_name, network_logo_path, date_added, last_played_at, is_locked, created_at, updated_at
`

type CreateSeriesParams struct {
	LibraryID        uuid.UUID      `json:"libraryId"`
	Title            string         `json:"title"`
	SortTitle        *string        `json:"sortTitle"`
	OriginalTitle    *string        `json:"originalTitle"`
	Tagline          *string        `json:"tagline"`
	Overview         *string        `json:"overview"`
	FirstAirDate     pgtype.Date    `json:"firstAirDate"`
	LastAirDate      pgtype.Date    `json:"lastAirDate"`
	Year             *int32         `json:"year"`
	Status           *string        `json:"status"`
	Type             *string        `json:"type"`
	ContentRating    *string        `json:"contentRating"`
	RatingLevel      *int32         `json:"ratingLevel"`
	CommunityRating  pgtype.Numeric `json:"communityRating"`
	VoteCount        *int32         `json:"voteCount"`
	PosterPath       *string        `json:"posterPath"`
	PosterBlurhash   *string        `json:"posterBlurhash"`
	BackdropPath     *string        `json:"backdropPath"`
	BackdropBlurhash *string        `json:"backdropBlurhash"`
	LogoPath         *string        `json:"logoPath"`
	TmdbID           *int32         `json:"tmdbId"`
	ImdbID           *string        `json:"imdbId"`
	TvdbID           *int32         `json:"tvdbId"`
	NetworkName      *string        `json:"networkName"`
	NetworkLogoPath  *string        `json:"networkLogoPath"`
}

func (q *Queries) CreateSeries(ctx context.Context, arg CreateSeriesParams) (Series, error) {
	row := q.db.QueryRow(ctx, createSeries,
		arg.LibraryID,
		arg.Title,
		arg.SortTitle,
		arg.OriginalTitle,
		arg.Tagline,
		arg.Overview,
		arg.FirstAirDate,
		arg.LastAirDate,
		arg.Year,
		arg.Status,
		arg.Type,
		arg.ContentRating,
		arg.RatingLevel,
		arg.CommunityRating,
		arg.VoteCount,
		arg.PosterPath,
		arg.PosterBlurhash,
		arg.BackdropPath,
		arg.BackdropBlurhash,
		arg.LogoPath,
		arg.TmdbID,
		arg.ImdbID,
		arg.TvdbID,
		arg.NetworkName,
		arg.NetworkLogoPath,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.Year,
		&i.Status,
		&i.Type,
		&i.ContentRating,
		&i.RatingLevel,
		&i.CommunityRating,
		&i.VoteCount,
		&i.SeasonCount,
		&i.EpisodeCount,
		&i.SpecialCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.NetworkName,
		&i.NetworkLogoPath,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSeries = `-- name: DeleteSeries :exec
DELETE FROM series WHERE id = $1
`

func (q *Queries) DeleteSeries(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeries, id)
	return err
}

const deleteSeriesByLibrary = `-- name: DeleteSeriesByLibrary :exec
DELETE FROM series WHERE library_id = $1
`

func (q *Queries) DeleteSeriesByLibrary(ctx context.Context, libraryID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeriesByLibrary, libraryID)
	return err
}

const getSeriesByID = `-- name: GetSeriesByID :one

SELECT id, library_id, title, sort_title, original_title, tagline, overview, first_air_date, last_air_date, year, status, type, content_rating, rating_level, community_rating, vote_count, season_count, episode_count, special_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, network_name, network_logo_path, date_added, last_played_at, is_locked, created_at, updated_at FROM series WHERE id = $1
`

// TV Series Core Queries
func (q *Queries) GetSeriesByID(ctx context.Context, id uuid.UUID) (Series, error) {
	row := q.db.QueryRow(ctx, getSeriesByID, id)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.Year,
		&i.Status,
		&i.Type,
		&i.ContentRating,
		&i.RatingLevel,
		&i.CommunityRating,
		&i.VoteCount,
		&i.SeasonCount,
		&i.EpisodeCount,
		&i.SpecialCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.NetworkName,
		&i.NetworkLogoPath,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeriesByImdbID = `-- name: GetSeriesByImdbID :one
SELECT id, library_id, title, sort_title, original_title, tagline, overview, first_air_date, last_air_date, year, status, type, content_rating, rating_level, community_rating, vote_count, season_count, episode_count, special_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, network_name, network_logo_path, date_added, last_played_at, is_locked, created_at, updated_at FROM series WHERE imdb_id = $1
`

func (q *Queries) GetSeriesByImdbID(ctx context.Context, imdbID *string) (Series, error) {
	row := q.db.QueryRow(ctx, getSeriesByImdbID, imdbID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.Year,
		&i.Status,
		&i.Type,
		&i.ContentRating,
		&i.RatingLevel,
		&i.CommunityRating,
		&i.VoteCount,
		&i.SeasonCount,
		&i.EpisodeCount,
		&i.SpecialCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.NetworkName,
		&i.NetworkLogoPath,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeriesByPath = `-- name: GetSeriesByPath :one
SELECT s.id, s.library_id, s.title, s.sort_title, s.original_title, s.tagline, s.overview, s.first_air_date, s.last_air_date, s.year, s.status, s.type, s.content_rating, s.rating_level, s.community_rating, s.vote_count, s.season_count, s.episode_count, s.special_count, s.poster_path, s.poster_blurhash, s.backdrop_path, s.backdrop_blurhash, s.logo_path, s.tmdb_id, s.imdb_id, s.tvdb_id, s.network_name, s.network_logo_path, s.date_added, s.last_played_at, s.is_locked, s.created_at, s.updated_at FROM series s
JOIN episodes e ON e.series_id = s.id
WHERE e.path = $1
LIMIT 1
`

func (q *Queries) GetSeriesByPath(ctx context.Context, path string) (Series, error) {
	row := q.db.QueryRow(ctx, getSeriesByPath, path)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.Year,
		&i.Status,
		&i.Type,
		&i.ContentRating,
		&i.RatingLevel,
		&i.CommunityRating,
		&i.VoteCount,
		&i.SeasonCount,
		&i.EpisodeCount,
		&i.SpecialCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.NetworkName,
		&i.NetworkLogoPath,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeriesByTmdbID = `-- name: GetSeriesByTmdbID :one
SELECT id, library_id, title, sort_title, original_title, tagline, overview, first_air_date, last_air_date, year, status, type, content_rating, rating_level, community_rating, vote_count, season_count, episode_count, special_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, network_name, network_logo_path, date_added, last_played_at, is_locked, created_at, updated_at FROM series WHERE tmdb_id = $1
`

func (q *Queries) GetSeriesByTmdbID(ctx context.Context, tmdbID *int32) (Series, error) {
	row := q.db.QueryRow(ctx, getSeriesByTmdbID, tmdbID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.Year,
		&i.Status,
		&i.Type,
		&i.ContentRating,
		&i.RatingLevel,
		&i.CommunityRating,
		&i.VoteCount,
		&i.SeasonCount,
		&i.EpisodeCount,
		&i.SpecialCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.NetworkName,
		&i.NetworkLogoPath,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeriesByTvdbID = `-- name: GetSeriesByTvdbID :one
SELECT id, library_id, title, sort_title, original_title, tagline, overview, first_air_date, last_air_date, year, status, type, content_rating, rating_level, community_rating, vote_count, season_count, episode_count, special_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, network_name, network_logo_path, date_added, last_played_at, is_locked, created_at, updated_at FROM series WHERE tvdb_id = $1
`

func (q *Queries) GetSeriesByTvdbID(ctx context.Context, tvdbID *int32) (Series, error) {
	row := q.db.QueryRow(ctx, getSeriesByTvdbID, tvdbID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.Year,
		&i.Status,
		&i.Type,
		&i.ContentRating,
		&i.RatingLevel,
		&i.CommunityRating,
		&i.VoteCount,
		&i.SeasonCount,
		&i.EpisodeCount,
		&i.SpecialCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.NetworkName,
		&i.NetworkLogoPath,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCurrentlyAiringSeries = `-- name: ListCurrentlyAiringSeries :many
SELECT id, library_id, title, sort_title, original_title, tagline, overview, first_air_date, last_air_date, year, status, type, content_rating, rating_level, community_rating, vote_count, season_count, episode_count, special_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, network_name, network_logo_path, date_added, last_played_at, is_locked, created_at, updated_at FROM series
WHERE library_id = ANY($2::uuid[])
  AND status IN ('Returning Series', 'In Production')
ORDER BY last_air_date DESC NULLS LAST
LIMIT $1
`

type ListCurrentlyAiringSeriesParams struct {
	Limit      int32       `json:"limit"`
	LibraryIds []uuid.UUID `json:"libraryIds"`
}

func (q *Queries) ListCurrentlyAiringSeries(ctx context.Context, arg ListCurrentlyAiringSeriesParams) ([]Series, error) {
	rows, err := q.db.Query(ctx, listCurrentlyAiringSeries, arg.Limit, arg.LibraryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.Year,
			&i.Status,
			&i.Type,
			&i.ContentRating,
			&i.RatingLevel,
			&i.CommunityRating,
			&i.VoteCount,
			&i.SeasonCount,
			&i.EpisodeCount,
			&i.SpecialCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.NetworkName,
			&i.NetworkLogoPath,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentlyAddedSeries = `-- name: ListRecentlyAddedSeries :many
SELECT id, library_id, title, sort_title, original_title, tagline, overview, first_air_date, last_air_date, year, status, type, content_rating, rating_level, community_rating, vote_count, season_count, episode_count, special_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, network_name, network_logo_path, date_added, last_played_at, is_locked, created_at, updated_at FROM series
WHERE library_id = ANY($2::uuid[])
ORDER BY date_added DESC
LIMIT $1
`

type ListRecentlyAddedSeriesParams struct {
	Limit      int32       `json:"limit"`
	LibraryIds []uuid.UUID `json:"libraryIds"`
}

func (q *Queries) ListRecentlyAddedSeries(ctx context.Context, arg ListRecentlyAddedSeriesParams) ([]Series, error) {
	rows, err := q.db.Query(ctx, listRecentlyAddedSeries, arg.Limit, arg.LibraryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.Year,
			&i.Status,
			&i.Type,
			&i.ContentRating,
			&i.RatingLevel,
			&i.CommunityRating,
			&i.VoteCount,
			&i.SeasonCount,
			&i.EpisodeCount,
			&i.SpecialCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.NetworkName,
			&i.NetworkLogoPath,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentlyPlayedSeries = `-- name: ListRecentlyPlayedSeries :many
SELECT id, library_id, title, sort_title, original_title, tagline, overview, first_air_date, last_air_date, year, status, type, content_rating, rating_level, community_rating, vote_count, season_count, episode_count, special_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, network_name, network_logo_path, date_added, last_played_at, is_locked, created_at, updated_at FROM series
WHERE library_id = ANY($2::uuid[])
  AND last_played_at IS NOT NULL
ORDER BY last_played_at DESC
LIMIT $1
`

type ListRecentlyPlayedSeriesParams struct {
	Limit      int32       `json:"limit"`
	LibraryIds []uuid.UUID `json:"libraryIds"`
}

func (q *Queries) ListRecentlyPlayedSeries(ctx context.Context, arg ListRecentlyPlayedSeriesParams) ([]Series, error) {
	rows, err := q.db.Query(ctx, listRecentlyPlayedSeries, arg.Limit, arg.LibraryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.Year,
			&i.Status,
			&i.Type,
			&i.ContentRating,
			&i.RatingLevel,
			&i.CommunityRating,
			&i.VoteCount,
			&i.SeasonCount,
			&i.EpisodeCount,
			&i.SpecialCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.NetworkName,
			&i.NetworkLogoPath,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeries = `-- name: ListSeries :many
SELECT id, library_id, title, sort_title, original_title, tagline, overview, first_air_date, last_air_date, year, status, type, content_rating, rating_level, community_rating, vote_count, season_count, episode_count, special_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, network_name, network_logo_path, date_added, last_played_at, is_locked, created_at, updated_at FROM series
ORDER BY
    CASE WHEN $3::text = 'title' AND $4::text = 'asc' THEN sort_title END ASC,
    CASE WHEN $3::text = 'title' AND $4::text = 'desc' THEN sort_title END DESC,
    CASE WHEN $3::text = 'date_added' AND $4::text = 'asc' THEN date_added END ASC,
    CASE WHEN $3::text = 'date_added' AND $4::text = 'desc' THEN date_added END DESC,
    CASE WHEN $3::text = 'first_air_date' AND $4::text = 'asc' THEN first_air_date END ASC,
    CASE WHEN $3::text = 'first_air_date' AND $4::text = 'desc' THEN first_air_date END DESC,
    CASE WHEN $3::text = 'rating' AND $4::text = 'asc' THEN community_rating END ASC NULLS LAST,
    CASE WHEN $3::text = 'rating' AND $4::text = 'desc' THEN community_rating END DESC NULLS LAST,
    sort_title ASC
LIMIT $1 OFFSET $2
`

type ListSeriesParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	SortBy    string `json:"sortBy"`
	SortOrder string `json:"sortOrder"`
}

func (q *Queries) ListSeries(ctx context.Context, arg ListSeriesParams) ([]Series, error) {
	rows, err := q.db.Query(ctx, listSeries,
		arg.Limit,
		arg.Offset,
		arg.SortBy,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.Year,
			&i.Status,
			&i.Type,
			&i.ContentRating,
			&i.RatingLevel,
			&i.CommunityRating,
			&i.VoteCount,
			&i.SeasonCount,
			&i.EpisodeCount,
			&i.SpecialCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.NetworkName,
			&i.NetworkLogoPath,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesByLibrary = `-- name: ListSeriesByLibrary :many
SELECT id, library_id, title, sort_title, original_title, tagline, overview, first_air_date, last_air_date, year, status, type, content_rating, rating_level, community_rating, vote_count, season_count, episode_count, special_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, network_name, network_logo_path, date_added, last_played_at, is_locked, created_at, updated_at FROM series
WHERE library_id = $1
ORDER BY
    CASE WHEN $4::text = 'title' AND $5::text = 'asc' THEN sort_title END ASC,
    CASE WHEN $4::text = 'title' AND $5::text = 'desc' THEN sort_title END DESC,
    CASE WHEN $4::text = 'date_added' AND $5::text = 'asc' THEN date_added END ASC,
    CASE WHEN $4::text = 'date_added' AND $5::text = 'desc' THEN date_added END DESC,
    CASE WHEN $4::text = 'first_air_date' AND $5::text = 'asc' THEN first_air_date END ASC,
    CASE WHEN $4::text = 'first_air_date' AND $5::text = 'desc' THEN first_air_date END DESC,
    CASE WHEN $4::text = 'rating' AND $5::text = 'asc' THEN community_rating END ASC NULLS LAST,
    CASE WHEN $4::text = 'rating' AND $5::text = 'desc' THEN community_rating END DESC NULLS LAST,
    sort_title ASC
LIMIT $2 OFFSET $3
`

type ListSeriesByLibraryParams struct {
	LibraryID uuid.UUID `json:"libraryId"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
	SortBy    string    `json:"sortBy"`
	SortOrder string    `json:"sortOrder"`
}

func (q *Queries) ListSeriesByLibrary(ctx context.Context, arg ListSeriesByLibraryParams) ([]Series, error) {
	rows, err := q.db.Query(ctx, listSeriesByLibrary,
		arg.LibraryID,
		arg.Limit,
		arg.Offset,
		arg.SortBy,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.Year,
			&i.Status,
			&i.Type,
			&i.ContentRating,
			&i.RatingLevel,
			&i.CommunityRating,
			&i.VoteCount,
			&i.SeasonCount,
			&i.EpisodeCount,
			&i.SpecialCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.NetworkName,
			&i.NetworkLogoPath,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesPaths = `-- name: ListSeriesPaths :many
SELECT DISTINCT s.id, e.path FROM series s
JOIN episodes e ON e.series_id = s.id
WHERE s.library_id = $1
`

type ListSeriesPathsRow struct {
	ID   uuid.UUID `json:"id"`
	Path string    `json:"path"`
}

func (q *Queries) ListSeriesPaths(ctx context.Context, libraryID uuid.UUID) ([]ListSeriesPathsRow, error) {
	rows, err := q.db.Query(ctx, listSeriesPaths, libraryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSeriesPathsRow{}
	for rows.Next() {
		var i ListSeriesPathsRow
		if err := rows.Scan(&i.ID, &i.Path); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSeries = `-- name: SearchSeries :many
SELECT id, library_id, title, sort_title, original_title, tagline, overview, first_air_date, last_air_date, year, status, type, content_rating, rating_level, community_rating, vote_count, season_count, episode_count, special_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, network_name, network_logo_path, date_added, last_played_at, is_locked, created_at, updated_at FROM series
WHERE to_tsvector('english', COALESCE(title, '') || ' ' || COALESCE(original_title, '') || ' ' || COALESCE(overview, ''))
      @@ plainto_tsquery('english', $1)
ORDER BY ts_rank(
    to_tsvector('english', COALESCE(title, '') || ' ' || COALESCE(original_title, '') || ' ' || COALESCE(overview, '')),
    plainto_tsquery('english', $1)
) DESC
LIMIT $2 OFFSET $3
`

type SearchSeriesParams struct {
	PlaintoTsquery string `json:"plaintoTsquery"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

func (q *Queries) SearchSeries(ctx context.Context, arg SearchSeriesParams) ([]Series, error) {
	rows, err := q.db.Query(ctx, searchSeries, arg.PlaintoTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.LibraryID,
			&i.Title,
			&i.SortTitle,
			&i.OriginalTitle,
			&i.Tagline,
			&i.Overview,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.Year,
			&i.Status,
			&i.Type,
			&i.ContentRating,
			&i.RatingLevel,
			&i.CommunityRating,
			&i.VoteCount,
			&i.SeasonCount,
			&i.EpisodeCount,
			&i.SpecialCount,
			&i.PosterPath,
			&i.PosterBlurhash,
			&i.BackdropPath,
			&i.BackdropBlurhash,
			&i.LogoPath,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.NetworkName,
			&i.NetworkLogoPath,
			&i.DateAdded,
			&i.LastPlayedAt,
			&i.IsLocked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const seriesExistsByTmdbID = `-- name: SeriesExistsByTmdbID :one
SELECT EXISTS(SELECT 1 FROM series WHERE tmdb_id = $1)
`

func (q *Queries) SeriesExistsByTmdbID(ctx context.Context, tmdbID *int32) (bool, error) {
	row := q.db.QueryRow(ctx, seriesExistsByTmdbID, tmdbID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const seriesExistsByTvdbID = `-- name: SeriesExistsByTvdbID :one
SELECT EXISTS(SELECT 1 FROM series WHERE tvdb_id = $1)
`

func (q *Queries) SeriesExistsByTvdbID(ctx context.Context, tvdbID *int32) (bool, error) {
	row := q.db.QueryRow(ctx, seriesExistsByTvdbID, tvdbID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateSeries = `-- name: UpdateSeries :one
UPDATE series SET
    title = COALESCE($1, title),
    sort_title = COALESCE($2, sort_title),
    original_title = COALESCE($3, original_title),
    tagline = COALESCE($4, tagline),
    overview = COALESCE($5, overview),
    first_air_date = COALESCE($6, first_air_date),
    last_air_date = COALESCE($7, last_air_date),
    year = COALESCE($8, year),
    status = COALESCE($9, status),
    type = COALESCE($10, type),
    content_rating = COALESCE($11, content_rating),
    rating_level = COALESCE($12, rating_level),
    community_rating = COALESCE($13, community_rating),
    vote_count = COALESCE($14, vote_count),
    poster_path = COALESCE($15, poster_path),
    poster_blurhash = COALESCE($16, poster_blurhash),
    backdrop_path = COALESCE($17, backdrop_path),
    backdrop_blurhash = COALESCE($18, backdrop_blurhash),
    logo_path = COALESCE($19, logo_path),
    tmdb_id = COALESCE($20, tmdb_id),
    imdb_id = COALESCE($21, imdb_id),
    tvdb_id = COALESCE($22, tvdb_id),
    network_name = COALESCE($23, network_name),
    network_logo_path = COALESCE($24, network_logo_path),
    is_locked = COALESCE($25, is_locked)
WHERE id = $26
RETURNING id, library_id, title, sort_title, original_title, tagline, overview, first_air_date, last_air_date, year, status, type, content_rating, rating_level, community_rating, vote_count, season_count, episode_count, special_count, poster_path, poster_blurhash, backdrop_path, backdrop_blurhash, logo_path, tmdb_id, imdb_id, tvdb_id, network_name, network_logo_path, date_added, last_played_at, is_locked, created_at, updated_at
`

type UpdateSeriesParams struct {
	Title            *string        `json:"title"`
	SortTitle        *string        `json:"sortTitle"`
	OriginalTitle    *string        `json:"originalTitle"`
	Tagline          *string        `json:"tagline"`
	Overview         *string        `json:"overview"`
	FirstAirDate     pgtype.Date    `json:"firstAirDate"`
	LastAirDate      pgtype.Date    `json:"lastAirDate"`
	Year             *int32         `json:"year"`
	Status           *string        `json:"status"`
	Type             *string        `json:"type"`
	ContentRating    *string        `json:"contentRating"`
	RatingLevel      *int32         `json:"ratingLevel"`
	CommunityRating  pgtype.Numeric `json:"communityRating"`
	VoteCount        *int32         `json:"voteCount"`
	PosterPath       *string        `json:"posterPath"`
	PosterBlurhash   *string        `json:"posterBlurhash"`
	BackdropPath     *string        `json:"backdropPath"`
	BackdropBlurhash *string        `json:"backdropBlurhash"`
	LogoPath         *string        `json:"logoPath"`
	TmdbID           *int32         `json:"tmdbId"`
	ImdbID           *string        `json:"imdbId"`
	TvdbID           *int32         `json:"tvdbId"`
	NetworkName      *string        `json:"networkName"`
	NetworkLogoPath  *string        `json:"networkLogoPath"`
	IsLocked         *bool          `json:"isLocked"`
	ID               uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateSeries(ctx context.Context, arg UpdateSeriesParams) (Series, error) {
	row := q.db.QueryRow(ctx, updateSeries,
		arg.Title,
		arg.SortTitle,
		arg.OriginalTitle,
		arg.Tagline,
		arg.Overview,
		arg.FirstAirDate,
		arg.LastAirDate,
		arg.Year,
		arg.Status,
		arg.Type,
		arg.ContentRating,
		arg.RatingLevel,
		arg.CommunityRating,
		arg.VoteCount,
		arg.PosterPath,
		arg.PosterBlurhash,
		arg.BackdropPath,
		arg.BackdropBlurhash,
		arg.LogoPath,
		arg.TmdbID,
		arg.ImdbID,
		arg.TvdbID,
		arg.NetworkName,
		arg.NetworkLogoPath,
		arg.IsLocked,
		arg.ID,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.LibraryID,
		&i.Title,
		&i.SortTitle,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Overview,
		&i.FirstAirDate,
		&i.LastAirDate,
		&i.Year,
		&i.Status,
		&i.Type,
		&i.ContentRating,
		&i.RatingLevel,
		&i.CommunityRating,
		&i.VoteCount,
		&i.SeasonCount,
		&i.EpisodeCount,
		&i.SpecialCount,
		&i.PosterPath,
		&i.PosterBlurhash,
		&i.BackdropPath,
		&i.BackdropBlurhash,
		&i.LogoPath,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.NetworkName,
		&i.NetworkLogoPath,
		&i.DateAdded,
		&i.LastPlayedAt,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSeriesPlaybackStats = `-- name: UpdateSeriesPlaybackStats :exec
UPDATE series SET last_played_at = NOW() WHERE id = $1
`

func (q *Queries) UpdateSeriesPlaybackStats(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateSeriesPlaybackStats, id)
	return err
}
