// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: watch_progress.sql

package tvshowdb

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOrUpdateWatchProgress = `-- name: CreateOrUpdateWatchProgress :one
INSERT INTO tvshow.episode_watched (
    user_id, episode_id, progress_seconds, duration_seconds, is_completed, watch_count, last_watched_at
) VALUES (
    $1, $2, $3, $4, $5, 1, NOW()
)
ON CONFLICT (user_id, episode_id) DO UPDATE SET
    progress_seconds = $3,
    duration_seconds = $4,
    is_completed = $5,
    watch_count = CASE WHEN $5 AND NOT tvshow.episode_watched.is_completed THEN tvshow.episode_watched.watch_count + 1 ELSE tvshow.episode_watched.watch_count END,
    last_watched_at = NOW()
RETURNING id, user_id, episode_id, progress_seconds, duration_seconds, is_completed, watch_count, last_watched_at, created_at, updated_at
`

type CreateOrUpdateWatchProgressParams struct {
	UserID          uuid.UUID `json:"userId"`
	EpisodeID       uuid.UUID `json:"episodeId"`
	ProgressSeconds int32     `json:"progressSeconds"`
	DurationSeconds int32     `json:"durationSeconds"`
	IsCompleted     bool      `json:"isCompleted"`
}

func (q *Queries) CreateOrUpdateWatchProgress(ctx context.Context, arg CreateOrUpdateWatchProgressParams) (TvshowEpisodeWatched, error) {
	row := q.db.QueryRow(ctx, createOrUpdateWatchProgress,
		arg.UserID,
		arg.EpisodeID,
		arg.ProgressSeconds,
		arg.DurationSeconds,
		arg.IsCompleted,
	)
	var i TvshowEpisodeWatched
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EpisodeID,
		&i.ProgressSeconds,
		&i.DurationSeconds,
		&i.IsCompleted,
		&i.WatchCount,
		&i.LastWatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSeriesWatchProgress = `-- name: DeleteSeriesWatchProgress :exec
DELETE FROM tvshow.episode_watched
WHERE user_id = $1 AND episode_id IN (
    SELECT id FROM tvshow.episodes WHERE series_id = $2
)
`

type DeleteSeriesWatchProgressParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

func (q *Queries) DeleteSeriesWatchProgress(ctx context.Context, arg DeleteSeriesWatchProgressParams) error {
	_, err := q.db.Exec(ctx, deleteSeriesWatchProgress, arg.UserID, arg.SeriesID)
	return err
}

const deleteWatchProgress = `-- name: DeleteWatchProgress :exec
DELETE FROM tvshow.episode_watched
WHERE user_id = $1 AND episode_id = $2
`

type DeleteWatchProgressParams struct {
	UserID    uuid.UUID `json:"userId"`
	EpisodeID uuid.UUID `json:"episodeId"`
}

func (q *Queries) DeleteWatchProgress(ctx context.Context, arg DeleteWatchProgressParams) error {
	_, err := q.db.Exec(ctx, deleteWatchProgress, arg.UserID, arg.EpisodeID)
	return err
}

const getEpisodeWatchProgress = `-- name: GetEpisodeWatchProgress :one
SELECT id, user_id, episode_id, progress_seconds, duration_seconds, is_completed, watch_count, last_watched_at, created_at, updated_at FROM tvshow.episode_watched
WHERE user_id = $1 AND episode_id = $2
`

type GetEpisodeWatchProgressParams struct {
	UserID    uuid.UUID `json:"userId"`
	EpisodeID uuid.UUID `json:"episodeId"`
}

func (q *Queries) GetEpisodeWatchProgress(ctx context.Context, arg GetEpisodeWatchProgressParams) (TvshowEpisodeWatched, error) {
	row := q.db.QueryRow(ctx, getEpisodeWatchProgress, arg.UserID, arg.EpisodeID)
	var i TvshowEpisodeWatched
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EpisodeID,
		&i.ProgressSeconds,
		&i.DurationSeconds,
		&i.IsCompleted,
		&i.WatchCount,
		&i.LastWatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNextUnwatchedEpisode = `-- name: GetNextUnwatchedEpisode :one
SELECT e.id, e.series_id, e.season_id, e.tmdb_id, e.tvdb_id, e.imdb_id, e.season_number, e.episode_number, e.title, e.overview, e.titles_i18n, e.overviews_i18n, e.air_date, e.runtime, e.vote_average, e.vote_count, e.still_path, e.production_code, e.created_at, e.updated_at
FROM tvshow.episodes e
LEFT JOIN tvshow.episode_watched ew ON e.id = ew.episode_id AND ew.user_id = $1
WHERE e.series_id = $2
    AND (ew.is_completed IS NULL OR ew.is_completed = FALSE)
ORDER BY e.season_number ASC, e.episode_number ASC
LIMIT 1
`

type GetNextUnwatchedEpisodeParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

func (q *Queries) GetNextUnwatchedEpisode(ctx context.Context, arg GetNextUnwatchedEpisodeParams) (TvshowEpisode, error) {
	row := q.db.QueryRow(ctx, getNextUnwatchedEpisode, arg.UserID, arg.SeriesID)
	var i TvshowEpisode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonID,
		&i.TmdbID,
		&i.TvdbID,
		&i.ImdbID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.TitlesI18n,
		&i.OverviewsI18n,
		&i.AirDate,
		&i.Runtime,
		&i.VoteAverage,
		&i.VoteCount,
		&i.StillPath,
		&i.ProductionCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeriesWatchStats = `-- name: GetSeriesWatchStats :one
SELECT
    COUNT(*) FILTER (WHERE ew.is_completed = TRUE) as watched_count,
    COUNT(*) FILTER (WHERE ew.is_completed = FALSE AND ew.progress_seconds > 0) as in_progress_count,
    SUM(ew.watch_count) as total_watches,
    (SELECT COUNT(*) FROM tvshow.episodes ep WHERE ep.series_id = $2) as total_episodes
FROM tvshow.episode_watched ew
JOIN tvshow.episodes e ON ew.episode_id = e.id
WHERE ew.user_id = $1 AND e.series_id = $2
`

type GetSeriesWatchStatsParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

type GetSeriesWatchStatsRow struct {
	WatchedCount    int64 `json:"watchedCount"`
	InProgressCount int64 `json:"inProgressCount"`
	TotalWatches    int64 `json:"totalWatches"`
	TotalEpisodes   int64 `json:"totalEpisodes"`
}

func (q *Queries) GetSeriesWatchStats(ctx context.Context, arg GetSeriesWatchStatsParams) (GetSeriesWatchStatsRow, error) {
	row := q.db.QueryRow(ctx, getSeriesWatchStats, arg.UserID, arg.SeriesID)
	var i GetSeriesWatchStatsRow
	err := row.Scan(
		&i.WatchedCount,
		&i.InProgressCount,
		&i.TotalWatches,
		&i.TotalEpisodes,
	)
	return i, err
}

const getUserTVStats = `-- name: GetUserTVStats :one
SELECT
    COUNT(DISTINCT e.series_id) as series_count,
    COUNT(*) FILTER (WHERE ew.is_completed = TRUE) as episodes_watched,
    COUNT(*) FILTER (WHERE ew.is_completed = FALSE AND ew.progress_seconds > 0) as episodes_in_progress,
    COALESCE(SUM(ew.watch_count), 0) as total_watches
FROM tvshow.episode_watched ew
JOIN tvshow.episodes e ON ew.episode_id = e.id
WHERE ew.user_id = $1
`

type GetUserTVStatsRow struct {
	SeriesCount        int64       `json:"seriesCount"`
	EpisodesWatched    int64       `json:"episodesWatched"`
	EpisodesInProgress int64       `json:"episodesInProgress"`
	TotalWatches       interface{} `json:"totalWatches"`
}

func (q *Queries) GetUserTVStats(ctx context.Context, userID uuid.UUID) (GetUserTVStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserTVStats, userID)
	var i GetUserTVStatsRow
	err := row.Scan(
		&i.SeriesCount,
		&i.EpisodesWatched,
		&i.EpisodesInProgress,
		&i.TotalWatches,
	)
	return i, err
}

const listContinueWatchingSeries = `-- name: ListContinueWatchingSeries :many
SELECT DISTINCT ON (s.id)
    s.id, s.tmdb_id, s.tvdb_id, s.imdb_id, s.sonarr_id, s.title, s.tagline, s.overview, s.titles_i18n, s.taglines_i18n, s.overviews_i18n, s.age_ratings, s.original_language, s.original_title, s.status, s.type, s.first_air_date, s.last_air_date, s.vote_average, s.vote_count, s.popularity, s.poster_path, s.backdrop_path, s.total_seasons, s.total_episodes, s.trailer_url, s.homepage, s.metadata_updated_at, s.created_at, s.updated_at,
    e.id as last_episode_id,
    e.season_number as last_season_number,
    e.episode_number as last_episode_number,
    e.title as last_episode_title,
    ew.progress_seconds,
    ew.duration_seconds,
    ew.last_watched_at
FROM tvshow.episode_watched ew
JOIN tvshow.episodes e ON ew.episode_id = e.id
JOIN tvshow.series s ON e.series_id = s.id
WHERE ew.user_id = $1
    AND NOT ew.is_completed
    AND ew.progress_seconds > 0
ORDER BY s.id, ew.last_watched_at DESC
LIMIT $2
`

type ListContinueWatchingSeriesParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
}

type ListContinueWatchingSeriesRow struct {
	ID                uuid.UUID          `json:"id"`
	TmdbID            *int32             `json:"tmdbId"`
	TvdbID            *int32             `json:"tvdbId"`
	ImdbID            *string            `json:"imdbId"`
	SonarrID          *int32             `json:"sonarrId"`
	Title             string             `json:"title"`
	Tagline           *string            `json:"tagline"`
	Overview          *string            `json:"overview"`
	TitlesI18n        json.RawMessage    `json:"titlesI18n"`
	TaglinesI18n      json.RawMessage    `json:"taglinesI18n"`
	OverviewsI18n     json.RawMessage    `json:"overviewsI18n"`
	AgeRatings        json.RawMessage    `json:"ageRatings"`
	OriginalLanguage  string             `json:"originalLanguage"`
	OriginalTitle     *string            `json:"originalTitle"`
	Status            *string            `json:"status"`
	Type              *string            `json:"type"`
	FirstAirDate      pgtype.Date        `json:"firstAirDate"`
	LastAirDate       pgtype.Date        `json:"lastAirDate"`
	VoteAverage       pgtype.Numeric     `json:"voteAverage"`
	VoteCount         *int32             `json:"voteCount"`
	Popularity        pgtype.Numeric     `json:"popularity"`
	PosterPath        *string            `json:"posterPath"`
	BackdropPath      *string            `json:"backdropPath"`
	TotalSeasons      int32              `json:"totalSeasons"`
	TotalEpisodes     int32              `json:"totalEpisodes"`
	TrailerUrl        *string            `json:"trailerUrl"`
	Homepage          *string            `json:"homepage"`
	MetadataUpdatedAt pgtype.Timestamptz `json:"metadataUpdatedAt"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
	LastEpisodeID     uuid.UUID          `json:"lastEpisodeId"`
	LastSeasonNumber  int32              `json:"lastSeasonNumber"`
	LastEpisodeNumber int32              `json:"lastEpisodeNumber"`
	LastEpisodeTitle  string             `json:"lastEpisodeTitle"`
	ProgressSeconds   int32              `json:"progressSeconds"`
	DurationSeconds   int32              `json:"durationSeconds"`
	LastWatchedAt     pgtype.Timestamptz `json:"lastWatchedAt"`
}

func (q *Queries) ListContinueWatchingSeries(ctx context.Context, arg ListContinueWatchingSeriesParams) ([]ListContinueWatchingSeriesRow, error) {
	rows, err := q.db.Query(ctx, listContinueWatchingSeries, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContinueWatchingSeriesRow{}
	for rows.Next() {
		var i ListContinueWatchingSeriesRow
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.TvdbID,
			&i.ImdbID,
			&i.SonarrID,
			&i.Title,
			&i.Tagline,
			&i.Overview,
			&i.TitlesI18n,
			&i.TaglinesI18n,
			&i.OverviewsI18n,
			&i.AgeRatings,
			&i.OriginalLanguage,
			&i.OriginalTitle,
			&i.Status,
			&i.Type,
			&i.FirstAirDate,
			&i.LastAirDate,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Popularity,
			&i.PosterPath,
			&i.BackdropPath,
			&i.TotalSeasons,
			&i.TotalEpisodes,
			&i.TrailerUrl,
			&i.Homepage,
			&i.MetadataUpdatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastEpisodeID,
			&i.LastSeasonNumber,
			&i.LastEpisodeNumber,
			&i.LastEpisodeTitle,
			&i.ProgressSeconds,
			&i.DurationSeconds,
			&i.LastWatchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWatchedEpisodesBySeries = `-- name: ListWatchedEpisodesBySeries :many
SELECT ew.id, ew.user_id, ew.episode_id, ew.progress_seconds, ew.duration_seconds, ew.is_completed, ew.watch_count, ew.last_watched_at, ew.created_at, ew.updated_at, e.season_number, e.episode_number, e.title as episode_title
FROM tvshow.episode_watched ew
JOIN tvshow.episodes e ON ew.episode_id = e.id
WHERE ew.user_id = $1 AND e.series_id = $2
ORDER BY e.season_number ASC, e.episode_number ASC
`

type ListWatchedEpisodesBySeriesParams struct {
	UserID   uuid.UUID `json:"userId"`
	SeriesID uuid.UUID `json:"seriesId"`
}

type ListWatchedEpisodesBySeriesRow struct {
	ID              uuid.UUID          `json:"id"`
	UserID          uuid.UUID          `json:"userId"`
	EpisodeID       uuid.UUID          `json:"episodeId"`
	ProgressSeconds int32              `json:"progressSeconds"`
	DurationSeconds int32              `json:"durationSeconds"`
	IsCompleted     bool               `json:"isCompleted"`
	WatchCount      int32              `json:"watchCount"`
	LastWatchedAt   pgtype.Timestamptz `json:"lastWatchedAt"`
	CreatedAt       time.Time          `json:"createdAt"`
	UpdatedAt       time.Time          `json:"updatedAt"`
	SeasonNumber    int32              `json:"seasonNumber"`
	EpisodeNumber   int32              `json:"episodeNumber"`
	EpisodeTitle    string             `json:"episodeTitle"`
}

func (q *Queries) ListWatchedEpisodesBySeries(ctx context.Context, arg ListWatchedEpisodesBySeriesParams) ([]ListWatchedEpisodesBySeriesRow, error) {
	rows, err := q.db.Query(ctx, listWatchedEpisodesBySeries, arg.UserID, arg.SeriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWatchedEpisodesBySeriesRow{}
	for rows.Next() {
		var i ListWatchedEpisodesBySeriesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EpisodeID,
			&i.ProgressSeconds,
			&i.DurationSeconds,
			&i.IsCompleted,
			&i.WatchCount,
			&i.LastWatchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.EpisodeTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWatchedEpisodesByUser = `-- name: ListWatchedEpisodesByUser :many
SELECT
    ew.id, ew.user_id, ew.episode_id, ew.progress_seconds, ew.duration_seconds, ew.is_completed, ew.watch_count, ew.last_watched_at, ew.created_at, ew.updated_at,
    e.season_number,
    e.episode_number,
    e.title as episode_title,
    e.still_path as episode_still_path,
    s.id as series_id,
    s.title as series_title,
    s.poster_path as series_poster_path
FROM tvshow.episode_watched ew
JOIN tvshow.episodes e ON ew.episode_id = e.id
JOIN tvshow.series s ON e.series_id = s.id
WHERE ew.user_id = $1 AND ew.is_completed = TRUE
ORDER BY ew.last_watched_at DESC
LIMIT $2 OFFSET $3
`

type ListWatchedEpisodesByUserParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListWatchedEpisodesByUserRow struct {
	ID               uuid.UUID          `json:"id"`
	UserID           uuid.UUID          `json:"userId"`
	EpisodeID        uuid.UUID          `json:"episodeId"`
	ProgressSeconds  int32              `json:"progressSeconds"`
	DurationSeconds  int32              `json:"durationSeconds"`
	IsCompleted      bool               `json:"isCompleted"`
	WatchCount       int32              `json:"watchCount"`
	LastWatchedAt    pgtype.Timestamptz `json:"lastWatchedAt"`
	CreatedAt        time.Time          `json:"createdAt"`
	UpdatedAt        time.Time          `json:"updatedAt"`
	SeasonNumber     int32              `json:"seasonNumber"`
	EpisodeNumber    int32              `json:"episodeNumber"`
	EpisodeTitle     string             `json:"episodeTitle"`
	EpisodeStillPath *string            `json:"episodeStillPath"`
	SeriesID         uuid.UUID          `json:"seriesId"`
	SeriesTitle      string             `json:"seriesTitle"`
	SeriesPosterPath *string            `json:"seriesPosterPath"`
}

func (q *Queries) ListWatchedEpisodesByUser(ctx context.Context, arg ListWatchedEpisodesByUserParams) ([]ListWatchedEpisodesByUserRow, error) {
	rows, err := q.db.Query(ctx, listWatchedEpisodesByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWatchedEpisodesByUserRow{}
	for rows.Next() {
		var i ListWatchedEpisodesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EpisodeID,
			&i.ProgressSeconds,
			&i.DurationSeconds,
			&i.IsCompleted,
			&i.WatchCount,
			&i.LastWatchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.EpisodeTitle,
			&i.EpisodeStillPath,
			&i.SeriesID,
			&i.SeriesTitle,
			&i.SeriesPosterPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEpisodeWatched = `-- name: MarkEpisodeWatched :one
INSERT INTO tvshow.episode_watched (
    user_id, episode_id, progress_seconds, duration_seconds, is_completed, watch_count, last_watched_at
) VALUES (
    $1, $2, $3, $3, TRUE, 1, NOW()
)
ON CONFLICT (user_id, episode_id) DO UPDATE SET
    progress_seconds = $3,
    duration_seconds = $3,
    is_completed = TRUE,
    watch_count = tvshow.episode_watched.watch_count + 1,
    last_watched_at = NOW()
RETURNING id, user_id, episode_id, progress_seconds, duration_seconds, is_completed, watch_count, last_watched_at, created_at, updated_at
`

type MarkEpisodeWatchedParams struct {
	UserID          uuid.UUID `json:"userId"`
	EpisodeID       uuid.UUID `json:"episodeId"`
	ProgressSeconds int32     `json:"progressSeconds"`
}

func (q *Queries) MarkEpisodeWatched(ctx context.Context, arg MarkEpisodeWatchedParams) (TvshowEpisodeWatched, error) {
	row := q.db.QueryRow(ctx, markEpisodeWatched, arg.UserID, arg.EpisodeID, arg.ProgressSeconds)
	var i TvshowEpisodeWatched
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EpisodeID,
		&i.ProgressSeconds,
		&i.DurationSeconds,
		&i.IsCompleted,
		&i.WatchCount,
		&i.LastWatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
