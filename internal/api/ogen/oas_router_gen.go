// Code generated by ogen, DO NOT EDIT.

package ogen

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [3]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"

			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "api/v1/"

				if l := len("api/v1/"); len(elem) >= l && elem[0:l] == "api/v1/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "a"

					if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "dmin/"

						if l := len("dmin/"); len(elem) >= l && elem[0:l] == "dmin/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "activity"

							if l := len("activity"); len(elem) >= l && elem[0:l] == "activity" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleSearchActivityLogsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "actions"

									if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetRecentActionsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'r': // Prefix: "resources/"

									if l := len("resources/"); len(elem) >= l && elem[0:l] == "resources/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "resourceType"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "resourceId"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetResourceActivityLogsRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								case 's': // Prefix: "stats"

									if l := len("stats"); len(elem) >= l && elem[0:l] == "stats" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetActivityStatsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'u': // Prefix: "users/"

									if l := len("users/"); len(elem) >= l && elem[0:l] == "users/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "userId"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetUserActivityLogsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						case 'i': // Prefix: "integrations/"

							if l := len("integrations/"); len(elem) >= l && elem[0:l] == "integrations/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'r': // Prefix: "radarr/"

								if l := len("radarr/"); len(elem) >= l && elem[0:l] == "radarr/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'q': // Prefix: "quality-profiles"

									if l := len("quality-profiles"); len(elem) >= l && elem[0:l] == "quality-profiles" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleAdminGetRadarrQualityProfilesRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'r': // Prefix: "root-folders"

									if l := len("root-folders"); len(elem) >= l && elem[0:l] == "root-folders" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleAdminGetRadarrRootFoldersRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 's': // Prefix: "s"

									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 't': // Prefix: "tatus"

										if l := len("tatus"); len(elem) >= l && elem[0:l] == "tatus" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleAdminGetRadarrStatusRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 'y': // Prefix: "ync"

										if l := len("ync"); len(elem) >= l && elem[0:l] == "ync" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleAdminTriggerRadarrSyncRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

								}

							case 's': // Prefix: "sonarr/"

								if l := len("sonarr/"); len(elem) >= l && elem[0:l] == "sonarr/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'q': // Prefix: "quality-profiles"

									if l := len("quality-profiles"); len(elem) >= l && elem[0:l] == "quality-profiles" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleAdminGetSonarrQualityProfilesRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'r': // Prefix: "root-folders"

									if l := len("root-folders"); len(elem) >= l && elem[0:l] == "root-folders" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleAdminGetSonarrRootFoldersRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 's': // Prefix: "s"

									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 't': // Prefix: "tatus"

										if l := len("tatus"); len(elem) >= l && elem[0:l] == "tatus" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleAdminGetSonarrStatusRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 'y': // Prefix: "ync"

										if l := len("ync"); len(elem) >= l && elem[0:l] == "ync" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleAdminTriggerSonarrSyncRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

								}

							}

						case 'o': // Prefix: "oidc/providers"

							if l := len("oidc/providers"); len(elem) >= l && elem[0:l] == "oidc/providers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleAdminListOIDCProvidersRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleAdminCreateOIDCProviderRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "providerId"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleAdminDeleteOIDCProviderRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleAdminGetOIDCProviderRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleAdminUpdateOIDCProviderRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PATCH")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'd': // Prefix: "d"

										if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "efault"

											if l := len("efault"); len(elem) >= l && elem[0:l] == "efault" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleAdminSetDefaultOIDCProviderRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										case 'i': // Prefix: "isable"

											if l := len("isable"); len(elem) >= l && elem[0:l] == "isable" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleAdminDisableOIDCProviderRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										}

									case 'e': // Prefix: "enable"

										if l := len("enable"); len(elem) >= l && elem[0:l] == "enable" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleAdminEnableOIDCProviderRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

								}

							}

						}

					case 'p': // Prefix: "pikeys"

						if l := len("pikeys"); len(elem) >= l && elem[0:l] == "pikeys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleListAPIKeysRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateAPIKeyRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "keyId"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleRevokeAPIKeyRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleGetAPIKeyRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET")
								}

								return
							}

						}

					case 'u': // Prefix: "uth/"

						if l := len("uth/"); len(elem) >= l && elem[0:l] == "uth/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "change-password"

							if l := len("change-password"); len(elem) >= l && elem[0:l] == "change-password" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleChangePasswordRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'f': // Prefix: "forgot-password"

							if l := len("forgot-password"); len(elem) >= l && elem[0:l] == "forgot-password" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleForgotPasswordRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'l': // Prefix: "log"

							if l := len("log"); len(elem) >= l && elem[0:l] == "log" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'i': // Prefix: "in"

								if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleLoginRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'o': // Prefix: "out"

								if l := len("out"); len(elem) >= l && elem[0:l] == "out" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleLogoutRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							}

						case 'r': // Prefix: "re"

							if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'f': // Prefix: "fresh"

								if l := len("fresh"); len(elem) >= l && elem[0:l] == "fresh" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleRefreshTokenRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'g': // Prefix: "gister"

								if l := len("gister"); len(elem) >= l && elem[0:l] == "gister" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleRegisterRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 's': // Prefix: "se"

								if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'n': // Prefix: "nd-verification"

									if l := len("nd-verification"); len(elem) >= l && elem[0:l] == "nd-verification" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleResendVerificationRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 't': // Prefix: "t-password"

									if l := len("t-password"); len(elem) >= l && elem[0:l] == "t-password" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleResetPasswordRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						case 'v': // Prefix: "verify-email"

							if l := len("verify-email"); len(elem) >= l && elem[0:l] == "verify-email" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleVerifyEmailRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					}

				case 'c': // Prefix: "collections/"

					if l := len("collections/"); len(elem) >= l && elem[0:l] == "collections/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetCollectionRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/movies"

						if l := len("/movies"); len(elem) >= l && elem[0:l] == "/movies" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetCollectionMoviesRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					}

				case 'i': // Prefix: "images/"

					if l := len("images/"); len(elem) >= l && elem[0:l] == "images/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "type"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "size"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "path"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetProxiedImageRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				case 'l': // Prefix: "libraries"

					if l := len("libraries"); len(elem) >= l && elem[0:l] == "libraries" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListLibrariesRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateLibraryRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "libraryId"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteLibraryRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetLibraryRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateLibraryRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PUT")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'p': // Prefix: "permissions"

								if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleListLibraryPermissionsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleGrantLibraryPermissionRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "userId"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleRevokeLibraryPermissionRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE")
										}

										return
									}

								}

							case 's': // Prefix: "scan"

								if l := len("scan"); len(elem) >= l && elem[0:l] == "scan" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleTriggerLibraryScanRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case 's': // Prefix: "s"

									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleListLibraryScansRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						}

					}

				case 'm': // Prefix: "m"

					if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'e': // Prefix: "etadata/"

						if l := len("etadata/"); len(elem) >= l && elem[0:l] == "etadata/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "collection/"

							if l := len("collection/"); len(elem) >= l && elem[0:l] == "collection/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "tmdbId"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetCollectionMetadataRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'm': // Prefix: "movie/"

							if l := len("movie/"); len(elem) >= l && elem[0:l] == "movie/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "tmdbId"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetMovieMetadataRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 's': // Prefix: "search/"

							if l := len("search/"); len(elem) >= l && elem[0:l] == "search/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'm': // Prefix: "movie"

								if l := len("movie"); len(elem) >= l && elem[0:l] == "movie" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleSearchMoviesMetadataRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 't': // Prefix: "tv"

								if l := len("tv"); len(elem) >= l && elem[0:l] == "tv" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleSearchTVShowsMetadataRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						case 't': // Prefix: "tv/"

							if l := len("tv/"); len(elem) >= l && elem[0:l] == "tv/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "tmdbId"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetTVShowMetadataRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/season/"

								if l := len("/season/"); len(elem) >= l && elem[0:l] == "/season/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "seasonNumber"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleGetSeasonMetadataRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/episode/"

									if l := len("/episode/"); len(elem) >= l && elem[0:l] == "/episode/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "episodeNumber"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetEpisodeMetadataRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						}

					case 'f': // Prefix: "fa/"

						if l := len("fa/"); len(elem) >= l && elem[0:l] == "fa/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "backup-codes/"

							if l := len("backup-codes/"); len(elem) >= l && elem[0:l] == "backup-codes/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'g': // Prefix: "generate"

								if l := len("generate"); len(elem) >= l && elem[0:l] == "generate" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleGenerateBackupCodesRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'r': // Prefix: "regenerate"

								if l := len("regenerate"); len(elem) >= l && elem[0:l] == "regenerate" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleRegenerateBackupCodesRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							}

						case 'd': // Prefix: "disable"

							if l := len("disable"); len(elem) >= l && elem[0:l] == "disable" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleDisableMFARequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'e': // Prefix: "enable"

							if l := len("enable"); len(elem) >= l && elem[0:l] == "enable" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleEnableMFARequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 's': // Prefix: "status"

							if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetMFAStatusRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 't': // Prefix: "totp"

							if l := len("totp"); len(elem) >= l && elem[0:l] == "totp" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDisableTOTPRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 's': // Prefix: "setup"

									if l := len("setup"); len(elem) >= l && elem[0:l] == "setup" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleSetupTOTPRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 'v': // Prefix: "verify"

									if l := len("verify"); len(elem) >= l && elem[0:l] == "verify" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleVerifyTOTPRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						case 'w': // Prefix: "webauthn/"

							if l := len("webauthn/"); len(elem) >= l && elem[0:l] == "webauthn/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "credentials"

								if l := len("credentials"); len(elem) >= l && elem[0:l] == "credentials" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleListWebAuthnCredentialsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "credentialId"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleDeleteWebAuthnCredentialRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "PATCH":
											s.handleRenameWebAuthnCredentialRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,PATCH")
										}

										return
									}

								}

							case 'l': // Prefix: "login/"

								if l := len("login/"); len(elem) >= l && elem[0:l] == "login/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "begin"

									if l := len("begin"); len(elem) >= l && elem[0:l] == "begin" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleBeginWebAuthnLoginRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 'f': // Prefix: "finish"

									if l := len("finish"); len(elem) >= l && elem[0:l] == "finish" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleFinishWebAuthnLoginRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							case 'r': // Prefix: "register/"

								if l := len("register/"); len(elem) >= l && elem[0:l] == "register/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "begin"

									if l := len("begin"); len(elem) >= l && elem[0:l] == "begin" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleBeginWebAuthnRegistrationRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 'f': // Prefix: "finish"

									if l := len("finish"); len(elem) >= l && elem[0:l] == "finish" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleFinishWebAuthnRegistrationRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						}

					case 'o': // Prefix: "ovies"

						if l := len("ovies"); len(elem) >= l && elem[0:l] == "ovies" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleListMoviesRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "continue-watching"
								origElem := elem
								if l := len("continue-watching"); len(elem) >= l && elem[0:l] == "continue-watching" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetContinueWatchingRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							case 'r': // Prefix: "recently-added"
								origElem := elem
								if l := len("recently-added"); len(elem) >= l && elem[0:l] == "recently-added" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetRecentlyAddedRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							case 's': // Prefix: "s"
								origElem := elem
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "earch"

									if l := len("earch"); len(elem) >= l && elem[0:l] == "earch" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleSearchMoviesRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 't': // Prefix: "tats"

									if l := len("tats"); len(elem) >= l && elem[0:l] == "tats" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetUserMovieStatsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

								elem = origElem
							case 't': // Prefix: "top-rated"
								origElem := elem
								if l := len("top-rated"); len(elem) >= l && elem[0:l] == "top-rated" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetTopRatedRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							case 'w': // Prefix: "watch-history"
								origElem := elem
								if l := len("watch-history"); len(elem) >= l && elem[0:l] == "watch-history" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetWatchHistoryRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}
							// Param: "id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetMovieRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "c"

									if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "ast"

										if l := len("ast"); len(elem) >= l && elem[0:l] == "ast" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetMovieCastRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 'o': // Prefix: "ollection"

										if l := len("ollection"); len(elem) >= l && elem[0:l] == "ollection" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetMovieCollectionRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 'r': // Prefix: "rew"

										if l := len("rew"); len(elem) >= l && elem[0:l] == "rew" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetMovieCrewRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								case 'f': // Prefix: "files"

									if l := len("files"); len(elem) >= l && elem[0:l] == "files" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetMovieFilesRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'g': // Prefix: "genres"

									if l := len("genres"); len(elem) >= l && elem[0:l] == "genres" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetMovieGenresRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'p': // Prefix: "progress"

									if l := len("progress"); len(elem) >= l && elem[0:l] == "progress" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleDeleteWatchProgressRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handleGetWatchProgressRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "POST":
											s.handleUpdateWatchProgressRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,POST")
										}

										return
									}

								case 'r': // Prefix: "refresh"

									if l := len("refresh"); len(elem) >= l && elem[0:l] == "refresh" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleRefreshMovieMetadataRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 's': // Prefix: "similar"

									if l := len("similar"); len(elem) >= l && elem[0:l] == "similar" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetSimilarMoviesRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'w': // Prefix: "watched"

									if l := len("watched"); len(elem) >= l && elem[0:l] == "watched" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleMarkAsWatchedRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						}

					}

				case 'o': // Prefix: "oidc/"

					if l := len("oidc/"); len(elem) >= l && elem[0:l] == "oidc/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "auth/"

						if l := len("auth/"); len(elem) >= l && elem[0:l] == "auth/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "provider"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleOidcAuthorizeRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'c': // Prefix: "callback/"

						if l := len("callback/"); len(elem) >= l && elem[0:l] == "callback/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "provider"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleOidcCallbackRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'p': // Prefix: "providers"

						if l := len("providers"); len(elem) >= l && elem[0:l] == "providers" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleListOIDCProvidersRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					}

				case 'r': // Prefix: "rbac/"

					if l := len("rbac/"); len(elem) >= l && elem[0:l] == "rbac/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'p': // Prefix: "p"

						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "ermissions"

							if l := len("ermissions"); len(elem) >= l && elem[0:l] == "ermissions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleListPermissionsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'o': // Prefix: "olicies"

							if l := len("olicies"); len(elem) >= l && elem[0:l] == "olicies" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleRemovePolicyRequest([0]string{}, elemIsEscaped, w, r)
								case "GET":
									s.handleListPoliciesRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleAddPolicyRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,POST")
								}

								return
							}

						}

					case 'r': // Prefix: "roles"

						if l := len("roles"); len(elem) >= l && elem[0:l] == "roles" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleListRolesRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateRoleRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "roleName"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDeleteRoleRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleGetRoleRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/permissions"

								if l := len("/permissions"); len(elem) >= l && elem[0:l] == "/permissions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "PUT":
										s.handleUpdateRolePermissionsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "PUT")
									}

									return
								}

							}

						}

					case 'u': // Prefix: "users/"

						if l := len("users/"); len(elem) >= l && elem[0:l] == "users/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "userId"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/roles"

							if l := len("/roles"); len(elem) >= l && elem[0:l] == "/roles" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetUserRolesRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "POST":
									s.handleAssignRoleRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "role"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleRemoveRoleRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}

							}

						}

					}

				case 's': // Prefix: "se"

					if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "arch/"

						if l := len("arch/"); len(elem) >= l && elem[0:l] == "arch/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'm': // Prefix: "movies"

							if l := len("movies"); len(elem) >= l && elem[0:l] == "movies" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleSearchLibraryMoviesRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "autocomplete"

									if l := len("autocomplete"); len(elem) >= l && elem[0:l] == "autocomplete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleAutocompleteMoviesRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'f': // Prefix: "facets"

									if l := len("facets"); len(elem) >= l && elem[0:l] == "facets" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetSearchFacetsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						case 'r': // Prefix: "reindex"

							if l := len("reindex"); len(elem) >= l && elem[0:l] == "reindex" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleReindexSearchRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					case 's': // Prefix: "ssions"

						if l := len("ssions"); len(elem) >= l && elem[0:l] == "ssions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleLogoutAllRequest([0]string{}, elemIsEscaped, w, r)
							case "GET":
								s.handleListSessionsRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "current"
								origElem := elem
								if l := len("current"); len(elem) >= l && elem[0:l] == "current" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleLogoutCurrentRequest([0]string{}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetCurrentSessionRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET")
									}

									return
								}

								elem = origElem
							case 'r': // Prefix: "refresh"
								origElem := elem
								if l := len("refresh"); len(elem) >= l && elem[0:l] == "refresh" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleRefreshSessionRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							}
							// Param: "sessionId"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleRevokeSessionRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}

						}

					case 't': // Prefix: "ttings/"

						if l := len("ttings/"); len(elem) >= l && elem[0:l] == "ttings/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "server"

							if l := len("server"); len(elem) >= l && elem[0:l] == "server" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleListServerSettingsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "key"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetServerSettingRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdateServerSettingRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,PUT")
									}

									return
								}

							}

						case 'u': // Prefix: "user"

							if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleListUserSettingsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "key"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteUserSettingRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetUserSettingRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdateUserSettingRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}

							}

						}

					}

				case 't': // Prefix: "tvshows"

					if l := len("tvshows"); len(elem) >= l && elem[0:l] == "tvshows" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListTVShowsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "continue-watching"
							origElem := elem
							if l := len("continue-watching"); len(elem) >= l && elem[0:l] == "continue-watching" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetTVContinueWatchingRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						case 'e': // Prefix: "episodes/"
							origElem := elem
							if l := len("episodes/"); len(elem) >= l && elem[0:l] == "episodes/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'r': // Prefix: "recent"
								origElem := elem
								if l := len("recent"); len(elem) >= l && elem[0:l] == "recent" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetRecentEpisodesRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							case 'u': // Prefix: "upcoming"
								origElem := elem
								if l := len("upcoming"); len(elem) >= l && elem[0:l] == "upcoming" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetUpcomingEpisodesRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}
							// Param: "id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetTVEpisodeRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'f': // Prefix: "files"

									if l := len("files"); len(elem) >= l && elem[0:l] == "files" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetTVEpisodeFilesRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'p': // Prefix: "progress"

									if l := len("progress"); len(elem) >= l && elem[0:l] == "progress" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleDeleteTVEpisodeProgressRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handleGetTVEpisodeProgressRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "PUT":
											s.handleUpdateTVEpisodeProgressRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PUT")
										}

										return
									}

								case 'w': // Prefix: "watched"

									if l := len("watched"); len(elem) >= l && elem[0:l] == "watched" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleMarkTVEpisodeWatchedRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

							elem = origElem
						case 'r': // Prefix: "recently-added"
							origElem := elem
							if l := len("recently-added"); len(elem) >= l && elem[0:l] == "recently-added" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetRecentlyAddedTVShowsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						case 's': // Prefix: "s"
							origElem := elem
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "ea"

								if l := len("ea"); len(elem) >= l && elem[0:l] == "ea" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'r': // Prefix: "rch"

									if l := len("rch"); len(elem) >= l && elem[0:l] == "rch" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleSearchTVShowsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 's': // Prefix: "sons/"

									if l := len("sons/"); len(elem) >= l && elem[0:l] == "sons/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGetTVSeasonRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/episodes"

										if l := len("/episodes"); len(elem) >= l && elem[0:l] == "/episodes" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetTVSeasonEpisodesRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								}

							case 't': // Prefix: "tats"

								if l := len("tats"); len(elem) >= l && elem[0:l] == "tats" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetUserTVStatsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

							elem = origElem
						}
						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetTVShowRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "c"

								if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "ast"

									if l := len("ast"); len(elem) >= l && elem[0:l] == "ast" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetTVShowCastRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'r': // Prefix: "rew"

									if l := len("rew"); len(elem) >= l && elem[0:l] == "rew" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetTVShowCrewRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'e': // Prefix: "episodes"

								if l := len("episodes"); len(elem) >= l && elem[0:l] == "episodes" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetTVShowEpisodesRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'g': // Prefix: "genres"

								if l := len("genres"); len(elem) >= l && elem[0:l] == "genres" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetTVShowGenresRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'n': // Prefix: "ne"

								if l := len("ne"); len(elem) >= l && elem[0:l] == "ne" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 't': // Prefix: "tworks"

									if l := len("tworks"); len(elem) >= l && elem[0:l] == "tworks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetTVShowNetworksRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'x': // Prefix: "xt-episode"

									if l := len("xt-episode"); len(elem) >= l && elem[0:l] == "xt-episode" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetTVShowNextEpisodeRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'r': // Prefix: "refresh"

								if l := len("refresh"); len(elem) >= l && elem[0:l] == "refresh" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleRefreshTVShowMetadataRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 's': // Prefix: "seasons"

								if l := len("seasons"); len(elem) >= l && elem[0:l] == "seasons" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetTVShowSeasonsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'w': // Prefix: "watch-stats"

								if l := len("watch-stats"); len(elem) >= l && elem[0:l] == "watch-stats" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetTVShowWatchStatsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						}

					}

				case 'u': // Prefix: "users/"

					if l := len("users/"); len(elem) >= l && elem[0:l] == "users/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'm': // Prefix: "me"
						origElem := elem
						if l := len("me"); len(elem) >= l && elem[0:l] == "me" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetCurrentUserRequest([0]string{}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateCurrentUserRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,PUT")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "avatar"

								if l := len("avatar"); len(elem) >= l && elem[0:l] == "avatar" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleUploadAvatarRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'o': // Prefix: "oidc"

								if l := len("oidc"); len(elem) >= l && elem[0:l] == "oidc" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleListUserOIDCLinksRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "provider"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "DELETE":
											s.handleUnlinkOIDCProviderRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/link"

										if l := len("/link"); len(elem) >= l && elem[0:l] == "/link" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleInitOIDCLinkRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

								}

							case 'p': // Prefix: "preferences"

								if l := len("preferences"); len(elem) >= l && elem[0:l] == "preferences" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetUserPreferencesRequest([0]string{}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdateUserPreferencesRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,PUT")
									}

									return
								}

							}

						}

						elem = origElem
					}
					// Param: "userId"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleGetUserByIdRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 'w': // Prefix: "webhooks/"

					if l := len("webhooks/"); len(elem) >= l && elem[0:l] == "webhooks/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'r': // Prefix: "radarr"

						if l := len("radarr"); len(elem) >= l && elem[0:l] == "radarr" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleHandleRadarrWebhookRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 's': // Prefix: "sonarr"

						if l := len("sonarr"); len(elem) >= l && elem[0:l] == "sonarr" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleHandleSonarrWebhookRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					}

				}

			case 'h': // Prefix: "healthz"

				if l := len("healthz"); len(elem) >= l && elem[0:l] == "healthz" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleGetLivenessRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}

			case 'r': // Prefix: "readyz"

				if l := len("readyz"); len(elem) >= l && elem[0:l] == "readyz" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleGetReadinessRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}

			case 's': // Prefix: "startupz"

				if l := len("startupz"); len(elem) >= l && elem[0:l] == "startupz" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleGetStartupRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}

			}

		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name           string
	summary        string
	operationID    string
	operationGroup string
	pathPattern    string
	count          int
	args           [3]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// OperationGroup returns the x-ogen-operation-group value.
func (r Route) OperationGroup() string {
	return r.operationGroup
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"

			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "api/v1/"

				if l := len("api/v1/"); len(elem) >= l && elem[0:l] == "api/v1/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "a"

					if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "dmin/"

						if l := len("dmin/"); len(elem) >= l && elem[0:l] == "dmin/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "activity"

							if l := len("activity"); len(elem) >= l && elem[0:l] == "activity" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = SearchActivityLogsOperation
									r.summary = "Search activity logs (admin)"
									r.operationID = "searchActivityLogs"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/admin/activity"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "actions"

									if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetRecentActionsOperation
											r.summary = "Get recent action types (admin)"
											r.operationID = "getRecentActions"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/admin/activity/actions"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 'r': // Prefix: "resources/"

									if l := len("resources/"); len(elem) >= l && elem[0:l] == "resources/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "resourceType"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "resourceId"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetResourceActivityLogsOperation
												r.summary = "Get resource activity logs (admin)"
												r.operationID = "getResourceActivityLogs"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/admin/activity/resources/{resourceType}/{resourceId}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									}

								case 's': // Prefix: "stats"

									if l := len("stats"); len(elem) >= l && elem[0:l] == "stats" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetActivityStatsOperation
											r.summary = "Get activity statistics (admin)"
											r.operationID = "getActivityStats"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/admin/activity/stats"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 'u': // Prefix: "users/"

									if l := len("users/"); len(elem) >= l && elem[0:l] == "users/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "userId"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetUserActivityLogsOperation
											r.summary = "Get user activity logs (admin)"
											r.operationID = "getUserActivityLogs"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/admin/activity/users/{userId}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'i': // Prefix: "integrations/"

							if l := len("integrations/"); len(elem) >= l && elem[0:l] == "integrations/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'r': // Prefix: "radarr/"

								if l := len("radarr/"); len(elem) >= l && elem[0:l] == "radarr/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'q': // Prefix: "quality-profiles"

									if l := len("quality-profiles"); len(elem) >= l && elem[0:l] == "quality-profiles" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = AdminGetRadarrQualityProfilesOperation
											r.summary = "Get Radarr quality profiles (admin)"
											r.operationID = "adminGetRadarrQualityProfiles"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/admin/integrations/radarr/quality-profiles"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 'r': // Prefix: "root-folders"

									if l := len("root-folders"); len(elem) >= l && elem[0:l] == "root-folders" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = AdminGetRadarrRootFoldersOperation
											r.summary = "Get Radarr root folders (admin)"
											r.operationID = "adminGetRadarrRootFolders"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/admin/integrations/radarr/root-folders"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 's': // Prefix: "s"

									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 't': // Prefix: "tatus"

										if l := len("tatus"); len(elem) >= l && elem[0:l] == "tatus" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = AdminGetRadarrStatusOperation
												r.summary = "Get Radarr integration status (admin)"
												r.operationID = "adminGetRadarrStatus"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/admin/integrations/radarr/status"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									case 'y': // Prefix: "ync"

										if l := len("ync"); len(elem) >= l && elem[0:l] == "ync" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = AdminTriggerRadarrSyncOperation
												r.summary = "Trigger Radarr library sync (admin)"
												r.operationID = "adminTriggerRadarrSync"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/admin/integrations/radarr/sync"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									}

								}

							case 's': // Prefix: "sonarr/"

								if l := len("sonarr/"); len(elem) >= l && elem[0:l] == "sonarr/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'q': // Prefix: "quality-profiles"

									if l := len("quality-profiles"); len(elem) >= l && elem[0:l] == "quality-profiles" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = AdminGetSonarrQualityProfilesOperation
											r.summary = "Get Sonarr quality profiles (admin)"
											r.operationID = "adminGetSonarrQualityProfiles"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/admin/integrations/sonarr/quality-profiles"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 'r': // Prefix: "root-folders"

									if l := len("root-folders"); len(elem) >= l && elem[0:l] == "root-folders" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = AdminGetSonarrRootFoldersOperation
											r.summary = "Get Sonarr root folders (admin)"
											r.operationID = "adminGetSonarrRootFolders"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/admin/integrations/sonarr/root-folders"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 's': // Prefix: "s"

									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 't': // Prefix: "tatus"

										if l := len("tatus"); len(elem) >= l && elem[0:l] == "tatus" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = AdminGetSonarrStatusOperation
												r.summary = "Get Sonarr integration status (admin)"
												r.operationID = "adminGetSonarrStatus"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/admin/integrations/sonarr/status"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									case 'y': // Prefix: "ync"

										if l := len("ync"); len(elem) >= l && elem[0:l] == "ync" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = AdminTriggerSonarrSyncOperation
												r.summary = "Trigger Sonarr library sync (admin)"
												r.operationID = "adminTriggerSonarrSync"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/admin/integrations/sonarr/sync"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						case 'o': // Prefix: "oidc/providers"

							if l := len("oidc/providers"); len(elem) >= l && elem[0:l] == "oidc/providers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = AdminListOIDCProvidersOperation
									r.summary = "List all OIDC providers (admin)"
									r.operationID = "adminListOIDCProviders"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/admin/oidc/providers"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = AdminCreateOIDCProviderOperation
									r.summary = "Create OIDC provider (admin)"
									r.operationID = "adminCreateOIDCProvider"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/admin/oidc/providers"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "providerId"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = AdminDeleteOIDCProviderOperation
										r.summary = "Delete OIDC provider (admin)"
										r.operationID = "adminDeleteOIDCProvider"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/admin/oidc/providers/{providerId}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = AdminGetOIDCProviderOperation
										r.summary = "Get OIDC provider (admin)"
										r.operationID = "adminGetOIDCProvider"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/admin/oidc/providers/{providerId}"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = AdminUpdateOIDCProviderOperation
										r.summary = "Update OIDC provider (admin)"
										r.operationID = "adminUpdateOIDCProvider"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/admin/oidc/providers/{providerId}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'd': // Prefix: "d"

										if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "efault"

											if l := len("efault"); len(elem) >= l && elem[0:l] == "efault" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = AdminSetDefaultOIDCProviderOperation
													r.summary = "Set default OIDC provider (admin)"
													r.operationID = "adminSetDefaultOIDCProvider"
													r.operationGroup = ""
													r.pathPattern = "/api/v1/admin/oidc/providers/{providerId}/default"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										case 'i': // Prefix: "isable"

											if l := len("isable"); len(elem) >= l && elem[0:l] == "isable" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = AdminDisableOIDCProviderOperation
													r.summary = "Disable OIDC provider (admin)"
													r.operationID = "adminDisableOIDCProvider"
													r.operationGroup = ""
													r.pathPattern = "/api/v1/admin/oidc/providers/{providerId}/disable"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										}

									case 'e': // Prefix: "enable"

										if l := len("enable"); len(elem) >= l && elem[0:l] == "enable" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = AdminEnableOIDCProviderOperation
												r.summary = "Enable OIDC provider (admin)"
												r.operationID = "adminEnableOIDCProvider"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/admin/oidc/providers/{providerId}/enable"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						}

					case 'p': // Prefix: "pikeys"

						if l := len("pikeys"); len(elem) >= l && elem[0:l] == "pikeys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = ListAPIKeysOperation
								r.summary = "List API keys"
								r.operationID = "listAPIKeys"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/apikeys"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = CreateAPIKeyOperation
								r.summary = "Create API key"
								r.operationID = "createAPIKey"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/apikeys"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "keyId"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = RevokeAPIKeyOperation
									r.summary = "Revoke API key"
									r.operationID = "revokeAPIKey"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/apikeys/{keyId}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = GetAPIKeyOperation
									r.summary = "Get API key"
									r.operationID = "getAPIKey"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/apikeys/{keyId}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 'u': // Prefix: "uth/"

						if l := len("uth/"); len(elem) >= l && elem[0:l] == "uth/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "change-password"

							if l := len("change-password"); len(elem) >= l && elem[0:l] == "change-password" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = ChangePasswordOperation
									r.summary = "Change password"
									r.operationID = "changePassword"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/auth/change-password"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'f': // Prefix: "forgot-password"

							if l := len("forgot-password"); len(elem) >= l && elem[0:l] == "forgot-password" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = ForgotPasswordOperation
									r.summary = "Request password reset"
									r.operationID = "forgotPassword"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/auth/forgot-password"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'l': // Prefix: "log"

							if l := len("log"); len(elem) >= l && elem[0:l] == "log" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'i': // Prefix: "in"

								if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = LoginOperation
										r.summary = "Login with credentials"
										r.operationID = "login"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/auth/login"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'o': // Prefix: "out"

								if l := len("out"); len(elem) >= l && elem[0:l] == "out" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = LogoutOperation
										r.summary = "Logout"
										r.operationID = "logout"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/auth/logout"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						case 'r': // Prefix: "re"

							if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'f': // Prefix: "fresh"

								if l := len("fresh"); len(elem) >= l && elem[0:l] == "fresh" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = RefreshTokenOperation
										r.summary = "Refresh access token"
										r.operationID = "refreshToken"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/auth/refresh"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'g': // Prefix: "gister"

								if l := len("gister"); len(elem) >= l && elem[0:l] == "gister" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = RegisterOperation
										r.summary = "Register new user"
										r.operationID = "register"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/auth/register"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 's': // Prefix: "se"

								if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'n': // Prefix: "nd-verification"

									if l := len("nd-verification"); len(elem) >= l && elem[0:l] == "nd-verification" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = ResendVerificationOperation
											r.summary = "Resend verification email"
											r.operationID = "resendVerification"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/auth/resend-verification"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 't': // Prefix: "t-password"

									if l := len("t-password"); len(elem) >= l && elem[0:l] == "t-password" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = ResetPasswordOperation
											r.summary = "Reset password"
											r.operationID = "resetPassword"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/auth/reset-password"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'v': // Prefix: "verify-email"

							if l := len("verify-email"); len(elem) >= l && elem[0:l] == "verify-email" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = VerifyEmailOperation
									r.summary = "Verify email"
									r.operationID = "verifyEmail"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/auth/verify-email"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					}

				case 'c': // Prefix: "collections/"

					if l := len("collections/"); len(elem) >= l && elem[0:l] == "collections/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = GetCollectionOperation
							r.summary = "Get collection details"
							r.operationID = "getCollection"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/collections/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/movies"

						if l := len("/movies"); len(elem) >= l && elem[0:l] == "/movies" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = GetCollectionMoviesOperation
								r.summary = "Get collection movies"
								r.operationID = "getCollectionMovies"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/collections/{id}/movies"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					}

				case 'i': // Prefix: "images/"

					if l := len("images/"); len(elem) >= l && elem[0:l] == "images/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "type"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "size"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "path"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetProxiedImageOperation
									r.summary = "Proxy image from TMDb"
									r.operationID = "getProxiedImage"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/images/{type}/{size}/{path}"
									r.args = args
									r.count = 3
									return r, true
								default:
									return
								}
							}

						}

					}

				case 'l': // Prefix: "libraries"

					if l := len("libraries"); len(elem) >= l && elem[0:l] == "libraries" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = ListLibrariesOperation
							r.summary = "List accessible libraries"
							r.operationID = "listLibraries"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/libraries"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = CreateLibraryOperation
							r.summary = "Create a new library (admin)"
							r.operationID = "createLibrary"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/libraries"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "libraryId"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = DeleteLibraryOperation
								r.summary = "Delete a library (admin)"
								r.operationID = "deleteLibrary"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/libraries/{libraryId}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = GetLibraryOperation
								r.summary = "Get library details"
								r.operationID = "getLibrary"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/libraries/{libraryId}"
								r.args = args
								r.count = 1
								return r, true
							case "PUT":
								r.name = UpdateLibraryOperation
								r.summary = "Update a library (admin)"
								r.operationID = "updateLibrary"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/libraries/{libraryId}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'p': // Prefix: "permissions"

								if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = ListLibraryPermissionsOperation
										r.summary = "List library permissions (admin)"
										r.operationID = "listLibraryPermissions"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/libraries/{libraryId}/permissions"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = GrantLibraryPermissionOperation
										r.summary = "Grant library permission (admin)"
										r.operationID = "grantLibraryPermission"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/libraries/{libraryId}/permissions"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "userId"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = RevokeLibraryPermissionOperation
											r.summary = "Revoke library permission (admin)"
											r.operationID = "revokeLibraryPermission"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/libraries/{libraryId}/permissions/{userId}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								}

							case 's': // Prefix: "scan"

								if l := len("scan"); len(elem) >= l && elem[0:l] == "scan" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = TriggerLibraryScanOperation
										r.summary = "Trigger library scan (admin)"
										r.operationID = "triggerLibraryScan"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/libraries/{libraryId}/scan"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case 's': // Prefix: "s"

									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = ListLibraryScansOperation
											r.summary = "List library scans"
											r.operationID = "listLibraryScans"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/libraries/{libraryId}/scans"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					}

				case 'm': // Prefix: "m"

					if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'e': // Prefix: "etadata/"

						if l := len("etadata/"); len(elem) >= l && elem[0:l] == "etadata/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "collection/"

							if l := len("collection/"); len(elem) >= l && elem[0:l] == "collection/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "tmdbId"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetCollectionMetadataOperation
									r.summary = "Get collection details from TMDb"
									r.operationID = "getCollectionMetadata"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/metadata/collection/{tmdbId}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						case 'm': // Prefix: "movie/"

							if l := len("movie/"); len(elem) >= l && elem[0:l] == "movie/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "tmdbId"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetMovieMetadataOperation
									r.summary = "Get movie details from TMDb"
									r.operationID = "getMovieMetadata"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/metadata/movie/{tmdbId}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						case 's': // Prefix: "search/"

							if l := len("search/"); len(elem) >= l && elem[0:l] == "search/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'm': // Prefix: "movie"

								if l := len("movie"); len(elem) >= l && elem[0:l] == "movie" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = SearchMoviesMetadataOperation
										r.summary = "Search movies on TMDb"
										r.operationID = "searchMoviesMetadata"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/metadata/search/movie"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 't': // Prefix: "tv"

								if l := len("tv"); len(elem) >= l && elem[0:l] == "tv" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = SearchTVShowsMetadataOperation
										r.summary = "Search TV shows on TMDb"
										r.operationID = "searchTVShowsMetadata"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/metadata/search/tv"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						case 't': // Prefix: "tv/"

							if l := len("tv/"); len(elem) >= l && elem[0:l] == "tv/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "tmdbId"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetTVShowMetadataOperation
									r.summary = "Get TV show details from TMDb"
									r.operationID = "getTVShowMetadata"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/metadata/tv/{tmdbId}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/season/"

								if l := len("/season/"); len(elem) >= l && elem[0:l] == "/season/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "seasonNumber"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = GetSeasonMetadataOperation
										r.summary = "Get season details from TMDb"
										r.operationID = "getSeasonMetadata"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/metadata/tv/{tmdbId}/season/{seasonNumber}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/episode/"

									if l := len("/episode/"); len(elem) >= l && elem[0:l] == "/episode/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "episodeNumber"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetEpisodeMetadataOperation
											r.summary = "Get episode details from TMDb"
											r.operationID = "getEpisodeMetadata"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/metadata/tv/{tmdbId}/season/{seasonNumber}/episode/{episodeNumber}"
											r.args = args
											r.count = 3
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					case 'f': // Prefix: "fa/"

						if l := len("fa/"); len(elem) >= l && elem[0:l] == "fa/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "backup-codes/"

							if l := len("backup-codes/"); len(elem) >= l && elem[0:l] == "backup-codes/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'g': // Prefix: "generate"

								if l := len("generate"); len(elem) >= l && elem[0:l] == "generate" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = GenerateBackupCodesOperation
										r.summary = "Generate backup codes"
										r.operationID = "generateBackupCodes"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/mfa/backup-codes/generate"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'r': // Prefix: "regenerate"

								if l := len("regenerate"); len(elem) >= l && elem[0:l] == "regenerate" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = RegenerateBackupCodesOperation
										r.summary = "Regenerate backup codes"
										r.operationID = "regenerateBackupCodes"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/mfa/backup-codes/regenerate"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						case 'd': // Prefix: "disable"

							if l := len("disable"); len(elem) >= l && elem[0:l] == "disable" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = DisableMFAOperation
									r.summary = "Disable MFA requirement"
									r.operationID = "disableMFA"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/mfa/disable"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'e': // Prefix: "enable"

							if l := len("enable"); len(elem) >= l && elem[0:l] == "enable" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = EnableMFAOperation
									r.summary = "Enable MFA requirement"
									r.operationID = "enableMFA"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/mfa/enable"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 's': // Prefix: "status"

							if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetMFAStatusOperation
									r.summary = "Get MFA status"
									r.operationID = "getMFAStatus"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/mfa/status"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 't': // Prefix: "totp"

							if l := len("totp"); len(elem) >= l && elem[0:l] == "totp" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = DisableTOTPOperation
									r.summary = "Disable TOTP"
									r.operationID = "disableTOTP"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/mfa/totp"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 's': // Prefix: "setup"

									if l := len("setup"); len(elem) >= l && elem[0:l] == "setup" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = SetupTOTPOperation
											r.summary = "Setup TOTP"
											r.operationID = "setupTOTP"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/mfa/totp/setup"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 'v': // Prefix: "verify"

									if l := len("verify"); len(elem) >= l && elem[0:l] == "verify" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = VerifyTOTPOperation
											r.summary = "Verify and enable TOTP"
											r.operationID = "verifyTOTP"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/mfa/totp/verify"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'w': // Prefix: "webauthn/"

							if l := len("webauthn/"); len(elem) >= l && elem[0:l] == "webauthn/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "credentials"

								if l := len("credentials"); len(elem) >= l && elem[0:l] == "credentials" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = ListWebAuthnCredentialsOperation
										r.summary = "List WebAuthn credentials"
										r.operationID = "listWebAuthnCredentials"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/mfa/webauthn/credentials"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "credentialId"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = DeleteWebAuthnCredentialOperation
											r.summary = "Delete WebAuthn credential"
											r.operationID = "deleteWebAuthnCredential"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/mfa/webauthn/credentials/{credentialId}"
											r.args = args
											r.count = 1
											return r, true
										case "PATCH":
											r.name = RenameWebAuthnCredentialOperation
											r.summary = "Rename WebAuthn credential"
											r.operationID = "renameWebAuthnCredential"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/mfa/webauthn/credentials/{credentialId}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'l': // Prefix: "login/"

								if l := len("login/"); len(elem) >= l && elem[0:l] == "login/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "begin"

									if l := len("begin"); len(elem) >= l && elem[0:l] == "begin" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = BeginWebAuthnLoginOperation
											r.summary = "Begin WebAuthn login"
											r.operationID = "beginWebAuthnLogin"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/mfa/webauthn/login/begin"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 'f': // Prefix: "finish"

									if l := len("finish"); len(elem) >= l && elem[0:l] == "finish" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = FinishWebAuthnLoginOperation
											r.summary = "Finish WebAuthn login"
											r.operationID = "finishWebAuthnLogin"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/mfa/webauthn/login/finish"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							case 'r': // Prefix: "register/"

								if l := len("register/"); len(elem) >= l && elem[0:l] == "register/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "begin"

									if l := len("begin"); len(elem) >= l && elem[0:l] == "begin" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = BeginWebAuthnRegistrationOperation
											r.summary = "Begin WebAuthn registration"
											r.operationID = "beginWebAuthnRegistration"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/mfa/webauthn/register/begin"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 'f': // Prefix: "finish"

									if l := len("finish"); len(elem) >= l && elem[0:l] == "finish" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = FinishWebAuthnRegistrationOperation
											r.summary = "Finish WebAuthn registration"
											r.operationID = "finishWebAuthnRegistration"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/mfa/webauthn/register/finish"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					case 'o': // Prefix: "ovies"

						if l := len("ovies"); len(elem) >= l && elem[0:l] == "ovies" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = ListMoviesOperation
								r.summary = "List movies"
								r.operationID = "listMovies"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/movies"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "continue-watching"
								origElem := elem
								if l := len("continue-watching"); len(elem) >= l && elem[0:l] == "continue-watching" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetContinueWatchingOperation
										r.summary = "Get continue watching list"
										r.operationID = "getContinueWatching"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/movies/continue-watching"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'r': // Prefix: "recently-added"
								origElem := elem
								if l := len("recently-added"); len(elem) >= l && elem[0:l] == "recently-added" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetRecentlyAddedOperation
										r.summary = "Get recently added movies"
										r.operationID = "getRecentlyAdded"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/movies/recently-added"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 's': // Prefix: "s"
								origElem := elem
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "earch"

									if l := len("earch"); len(elem) >= l && elem[0:l] == "earch" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = SearchMoviesOperation
											r.summary = "Search movies"
											r.operationID = "searchMovies"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/movies/search"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 't': // Prefix: "tats"

									if l := len("tats"); len(elem) >= l && elem[0:l] == "tats" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetUserMovieStatsOperation
											r.summary = "Get user movie statistics"
											r.operationID = "getUserMovieStats"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/movies/stats"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

								elem = origElem
							case 't': // Prefix: "top-rated"
								origElem := elem
								if l := len("top-rated"); len(elem) >= l && elem[0:l] == "top-rated" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetTopRatedOperation
										r.summary = "Get top-rated movies"
										r.operationID = "getTopRated"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/movies/top-rated"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'w': // Prefix: "watch-history"
								origElem := elem
								if l := len("watch-history"); len(elem) >= l && elem[0:l] == "watch-history" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetWatchHistoryOperation
										r.summary = "Get watch history"
										r.operationID = "getWatchHistory"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/movies/watch-history"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetMovieOperation
									r.summary = "Get movie details"
									r.operationID = "getMovie"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/movies/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "c"

									if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "ast"

										if l := len("ast"); len(elem) >= l && elem[0:l] == "ast" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetMovieCastOperation
												r.summary = "Get movie cast"
												r.operationID = "getMovieCast"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/movies/{id}/cast"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 'o': // Prefix: "ollection"

										if l := len("ollection"); len(elem) >= l && elem[0:l] == "ollection" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetMovieCollectionOperation
												r.summary = "Get movie collection"
												r.operationID = "getMovieCollection"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/movies/{id}/collection"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 'r': // Prefix: "rew"

										if l := len("rew"); len(elem) >= l && elem[0:l] == "rew" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetMovieCrewOperation
												r.summary = "Get movie crew"
												r.operationID = "getMovieCrew"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/movies/{id}/crew"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								case 'f': // Prefix: "files"

									if l := len("files"); len(elem) >= l && elem[0:l] == "files" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetMovieFilesOperation
											r.summary = "Get movie files"
											r.operationID = "getMovieFiles"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/movies/{id}/files"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'g': // Prefix: "genres"

									if l := len("genres"); len(elem) >= l && elem[0:l] == "genres" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetMovieGenresOperation
											r.summary = "Get movie genres"
											r.operationID = "getMovieGenres"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/movies/{id}/genres"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'p': // Prefix: "progress"

									if l := len("progress"); len(elem) >= l && elem[0:l] == "progress" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = DeleteWatchProgressOperation
											r.summary = "Delete watch progress"
											r.operationID = "deleteWatchProgress"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/movies/{id}/progress"
											r.args = args
											r.count = 1
											return r, true
										case "GET":
											r.name = GetWatchProgressOperation
											r.summary = "Get watch progress"
											r.operationID = "getWatchProgress"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/movies/{id}/progress"
											r.args = args
											r.count = 1
											return r, true
										case "POST":
											r.name = UpdateWatchProgressOperation
											r.summary = "Update watch progress"
											r.operationID = "updateWatchProgress"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/movies/{id}/progress"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'r': // Prefix: "refresh"

									if l := len("refresh"); len(elem) >= l && elem[0:l] == "refresh" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = RefreshMovieMetadataOperation
											r.summary = "Refresh movie metadata"
											r.operationID = "refreshMovieMetadata"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/movies/{id}/refresh"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 's': // Prefix: "similar"

									if l := len("similar"); len(elem) >= l && elem[0:l] == "similar" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetSimilarMoviesOperation
											r.summary = "Get similar movies"
											r.operationID = "getSimilarMovies"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/movies/{id}/similar"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'w': // Prefix: "watched"

									if l := len("watched"); len(elem) >= l && elem[0:l] == "watched" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = MarkAsWatchedOperation
											r.summary = "Mark movie as watched"
											r.operationID = "markAsWatched"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/movies/{id}/watched"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					}

				case 'o': // Prefix: "oidc/"

					if l := len("oidc/"); len(elem) >= l && elem[0:l] == "oidc/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "auth/"

						if l := len("auth/"); len(elem) >= l && elem[0:l] == "auth/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "provider"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = OidcAuthorizeOperation
								r.summary = "Initiate OIDC login"
								r.operationID = "oidcAuthorize"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/oidc/auth/{provider}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					case 'c': // Prefix: "callback/"

						if l := len("callback/"); len(elem) >= l && elem[0:l] == "callback/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "provider"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = OidcCallbackOperation
								r.summary = "Handle OIDC callback"
								r.operationID = "oidcCallback"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/oidc/callback/{provider}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					case 'p': // Prefix: "providers"

						if l := len("providers"); len(elem) >= l && elem[0:l] == "providers" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = ListOIDCProvidersOperation
								r.summary = "List enabled OIDC providers"
								r.operationID = "listOIDCProviders"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/oidc/providers"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				case 'r': // Prefix: "rbac/"

					if l := len("rbac/"); len(elem) >= l && elem[0:l] == "rbac/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'p': // Prefix: "p"

						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "ermissions"

							if l := len("ermissions"); len(elem) >= l && elem[0:l] == "ermissions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = ListPermissionsOperation
									r.summary = "List available permissions"
									r.operationID = "listPermissions"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/rbac/permissions"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'o': // Prefix: "olicies"

							if l := len("olicies"); len(elem) >= l && elem[0:l] == "olicies" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = RemovePolicyOperation
									r.summary = "Remove policy"
									r.operationID = "removePolicy"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/rbac/policies"
									r.args = args
									r.count = 0
									return r, true
								case "GET":
									r.name = ListPoliciesOperation
									r.summary = "List policies"
									r.operationID = "listPolicies"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/rbac/policies"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = AddPolicyOperation
									r.summary = "Add policy"
									r.operationID = "addPolicy"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/rbac/policies"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 'r': // Prefix: "roles"

						if l := len("roles"); len(elem) >= l && elem[0:l] == "roles" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = ListRolesOperation
								r.summary = "List all roles"
								r.operationID = "listRoles"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/rbac/roles"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = CreateRoleOperation
								r.summary = "Create role"
								r.operationID = "createRole"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/rbac/roles"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "roleName"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = DeleteRoleOperation
									r.summary = "Delete role"
									r.operationID = "deleteRole"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/rbac/roles/{roleName}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = GetRoleOperation
									r.summary = "Get role details"
									r.operationID = "getRole"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/rbac/roles/{roleName}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/permissions"

								if l := len("/permissions"); len(elem) >= l && elem[0:l] == "/permissions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "PUT":
										r.name = UpdateRolePermissionsOperation
										r.summary = "Update role permissions"
										r.operationID = "updateRolePermissions"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/rbac/roles/{roleName}/permissions"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					case 'u': // Prefix: "users/"

						if l := len("users/"); len(elem) >= l && elem[0:l] == "users/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "userId"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/roles"

							if l := len("/roles"); len(elem) >= l && elem[0:l] == "/roles" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetUserRolesOperation
									r.summary = "Get user roles"
									r.operationID = "getUserRoles"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/rbac/users/{userId}/roles"
									r.args = args
									r.count = 1
									return r, true
								case "POST":
									r.name = AssignRoleOperation
									r.summary = "Assign role"
									r.operationID = "assignRole"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/rbac/users/{userId}/roles"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "role"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = RemoveRoleOperation
										r.summary = "Remove role"
										r.operationID = "removeRole"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/rbac/users/{userId}/roles/{role}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}

							}

						}

					}

				case 's': // Prefix: "se"

					if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "arch/"

						if l := len("arch/"); len(elem) >= l && elem[0:l] == "arch/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'm': // Prefix: "movies"

							if l := len("movies"); len(elem) >= l && elem[0:l] == "movies" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = SearchLibraryMoviesOperation
									r.summary = "Search movies in library"
									r.operationID = "searchLibraryMovies"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/search/movies"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "autocomplete"

									if l := len("autocomplete"); len(elem) >= l && elem[0:l] == "autocomplete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = AutocompleteMoviesOperation
											r.summary = "Autocomplete movie titles"
											r.operationID = "autocompleteMovies"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/search/movies/autocomplete"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 'f': // Prefix: "facets"

									if l := len("facets"); len(elem) >= l && elem[0:l] == "facets" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetSearchFacetsOperation
											r.summary = "Get search facets"
											r.operationID = "getSearchFacets"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/search/movies/facets"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'r': // Prefix: "reindex"

							if l := len("reindex"); len(elem) >= l && elem[0:l] == "reindex" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = ReindexSearchOperation
									r.summary = "Reindex all movies"
									r.operationID = "reindexSearch"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/search/reindex"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 's': // Prefix: "ssions"

						if l := len("ssions"); len(elem) >= l && elem[0:l] == "ssions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = LogoutAllOperation
								r.summary = "Logout all sessions"
								r.operationID = "logoutAll"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/sessions"
								r.args = args
								r.count = 0
								return r, true
							case "GET":
								r.name = ListSessionsOperation
								r.summary = "List user sessions"
								r.operationID = "listSessions"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/sessions"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "current"
								origElem := elem
								if l := len("current"); len(elem) >= l && elem[0:l] == "current" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = LogoutCurrentOperation
										r.summary = "Logout current session"
										r.operationID = "logoutCurrent"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/sessions/current"
										r.args = args
										r.count = 0
										return r, true
									case "GET":
										r.name = GetCurrentSessionOperation
										r.summary = "Get current session"
										r.operationID = "getCurrentSession"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/sessions/current"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'r': // Prefix: "refresh"
								origElem := elem
								if l := len("refresh"); len(elem) >= l && elem[0:l] == "refresh" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = RefreshSessionOperation
										r.summary = "Refresh session"
										r.operationID = "refreshSession"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/sessions/refresh"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "sessionId"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = RevokeSessionOperation
									r.summary = "Revoke session"
									r.operationID = "revokeSession"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/sessions/{sessionId}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 't': // Prefix: "ttings/"

						if l := len("ttings/"); len(elem) >= l && elem[0:l] == "ttings/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "server"

							if l := len("server"); len(elem) >= l && elem[0:l] == "server" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = ListServerSettingsOperation
									r.summary = "List all server settings"
									r.operationID = "listServerSettings"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/settings/server"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "key"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetServerSettingOperation
										r.summary = "Get a server setting"
										r.operationID = "getServerSetting"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/settings/server/{key}"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										r.name = UpdateServerSettingOperation
										r.summary = "Update a server setting"
										r.operationID = "updateServerSetting"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/settings/server/{key}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						case 'u': // Prefix: "user"

							if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = ListUserSettingsOperation
									r.summary = "List current user's settings"
									r.operationID = "listUserSettings"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/settings/user"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "key"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = DeleteUserSettingOperation
										r.summary = "Delete a user setting"
										r.operationID = "deleteUserSetting"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/settings/user/{key}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GetUserSettingOperation
										r.summary = "Get a user setting"
										r.operationID = "getUserSetting"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/settings/user/{key}"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										r.name = UpdateUserSettingOperation
										r.summary = "Update a user setting"
										r.operationID = "updateUserSetting"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/settings/user/{key}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					}

				case 't': // Prefix: "tvshows"

					if l := len("tvshows"); len(elem) >= l && elem[0:l] == "tvshows" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = ListTVShowsOperation
							r.summary = "List TV shows"
							r.operationID = "listTVShows"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/tvshows"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "continue-watching"
							origElem := elem
							if l := len("continue-watching"); len(elem) >= l && elem[0:l] == "continue-watching" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetTVContinueWatchingOperation
									r.summary = "Get continue watching list for TV shows"
									r.operationID = "getTVContinueWatching"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/tvshows/continue-watching"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 'e': // Prefix: "episodes/"
							origElem := elem
							if l := len("episodes/"); len(elem) >= l && elem[0:l] == "episodes/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'r': // Prefix: "recent"
								origElem := elem
								if l := len("recent"); len(elem) >= l && elem[0:l] == "recent" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetRecentEpisodesOperation
										r.summary = "Get recent episodes"
										r.operationID = "getRecentEpisodes"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/tvshows/episodes/recent"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'u': // Prefix: "upcoming"
								origElem := elem
								if l := len("upcoming"); len(elem) >= l && elem[0:l] == "upcoming" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetUpcomingEpisodesOperation
										r.summary = "Get upcoming episodes"
										r.operationID = "getUpcomingEpisodes"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/tvshows/episodes/upcoming"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetTVEpisodeOperation
									r.summary = "Get episode details"
									r.operationID = "getTVEpisode"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/tvshows/episodes/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'f': // Prefix: "files"

									if l := len("files"); len(elem) >= l && elem[0:l] == "files" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetTVEpisodeFilesOperation
											r.summary = "Get episode files"
											r.operationID = "getTVEpisodeFiles"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/tvshows/episodes/{id}/files"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'p': // Prefix: "progress"

									if l := len("progress"); len(elem) >= l && elem[0:l] == "progress" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = DeleteTVEpisodeProgressOperation
											r.summary = "Delete episode watch progress"
											r.operationID = "deleteTVEpisodeProgress"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/tvshows/episodes/{id}/progress"
											r.args = args
											r.count = 1
											return r, true
										case "GET":
											r.name = GetTVEpisodeProgressOperation
											r.summary = "Get episode watch progress"
											r.operationID = "getTVEpisodeProgress"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/tvshows/episodes/{id}/progress"
											r.args = args
											r.count = 1
											return r, true
										case "PUT":
											r.name = UpdateTVEpisodeProgressOperation
											r.summary = "Update episode watch progress"
											r.operationID = "updateTVEpisodeProgress"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/tvshows/episodes/{id}/progress"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'w': // Prefix: "watched"

									if l := len("watched"); len(elem) >= l && elem[0:l] == "watched" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = MarkTVEpisodeWatchedOperation
											r.summary = "Mark episode as watched"
											r.operationID = "markTVEpisodeWatched"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/tvshows/episodes/{id}/watched"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

							elem = origElem
						case 'r': // Prefix: "recently-added"
							origElem := elem
							if l := len("recently-added"); len(elem) >= l && elem[0:l] == "recently-added" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetRecentlyAddedTVShowsOperation
									r.summary = "Get recently added TV shows"
									r.operationID = "getRecentlyAddedTVShows"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/tvshows/recently-added"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 's': // Prefix: "s"
							origElem := elem
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "ea"

								if l := len("ea"); len(elem) >= l && elem[0:l] == "ea" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'r': // Prefix: "rch"

									if l := len("rch"); len(elem) >= l && elem[0:l] == "rch" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = SearchTVShowsOperation
											r.summary = "Search TV shows"
											r.operationID = "searchTVShows"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/tvshows/search"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 's': // Prefix: "sons/"

									if l := len("sons/"); len(elem) >= l && elem[0:l] == "sons/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = GetTVSeasonOperation
											r.summary = "Get season details"
											r.operationID = "getTVSeason"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/tvshows/seasons/{id}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/episodes"

										if l := len("/episodes"); len(elem) >= l && elem[0:l] == "/episodes" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetTVSeasonEpisodesOperation
												r.summary = "Get season episodes"
												r.operationID = "getTVSeasonEpisodes"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/tvshows/seasons/{id}/episodes"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							case 't': // Prefix: "tats"

								if l := len("tats"); len(elem) >= l && elem[0:l] == "tats" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetUserTVStatsOperation
										r.summary = "Get user TV show statistics"
										r.operationID = "getUserTVStats"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/tvshows/stats"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

							elem = origElem
						}
						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = GetTVShowOperation
								r.summary = "Get TV show details"
								r.operationID = "getTVShow"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/tvshows/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "c"

								if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "ast"

									if l := len("ast"); len(elem) >= l && elem[0:l] == "ast" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetTVShowCastOperation
											r.summary = "Get TV show cast"
											r.operationID = "getTVShowCast"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/tvshows/{id}/cast"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'r': // Prefix: "rew"

									if l := len("rew"); len(elem) >= l && elem[0:l] == "rew" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetTVShowCrewOperation
											r.summary = "Get TV show crew"
											r.operationID = "getTVShowCrew"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/tvshows/{id}/crew"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'e': // Prefix: "episodes"

								if l := len("episodes"); len(elem) >= l && elem[0:l] == "episodes" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetTVShowEpisodesOperation
										r.summary = "Get all episodes for a TV show"
										r.operationID = "getTVShowEpisodes"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/tvshows/{id}/episodes"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'g': // Prefix: "genres"

								if l := len("genres"); len(elem) >= l && elem[0:l] == "genres" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetTVShowGenresOperation
										r.summary = "Get TV show genres"
										r.operationID = "getTVShowGenres"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/tvshows/{id}/genres"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'n': // Prefix: "ne"

								if l := len("ne"); len(elem) >= l && elem[0:l] == "ne" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 't': // Prefix: "tworks"

									if l := len("tworks"); len(elem) >= l && elem[0:l] == "tworks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetTVShowNetworksOperation
											r.summary = "Get TV show networks"
											r.operationID = "getTVShowNetworks"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/tvshows/{id}/networks"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'x': // Prefix: "xt-episode"

									if l := len("xt-episode"); len(elem) >= l && elem[0:l] == "xt-episode" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetTVShowNextEpisodeOperation
											r.summary = "Get next unwatched episode"
											r.operationID = "getTVShowNextEpisode"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/tvshows/{id}/next-episode"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'r': // Prefix: "refresh"

								if l := len("refresh"); len(elem) >= l && elem[0:l] == "refresh" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = RefreshTVShowMetadataOperation
										r.summary = "Refresh TV show metadata"
										r.operationID = "refreshTVShowMetadata"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/tvshows/{id}/refresh"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 's': // Prefix: "seasons"

								if l := len("seasons"); len(elem) >= l && elem[0:l] == "seasons" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetTVShowSeasonsOperation
										r.summary = "Get TV show seasons"
										r.operationID = "getTVShowSeasons"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/tvshows/{id}/seasons"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'w': // Prefix: "watch-stats"

								if l := len("watch-stats"); len(elem) >= l && elem[0:l] == "watch-stats" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetTVShowWatchStatsOperation
										r.summary = "Get watch stats for a TV show"
										r.operationID = "getTVShowWatchStats"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/tvshows/{id}/watch-stats"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					}

				case 'u': // Prefix: "users/"

					if l := len("users/"); len(elem) >= l && elem[0:l] == "users/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'm': // Prefix: "me"
						origElem := elem
						if l := len("me"); len(elem) >= l && elem[0:l] == "me" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = GetCurrentUserOperation
								r.summary = "Get current user"
								r.operationID = "getCurrentUser"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/users/me"
								r.args = args
								r.count = 0
								return r, true
							case "PUT":
								r.name = UpdateCurrentUserOperation
								r.summary = "Update current user"
								r.operationID = "updateCurrentUser"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/users/me"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "avatar"

								if l := len("avatar"); len(elem) >= l && elem[0:l] == "avatar" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = UploadAvatarOperation
										r.summary = "Upload avatar"
										r.operationID = "uploadAvatar"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/users/me/avatar"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'o': // Prefix: "oidc"

								if l := len("oidc"); len(elem) >= l && elem[0:l] == "oidc" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = ListUserOIDCLinksOperation
										r.summary = "List user's OIDC links"
										r.operationID = "listUserOIDCLinks"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/users/me/oidc"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "provider"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											r.name = UnlinkOIDCProviderOperation
											r.summary = "Unlink OIDC provider"
											r.operationID = "unlinkOIDCProvider"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/users/me/oidc/{provider}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/link"

										if l := len("/link"); len(elem) >= l && elem[0:l] == "/link" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = InitOIDCLinkOperation
												r.summary = "Start linking OIDC provider"
												r.operationID = "initOIDCLink"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/users/me/oidc/{provider}/link"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							case 'p': // Prefix: "preferences"

								if l := len("preferences"); len(elem) >= l && elem[0:l] == "preferences" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetUserPreferencesOperation
										r.summary = "Get user preferences"
										r.operationID = "getUserPreferences"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/users/me/preferences"
										r.args = args
										r.count = 0
										return r, true
									case "PUT":
										r.name = UpdateUserPreferencesOperation
										r.summary = "Update user preferences"
										r.operationID = "updateUserPreferences"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/users/me/preferences"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						}

						elem = origElem
					}
					// Param: "userId"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = GetUserByIdOperation
							r.summary = "Get user by ID"
							r.operationID = "getUserById"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/users/{userId}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				case 'w': // Prefix: "webhooks/"

					if l := len("webhooks/"); len(elem) >= l && elem[0:l] == "webhooks/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'r': // Prefix: "radarr"

						if l := len("radarr"); len(elem) >= l && elem[0:l] == "radarr" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = HandleRadarrWebhookOperation
								r.summary = "Handle Radarr webhook"
								r.operationID = "handleRadarrWebhook"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/webhooks/radarr"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 's': // Prefix: "sonarr"

						if l := len("sonarr"); len(elem) >= l && elem[0:l] == "sonarr" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = HandleSonarrWebhookOperation
								r.summary = "Handle Sonarr webhook"
								r.operationID = "handleSonarrWebhook"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/webhooks/sonarr"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				}

			case 'h': // Prefix: "healthz"

				if l := len("healthz"); len(elem) >= l && elem[0:l] == "healthz" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch method {
					case "GET":
						r.name = GetLivenessOperation
						r.summary = "Liveness probe"
						r.operationID = "getLiveness"
						r.operationGroup = ""
						r.pathPattern = "/healthz"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}

			case 'r': // Prefix: "readyz"

				if l := len("readyz"); len(elem) >= l && elem[0:l] == "readyz" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch method {
					case "GET":
						r.name = GetReadinessOperation
						r.summary = "Readiness probe"
						r.operationID = "getReadiness"
						r.operationGroup = ""
						r.pathPattern = "/readyz"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}

			case 's': // Prefix: "startupz"

				if l := len("startupz"); len(elem) >= l && elem[0:l] == "startupz" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch method {
					case "GET":
						r.name = GetStartupOperation
						r.summary = "Startup probe"
						r.operationID = "getStartup"
						r.operationGroup = ""
						r.pathPattern = "/startupz"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}

			}

		}
	}
	return r, false
}
