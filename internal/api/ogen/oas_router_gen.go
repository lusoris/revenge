// Code generated by ogen, DO NOT EDIT.

package ogen

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [2]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"

			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "api/v1/"

				if l := len("api/v1/"); len(elem) >= l && elem[0:l] == "api/v1/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "a"

					if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'p': // Prefix: "pikeys"

						if l := len("pikeys"); len(elem) >= l && elem[0:l] == "pikeys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleListAPIKeysRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateAPIKeyRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "keyId"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleRevokeAPIKeyRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleGetAPIKeyRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET")
								}

								return
							}

						}

					case 'u': // Prefix: "uth/"

						if l := len("uth/"); len(elem) >= l && elem[0:l] == "uth/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "change-password"

							if l := len("change-password"); len(elem) >= l && elem[0:l] == "change-password" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleChangePasswordRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'f': // Prefix: "forgot-password"

							if l := len("forgot-password"); len(elem) >= l && elem[0:l] == "forgot-password" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleForgotPasswordRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'l': // Prefix: "log"

							if l := len("log"); len(elem) >= l && elem[0:l] == "log" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'i': // Prefix: "in"

								if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleLoginRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'o': // Prefix: "out"

								if l := len("out"); len(elem) >= l && elem[0:l] == "out" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleLogoutRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							}

						case 'r': // Prefix: "re"

							if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'f': // Prefix: "fresh"

								if l := len("fresh"); len(elem) >= l && elem[0:l] == "fresh" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleRefreshTokenRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'g': // Prefix: "gister"

								if l := len("gister"); len(elem) >= l && elem[0:l] == "gister" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleRegisterRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 's': // Prefix: "se"

								if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'n': // Prefix: "nd-verification"

									if l := len("nd-verification"); len(elem) >= l && elem[0:l] == "nd-verification" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleResendVerificationRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 't': // Prefix: "t-password"

									if l := len("t-password"); len(elem) >= l && elem[0:l] == "t-password" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleResetPasswordRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						case 'v': // Prefix: "verify-email"

							if l := len("verify-email"); len(elem) >= l && elem[0:l] == "verify-email" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleVerifyEmailRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					}

				case 'r': // Prefix: "rbac/"

					if l := len("rbac/"); len(elem) >= l && elem[0:l] == "rbac/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'p': // Prefix: "policies"

						if l := len("policies"); len(elem) >= l && elem[0:l] == "policies" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleRemovePolicyRequest([0]string{}, elemIsEscaped, w, r)
							case "GET":
								s.handleListPoliciesRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleAddPolicyRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,POST")
							}

							return
						}

					case 'u': // Prefix: "users/"

						if l := len("users/"); len(elem) >= l && elem[0:l] == "users/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "userId"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/roles"

							if l := len("/roles"); len(elem) >= l && elem[0:l] == "/roles" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetUserRolesRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "POST":
									s.handleAssignRoleRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "role"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleRemoveRoleRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}

							}

						}

					}

				case 's': // Prefix: "se"

					if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 's': // Prefix: "ssions"

						if l := len("ssions"); len(elem) >= l && elem[0:l] == "ssions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleLogoutAllRequest([0]string{}, elemIsEscaped, w, r)
							case "GET":
								s.handleListSessionsRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "current"
								origElem := elem
								if l := len("current"); len(elem) >= l && elem[0:l] == "current" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleLogoutCurrentRequest([0]string{}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetCurrentSessionRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET")
									}

									return
								}

								elem = origElem
							case 'r': // Prefix: "refresh"
								origElem := elem
								if l := len("refresh"); len(elem) >= l && elem[0:l] == "refresh" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleRefreshSessionRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							}
							// Param: "sessionId"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleRevokeSessionRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}

						}

					case 't': // Prefix: "ttings/"

						if l := len("ttings/"); len(elem) >= l && elem[0:l] == "ttings/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "server"

							if l := len("server"); len(elem) >= l && elem[0:l] == "server" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleListServerSettingsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "key"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetServerSettingRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdateServerSettingRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,PUT")
									}

									return
								}

							}

						case 'u': // Prefix: "user"

							if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleListUserSettingsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "key"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteUserSettingRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetUserSettingRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdateUserSettingRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}

							}

						}

					}

				case 'u': // Prefix: "users/"

					if l := len("users/"); len(elem) >= l && elem[0:l] == "users/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'm': // Prefix: "me"
						origElem := elem
						if l := len("me"); len(elem) >= l && elem[0:l] == "me" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetCurrentUserRequest([0]string{}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateCurrentUserRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,PUT")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "avatar"

								if l := len("avatar"); len(elem) >= l && elem[0:l] == "avatar" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleUploadAvatarRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'p': // Prefix: "preferences"

								if l := len("preferences"); len(elem) >= l && elem[0:l] == "preferences" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetUserPreferencesRequest([0]string{}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdateUserPreferencesRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,PUT")
									}

									return
								}

							}

						}

						elem = origElem
					}
					// Param: "userId"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleGetUserByIdRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				}

			case 'h': // Prefix: "health/"

				if l := len("health/"); len(elem) >= l && elem[0:l] == "health/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'l': // Prefix: "live"

					if l := len("live"); len(elem) >= l && elem[0:l] == "live" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleGetLivenessRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 'r': // Prefix: "ready"

					if l := len("ready"); len(elem) >= l && elem[0:l] == "ready" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleGetReadinessRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 's': // Prefix: "startup"

					if l := len("startup"); len(elem) >= l && elem[0:l] == "startup" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleGetStartupRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				}

			}

		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name           string
	summary        string
	operationID    string
	operationGroup string
	pathPattern    string
	count          int
	args           [2]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// OperationGroup returns the x-ogen-operation-group value.
func (r Route) OperationGroup() string {
	return r.operationGroup
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"

			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "api/v1/"

				if l := len("api/v1/"); len(elem) >= l && elem[0:l] == "api/v1/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "a"

					if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'p': // Prefix: "pikeys"

						if l := len("pikeys"); len(elem) >= l && elem[0:l] == "pikeys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = ListAPIKeysOperation
								r.summary = "List API keys"
								r.operationID = "listAPIKeys"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/apikeys"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = CreateAPIKeyOperation
								r.summary = "Create API key"
								r.operationID = "createAPIKey"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/apikeys"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "keyId"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = RevokeAPIKeyOperation
									r.summary = "Revoke API key"
									r.operationID = "revokeAPIKey"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/apikeys/{keyId}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = GetAPIKeyOperation
									r.summary = "Get API key"
									r.operationID = "getAPIKey"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/apikeys/{keyId}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 'u': // Prefix: "uth/"

						if l := len("uth/"); len(elem) >= l && elem[0:l] == "uth/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "change-password"

							if l := len("change-password"); len(elem) >= l && elem[0:l] == "change-password" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = ChangePasswordOperation
									r.summary = "Change password"
									r.operationID = "changePassword"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/auth/change-password"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'f': // Prefix: "forgot-password"

							if l := len("forgot-password"); len(elem) >= l && elem[0:l] == "forgot-password" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = ForgotPasswordOperation
									r.summary = "Request password reset"
									r.operationID = "forgotPassword"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/auth/forgot-password"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'l': // Prefix: "log"

							if l := len("log"); len(elem) >= l && elem[0:l] == "log" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'i': // Prefix: "in"

								if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = LoginOperation
										r.summary = "Login with credentials"
										r.operationID = "login"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/auth/login"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'o': // Prefix: "out"

								if l := len("out"); len(elem) >= l && elem[0:l] == "out" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = LogoutOperation
										r.summary = "Logout"
										r.operationID = "logout"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/auth/logout"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						case 'r': // Prefix: "re"

							if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'f': // Prefix: "fresh"

								if l := len("fresh"); len(elem) >= l && elem[0:l] == "fresh" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = RefreshTokenOperation
										r.summary = "Refresh access token"
										r.operationID = "refreshToken"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/auth/refresh"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'g': // Prefix: "gister"

								if l := len("gister"); len(elem) >= l && elem[0:l] == "gister" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = RegisterOperation
										r.summary = "Register new user"
										r.operationID = "register"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/auth/register"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 's': // Prefix: "se"

								if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'n': // Prefix: "nd-verification"

									if l := len("nd-verification"); len(elem) >= l && elem[0:l] == "nd-verification" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = ResendVerificationOperation
											r.summary = "Resend verification email"
											r.operationID = "resendVerification"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/auth/resend-verification"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 't': // Prefix: "t-password"

									if l := len("t-password"); len(elem) >= l && elem[0:l] == "t-password" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = ResetPasswordOperation
											r.summary = "Reset password"
											r.operationID = "resetPassword"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/auth/reset-password"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'v': // Prefix: "verify-email"

							if l := len("verify-email"); len(elem) >= l && elem[0:l] == "verify-email" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = VerifyEmailOperation
									r.summary = "Verify email"
									r.operationID = "verifyEmail"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/auth/verify-email"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					}

				case 'r': // Prefix: "rbac/"

					if l := len("rbac/"); len(elem) >= l && elem[0:l] == "rbac/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'p': // Prefix: "policies"

						if l := len("policies"); len(elem) >= l && elem[0:l] == "policies" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "DELETE":
								r.name = RemovePolicyOperation
								r.summary = "Remove policy"
								r.operationID = "removePolicy"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/rbac/policies"
								r.args = args
								r.count = 0
								return r, true
							case "GET":
								r.name = ListPoliciesOperation
								r.summary = "List policies"
								r.operationID = "listPolicies"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/rbac/policies"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = AddPolicyOperation
								r.summary = "Add policy"
								r.operationID = "addPolicy"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/rbac/policies"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'u': // Prefix: "users/"

						if l := len("users/"); len(elem) >= l && elem[0:l] == "users/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "userId"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/roles"

							if l := len("/roles"); len(elem) >= l && elem[0:l] == "/roles" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetUserRolesOperation
									r.summary = "Get user roles"
									r.operationID = "getUserRoles"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/rbac/users/{userId}/roles"
									r.args = args
									r.count = 1
									return r, true
								case "POST":
									r.name = AssignRoleOperation
									r.summary = "Assign role"
									r.operationID = "assignRole"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/rbac/users/{userId}/roles"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "role"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = RemoveRoleOperation
										r.summary = "Remove role"
										r.operationID = "removeRole"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/rbac/users/{userId}/roles/{role}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}

							}

						}

					}

				case 's': // Prefix: "se"

					if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 's': // Prefix: "ssions"

						if l := len("ssions"); len(elem) >= l && elem[0:l] == "ssions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = LogoutAllOperation
								r.summary = "Logout all sessions"
								r.operationID = "logoutAll"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/sessions"
								r.args = args
								r.count = 0
								return r, true
							case "GET":
								r.name = ListSessionsOperation
								r.summary = "List user sessions"
								r.operationID = "listSessions"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/sessions"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "current"
								origElem := elem
								if l := len("current"); len(elem) >= l && elem[0:l] == "current" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = LogoutCurrentOperation
										r.summary = "Logout current session"
										r.operationID = "logoutCurrent"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/sessions/current"
										r.args = args
										r.count = 0
										return r, true
									case "GET":
										r.name = GetCurrentSessionOperation
										r.summary = "Get current session"
										r.operationID = "getCurrentSession"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/sessions/current"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'r': // Prefix: "refresh"
								origElem := elem
								if l := len("refresh"); len(elem) >= l && elem[0:l] == "refresh" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = RefreshSessionOperation
										r.summary = "Refresh session"
										r.operationID = "refreshSession"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/sessions/refresh"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "sessionId"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = RevokeSessionOperation
									r.summary = "Revoke session"
									r.operationID = "revokeSession"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/sessions/{sessionId}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 't': // Prefix: "ttings/"

						if l := len("ttings/"); len(elem) >= l && elem[0:l] == "ttings/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "server"

							if l := len("server"); len(elem) >= l && elem[0:l] == "server" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = ListServerSettingsOperation
									r.summary = "List all server settings"
									r.operationID = "listServerSettings"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/settings/server"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "key"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetServerSettingOperation
										r.summary = "Get a server setting"
										r.operationID = "getServerSetting"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/settings/server/{key}"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										r.name = UpdateServerSettingOperation
										r.summary = "Update a server setting"
										r.operationID = "updateServerSetting"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/settings/server/{key}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						case 'u': // Prefix: "user"

							if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = ListUserSettingsOperation
									r.summary = "List current user's settings"
									r.operationID = "listUserSettings"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/settings/user"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "key"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = DeleteUserSettingOperation
										r.summary = "Delete a user setting"
										r.operationID = "deleteUserSetting"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/settings/user/{key}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GetUserSettingOperation
										r.summary = "Get a user setting"
										r.operationID = "getUserSetting"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/settings/user/{key}"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										r.name = UpdateUserSettingOperation
										r.summary = "Update a user setting"
										r.operationID = "updateUserSetting"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/settings/user/{key}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					}

				case 'u': // Prefix: "users/"

					if l := len("users/"); len(elem) >= l && elem[0:l] == "users/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'm': // Prefix: "me"
						origElem := elem
						if l := len("me"); len(elem) >= l && elem[0:l] == "me" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = GetCurrentUserOperation
								r.summary = "Get current user"
								r.operationID = "getCurrentUser"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/users/me"
								r.args = args
								r.count = 0
								return r, true
							case "PUT":
								r.name = UpdateCurrentUserOperation
								r.summary = "Update current user"
								r.operationID = "updateCurrentUser"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/users/me"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "avatar"

								if l := len("avatar"); len(elem) >= l && elem[0:l] == "avatar" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = UploadAvatarOperation
										r.summary = "Upload avatar"
										r.operationID = "uploadAvatar"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/users/me/avatar"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'p': // Prefix: "preferences"

								if l := len("preferences"); len(elem) >= l && elem[0:l] == "preferences" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetUserPreferencesOperation
										r.summary = "Get user preferences"
										r.operationID = "getUserPreferences"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/users/me/preferences"
										r.args = args
										r.count = 0
										return r, true
									case "PUT":
										r.name = UpdateUserPreferencesOperation
										r.summary = "Update user preferences"
										r.operationID = "updateUserPreferences"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/users/me/preferences"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						}

						elem = origElem
					}
					// Param: "userId"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = GetUserByIdOperation
							r.summary = "Get user by ID"
							r.operationID = "getUserById"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/users/{userId}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				}

			case 'h': // Prefix: "health/"

				if l := len("health/"); len(elem) >= l && elem[0:l] == "health/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'l': // Prefix: "live"

					if l := len("live"); len(elem) >= l && elem[0:l] == "live" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = GetLivenessOperation
							r.summary = "Liveness probe"
							r.operationID = "getLiveness"
							r.operationGroup = ""
							r.pathPattern = "/health/live"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'r': // Prefix: "ready"

					if l := len("ready"); len(elem) >= l && elem[0:l] == "ready" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = GetReadinessOperation
							r.summary = "Readiness probe"
							r.operationID = "getReadiness"
							r.operationGroup = ""
							r.pathPattern = "/health/ready"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 's': // Prefix: "startup"

					if l := len("startup"); len(elem) >= l && elem[0:l] == "startup" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = GetStartupOperation
							r.summary = "Startup probe"
							r.operationID = "getStartup"
							r.operationGroup = ""
							r.pathPattern = "/health/startup"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			}

		}
	}
	return r, false
}
