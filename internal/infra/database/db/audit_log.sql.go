// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit_log.sql

package db

import (
	"context"
	"encoding/json"
	"net/netip"
	"time"

	"github.com/google/uuid"
)

const countAuditLogsByEntity = `-- name: CountAuditLogsByEntity :one
SELECT COUNT(*) FROM activity_log
WHERE module = $1 AND entity_type = $2 AND entity_id = $3
`

type CountAuditLogsByEntityParams struct {
	Module     string    `json:"module"`
	EntityType string    `json:"entityType"`
	EntityID   uuid.UUID `json:"entityId"`
}

func (q *Queries) CountAuditLogsByEntity(ctx context.Context, arg CountAuditLogsByEntityParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsByEntity, arg.Module, arg.EntityType, arg.EntityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO activity_log (user_id, action, module, entity_id, entity_type, changes, ip_address, user_agent)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, user_id, action, module, entity_id, entity_type, changes, ip_address, user_agent, created_at
`

type CreateAuditLogParams struct {
	UserID     uuid.UUID       `json:"userId"`
	Action     string          `json:"action"`
	Module     string          `json:"module"`
	EntityID   uuid.UUID       `json:"entityId"`
	EntityType string          `json:"entityType"`
	Changes    json.RawMessage `json:"changes"`
	IpAddress  netip.Addr      `json:"ipAddress"`
	UserAgent  *string         `json:"userAgent"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (ActivityLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.UserID,
		arg.Action,
		arg.Module,
		arg.EntityID,
		arg.EntityType,
		arg.Changes,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i ActivityLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.Module,
		&i.EntityID,
		&i.EntityType,
		&i.Changes,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOldAuditLogs = `-- name: DeleteOldAuditLogs :exec
DELETE FROM activity_log WHERE created_at < $1
`

func (q *Queries) DeleteOldAuditLogs(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.Exec(ctx, deleteOldAuditLogs, createdAt)
	return err
}

const getAuditLogByID = `-- name: GetAuditLogByID :one
SELECT id, user_id, action, module, entity_id, entity_type, changes, ip_address, user_agent, created_at FROM activity_log WHERE id = $1 AND created_at = $2
`

type GetAuditLogByIDParams struct {
	ID        uuid.UUID `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
}

func (q *Queries) GetAuditLogByID(ctx context.Context, arg GetAuditLogByIDParams) (ActivityLog, error) {
	row := q.db.QueryRow(ctx, getAuditLogByID, arg.ID, arg.CreatedAt)
	var i ActivityLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.Module,
		&i.EntityID,
		&i.EntityType,
		&i.Changes,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const listAuditLogsByAction = `-- name: ListAuditLogsByAction :many
SELECT id, user_id, action, module, entity_id, entity_type, changes, ip_address, user_agent, created_at FROM activity_log
WHERE action = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByActionParams struct {
	Action string `json:"action"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListAuditLogsByAction(ctx context.Context, arg ListAuditLogsByActionParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByAction, arg.Action, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.Module,
			&i.EntityID,
			&i.EntityType,
			&i.Changes,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByEntity = `-- name: ListAuditLogsByEntity :many
SELECT id, user_id, action, module, entity_id, entity_type, changes, ip_address, user_agent, created_at FROM activity_log
WHERE module = $1 AND entity_type = $2 AND entity_id = $3
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type ListAuditLogsByEntityParams struct {
	Module     string    `json:"module"`
	EntityType string    `json:"entityType"`
	EntityID   uuid.UUID `json:"entityId"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) ListAuditLogsByEntity(ctx context.Context, arg ListAuditLogsByEntityParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByEntity,
		arg.Module,
		arg.EntityType,
		arg.EntityID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.Module,
			&i.EntityID,
			&i.EntityType,
			&i.Changes,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByModule = `-- name: ListAuditLogsByModule :many
SELECT id, user_id, action, module, entity_id, entity_type, changes, ip_address, user_agent, created_at FROM activity_log
WHERE module = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByModuleParams struct {
	Module string `json:"module"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListAuditLogsByModule(ctx context.Context, arg ListAuditLogsByModuleParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByModule, arg.Module, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.Module,
			&i.EntityID,
			&i.EntityType,
			&i.Changes,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByUser = `-- name: ListAuditLogsByUser :many
SELECT id, user_id, action, module, entity_id, entity_type, changes, ip_address, user_agent, created_at FROM activity_log
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByUserParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListAuditLogsByUser(ctx context.Context, arg ListAuditLogsByUserParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.Module,
			&i.EntityID,
			&i.EntityType,
			&i.Changes,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentAuditLogs = `-- name: ListRecentAuditLogs :many
SELECT id, user_id, action, module, entity_id, entity_type, changes, ip_address, user_agent, created_at FROM activity_log
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListRecentAuditLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListRecentAuditLogs(ctx context.Context, arg ListRecentAuditLogsParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, listRecentAuditLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.Module,
			&i.EntityID,
			&i.EntityType,
			&i.Changes,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
