// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: libraries.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countLibraries = `-- name: CountLibraries :one
SELECT COUNT(*) FROM libraries
`

func (q *Queries) CountLibraries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLibraries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLibrary = `-- name: CreateLibrary :one
INSERT INTO libraries (name, type, paths, settings, is_visible, is_adult, scan_interval_hours)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, name, type, paths, settings, is_visible, is_adult,
          scan_interval_hours, last_scan_at, created_at, updated_at
`

type CreateLibraryParams struct {
	Name              string          `json:"name"`
	Type              LibraryType     `json:"type"`
	Paths             []string        `json:"paths"`
	Settings          json.RawMessage `json:"settings"`
	IsVisible         bool            `json:"isVisible"`
	IsAdult           bool            `json:"isAdult"`
	ScanIntervalHours pgtype.Int4     `json:"scanIntervalHours"`
}

type CreateLibraryRow struct {
	ID                uuid.UUID          `json:"id"`
	Name              string             `json:"name"`
	Type              LibraryType        `json:"type"`
	Paths             []string           `json:"paths"`
	Settings          json.RawMessage    `json:"settings"`
	IsVisible         bool               `json:"isVisible"`
	IsAdult           bool               `json:"isAdult"`
	ScanIntervalHours pgtype.Int4        `json:"scanIntervalHours"`
	LastScanAt        pgtype.Timestamptz `json:"lastScanAt"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
}

func (q *Queries) CreateLibrary(ctx context.Context, arg CreateLibraryParams) (CreateLibraryRow, error) {
	row := q.db.QueryRow(ctx, createLibrary,
		arg.Name,
		arg.Type,
		arg.Paths,
		arg.Settings,
		arg.IsVisible,
		arg.IsAdult,
		arg.ScanIntervalHours,
	)
	var i CreateLibraryRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Paths,
		&i.Settings,
		&i.IsVisible,
		&i.IsAdult,
		&i.ScanIntervalHours,
		&i.LastScanAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLibrary = `-- name: DeleteLibrary :exec
DELETE FROM libraries WHERE id = $1
`

func (q *Queries) DeleteLibrary(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteLibrary, id)
	return err
}

const getLibraryByID = `-- name: GetLibraryByID :one
SELECT id, name, type, paths, settings, is_visible, is_adult,
       scan_interval_hours, last_scan_at, created_at, updated_at
FROM libraries
WHERE id = $1
`

type GetLibraryByIDRow struct {
	ID                uuid.UUID          `json:"id"`
	Name              string             `json:"name"`
	Type              LibraryType        `json:"type"`
	Paths             []string           `json:"paths"`
	Settings          json.RawMessage    `json:"settings"`
	IsVisible         bool               `json:"isVisible"`
	IsAdult           bool               `json:"isAdult"`
	ScanIntervalHours pgtype.Int4        `json:"scanIntervalHours"`
	LastScanAt        pgtype.Timestamptz `json:"lastScanAt"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
}

func (q *Queries) GetLibraryByID(ctx context.Context, id uuid.UUID) (GetLibraryByIDRow, error) {
	row := q.db.QueryRow(ctx, getLibraryByID, id)
	var i GetLibraryByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Paths,
		&i.Settings,
		&i.IsVisible,
		&i.IsAdult,
		&i.ScanIntervalHours,
		&i.LastScanAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLibraryByName = `-- name: GetLibraryByName :one
SELECT id, name, type, paths, settings, is_visible, is_adult,
       scan_interval_hours, last_scan_at, created_at, updated_at
FROM libraries
WHERE name = $1
`

type GetLibraryByNameRow struct {
	ID                uuid.UUID          `json:"id"`
	Name              string             `json:"name"`
	Type              LibraryType        `json:"type"`
	Paths             []string           `json:"paths"`
	Settings          json.RawMessage    `json:"settings"`
	IsVisible         bool               `json:"isVisible"`
	IsAdult           bool               `json:"isAdult"`
	ScanIntervalHours pgtype.Int4        `json:"scanIntervalHours"`
	LastScanAt        pgtype.Timestamptz `json:"lastScanAt"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
}

func (q *Queries) GetLibraryByName(ctx context.Context, name string) (GetLibraryByNameRow, error) {
	row := q.db.QueryRow(ctx, getLibraryByName, name)
	var i GetLibraryByNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Paths,
		&i.Settings,
		&i.IsVisible,
		&i.IsAdult,
		&i.ScanIntervalHours,
		&i.LastScanAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const libraryNameExists = `-- name: LibraryNameExists :one
SELECT EXISTS (SELECT 1 FROM libraries WHERE name = $1) AS exists
`

func (q *Queries) LibraryNameExists(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRow(ctx, libraryNameExists, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const libraryNameExistsExcluding = `-- name: LibraryNameExistsExcluding :one
SELECT EXISTS (SELECT 1 FROM libraries WHERE name = $1 AND id != $2) AS exists
`

type LibraryNameExistsExcludingParams struct {
	Name string    `json:"name"`
	ID   uuid.UUID `json:"id"`
}

func (q *Queries) LibraryNameExistsExcluding(ctx context.Context, arg LibraryNameExistsExcludingParams) (bool, error) {
	row := q.db.QueryRow(ctx, libraryNameExistsExcluding, arg.Name, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listLibraries = `-- name: ListLibraries :many
SELECT id, name, type, paths, settings, is_visible, is_adult,
       scan_interval_hours, last_scan_at, created_at, updated_at
FROM libraries
ORDER BY name
`

type ListLibrariesRow struct {
	ID                uuid.UUID          `json:"id"`
	Name              string             `json:"name"`
	Type              LibraryType        `json:"type"`
	Paths             []string           `json:"paths"`
	Settings          json.RawMessage    `json:"settings"`
	IsVisible         bool               `json:"isVisible"`
	IsAdult           bool               `json:"isAdult"`
	ScanIntervalHours pgtype.Int4        `json:"scanIntervalHours"`
	LastScanAt        pgtype.Timestamptz `json:"lastScanAt"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
}

func (q *Queries) ListLibraries(ctx context.Context) ([]ListLibrariesRow, error) {
	rows, err := q.db.Query(ctx, listLibraries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLibrariesRow{}
	for rows.Next() {
		var i ListLibrariesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Paths,
			&i.Settings,
			&i.IsVisible,
			&i.IsAdult,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLibrariesByType = `-- name: ListLibrariesByType :many
SELECT id, name, type, paths, settings, is_visible, is_adult,
       scan_interval_hours, last_scan_at, created_at, updated_at
FROM libraries
WHERE type = $1
ORDER BY name
`

type ListLibrariesByTypeRow struct {
	ID                uuid.UUID          `json:"id"`
	Name              string             `json:"name"`
	Type              LibraryType        `json:"type"`
	Paths             []string           `json:"paths"`
	Settings          json.RawMessage    `json:"settings"`
	IsVisible         bool               `json:"isVisible"`
	IsAdult           bool               `json:"isAdult"`
	ScanIntervalHours pgtype.Int4        `json:"scanIntervalHours"`
	LastScanAt        pgtype.Timestamptz `json:"lastScanAt"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
}

func (q *Queries) ListLibrariesByType(ctx context.Context, type_ LibraryType) ([]ListLibrariesByTypeRow, error) {
	rows, err := q.db.Query(ctx, listLibrariesByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLibrariesByTypeRow{}
	for rows.Next() {
		var i ListLibrariesByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Paths,
			&i.Settings,
			&i.IsVisible,
			&i.IsAdult,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLibrariesForUser = `-- name: ListLibrariesForUser :many
SELECT l.id, l.name, l.type, l.paths, l.settings, l.is_visible, l.is_adult,
       l.scan_interval_hours, l.last_scan_at, l.created_at, l.updated_at
FROM libraries l
JOIN users u ON u.id = $1
WHERE l.is_visible = true
  AND (NOT l.is_adult OR u.adult_content_enabled = true)
ORDER BY l.name
`

type ListLibrariesForUserRow struct {
	ID                uuid.UUID          `json:"id"`
	Name              string             `json:"name"`
	Type              LibraryType        `json:"type"`
	Paths             []string           `json:"paths"`
	Settings          json.RawMessage    `json:"settings"`
	IsVisible         bool               `json:"isVisible"`
	IsAdult           bool               `json:"isAdult"`
	ScanIntervalHours pgtype.Int4        `json:"scanIntervalHours"`
	LastScanAt        pgtype.Timestamptz `json:"lastScanAt"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
}

// List libraries accessible to a user (considers adult content settings)
func (q *Queries) ListLibrariesForUser(ctx context.Context, id uuid.UUID) ([]ListLibrariesForUserRow, error) {
	rows, err := q.db.Query(ctx, listLibrariesForUser, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLibrariesForUserRow{}
	for rows.Next() {
		var i ListLibrariesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Paths,
			&i.Settings,
			&i.IsVisible,
			&i.IsAdult,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonAdultLibraries = `-- name: ListNonAdultLibraries :many
SELECT id, name, type, paths, settings, is_visible, is_adult,
       scan_interval_hours, last_scan_at, created_at, updated_at
FROM libraries
WHERE is_adult = false
ORDER BY name
`

type ListNonAdultLibrariesRow struct {
	ID                uuid.UUID          `json:"id"`
	Name              string             `json:"name"`
	Type              LibraryType        `json:"type"`
	Paths             []string           `json:"paths"`
	Settings          json.RawMessage    `json:"settings"`
	IsVisible         bool               `json:"isVisible"`
	IsAdult           bool               `json:"isAdult"`
	ScanIntervalHours pgtype.Int4        `json:"scanIntervalHours"`
	LastScanAt        pgtype.Timestamptz `json:"lastScanAt"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
}

func (q *Queries) ListNonAdultLibraries(ctx context.Context) ([]ListNonAdultLibrariesRow, error) {
	rows, err := q.db.Query(ctx, listNonAdultLibraries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListNonAdultLibrariesRow{}
	for rows.Next() {
		var i ListNonAdultLibrariesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Paths,
			&i.Settings,
			&i.IsVisible,
			&i.IsAdult,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVisibleLibraries = `-- name: ListVisibleLibraries :many
SELECT id, name, type, paths, settings, is_visible, is_adult,
       scan_interval_hours, last_scan_at, created_at, updated_at
FROM libraries
WHERE is_visible = true
ORDER BY name
`

type ListVisibleLibrariesRow struct {
	ID                uuid.UUID          `json:"id"`
	Name              string             `json:"name"`
	Type              LibraryType        `json:"type"`
	Paths             []string           `json:"paths"`
	Settings          json.RawMessage    `json:"settings"`
	IsVisible         bool               `json:"isVisible"`
	IsAdult           bool               `json:"isAdult"`
	ScanIntervalHours pgtype.Int4        `json:"scanIntervalHours"`
	LastScanAt        pgtype.Timestamptz `json:"lastScanAt"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
}

func (q *Queries) ListVisibleLibraries(ctx context.Context) ([]ListVisibleLibrariesRow, error) {
	rows, err := q.db.Query(ctx, listVisibleLibraries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVisibleLibrariesRow{}
	for rows.Next() {
		var i ListVisibleLibrariesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Paths,
			&i.Settings,
			&i.IsVisible,
			&i.IsAdult,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLibrary = `-- name: UpdateLibrary :exec
UPDATE libraries
SET name = COALESCE($1, name),
    paths = COALESCE($2, paths),
    settings = COALESCE($3, settings),
    is_visible = COALESCE($4, is_visible),
    scan_interval_hours = COALESCE($5, scan_interval_hours),
    updated_at = NOW()
WHERE id = $6
`

type UpdateLibraryParams struct {
	Name              pgtype.Text `json:"name"`
	Paths             []string    `json:"paths"`
	Settings          []byte      `json:"settings"`
	IsVisible         pgtype.Bool `json:"isVisible"`
	ScanIntervalHours pgtype.Int4 `json:"scanIntervalHours"`
	ID                uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateLibrary(ctx context.Context, arg UpdateLibraryParams) error {
	_, err := q.db.Exec(ctx, updateLibrary,
		arg.Name,
		arg.Paths,
		arg.Settings,
		arg.IsVisible,
		arg.ScanIntervalHours,
		arg.ID,
	)
	return err
}

const updateLibraryLastScan = `-- name: UpdateLibraryLastScan :exec
UPDATE libraries
SET last_scan_at = NOW(), updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateLibraryLastScan(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateLibraryLastScan, id)
	return err
}
