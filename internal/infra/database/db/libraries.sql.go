// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: libraries.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countLibraries = `-- name: CountLibraries :one
SELECT COUNT(*) FROM libraries
`

func (q *Queries) CountLibraries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLibraries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLibrary = `-- name: CreateLibrary :one
INSERT INTO libraries (
    name, type, paths,
    scan_enabled, scan_interval_hours,
    preferred_language, download_images, download_nfo, generate_chapters,
    is_private, owner_user_id, sort_order, icon
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, name, type, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, download_images, download_nfo, generate_chapters, is_private, owner_user_id, sort_order, icon, created_at, updated_at
`

type CreateLibraryParams struct {
	Name              string      `json:"name"`
	Type              LibraryType `json:"type"`
	Paths             []string    `json:"paths"`
	ScanEnabled       bool        `json:"scanEnabled"`
	ScanIntervalHours int32       `json:"scanIntervalHours"`
	PreferredLanguage *string     `json:"preferredLanguage"`
	DownloadImages    bool        `json:"downloadImages"`
	DownloadNfo       bool        `json:"downloadNfo"`
	GenerateChapters  bool        `json:"generateChapters"`
	IsPrivate         bool        `json:"isPrivate"`
	OwnerUserID       pgtype.UUID `json:"ownerUserId"`
	SortOrder         int32       `json:"sortOrder"`
	Icon              *string     `json:"icon"`
}

func (q *Queries) CreateLibrary(ctx context.Context, arg CreateLibraryParams) (Library, error) {
	row := q.db.QueryRow(ctx, createLibrary,
		arg.Name,
		arg.Type,
		arg.Paths,
		arg.ScanEnabled,
		arg.ScanIntervalHours,
		arg.PreferredLanguage,
		arg.DownloadImages,
		arg.DownloadNfo,
		arg.GenerateChapters,
		arg.IsPrivate,
		arg.OwnerUserID,
		arg.SortOrder,
		arg.Icon,
	)
	var i Library
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Paths,
		&i.ScanEnabled,
		&i.ScanIntervalHours,
		&i.LastScanAt,
		&i.LastScanDuration,
		&i.PreferredLanguage,
		&i.DownloadImages,
		&i.DownloadNfo,
		&i.GenerateChapters,
		&i.IsPrivate,
		&i.OwnerUserID,
		&i.SortOrder,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLibrary = `-- name: DeleteLibrary :exec
DELETE FROM libraries WHERE id = $1
`

func (q *Queries) DeleteLibrary(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteLibrary, id)
	return err
}

const getLibraryByID = `-- name: GetLibraryByID :one
SELECT id, name, type, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, download_images, download_nfo, generate_chapters, is_private, owner_user_id, sort_order, icon, created_at, updated_at FROM libraries WHERE id = $1
`

func (q *Queries) GetLibraryByID(ctx context.Context, id uuid.UUID) (Library, error) {
	row := q.db.QueryRow(ctx, getLibraryByID, id)
	var i Library
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Paths,
		&i.ScanEnabled,
		&i.ScanIntervalHours,
		&i.LastScanAt,
		&i.LastScanDuration,
		&i.PreferredLanguage,
		&i.DownloadImages,
		&i.DownloadNfo,
		&i.GenerateChapters,
		&i.IsPrivate,
		&i.OwnerUserID,
		&i.SortOrder,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const grantLibraryAccess = `-- name: GrantLibraryAccess :exec
INSERT INTO library_user_access (library_id, user_id, can_manage)
VALUES ($1, $2, $3)
ON CONFLICT (library_id, user_id) DO UPDATE SET can_manage = $3
`

type GrantLibraryAccessParams struct {
	LibraryID uuid.UUID `json:"libraryId"`
	UserID    uuid.UUID `json:"userId"`
	CanManage bool      `json:"canManage"`
}

// Library User Access
func (q *Queries) GrantLibraryAccess(ctx context.Context, arg GrantLibraryAccessParams) error {
	_, err := q.db.Exec(ctx, grantLibraryAccess, arg.LibraryID, arg.UserID, arg.CanManage)
	return err
}

const listAccessibleLibraries = `-- name: ListAccessibleLibraries :many
SELECT l.id, l.name, l.type, l.paths, l.scan_enabled, l.scan_interval_hours, l.last_scan_at, l.last_scan_duration, l.preferred_language, l.download_images, l.download_nfo, l.generate_chapters, l.is_private, l.owner_user_id, l.sort_order, l.icon, l.created_at, l.updated_at FROM libraries l
LEFT JOIN library_user_access lua ON l.id = lua.library_id
WHERE l.is_private = false
   OR l.owner_user_id = $1
   OR lua.user_id = $1
ORDER BY l.sort_order ASC, l.name ASC
`

func (q *Queries) ListAccessibleLibraries(ctx context.Context, ownerUserID pgtype.UUID) ([]Library, error) {
	rows, err := q.db.Query(ctx, listAccessibleLibraries, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Library{}
	for rows.Next() {
		var i Library
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Paths,
			&i.ScanEnabled,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.LastScanDuration,
			&i.PreferredLanguage,
			&i.DownloadImages,
			&i.DownloadNfo,
			&i.GenerateChapters,
			&i.IsPrivate,
			&i.OwnerUserID,
			&i.SortOrder,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLibraries = `-- name: ListLibraries :many
SELECT id, name, type, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, download_images, download_nfo, generate_chapters, is_private, owner_user_id, sort_order, icon, created_at, updated_at FROM libraries
ORDER BY sort_order ASC, name ASC
`

func (q *Queries) ListLibraries(ctx context.Context) ([]Library, error) {
	rows, err := q.db.Query(ctx, listLibraries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Library{}
	for rows.Next() {
		var i Library
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Paths,
			&i.ScanEnabled,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.LastScanDuration,
			&i.PreferredLanguage,
			&i.DownloadImages,
			&i.DownloadNfo,
			&i.GenerateChapters,
			&i.IsPrivate,
			&i.OwnerUserID,
			&i.SortOrder,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLibrariesByType = `-- name: ListLibrariesByType :many
SELECT id, name, type, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, download_images, download_nfo, generate_chapters, is_private, owner_user_id, sort_order, icon, created_at, updated_at FROM libraries
WHERE type = $1
ORDER BY sort_order ASC, name ASC
`

func (q *Queries) ListLibrariesByType(ctx context.Context, type_ LibraryType) ([]Library, error) {
	rows, err := q.db.Query(ctx, listLibrariesByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Library{}
	for rows.Next() {
		var i Library
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Paths,
			&i.ScanEnabled,
			&i.ScanIntervalHours,
			&i.LastScanAt,
			&i.LastScanDuration,
			&i.PreferredLanguage,
			&i.DownloadImages,
			&i.DownloadNfo,
			&i.GenerateChapters,
			&i.IsPrivate,
			&i.OwnerUserID,
			&i.SortOrder,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLibraryUsers = `-- name: ListLibraryUsers :many
SELECT lua.library_id, lua.user_id, lua.can_manage, u.username, u.email
FROM library_user_access lua
JOIN users u ON lua.user_id = u.id
WHERE lua.library_id = $1
`

type ListLibraryUsersRow struct {
	LibraryID uuid.UUID `json:"libraryId"`
	UserID    uuid.UUID `json:"userId"`
	CanManage bool      `json:"canManage"`
	Username  string    `json:"username"`
	Email     *string   `json:"email"`
}

func (q *Queries) ListLibraryUsers(ctx context.Context, libraryID uuid.UUID) ([]ListLibraryUsersRow, error) {
	rows, err := q.db.Query(ctx, listLibraryUsers, libraryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLibraryUsersRow{}
	for rows.Next() {
		var i ListLibraryUsersRow
		if err := rows.Scan(
			&i.LibraryID,
			&i.UserID,
			&i.CanManage,
			&i.Username,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeLibraryAccess = `-- name: RevokeLibraryAccess :exec
DELETE FROM library_user_access
WHERE library_id = $1 AND user_id = $2
`

type RevokeLibraryAccessParams struct {
	LibraryID uuid.UUID `json:"libraryId"`
	UserID    uuid.UUID `json:"userId"`
}

func (q *Queries) RevokeLibraryAccess(ctx context.Context, arg RevokeLibraryAccessParams) error {
	_, err := q.db.Exec(ctx, revokeLibraryAccess, arg.LibraryID, arg.UserID)
	return err
}

const updateLibrary = `-- name: UpdateLibrary :one
UPDATE libraries SET
    name = COALESCE($1, name),
    paths = COALESCE($2, paths),
    scan_enabled = COALESCE($3, scan_enabled),
    scan_interval_hours = COALESCE($4, scan_interval_hours),
    preferred_language = COALESCE($5, preferred_language),
    download_images = COALESCE($6, download_images),
    download_nfo = COALESCE($7, download_nfo),
    generate_chapters = COALESCE($8, generate_chapters),
    is_private = COALESCE($9, is_private),
    sort_order = COALESCE($10, sort_order),
    icon = COALESCE($11, icon)
WHERE id = $12
RETURNING id, name, type, paths, scan_enabled, scan_interval_hours, last_scan_at, last_scan_duration, preferred_language, download_images, download_nfo, generate_chapters, is_private, owner_user_id, sort_order, icon, created_at, updated_at
`

type UpdateLibraryParams struct {
	Name              *string   `json:"name"`
	Paths             []string  `json:"paths"`
	ScanEnabled       *bool     `json:"scanEnabled"`
	ScanIntervalHours *int32    `json:"scanIntervalHours"`
	PreferredLanguage *string   `json:"preferredLanguage"`
	DownloadImages    *bool     `json:"downloadImages"`
	DownloadNfo       *bool     `json:"downloadNfo"`
	GenerateChapters  *bool     `json:"generateChapters"`
	IsPrivate         *bool     `json:"isPrivate"`
	SortOrder         *int32    `json:"sortOrder"`
	Icon              *string   `json:"icon"`
	ID                uuid.UUID `json:"id"`
}

func (q *Queries) UpdateLibrary(ctx context.Context, arg UpdateLibraryParams) (Library, error) {
	row := q.db.QueryRow(ctx, updateLibrary,
		arg.Name,
		arg.Paths,
		arg.ScanEnabled,
		arg.ScanIntervalHours,
		arg.PreferredLanguage,
		arg.DownloadImages,
		arg.DownloadNfo,
		arg.GenerateChapters,
		arg.IsPrivate,
		arg.SortOrder,
		arg.Icon,
		arg.ID,
	)
	var i Library
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Paths,
		&i.ScanEnabled,
		&i.ScanIntervalHours,
		&i.LastScanAt,
		&i.LastScanDuration,
		&i.PreferredLanguage,
		&i.DownloadImages,
		&i.DownloadNfo,
		&i.GenerateChapters,
		&i.IsPrivate,
		&i.OwnerUserID,
		&i.SortOrder,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLibraryScanStatus = `-- name: UpdateLibraryScanStatus :exec
UPDATE libraries SET
    last_scan_at = NOW(),
    last_scan_duration = $2
WHERE id = $1
`

type UpdateLibraryScanStatusParams struct {
	ID               uuid.UUID       `json:"id"`
	LastScanDuration pgtype.Interval `json:"lastScanDuration"`
}

func (q *Queries) UpdateLibraryScanStatus(ctx context.Context, arg UpdateLibraryScanStatusParams) error {
	_, err := q.db.Exec(ctx, updateLibraryScanStatus, arg.ID, arg.LastScanDuration)
	return err
}

const userCanAccessLibrary = `-- name: UserCanAccessLibrary :one
SELECT EXISTS(
    SELECT 1 FROM libraries l
    LEFT JOIN library_user_access lua ON l.id = lua.library_id
    WHERE l.id = $1
      AND (l.is_private = false OR l.owner_user_id = $2 OR lua.user_id = $2)
)
`

type UserCanAccessLibraryParams struct {
	ID          uuid.UUID   `json:"id"`
	OwnerUserID pgtype.UUID `json:"ownerUserId"`
}

func (q *Queries) UserCanAccessLibrary(ctx context.Context, arg UserCanAccessLibraryParams) (bool, error) {
	row := q.db.QueryRow(ctx, userCanAccessLibrary, arg.ID, arg.OwnerUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
