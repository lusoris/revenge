// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql
//
// Security note: gosec G101 warnings suppressed - these are SQL query names
// and parameter names, not actual credentials or secrets.
// #nosec G101 -- SQLC generated code, query/field names not credentials

package db

import (
	"context"
	"net/netip"

	"github.com/google/uuid"
)

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM shared.users
WHERE deleted_at IS NULL
  AND ($1::boolean IS NULL OR is_active = $1)
  AND ($2::boolean IS NULL OR is_admin = $2)
`

type CountUsersParams struct {
	IsActive *bool `json:"isActive"`
	IsAdmin  *bool `json:"isAdmin"`
}

// Count users matching filters
func (q *Queries) CountUsers(ctx context.Context, arg CountUsersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers, arg.IsActive, arg.IsAdmin)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAvatar = `-- name: CreateAvatar :one
INSERT INTO shared.user_avatars (
    user_id,
    file_path,
    file_size_bytes,
    mime_type,
    width,
    height,
    is_animated,
    version,
    is_current,
    uploaded_from_ip,
    uploaded_from_user_agent
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, TRUE, $9, $10
) RETURNING id, user_id, file_path, file_size_bytes, mime_type, width, height, is_animated, version, is_current, uploaded_at, uploaded_from_ip, uploaded_from_user_agent, created_at, updated_at, deleted_at
`

type CreateAvatarParams struct {
	UserID                uuid.UUID  `json:"userId"`
	FilePath              string     `json:"filePath"`
	FileSizeBytes         int64      `json:"fileSizeBytes"`
	MimeType              string     `json:"mimeType"`
	Width                 int32      `json:"width"`
	Height                int32      `json:"height"`
	IsAnimated            *bool      `json:"isAnimated"`
	Version               int32      `json:"version"`
	UploadedFromIp        netip.Addr `json:"uploadedFromIp"`
	UploadedFromUserAgent *string    `json:"uploadedFromUserAgent"`
}

// Upload a new avatar (sets it as current)
func (q *Queries) CreateAvatar(ctx context.Context, arg CreateAvatarParams) (SharedUserAvatar, error) {
	row := q.db.QueryRow(ctx, createAvatar,
		arg.UserID,
		arg.FilePath,
		arg.FileSizeBytes,
		arg.MimeType,
		arg.Width,
		arg.Height,
		arg.IsAnimated,
		arg.Version,
		arg.UploadedFromIp,
		arg.UploadedFromUserAgent,
	)
	var i SharedUserAvatar
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FilePath,
		&i.FileSizeBytes,
		&i.MimeType,
		&i.Width,
		&i.Height,
		&i.IsAnimated,
		&i.Version,
		&i.IsCurrent,
		&i.UploadedAt,
		&i.UploadedFromIp,
		&i.UploadedFromUserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO shared.users (
    username,
    email,
    password_hash,
    display_name,
    timezone,
    qar_enabled,
    is_active,
    is_admin
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, username, email, password_hash, display_name, avatar_url, locale, timezone, qar_enabled, is_active, is_admin, email_verified, email_verified_at, created_at, updated_at, last_login_at, deleted_at
`

type CreateUserParams struct {
	Username     string  `json:"username"`
	Email        string  `json:"email"`
	PasswordHash string  `json:"passwordHash"`
	DisplayName  *string `json:"displayName"`
	Timezone     *string `json:"timezone"`
	QarEnabled   *bool   `json:"qarEnabled"`
	IsActive     *bool   `json:"isActive"`
	IsAdmin      *bool   `json:"isAdmin"`
}

// Create a new user
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (SharedUser, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.DisplayName,
		arg.Timezone,
		arg.QarEnabled,
		arg.IsActive,
		arg.IsAdmin,
	)
	var i SharedUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Locale,
		&i.Timezone,
		&i.QarEnabled,
		&i.IsActive,
		&i.IsAdmin,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteAvatar = `-- name: DeleteAvatar :exec
UPDATE shared.user_avatars
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

// Soft delete an avatar
func (q *Queries) DeleteAvatar(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAvatar, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE shared.users
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

// Soft delete a user
func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const deleteUserPreferences = `-- name: DeleteUserPreferences :exec
DELETE FROM shared.user_preferences
WHERE user_id = $1
`

// Delete user preferences (cleanup on user deletion)
func (q *Queries) DeleteUserPreferences(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserPreferences, userID)
	return err
}

const getAvatarByID = `-- name: GetAvatarByID :one
SELECT id, user_id, file_path, file_size_bytes, mime_type, width, height, is_animated, version, is_current, uploaded_at, uploaded_from_ip, uploaded_from_user_agent, created_at, updated_at, deleted_at FROM shared.user_avatars
WHERE id = $1 AND deleted_at IS NULL
`

// Get a specific avatar by ID
func (q *Queries) GetAvatarByID(ctx context.Context, id uuid.UUID) (SharedUserAvatar, error) {
	row := q.db.QueryRow(ctx, getAvatarByID, id)
	var i SharedUserAvatar
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FilePath,
		&i.FileSizeBytes,
		&i.MimeType,
		&i.Width,
		&i.Height,
		&i.IsAnimated,
		&i.Version,
		&i.IsCurrent,
		&i.UploadedAt,
		&i.UploadedFromIp,
		&i.UploadedFromUserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCurrentAvatar = `-- name: GetCurrentAvatar :one

SELECT id, user_id, file_path, file_size_bytes, mime_type, width, height, is_animated, version, is_current, uploaded_at, uploaded_from_ip, uploaded_from_user_agent, created_at, updated_at, deleted_at FROM shared.user_avatars
WHERE user_id = $1 AND is_current = TRUE AND deleted_at IS NULL
`

// ============================================================================
// User Avatars Queries
// ============================================================================
// Get the current avatar for a user
func (q *Queries) GetCurrentAvatar(ctx context.Context, userID uuid.UUID) (SharedUserAvatar, error) {
	row := q.db.QueryRow(ctx, getCurrentAvatar, userID)
	var i SharedUserAvatar
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FilePath,
		&i.FileSizeBytes,
		&i.MimeType,
		&i.Width,
		&i.Height,
		&i.IsAnimated,
		&i.Version,
		&i.IsCurrent,
		&i.UploadedAt,
		&i.UploadedFromIp,
		&i.UploadedFromUserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getLatestAvatarVersion = `-- name: GetLatestAvatarVersion :one
SELECT COALESCE(MAX(version), 0)::integer as max_version
FROM shared.user_avatars
WHERE user_id = $1
`

// Get the latest avatar version number for a user
func (q *Queries) GetLatestAvatarVersion(ctx context.Context, userID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getLatestAvatarVersion, userID)
	var max_version int32
	err := row.Scan(&max_version)
	return max_version, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash, display_name, avatar_url, locale, timezone, qar_enabled, is_active, is_admin, email_verified, email_verified_at, created_at, updated_at, last_login_at, deleted_at FROM shared.users
WHERE email = $1 AND deleted_at IS NULL
`

// Get a user by email
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (SharedUser, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i SharedUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Locale,
		&i.Timezone,
		&i.QarEnabled,
		&i.IsActive,
		&i.IsAdmin,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, password_hash, display_name, avatar_url, locale, timezone, qar_enabled, is_active, is_admin, email_verified, email_verified_at, created_at, updated_at, last_login_at, deleted_at FROM shared.users
WHERE id = $1 AND deleted_at IS NULL
`

// Get a user by their UUID
func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (SharedUser, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i SharedUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Locale,
		&i.Timezone,
		&i.QarEnabled,
		&i.IsActive,
		&i.IsAdmin,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password_hash, display_name, avatar_url, locale, timezone, qar_enabled, is_active, is_admin, email_verified, email_verified_at, created_at, updated_at, last_login_at, deleted_at FROM shared.users
WHERE username = $1 AND deleted_at IS NULL
`

// Get a user by username
func (q *Queries) GetUserByUsername(ctx context.Context, username string) (SharedUser, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i SharedUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Locale,
		&i.Timezone,
		&i.QarEnabled,
		&i.IsActive,
		&i.IsAdmin,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserPreferences = `-- name: GetUserPreferences :one

SELECT user_id, email_notifications, push_notifications, digest_notifications, profile_visibility, show_email, show_activity, theme, display_language, content_language, show_adult_content, show_spoilers, auto_play_videos, created_at, updated_at FROM shared.user_preferences
WHERE user_id = $1
`

// ============================================================================
// User Preferences Queries
// ============================================================================
// Get user preferences
func (q *Queries) GetUserPreferences(ctx context.Context, userID uuid.UUID) (SharedUserPreference, error) {
	row := q.db.QueryRow(ctx, getUserPreferences, userID)
	var i SharedUserPreference
	err := row.Scan(
		&i.UserID,
		&i.EmailNotifications,
		&i.PushNotifications,
		&i.DigestNotifications,
		&i.ProfileVisibility,
		&i.ShowEmail,
		&i.ShowActivity,
		&i.Theme,
		&i.DisplayLanguage,
		&i.ContentLanguage,
		&i.ShowAdultContent,
		&i.ShowSpoilers,
		&i.AutoPlayVideos,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const hardDeleteAvatar = `-- name: HardDeleteAvatar :exec
DELETE FROM shared.user_avatars
WHERE id = $1
`

// Permanently delete an avatar file
func (q *Queries) HardDeleteAvatar(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteAvatar, id)
	return err
}

const hardDeleteUser = `-- name: HardDeleteUser :exec
DELETE FROM shared.users
WHERE id = $1
`

// Permanently delete a user (GDPR compliance)
func (q *Queries) HardDeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteUser, id)
	return err
}

const listUserAvatars = `-- name: ListUserAvatars :many
SELECT id, user_id, file_path, file_size_bytes, mime_type, width, height, is_animated, version, is_current, uploaded_at, uploaded_from_ip, uploaded_from_user_agent, created_at, updated_at, deleted_at FROM shared.user_avatars
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY version DESC
LIMIT $2 OFFSET $3
`

type ListUserAvatarsParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

// List all avatars for a user (for history)
func (q *Queries) ListUserAvatars(ctx context.Context, arg ListUserAvatarsParams) ([]SharedUserAvatar, error) {
	rows, err := q.db.Query(ctx, listUserAvatars, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharedUserAvatar{}
	for rows.Next() {
		var i SharedUserAvatar
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FilePath,
			&i.FileSizeBytes,
			&i.MimeType,
			&i.Width,
			&i.Height,
			&i.IsAnimated,
			&i.Version,
			&i.IsCurrent,
			&i.UploadedAt,
			&i.UploadedFromIp,
			&i.UploadedFromUserAgent,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, password_hash, display_name, avatar_url, locale, timezone, qar_enabled, is_active, is_admin, email_verified, email_verified_at, created_at, updated_at, last_login_at, deleted_at FROM shared.users
WHERE deleted_at IS NULL
  AND ($1::boolean IS NULL OR is_active = $1)
  AND ($2::boolean IS NULL OR is_admin = $2)
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type ListUsersParams struct {
	IsActive *bool `json:"isActive"`
	IsAdmin  *bool `json:"isAdmin"`
	Offset   int32 `json:"offset"`
	Limit    int32 `json:"limit"`
}

// List all active users with optional filters
// Use sqlc.narg for nullable parameters
func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]SharedUser, error) {
	rows, err := q.db.Query(ctx, listUsers,
		arg.IsActive,
		arg.IsAdmin,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharedUser{}
	for rows.Next() {
		var i SharedUser
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.Locale,
			&i.Timezone,
			&i.QarEnabled,
			&i.IsActive,
			&i.IsAdmin,
			&i.EmailVerified,
			&i.EmailVerifiedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCurrentAvatar = `-- name: SetCurrentAvatar :exec
UPDATE shared.user_avatars
SET is_current = TRUE, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

// Set an existing avatar as current
func (q *Queries) SetCurrentAvatar(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, setCurrentAvatar, id)
	return err
}

const unsetCurrentAvatars = `-- name: UnsetCurrentAvatars :exec
UPDATE shared.user_avatars
SET is_current = FALSE, updated_at = NOW()
WHERE user_id = $1 AND is_current = TRUE AND deleted_at IS NULL
`

// Mark all user's avatars as not current (before setting a new current)
func (q *Queries) UnsetCurrentAvatars(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, unsetCurrentAvatars, userID)
	return err
}

const updateLastLogin = `-- name: UpdateLastLogin :exec
UPDATE shared.users
SET last_login_at = NOW(), updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

// Update user last login timestamp
func (q *Queries) UpdateLastLogin(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateLastLogin, id)
	return err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE shared.users
SET password_hash = $2, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdatePasswordParams struct {
	ID           uuid.UUID `json:"id"`
	PasswordHash string    `json:"passwordHash"`
}

// Update user password hash
func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE shared.users
SET
    email = COALESCE($1, email),
    display_name = COALESCE($2, display_name),
    avatar_url = COALESCE($3, avatar_url),
    timezone = COALESCE($4, timezone),
    qar_enabled = COALESCE($5, qar_enabled),
    is_active = COALESCE($6, is_active),
    is_admin = COALESCE($7, is_admin),
    updated_at = NOW()
WHERE id = $8 AND deleted_at IS NULL
RETURNING id, username, email, password_hash, display_name, avatar_url, locale, timezone, qar_enabled, is_active, is_admin, email_verified, email_verified_at, created_at, updated_at, last_login_at, deleted_at
`

type UpdateUserParams struct {
	Email       *string   `json:"email"`
	DisplayName *string   `json:"displayName"`
	AvatarUrl   *string   `json:"avatarUrl"`
	Timezone    *string   `json:"timezone"`
	QarEnabled  *bool     `json:"qarEnabled"`
	IsActive    *bool     `json:"isActive"`
	IsAdmin     *bool     `json:"isAdmin"`
	UserID      uuid.UUID `json:"userId"`
}

// Update user fields
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (SharedUser, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.Email,
		arg.DisplayName,
		arg.AvatarUrl,
		arg.Timezone,
		arg.QarEnabled,
		arg.IsActive,
		arg.IsAdmin,
		arg.UserID,
	)
	var i SharedUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Locale,
		&i.Timezone,
		&i.QarEnabled,
		&i.IsActive,
		&i.IsAdmin,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.DeletedAt,
	)
	return i, err
}

const upsertUserPreferences = `-- name: UpsertUserPreferences :one
INSERT INTO shared.user_preferences (
    user_id,
    email_notifications,
    push_notifications,
    digest_notifications,
    profile_visibility,
    show_email,
    show_activity,
    theme,
    display_language,
    content_language,
    show_adult_content,
    show_spoilers,
    auto_play_videos
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
ON CONFLICT (user_id) DO UPDATE SET
    email_notifications = COALESCE(EXCLUDED.email_notifications, user_preferences.email_notifications),
    push_notifications = COALESCE(EXCLUDED.push_notifications, user_preferences.push_notifications),
    digest_notifications = COALESCE(EXCLUDED.digest_notifications, user_preferences.digest_notifications),
    profile_visibility = COALESCE(EXCLUDED.profile_visibility, user_preferences.profile_visibility),
    show_email = COALESCE(EXCLUDED.show_email, user_preferences.show_email),
    show_activity = COALESCE(EXCLUDED.show_activity, user_preferences.show_activity),
    theme = COALESCE(EXCLUDED.theme, user_preferences.theme),
    display_language = COALESCE(EXCLUDED.display_language, user_preferences.display_language),
    content_language = COALESCE(EXCLUDED.content_language, user_preferences.content_language),
    show_adult_content = COALESCE(EXCLUDED.show_adult_content, user_preferences.show_adult_content),
    show_spoilers = COALESCE(EXCLUDED.show_spoilers, user_preferences.show_spoilers),
    auto_play_videos = COALESCE(EXCLUDED.auto_play_videos, user_preferences.auto_play_videos),
    updated_at = NOW()
RETURNING user_id, email_notifications, push_notifications, digest_notifications, profile_visibility, show_email, show_activity, theme, display_language, content_language, show_adult_content, show_spoilers, auto_play_videos, created_at, updated_at
`

type UpsertUserPreferencesParams struct {
	UserID              uuid.UUID `json:"userId"`
	EmailNotifications  []byte    `json:"emailNotifications"`
	PushNotifications   []byte    `json:"pushNotifications"`
	DigestNotifications []byte    `json:"digestNotifications"`
	ProfileVisibility   *string   `json:"profileVisibility"`
	ShowEmail           *bool     `json:"showEmail"`
	ShowActivity        *bool     `json:"showActivity"`
	Theme               *string   `json:"theme"`
	DisplayLanguage     *string   `json:"displayLanguage"`
	ContentLanguage     *string   `json:"contentLanguage"`
	ShowAdultContent    *bool     `json:"showAdultContent"`
	ShowSpoilers        *bool     `json:"showSpoilers"`
	AutoPlayVideos      *bool     `json:"autoPlayVideos"`
}

// Create or update user preferences
func (q *Queries) UpsertUserPreferences(ctx context.Context, arg UpsertUserPreferencesParams) (SharedUserPreference, error) {
	row := q.db.QueryRow(ctx, upsertUserPreferences,
		arg.UserID,
		arg.EmailNotifications,
		arg.PushNotifications,
		arg.DigestNotifications,
		arg.ProfileVisibility,
		arg.ShowEmail,
		arg.ShowActivity,
		arg.Theme,
		arg.DisplayLanguage,
		arg.ContentLanguage,
		arg.ShowAdultContent,
		arg.ShowSpoilers,
		arg.AutoPlayVideos,
	)
	var i SharedUserPreference
	err := row.Scan(
		&i.UserID,
		&i.EmailNotifications,
		&i.PushNotifications,
		&i.DigestNotifications,
		&i.ProfileVisibility,
		&i.ShowEmail,
		&i.ShowActivity,
		&i.Theme,
		&i.DisplayLanguage,
		&i.ContentLanguage,
		&i.ShowAdultContent,
		&i.ShowSpoilers,
		&i.AutoPlayVideos,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const verifyEmail = `-- name: VerifyEmail :exec
UPDATE shared.users
SET email_verified = TRUE, email_verified_at = NOW(), updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

// Mark email as verified
func (q *Queries) VerifyEmail(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, verifyEmail, id)
	return err
}
