// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: resource_grants.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countResourceGrants = `-- name: CountResourceGrants :one
SELECT COUNT(*) FROM resource_grants
WHERE resource_type = $1 AND resource_id = $2
`

type CountResourceGrantsParams struct {
	ResourceType string    `json:"resourceType"`
	ResourceID   uuid.UUID `json:"resourceId"`
}

func (q *Queries) CountResourceGrants(ctx context.Context, arg CountResourceGrantsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countResourceGrants, arg.ResourceType, arg.ResourceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createResourceGrant = `-- name: CreateResourceGrant :one
INSERT INTO resource_grants (user_id, resource_type, resource_id, grant_type, granted_by, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (user_id, resource_type, resource_id)
DO UPDATE SET grant_type = EXCLUDED.grant_type, granted_by = EXCLUDED.granted_by, granted_at = NOW(), expires_at = EXCLUDED.expires_at
RETURNING id, user_id, resource_type, resource_id, grant_type, granted_by, granted_at, expires_at
`

type CreateResourceGrantParams struct {
	UserID       uuid.UUID          `json:"userId"`
	ResourceType string             `json:"resourceType"`
	ResourceID   uuid.UUID          `json:"resourceId"`
	GrantType    string             `json:"grantType"`
	GrantedBy    pgtype.UUID        `json:"grantedBy"`
	ExpiresAt    pgtype.Timestamptz `json:"expiresAt"`
}

func (q *Queries) CreateResourceGrant(ctx context.Context, arg CreateResourceGrantParams) (ResourceGrant, error) {
	row := q.db.QueryRow(ctx, createResourceGrant,
		arg.UserID,
		arg.ResourceType,
		arg.ResourceID,
		arg.GrantType,
		arg.GrantedBy,
		arg.ExpiresAt,
	)
	var i ResourceGrant
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResourceType,
		&i.ResourceID,
		&i.GrantType,
		&i.GrantedBy,
		&i.GrantedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const deleteExpiredResourceGrants = `-- name: DeleteExpiredResourceGrants :exec
DELETE FROM resource_grants
WHERE expires_at IS NOT NULL AND expires_at < NOW()
`

func (q *Queries) DeleteExpiredResourceGrants(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredResourceGrants)
	return err
}

const deleteResourceGrant = `-- name: DeleteResourceGrant :exec
DELETE FROM resource_grants
WHERE user_id = $1 AND resource_type = $2 AND resource_id = $3
`

type DeleteResourceGrantParams struct {
	UserID       uuid.UUID `json:"userId"`
	ResourceType string    `json:"resourceType"`
	ResourceID   uuid.UUID `json:"resourceId"`
}

func (q *Queries) DeleteResourceGrant(ctx context.Context, arg DeleteResourceGrantParams) error {
	_, err := q.db.Exec(ctx, deleteResourceGrant, arg.UserID, arg.ResourceType, arg.ResourceID)
	return err
}

const deleteResourceGrantByID = `-- name: DeleteResourceGrantByID :exec
DELETE FROM resource_grants WHERE id = $1
`

func (q *Queries) DeleteResourceGrantByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteResourceGrantByID, id)
	return err
}

const deleteResourceGrantsByResource = `-- name: DeleteResourceGrantsByResource :exec
DELETE FROM resource_grants
WHERE resource_type = $1 AND resource_id = $2
`

type DeleteResourceGrantsByResourceParams struct {
	ResourceType string    `json:"resourceType"`
	ResourceID   uuid.UUID `json:"resourceId"`
}

func (q *Queries) DeleteResourceGrantsByResource(ctx context.Context, arg DeleteResourceGrantsByResourceParams) error {
	_, err := q.db.Exec(ctx, deleteResourceGrantsByResource, arg.ResourceType, arg.ResourceID)
	return err
}

const getResourceGrant = `-- name: GetResourceGrant :one
SELECT id, user_id, resource_type, resource_id, grant_type, granted_by, granted_at, expires_at FROM resource_grants
WHERE user_id = $1 AND resource_type = $2 AND resource_id = $3
`

type GetResourceGrantParams struct {
	UserID       uuid.UUID `json:"userId"`
	ResourceType string    `json:"resourceType"`
	ResourceID   uuid.UUID `json:"resourceId"`
}

func (q *Queries) GetResourceGrant(ctx context.Context, arg GetResourceGrantParams) (ResourceGrant, error) {
	row := q.db.QueryRow(ctx, getResourceGrant, arg.UserID, arg.ResourceType, arg.ResourceID)
	var i ResourceGrant
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResourceType,
		&i.ResourceID,
		&i.GrantType,
		&i.GrantedBy,
		&i.GrantedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const hasResourceGrant = `-- name: HasResourceGrant :one
SELECT EXISTS(
    SELECT 1 FROM resource_grants
    WHERE user_id = $1
    AND resource_type = $2
    AND resource_id = $3
    AND grant_type = ANY($4::text[])
    AND (expires_at IS NULL OR expires_at > NOW())
)
`

type HasResourceGrantParams struct {
	UserID       uuid.UUID `json:"userId"`
	ResourceType string    `json:"resourceType"`
	ResourceID   uuid.UUID `json:"resourceId"`
	Column4      []string  `json:"column4"`
}

func (q *Queries) HasResourceGrant(ctx context.Context, arg HasResourceGrantParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasResourceGrant,
		arg.UserID,
		arg.ResourceType,
		arg.ResourceID,
		arg.Column4,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listResourceGrants = `-- name: ListResourceGrants :many
SELECT id, user_id, resource_type, resource_id, grant_type, granted_by, granted_at, expires_at FROM resource_grants
WHERE resource_type = $1 AND resource_id = $2
ORDER BY granted_at DESC
`

type ListResourceGrantsParams struct {
	ResourceType string    `json:"resourceType"`
	ResourceID   uuid.UUID `json:"resourceId"`
}

func (q *Queries) ListResourceGrants(ctx context.Context, arg ListResourceGrantsParams) ([]ResourceGrant, error) {
	rows, err := q.db.Query(ctx, listResourceGrants, arg.ResourceType, arg.ResourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ResourceGrant{}
	for rows.Next() {
		var i ResourceGrant
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ResourceType,
			&i.ResourceID,
			&i.GrantType,
			&i.GrantedBy,
			&i.GrantedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserResourceGrants = `-- name: ListUserResourceGrants :many
SELECT id, user_id, resource_type, resource_id, grant_type, granted_by, granted_at, expires_at FROM resource_grants
WHERE user_id = $1
AND (expires_at IS NULL OR expires_at > NOW())
ORDER BY granted_at DESC
LIMIT $2 OFFSET $3
`

type ListUserResourceGrantsParams struct {
	UserID uuid.UUID `json:"userId"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListUserResourceGrants(ctx context.Context, arg ListUserResourceGrantsParams) ([]ResourceGrant, error) {
	rows, err := q.db.Query(ctx, listUserResourceGrants, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ResourceGrant{}
	for rows.Next() {
		var i ResourceGrant
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ResourceType,
			&i.ResourceID,
			&i.GrantType,
			&i.GrantedBy,
			&i.GrantedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserResourceGrantsByType = `-- name: ListUserResourceGrantsByType :many
SELECT id, user_id, resource_type, resource_id, grant_type, granted_by, granted_at, expires_at FROM resource_grants
WHERE user_id = $1
AND resource_type = $2
AND (expires_at IS NULL OR expires_at > NOW())
ORDER BY granted_at DESC
LIMIT $3 OFFSET $4
`

type ListUserResourceGrantsByTypeParams struct {
	UserID       uuid.UUID `json:"userId"`
	ResourceType string    `json:"resourceType"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

func (q *Queries) ListUserResourceGrantsByType(ctx context.Context, arg ListUserResourceGrantsByTypeParams) ([]ResourceGrant, error) {
	rows, err := q.db.Query(ctx, listUserResourceGrantsByType,
		arg.UserID,
		arg.ResourceType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ResourceGrant{}
	for rows.Next() {
		var i ResourceGrant
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ResourceType,
			&i.ResourceID,
			&i.GrantType,
			&i.GrantedBy,
			&i.GrantedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResourceGrant = `-- name: UpdateResourceGrant :one
UPDATE resource_grants
SET grant_type = $4, expires_at = $5
WHERE user_id = $1 AND resource_type = $2 AND resource_id = $3
RETURNING id, user_id, resource_type, resource_id, grant_type, granted_by, granted_at, expires_at
`

type UpdateResourceGrantParams struct {
	UserID       uuid.UUID          `json:"userId"`
	ResourceType string             `json:"resourceType"`
	ResourceID   uuid.UUID          `json:"resourceId"`
	GrantType    string             `json:"grantType"`
	ExpiresAt    pgtype.Timestamptz `json:"expiresAt"`
}

func (q *Queries) UpdateResourceGrant(ctx context.Context, arg UpdateResourceGrantParams) (ResourceGrant, error) {
	row := q.db.QueryRow(ctx, updateResourceGrant,
		arg.UserID,
		arg.ResourceType,
		arg.ResourceID,
		arg.GrantType,
		arg.ExpiresAt,
	)
	var i ResourceGrant
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResourceType,
		&i.ResourceID,
		&i.GrantType,
		&i.GrantedBy,
		&i.GrantedAt,
		&i.ExpiresAt,
	)
	return i, err
}
