// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ratings.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createContentRating = `-- name: CreateContentRating :one
INSERT INTO content_ratings (content_id, content_type, rating_id, source)
VALUES ($1, $2, $3, $4)
ON CONFLICT (content_id, rating_id) DO UPDATE SET source = EXCLUDED.source
RETURNING id, content_id, content_type, rating_id, source, created_at
`

type CreateContentRatingParams struct {
	ContentID   uuid.UUID   `json:"contentId"`
	ContentType string      `json:"contentType"`
	RatingID    uuid.UUID   `json:"ratingId"`
	Source      pgtype.Text `json:"source"`
}

func (q *Queries) CreateContentRating(ctx context.Context, arg CreateContentRatingParams) (ContentRating, error) {
	row := q.db.QueryRow(ctx, createContentRating,
		arg.ContentID,
		arg.ContentType,
		arg.RatingID,
		arg.Source,
	)
	var i ContentRating
	err := row.Scan(
		&i.ID,
		&i.ContentID,
		&i.ContentType,
		&i.RatingID,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAllContentRatings = `-- name: DeleteAllContentRatings :exec
DELETE FROM content_ratings
WHERE content_id = $1 AND content_type = $2
`

type DeleteAllContentRatingsParams struct {
	ContentID   uuid.UUID `json:"contentId"`
	ContentType string    `json:"contentType"`
}

func (q *Queries) DeleteAllContentRatings(ctx context.Context, arg DeleteAllContentRatingsParams) error {
	_, err := q.db.Exec(ctx, deleteAllContentRatings, arg.ContentID, arg.ContentType)
	return err
}

const deleteContentRating = `-- name: DeleteContentRating :exec
DELETE FROM content_ratings
WHERE content_id = $1 AND rating_id = $2
`

type DeleteContentRatingParams struct {
	ContentID uuid.UUID `json:"contentId"`
	RatingID  uuid.UUID `json:"ratingId"`
}

func (q *Queries) DeleteContentRating(ctx context.Context, arg DeleteContentRatingParams) error {
	_, err := q.db.Exec(ctx, deleteContentRating, arg.ContentID, arg.RatingID)
	return err
}

const filterAllowedContentIDs = `-- name: FilterAllowedContentIDs :many
SELECT cmrl.content_id
FROM content_min_rating_levels cmrl
WHERE cmrl.content_id = ANY($1::uuid[])
  AND cmrl.content_type = $2
  AND cmrl.min_level <= $3
  AND (NOT cmrl.is_adult OR $4 = true)
`

type FilterAllowedContentIDsParams struct {
	Column1     []uuid.UUID `json:"column1"`
	ContentType string      `json:"contentType"`
	MinLevel    interface{} `json:"minLevel"`
	Column4     interface{} `json:"column4"`
}

// Filter a list of content IDs to only those allowed for a user
func (q *Queries) FilterAllowedContentIDs(ctx context.Context, arg FilterAllowedContentIDsParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, filterAllowedContentIDs,
		arg.Column1,
		arg.ContentType,
		arg.MinLevel,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var content_id uuid.UUID
		if err := rows.Scan(&content_id); err != nil {
			return nil, err
		}
		items = append(items, content_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContentDisplayRating = `-- name: GetContentDisplayRating :one
SELECT cr.id, cr.content_id, cr.content_type, cr.rating_id, cr.source, cr.created_at,
       r.code as rating_code, r.name as rating_name, r.normalized_level, r.is_adult,
       rs.code as system_code, rs.name as system_name
FROM content_ratings cr
JOIN ratings r ON cr.rating_id = r.id
JOIN rating_systems rs ON r.system_id = rs.id
WHERE cr.content_id = $1 AND cr.content_type = $2
ORDER BY
    CASE WHEN rs.code = $3 THEN 0 ELSE 1 END,  -- Prefer specified system
    rs.sort_order,
    r.sort_order
LIMIT 1
`

type GetContentDisplayRatingParams struct {
	ContentID   uuid.UUID `json:"contentId"`
	ContentType string    `json:"contentType"`
	Code        string    `json:"code"`
}

type GetContentDisplayRatingRow struct {
	ID              uuid.UUID   `json:"id"`
	ContentID       uuid.UUID   `json:"contentId"`
	ContentType     string      `json:"contentType"`
	RatingID        uuid.UUID   `json:"ratingId"`
	Source          pgtype.Text `json:"source"`
	CreatedAt       time.Time   `json:"createdAt"`
	RatingCode      string      `json:"ratingCode"`
	RatingName      string      `json:"ratingName"`
	NormalizedLevel int32       `json:"normalizedLevel"`
	IsAdult         bool        `json:"isAdult"`
	SystemCode      string      `json:"systemCode"`
	SystemName      string      `json:"systemName"`
}

// Get the rating to display for content, preferring the specified system
func (q *Queries) GetContentDisplayRating(ctx context.Context, arg GetContentDisplayRatingParams) (GetContentDisplayRatingRow, error) {
	row := q.db.QueryRow(ctx, getContentDisplayRating, arg.ContentID, arg.ContentType, arg.Code)
	var i GetContentDisplayRatingRow
	err := row.Scan(
		&i.ID,
		&i.ContentID,
		&i.ContentType,
		&i.RatingID,
		&i.Source,
		&i.CreatedAt,
		&i.RatingCode,
		&i.RatingName,
		&i.NormalizedLevel,
		&i.IsAdult,
		&i.SystemCode,
		&i.SystemName,
	)
	return i, err
}

const getContentMinLevel = `-- name: GetContentMinLevel :one
SELECT content_id, content_type, min_level, is_adult
FROM content_min_rating_levels
WHERE content_id = $1 AND content_type = $2
`

type GetContentMinLevelParams struct {
	ContentID   uuid.UUID `json:"contentId"`
	ContentType string    `json:"contentType"`
}

func (q *Queries) GetContentMinLevel(ctx context.Context, arg GetContentMinLevelParams) (ContentMinRatingLevel, error) {
	row := q.db.QueryRow(ctx, getContentMinLevel, arg.ContentID, arg.ContentType)
	var i ContentMinRatingLevel
	err := row.Scan(
		&i.ContentID,
		&i.ContentType,
		&i.MinLevel,
		&i.IsAdult,
	)
	return i, err
}

const getContentRatings = `-- name: GetContentRatings :many
SELECT cr.id, cr.content_id, cr.content_type, cr.rating_id, cr.source, cr.created_at,
       r.code as rating_code, r.name as rating_name, r.normalized_level, r.is_adult,
       rs.code as system_code, rs.name as system_name
FROM content_ratings cr
JOIN ratings r ON cr.rating_id = r.id
JOIN rating_systems rs ON r.system_id = rs.id
WHERE cr.content_id = $1 AND cr.content_type = $2
ORDER BY rs.sort_order, r.sort_order
`

type GetContentRatingsParams struct {
	ContentID   uuid.UUID `json:"contentId"`
	ContentType string    `json:"contentType"`
}

type GetContentRatingsRow struct {
	ID              uuid.UUID   `json:"id"`
	ContentID       uuid.UUID   `json:"contentId"`
	ContentType     string      `json:"contentType"`
	RatingID        uuid.UUID   `json:"ratingId"`
	Source          pgtype.Text `json:"source"`
	CreatedAt       time.Time   `json:"createdAt"`
	RatingCode      string      `json:"ratingCode"`
	RatingName      string      `json:"ratingName"`
	NormalizedLevel int32       `json:"normalizedLevel"`
	IsAdult         bool        `json:"isAdult"`
	SystemCode      string      `json:"systemCode"`
	SystemName      string      `json:"systemName"`
}

func (q *Queries) GetContentRatings(ctx context.Context, arg GetContentRatingsParams) ([]GetContentRatingsRow, error) {
	rows, err := q.db.Query(ctx, getContentRatings, arg.ContentID, arg.ContentType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContentRatingsRow{}
	for rows.Next() {
		var i GetContentRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.ContentID,
			&i.ContentType,
			&i.RatingID,
			&i.Source,
			&i.CreatedAt,
			&i.RatingCode,
			&i.RatingName,
			&i.NormalizedLevel,
			&i.IsAdult,
			&i.SystemCode,
			&i.SystemName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingByID = `-- name: GetRatingByID :one
SELECT r.id, r.system_id, r.code, r.name, r.description, r.min_age,
       r.normalized_level, r.sort_order, r.is_adult, r.icon_url, r.created_at,
       rs.code as system_code, rs.name as system_name
FROM ratings r
JOIN rating_systems rs ON r.system_id = rs.id
WHERE r.id = $1
`

type GetRatingByIDRow struct {
	ID              uuid.UUID   `json:"id"`
	SystemID        uuid.UUID   `json:"systemId"`
	Code            string      `json:"code"`
	Name            string      `json:"name"`
	Description     pgtype.Text `json:"description"`
	MinAge          pgtype.Int4 `json:"minAge"`
	NormalizedLevel int32       `json:"normalizedLevel"`
	SortOrder       int32       `json:"sortOrder"`
	IsAdult         bool        `json:"isAdult"`
	IconUrl         pgtype.Text `json:"iconUrl"`
	CreatedAt       time.Time   `json:"createdAt"`
	SystemCode      string      `json:"systemCode"`
	SystemName      string      `json:"systemName"`
}

func (q *Queries) GetRatingByID(ctx context.Context, id uuid.UUID) (GetRatingByIDRow, error) {
	row := q.db.QueryRow(ctx, getRatingByID, id)
	var i GetRatingByIDRow
	err := row.Scan(
		&i.ID,
		&i.SystemID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.MinAge,
		&i.NormalizedLevel,
		&i.SortOrder,
		&i.IsAdult,
		&i.IconUrl,
		&i.CreatedAt,
		&i.SystemCode,
		&i.SystemName,
	)
	return i, err
}

const getRatingBySystemAndCode = `-- name: GetRatingBySystemAndCode :one
SELECT r.id, r.system_id, r.code, r.name, r.description, r.min_age,
       r.normalized_level, r.sort_order, r.is_adult, r.icon_url, r.created_at,
       rs.code as system_code, rs.name as system_name
FROM ratings r
JOIN rating_systems rs ON r.system_id = rs.id
WHERE r.system_id = $1 AND r.code = $2
`

type GetRatingBySystemAndCodeParams struct {
	SystemID uuid.UUID `json:"systemId"`
	Code     string    `json:"code"`
}

type GetRatingBySystemAndCodeRow struct {
	ID              uuid.UUID   `json:"id"`
	SystemID        uuid.UUID   `json:"systemId"`
	Code            string      `json:"code"`
	Name            string      `json:"name"`
	Description     pgtype.Text `json:"description"`
	MinAge          pgtype.Int4 `json:"minAge"`
	NormalizedLevel int32       `json:"normalizedLevel"`
	SortOrder       int32       `json:"sortOrder"`
	IsAdult         bool        `json:"isAdult"`
	IconUrl         pgtype.Text `json:"iconUrl"`
	CreatedAt       time.Time   `json:"createdAt"`
	SystemCode      string      `json:"systemCode"`
	SystemName      string      `json:"systemName"`
}

func (q *Queries) GetRatingBySystemAndCode(ctx context.Context, arg GetRatingBySystemAndCodeParams) (GetRatingBySystemAndCodeRow, error) {
	row := q.db.QueryRow(ctx, getRatingBySystemAndCode, arg.SystemID, arg.Code)
	var i GetRatingBySystemAndCodeRow
	err := row.Scan(
		&i.ID,
		&i.SystemID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.MinAge,
		&i.NormalizedLevel,
		&i.SortOrder,
		&i.IsAdult,
		&i.IconUrl,
		&i.CreatedAt,
		&i.SystemCode,
		&i.SystemName,
	)
	return i, err
}

const getRatingEquivalents = `-- name: GetRatingEquivalents :many
SELECT r.id, r.system_id, r.code, r.name, r.description, r.min_age,
       r.normalized_level, r.sort_order, r.is_adult, r.icon_url, r.created_at,
       rs.code as system_code, rs.name as system_name
FROM ratings r
JOIN rating_systems rs ON r.system_id = rs.id
JOIN rating_equivalents re ON r.id = re.equivalent_rating_id
WHERE re.rating_id = $1
ORDER BY rs.sort_order, r.sort_order
`

type GetRatingEquivalentsRow struct {
	ID              uuid.UUID   `json:"id"`
	SystemID        uuid.UUID   `json:"systemId"`
	Code            string      `json:"code"`
	Name            string      `json:"name"`
	Description     pgtype.Text `json:"description"`
	MinAge          pgtype.Int4 `json:"minAge"`
	NormalizedLevel int32       `json:"normalizedLevel"`
	SortOrder       int32       `json:"sortOrder"`
	IsAdult         bool        `json:"isAdult"`
	IconUrl         pgtype.Text `json:"iconUrl"`
	CreatedAt       time.Time   `json:"createdAt"`
	SystemCode      string      `json:"systemCode"`
	SystemName      string      `json:"systemName"`
}

func (q *Queries) GetRatingEquivalents(ctx context.Context, ratingID uuid.UUID) ([]GetRatingEquivalentsRow, error) {
	rows, err := q.db.Query(ctx, getRatingEquivalents, ratingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRatingEquivalentsRow{}
	for rows.Next() {
		var i GetRatingEquivalentsRow
		if err := rows.Scan(
			&i.ID,
			&i.SystemID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.MinAge,
			&i.NormalizedLevel,
			&i.SortOrder,
			&i.IsAdult,
			&i.IconUrl,
			&i.CreatedAt,
			&i.SystemCode,
			&i.SystemName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingSystemByCode = `-- name: GetRatingSystemByCode :one
SELECT id, code, name, country_codes, is_active, sort_order, created_at
FROM rating_systems
WHERE code = $1
`

func (q *Queries) GetRatingSystemByCode(ctx context.Context, code string) (RatingSystem, error) {
	row := q.db.QueryRow(ctx, getRatingSystemByCode, code)
	var i RatingSystem
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CountryCodes,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const getRatingSystemByID = `-- name: GetRatingSystemByID :one
SELECT id, code, name, country_codes, is_active, sort_order, created_at
FROM rating_systems
WHERE id = $1
`

func (q *Queries) GetRatingSystemByID(ctx context.Context, id uuid.UUID) (RatingSystem, error) {
	row := q.db.QueryRow(ctx, getRatingSystemByID, id)
	var i RatingSystem
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CountryCodes,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const isContentAllowed = `-- name: IsContentAllowed :one
SELECT EXISTS (
    SELECT 1 FROM content_min_rating_levels
    WHERE content_id = $1
      AND content_type = $2
      AND min_level <= $3
      AND (NOT is_adult OR $4 = true)
) AS allowed
`

type IsContentAllowedParams struct {
	ContentID   uuid.UUID   `json:"contentId"`
	ContentType string      `json:"contentType"`
	MinLevel    interface{} `json:"minLevel"`
	Column4     interface{} `json:"column4"`
}

// Check if content is allowed for a user's rating level
func (q *Queries) IsContentAllowed(ctx context.Context, arg IsContentAllowedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isContentAllowed,
		arg.ContentID,
		arg.ContentType,
		arg.MinLevel,
		arg.Column4,
	)
	var allowed bool
	err := row.Scan(&allowed)
	return allowed, err
}

const listRatingSystems = `-- name: ListRatingSystems :many
SELECT id, code, name, country_codes, is_active, sort_order, created_at
FROM rating_systems
WHERE is_active = true
ORDER BY sort_order, name
`

func (q *Queries) ListRatingSystems(ctx context.Context) ([]RatingSystem, error) {
	rows, err := q.db.Query(ctx, listRatingSystems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RatingSystem{}
	for rows.Next() {
		var i RatingSystem
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.CountryCodes,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRatingSystemsByCountry = `-- name: ListRatingSystemsByCountry :many
SELECT id, code, name, country_codes, is_active, sort_order, created_at
FROM rating_systems
WHERE is_active = true
  AND $1 = ANY(country_codes)
ORDER BY sort_order, name
`

func (q *Queries) ListRatingSystemsByCountry(ctx context.Context, countryCodes []string) ([]RatingSystem, error) {
	rows, err := q.db.Query(ctx, listRatingSystemsByCountry, countryCodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RatingSystem{}
	for rows.Next() {
		var i RatingSystem
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.CountryCodes,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRatingsByNormalizedLevel = `-- name: ListRatingsByNormalizedLevel :many
SELECT r.id, r.system_id, r.code, r.name, r.description, r.min_age,
       r.normalized_level, r.sort_order, r.is_adult, r.icon_url, r.created_at,
       rs.code as system_code, rs.name as system_name
FROM ratings r
JOIN rating_systems rs ON r.system_id = rs.id
WHERE r.normalized_level <= $1
ORDER BY r.normalized_level, r.system_id, r.sort_order
`

type ListRatingsByNormalizedLevelRow struct {
	ID              uuid.UUID   `json:"id"`
	SystemID        uuid.UUID   `json:"systemId"`
	Code            string      `json:"code"`
	Name            string      `json:"name"`
	Description     pgtype.Text `json:"description"`
	MinAge          pgtype.Int4 `json:"minAge"`
	NormalizedLevel int32       `json:"normalizedLevel"`
	SortOrder       int32       `json:"sortOrder"`
	IsAdult         bool        `json:"isAdult"`
	IconUrl         pgtype.Text `json:"iconUrl"`
	CreatedAt       time.Time   `json:"createdAt"`
	SystemCode      string      `json:"systemCode"`
	SystemName      string      `json:"systemName"`
}

func (q *Queries) ListRatingsByNormalizedLevel(ctx context.Context, normalizedLevel int32) ([]ListRatingsByNormalizedLevelRow, error) {
	rows, err := q.db.Query(ctx, listRatingsByNormalizedLevel, normalizedLevel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRatingsByNormalizedLevelRow{}
	for rows.Next() {
		var i ListRatingsByNormalizedLevelRow
		if err := rows.Scan(
			&i.ID,
			&i.SystemID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.MinAge,
			&i.NormalizedLevel,
			&i.SortOrder,
			&i.IsAdult,
			&i.IconUrl,
			&i.CreatedAt,
			&i.SystemCode,
			&i.SystemName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRatingsBySystem = `-- name: ListRatingsBySystem :many
SELECT r.id, r.system_id, r.code, r.name, r.description, r.min_age,
       r.normalized_level, r.sort_order, r.is_adult, r.icon_url, r.created_at,
       rs.code as system_code, rs.name as system_name
FROM ratings r
JOIN rating_systems rs ON r.system_id = rs.id
WHERE r.system_id = $1
ORDER BY r.sort_order, r.normalized_level
`

type ListRatingsBySystemRow struct {
	ID              uuid.UUID   `json:"id"`
	SystemID        uuid.UUID   `json:"systemId"`
	Code            string      `json:"code"`
	Name            string      `json:"name"`
	Description     pgtype.Text `json:"description"`
	MinAge          pgtype.Int4 `json:"minAge"`
	NormalizedLevel int32       `json:"normalizedLevel"`
	SortOrder       int32       `json:"sortOrder"`
	IsAdult         bool        `json:"isAdult"`
	IconUrl         pgtype.Text `json:"iconUrl"`
	CreatedAt       time.Time   `json:"createdAt"`
	SystemCode      string      `json:"systemCode"`
	SystemName      string      `json:"systemName"`
}

func (q *Queries) ListRatingsBySystem(ctx context.Context, systemID uuid.UUID) ([]ListRatingsBySystemRow, error) {
	rows, err := q.db.Query(ctx, listRatingsBySystem, systemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRatingsBySystemRow{}
	for rows.Next() {
		var i ListRatingsBySystemRow
		if err := rows.Scan(
			&i.ID,
			&i.SystemID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.MinAge,
			&i.NormalizedLevel,
			&i.SortOrder,
			&i.IsAdult,
			&i.IconUrl,
			&i.CreatedAt,
			&i.SystemCode,
			&i.SystemName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshContentMinRatingLevels = `-- name: RefreshContentMinRatingLevels :exec
REFRESH MATERIALIZED VIEW CONCURRENTLY content_min_rating_levels
`

func (q *Queries) RefreshContentMinRatingLevels(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshContentMinRatingLevels)
	return err
}
