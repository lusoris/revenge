// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activity.sql

package db

import (
	"context"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countActivityLogs = `-- name: CountActivityLogs :one
SELECT COUNT(*) FROM public.activity_log
`

// Count total activity logs
func (q *Queries) CountActivityLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActivityLogs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countResourceActivityLogs = `-- name: CountResourceActivityLogs :one
SELECT COUNT(*) FROM public.activity_log
WHERE resource_type = $1 AND resource_id = $2
`

type CountResourceActivityLogsParams struct {
	ResourceType *string     `json:"resourceType"`
	ResourceID   pgtype.UUID `json:"resourceId"`
}

// Count activity logs for a specific resource
func (q *Queries) CountResourceActivityLogs(ctx context.Context, arg CountResourceActivityLogsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countResourceActivityLogs, arg.ResourceType, arg.ResourceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchActivityLogs = `-- name: CountSearchActivityLogs :one
SELECT COUNT(*) FROM public.activity_log
WHERE 
    ($1::UUID IS NULL OR user_id = $1)
    AND ($2::VARCHAR IS NULL OR action = $2)
    AND ($3::VARCHAR IS NULL OR resource_type = $3)
    AND ($4::UUID IS NULL OR resource_id = $4)
    AND ($5::BOOLEAN IS NULL OR success = $5)
    AND ($6::TIMESTAMPTZ IS NULL OR created_at >= $6)
    AND ($7::TIMESTAMPTZ IS NULL OR created_at <= $7)
`

type CountSearchActivityLogsParams struct {
	Column1 uuid.UUID `json:"column1"`
	Column2 string    `json:"column2"`
	Column3 string    `json:"column3"`
	Column4 uuid.UUID `json:"column4"`
	Column5 bool      `json:"column5"`
	Column6 time.Time `json:"column6"`
	Column7 time.Time `json:"column7"`
}

// Count activity logs matching search filters
func (q *Queries) CountSearchActivityLogs(ctx context.Context, arg CountSearchActivityLogsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchActivityLogs,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserActivityLogs = `-- name: CountUserActivityLogs :one
SELECT COUNT(*) FROM public.activity_log WHERE user_id = $1
`

// Count activity logs for a specific user
func (q *Queries) CountUserActivityLogs(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserActivityLogs, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createActivityLog = `-- name: CreateActivityLog :one
INSERT INTO public.activity_log (
    user_id,
    username,
    action,
    resource_type,
    resource_id,
    changes,
    metadata,
    ip_address,
    user_agent,
    success,
    error_message
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, user_id, username, action, resource_type, resource_id, changes, metadata, ip_address, user_agent, success, error_message, created_at
`

type CreateActivityLogParams struct {
	UserID       pgtype.UUID `json:"userId"`
	Username     *string     `json:"username"`
	Action       string      `json:"action"`
	ResourceType *string     `json:"resourceType"`
	ResourceID   pgtype.UUID `json:"resourceId"`
	Changes      []byte      `json:"changes"`
	Metadata     []byte      `json:"metadata"`
	IpAddress    netip.Addr  `json:"ipAddress"`
	UserAgent    *string     `json:"userAgent"`
	Success      *bool       `json:"success"`
	ErrorMessage *string     `json:"errorMessage"`
}

// Insert a new activity log entry
func (q *Queries) CreateActivityLog(ctx context.Context, arg CreateActivityLogParams) (ActivityLog, error) {
	row := q.db.QueryRow(ctx, createActivityLog,
		arg.UserID,
		arg.Username,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.Changes,
		arg.Metadata,
		arg.IpAddress,
		arg.UserAgent,
		arg.Success,
		arg.ErrorMessage,
	)
	var i ActivityLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Changes,
		&i.Metadata,
		&i.IpAddress,
		&i.UserAgent,
		&i.Success,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOldActivityLogs = `-- name: DeleteOldActivityLogs :execrows
DELETE FROM public.activity_log
WHERE created_at < $1
`

// Delete activity logs older than a specific date (for cleanup job)
func (q *Queries) DeleteOldActivityLogs(ctx context.Context, createdAt time.Time) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldActivityLogs, createdAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getActivityLog = `-- name: GetActivityLog :one
SELECT id, user_id, username, action, resource_type, resource_id, changes, metadata, ip_address, user_agent, success, error_message, created_at FROM public.activity_log WHERE id = $1
`

// Get a single activity log entry by ID
func (q *Queries) GetActivityLog(ctx context.Context, id uuid.UUID) (ActivityLog, error) {
	row := q.db.QueryRow(ctx, getActivityLog, id)
	var i ActivityLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Changes,
		&i.Metadata,
		&i.IpAddress,
		&i.UserAgent,
		&i.Success,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const getActivityLogStats = `-- name: GetActivityLogStats :one
SELECT 
    COUNT(*) as total_count,
    COUNT(*) FILTER (WHERE success = true) as success_count,
    COUNT(*) FILTER (WHERE success = false) as failed_count,
    MIN(created_at) as oldest_entry,
    MAX(created_at) as newest_entry
FROM public.activity_log
`

type GetActivityLogStatsRow struct {
	TotalCount   int64       `json:"totalCount"`
	SuccessCount int64       `json:"successCount"`
	FailedCount  int64       `json:"failedCount"`
	OldestEntry  interface{} `json:"oldestEntry"`
	NewestEntry  interface{} `json:"newestEntry"`
}

// Get activity log statistics
func (q *Queries) GetActivityLogStats(ctx context.Context) (GetActivityLogStatsRow, error) {
	row := q.db.QueryRow(ctx, getActivityLogStats)
	var i GetActivityLogStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.SuccessCount,
		&i.FailedCount,
		&i.OldestEntry,
		&i.NewestEntry,
	)
	return i, err
}

const getActivityLogsByAction = `-- name: GetActivityLogsByAction :many
SELECT id, user_id, username, action, resource_type, resource_id, changes, metadata, ip_address, user_agent, success, error_message, created_at FROM public.activity_log
WHERE action = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetActivityLogsByActionParams struct {
	Action string `json:"action"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

// Get activity logs by action type
func (q *Queries) GetActivityLogsByAction(ctx context.Context, arg GetActivityLogsByActionParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, getActivityLogsByAction, arg.Action, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Changes,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivityLogsByIP = `-- name: GetActivityLogsByIP :many
SELECT id, user_id, username, action, resource_type, resource_id, changes, metadata, ip_address, user_agent, success, error_message, created_at FROM public.activity_log
WHERE ip_address = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetActivityLogsByIPParams struct {
	IpAddress netip.Addr `json:"ipAddress"`
	Limit     int32      `json:"limit"`
	Offset    int32      `json:"offset"`
}

// Get activity logs from a specific IP address
func (q *Queries) GetActivityLogsByIP(ctx context.Context, arg GetActivityLogsByIPParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, getActivityLogsByIP, arg.IpAddress, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Changes,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedActivityLogs = `-- name: GetFailedActivityLogs :many
SELECT id, user_id, username, action, resource_type, resource_id, changes, metadata, ip_address, user_agent, success, error_message, created_at FROM public.activity_log
WHERE success = false
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetFailedActivityLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get failed activity logs (for monitoring)
func (q *Queries) GetFailedActivityLogs(ctx context.Context, arg GetFailedActivityLogsParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, getFailedActivityLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Changes,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOldActivityLogsCount = `-- name: GetOldActivityLogsCount :one
SELECT COUNT(*) FROM public.activity_log
WHERE created_at < $1
`

// Count activity logs older than a specific date (for dry-run)
func (q *Queries) GetOldActivityLogsCount(ctx context.Context, createdAt time.Time) (int64, error) {
	row := q.db.QueryRow(ctx, getOldActivityLogsCount, createdAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRecentActions = `-- name: GetRecentActions :many
SELECT DISTINCT action, COUNT(*) as count
FROM public.activity_log
WHERE created_at > now() - interval '7 days'
GROUP BY action
ORDER BY count DESC
LIMIT $1
`

type GetRecentActionsRow struct {
	Action string `json:"action"`
	Count  int64  `json:"count"`
}

// Get recent distinct actions (for autocomplete/filtering)
func (q *Queries) GetRecentActions(ctx context.Context, limit int32) ([]GetRecentActionsRow, error) {
	rows, err := q.db.Query(ctx, getRecentActions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentActionsRow{}
	for rows.Next() {
		var i GetRecentActionsRow
		if err := rows.Scan(&i.Action, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourceActivityLogs = `-- name: GetResourceActivityLogs :many
SELECT id, user_id, username, action, resource_type, resource_id, changes, metadata, ip_address, user_agent, success, error_message, created_at FROM public.activity_log
WHERE resource_type = $1 AND resource_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetResourceActivityLogsParams struct {
	ResourceType *string     `json:"resourceType"`
	ResourceID   pgtype.UUID `json:"resourceId"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
}

// Get activity logs for a specific resource
func (q *Queries) GetResourceActivityLogs(ctx context.Context, arg GetResourceActivityLogsParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, getResourceActivityLogs,
		arg.ResourceType,
		arg.ResourceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Changes,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActivityLogs = `-- name: GetUserActivityLogs :many
SELECT id, user_id, username, action, resource_type, resource_id, changes, metadata, ip_address, user_agent, success, error_message, created_at FROM public.activity_log
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserActivityLogsParams struct {
	UserID pgtype.UUID `json:"userId"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

// Get activity logs for a specific user
func (q *Queries) GetUserActivityLogs(ctx context.Context, arg GetUserActivityLogsParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, getUserActivityLogs, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Changes,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivityLogs = `-- name: ListActivityLogs :many
SELECT id, user_id, username, action, resource_type, resource_id, changes, metadata, ip_address, user_agent, success, error_message, created_at FROM public.activity_log
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListActivityLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// List activity logs with pagination, ordered by created_at DESC
func (q *Queries) ListActivityLogs(ctx context.Context, arg ListActivityLogsParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, listActivityLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Changes,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchActivityLogs = `-- name: SearchActivityLogs :many
SELECT id, user_id, username, action, resource_type, resource_id, changes, metadata, ip_address, user_agent, success, error_message, created_at FROM public.activity_log
WHERE 
    ($1::UUID IS NULL OR user_id = $1)
    AND ($2::VARCHAR IS NULL OR action = $2)
    AND ($3::VARCHAR IS NULL OR resource_type = $3)
    AND ($4::UUID IS NULL OR resource_id = $4)
    AND ($5::BOOLEAN IS NULL OR success = $5)
    AND ($6::TIMESTAMPTZ IS NULL OR created_at >= $6)
    AND ($7::TIMESTAMPTZ IS NULL OR created_at <= $7)
ORDER BY created_at DESC
LIMIT $8 OFFSET $9
`

type SearchActivityLogsParams struct {
	Column1 uuid.UUID `json:"column1"`
	Column2 string    `json:"column2"`
	Column3 string    `json:"column3"`
	Column4 uuid.UUID `json:"column4"`
	Column5 bool      `json:"column5"`
	Column6 time.Time `json:"column6"`
	Column7 time.Time `json:"column7"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

// Search activity logs with optional filters
func (q *Queries) SearchActivityLogs(ctx context.Context, arg SearchActivityLogsParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, searchActivityLogs,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLog{}
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Changes,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
