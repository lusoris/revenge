// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: genres.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countGenresByDomain = `-- name: CountGenresByDomain :one
SELECT COUNT(*) FROM genres WHERE domain = $1
`

func (q *Queries) CountGenresByDomain(ctx context.Context, domain GenreDomain) (int64, error) {
	row := q.db.QueryRow(ctx, countGenresByDomain, domain)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGenre = `-- name: CreateGenre :one
INSERT INTO genres (domain, name, slug, description, parent_id, external_ids)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, domain, name, slug, description, parent_id, external_ids, created_at, updated_at
`

type CreateGenreParams struct {
	Domain      GenreDomain     `json:"domain"`
	Name        string          `json:"name"`
	Slug        string          `json:"slug"`
	Description *string         `json:"description"`
	ParentID    pgtype.UUID     `json:"parentId"`
	ExternalIds json.RawMessage `json:"externalIds"`
}

func (q *Queries) CreateGenre(ctx context.Context, arg CreateGenreParams) (Genre, error) {
	row := q.db.QueryRow(ctx, createGenre,
		arg.Domain,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ParentID,
		arg.ExternalIds,
	)
	var i Genre
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ParentID,
		&i.ExternalIds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGenre = `-- name: DeleteGenre :exec
DELETE FROM genres WHERE id = $1
`

func (q *Queries) DeleteGenre(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGenre, id)
	return err
}

const genreExists = `-- name: GenreExists :one
SELECT EXISTS(SELECT 1 FROM genres WHERE id = $1)
`

func (q *Queries) GenreExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, genreExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const genreSlugExists = `-- name: GenreSlugExists :one
SELECT EXISTS(SELECT 1 FROM genres WHERE domain = $1 AND slug = $2)
`

type GenreSlugExistsParams struct {
	Domain GenreDomain `json:"domain"`
	Slug   string      `json:"slug"`
}

func (q *Queries) GenreSlugExists(ctx context.Context, arg GenreSlugExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, genreSlugExists, arg.Domain, arg.Slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getGenreByID = `-- name: GetGenreByID :one
SELECT id, domain, name, slug, description, parent_id, external_ids, created_at, updated_at FROM genres WHERE id = $1
`

func (q *Queries) GetGenreByID(ctx context.Context, id uuid.UUID) (Genre, error) {
	row := q.db.QueryRow(ctx, getGenreByID, id)
	var i Genre
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ParentID,
		&i.ExternalIds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGenreBySlug = `-- name: GetGenreBySlug :one
SELECT id, domain, name, slug, description, parent_id, external_ids, created_at, updated_at FROM genres WHERE domain = $1 AND slug = $2
`

type GetGenreBySlugParams struct {
	Domain GenreDomain `json:"domain"`
	Slug   string      `json:"slug"`
}

func (q *Queries) GetGenreBySlug(ctx context.Context, arg GetGenreBySlugParams) (Genre, error) {
	row := q.db.QueryRow(ctx, getGenreBySlug, arg.Domain, arg.Slug)
	var i Genre
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ParentID,
		&i.ExternalIds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listChildGenres = `-- name: ListChildGenres :many
SELECT id, domain, name, slug, description, parent_id, external_ids, created_at, updated_at FROM genres
WHERE parent_id = $1
ORDER BY name ASC
`

func (q *Queries) ListChildGenres(ctx context.Context, parentID pgtype.UUID) ([]Genre, error) {
	rows, err := q.db.Query(ctx, listChildGenres, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Genre{}
	for rows.Next() {
		var i Genre
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ParentID,
			&i.ExternalIds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGenresByDomain = `-- name: ListGenresByDomain :many
SELECT id, domain, name, slug, description, parent_id, external_ids, created_at, updated_at FROM genres
WHERE domain = $1
ORDER BY name ASC
`

func (q *Queries) ListGenresByDomain(ctx context.Context, domain GenreDomain) ([]Genre, error) {
	rows, err := q.db.Query(ctx, listGenresByDomain, domain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Genre{}
	for rows.Next() {
		var i Genre
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ParentID,
			&i.ExternalIds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopLevelGenresByDomain = `-- name: ListTopLevelGenresByDomain :many
SELECT id, domain, name, slug, description, parent_id, external_ids, created_at, updated_at FROM genres
WHERE domain = $1 AND parent_id IS NULL
ORDER BY name ASC
`

func (q *Queries) ListTopLevelGenresByDomain(ctx context.Context, domain GenreDomain) ([]Genre, error) {
	rows, err := q.db.Query(ctx, listTopLevelGenresByDomain, domain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Genre{}
	for rows.Next() {
		var i Genre
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ParentID,
			&i.ExternalIds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGenres = `-- name: SearchGenres :many
SELECT id, domain, name, slug, description, parent_id, external_ids, created_at, updated_at FROM genres
WHERE domain = $1 AND name ILIKE '%' || $2 || '%'
ORDER BY
    CASE WHEN name ILIKE $2 THEN 0 ELSE 1 END,
    name ASC
LIMIT $3
`

type SearchGenresParams struct {
	Domain  GenreDomain `json:"domain"`
	Column2 *string     `json:"column2"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) SearchGenres(ctx context.Context, arg SearchGenresParams) ([]Genre, error) {
	rows, err := q.db.Query(ctx, searchGenres, arg.Domain, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Genre{}
	for rows.Next() {
		var i Genre
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ParentID,
			&i.ExternalIds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGenre = `-- name: UpdateGenre :one
UPDATE genres SET
    name = COALESCE($1, name),
    slug = COALESCE($2, slug),
    description = COALESCE($3, description),
    parent_id = $4,
    external_ids = COALESCE($5, external_ids)
WHERE id = $6
RETURNING id, domain, name, slug, description, parent_id, external_ids, created_at, updated_at
`

type UpdateGenreParams struct {
	Name        *string     `json:"name"`
	Slug        *string     `json:"slug"`
	Description *string     `json:"description"`
	ParentID    pgtype.UUID `json:"parentId"`
	ExternalIds []byte      `json:"externalIds"`
	ID          uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateGenre(ctx context.Context, arg UpdateGenreParams) (Genre, error) {
	row := q.db.QueryRow(ctx, updateGenre,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ParentID,
		arg.ExternalIds,
		arg.ID,
	)
	var i Genre
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ParentID,
		&i.ExternalIds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
