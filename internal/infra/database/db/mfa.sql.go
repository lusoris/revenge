// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: mfa.sql

package db

import (
	"context"
	"encoding/json"
	"net/netip"

	"github.com/google/uuid"
)

const addTrustedDevice = `-- name: AddTrustedDevice :exec
UPDATE public.user_mfa_settings
SET trusted_devices = trusted_devices || $2::jsonb,
    updated_at = NOW()
WHERE user_id = $1
`

type AddTrustedDeviceParams struct {
	UserID  uuid.UUID       `json:"userId"`
	Column2 json.RawMessage `json:"column2"`
}

// Add a device fingerprint to trusted devices
func (q *Queries) AddTrustedDevice(ctx context.Context, arg AddTrustedDeviceParams) error {
	_, err := q.db.Exec(ctx, addTrustedDevice, arg.UserID, arg.Column2)
	return err
}

const clearTrustedDevices = `-- name: ClearTrustedDevices :exec

UPDATE public.user_mfa_settings
SET trusted_devices = '[]'::jsonb,
    updated_at = NOW()
WHERE user_id = $1
`

// NOTE: RemoveTrustedDevice removed - implement in application code
// Use ClearTrustedDevices to reset all devices
// Clear all trusted devices for a user
func (q *Queries) ClearTrustedDevices(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearTrustedDevices, userID)
	return err
}

const countUnusedBackupCodes = `-- name: CountUnusedBackupCodes :one
SELECT COUNT(*) FROM public.mfa_backup_codes
WHERE user_id = $1 AND used_at IS NULL
`

// Count unused backup codes for a user
func (q *Queries) CountUnusedBackupCodes(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUnusedBackupCodes, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWebAuthnCredentials = `-- name: CountWebAuthnCredentials :one
SELECT COUNT(*) FROM public.webauthn_credentials
WHERE user_id = $1
`

// Count WebAuthn credentials for a user
func (q *Queries) CountWebAuthnCredentials(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countWebAuthnCredentials, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreateBackupCodesParams struct {
	UserID   uuid.UUID `json:"userId"`
	CodeHash string    `json:"codeHash"`
}

const createTOTPSecret = `-- name: CreateTOTPSecret :one
INSERT INTO public.user_totp_secrets (
    user_id,
    encrypted_secret,
    enabled
) VALUES (
    $1, $2, false
) RETURNING user_id, encrypted_secret, verified_at, enabled, last_used_at, created_at, updated_at, last_used_code
`

type CreateTOTPSecretParams struct {
	UserID          uuid.UUID `json:"userId"`
	EncryptedSecret []byte    `json:"encryptedSecret"`
}

// Create a new TOTP secret for a user
func (q *Queries) CreateTOTPSecret(ctx context.Context, arg CreateTOTPSecretParams) (UserTotpSecret, error) {
	row := q.db.QueryRow(ctx, createTOTPSecret, arg.UserID, arg.EncryptedSecret)
	var i UserTotpSecret
	err := row.Scan(
		&i.UserID,
		&i.EncryptedSecret,
		&i.VerifiedAt,
		&i.Enabled,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedCode,
	)
	return i, err
}

const createUserMFASettings = `-- name: CreateUserMFASettings :one
INSERT INTO public.user_mfa_settings (
    user_id,
    totp_enabled,
    webauthn_enabled,
    backup_codes_generated,
    require_mfa,
    remember_device_enabled,
    remember_device_duration_days,
    trusted_devices
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING user_id, totp_enabled, webauthn_enabled, backup_codes_generated, require_mfa, remember_device_enabled, remember_device_duration_days, trusted_devices, created_at, updated_at
`

type CreateUserMFASettingsParams struct {
	UserID                     uuid.UUID       `json:"userId"`
	TotpEnabled                bool            `json:"totpEnabled"`
	WebauthnEnabled            bool            `json:"webauthnEnabled"`
	BackupCodesGenerated       bool            `json:"backupCodesGenerated"`
	RequireMfa                 bool            `json:"requireMfa"`
	RememberDeviceEnabled      bool            `json:"rememberDeviceEnabled"`
	RememberDeviceDurationDays int32           `json:"rememberDeviceDurationDays"`
	TrustedDevices             json.RawMessage `json:"trustedDevices"`
}

// Create MFA settings for a user
func (q *Queries) CreateUserMFASettings(ctx context.Context, arg CreateUserMFASettingsParams) (UserMfaSetting, error) {
	row := q.db.QueryRow(ctx, createUserMFASettings,
		arg.UserID,
		arg.TotpEnabled,
		arg.WebauthnEnabled,
		arg.BackupCodesGenerated,
		arg.RequireMfa,
		arg.RememberDeviceEnabled,
		arg.RememberDeviceDurationDays,
		arg.TrustedDevices,
	)
	var i UserMfaSetting
	err := row.Scan(
		&i.UserID,
		&i.TotpEnabled,
		&i.WebauthnEnabled,
		&i.BackupCodesGenerated,
		&i.RequireMfa,
		&i.RememberDeviceEnabled,
		&i.RememberDeviceDurationDays,
		&i.TrustedDevices,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWebAuthnCredential = `-- name: CreateWebAuthnCredential :one
INSERT INTO public.webauthn_credentials (
    user_id,
    credential_id,
    public_key,
    attestation_type,
    transports,
    backup_eligible,
    backup_state,
    user_present,
    user_verified,
    aaguid,
    name
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, user_id, credential_id, public_key, sign_count, clone_detected, aaguid, attestation_type, transports, backup_eligible, backup_state, user_present, user_verified, name, created_at, last_used_at
`

type CreateWebAuthnCredentialParams struct {
	UserID          uuid.UUID `json:"userId"`
	CredentialID    []byte    `json:"credentialId"`
	PublicKey       []byte    `json:"publicKey"`
	AttestationType string    `json:"attestationType"`
	Transports      []string  `json:"transports"`
	BackupEligible  bool      `json:"backupEligible"`
	BackupState     bool      `json:"backupState"`
	UserPresent     bool      `json:"userPresent"`
	UserVerified    bool      `json:"userVerified"`
	Aaguid          []byte    `json:"aaguid"`
	Name            *string   `json:"name"`
}

// Create a new WebAuthn credential
func (q *Queries) CreateWebAuthnCredential(ctx context.Context, arg CreateWebAuthnCredentialParams) (WebauthnCredential, error) {
	row := q.db.QueryRow(ctx, createWebAuthnCredential,
		arg.UserID,
		arg.CredentialID,
		arg.PublicKey,
		arg.AttestationType,
		arg.Transports,
		arg.BackupEligible,
		arg.BackupState,
		arg.UserPresent,
		arg.UserVerified,
		arg.Aaguid,
		arg.Name,
	)
	var i WebauthnCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CredentialID,
		&i.PublicKey,
		&i.SignCount,
		&i.CloneDetected,
		&i.Aaguid,
		&i.AttestationType,
		&i.Transports,
		&i.BackupEligible,
		&i.BackupState,
		&i.UserPresent,
		&i.UserVerified,
		&i.Name,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const deleteAllBackupCodes = `-- name: DeleteAllBackupCodes :exec
DELETE FROM public.mfa_backup_codes
WHERE user_id = $1
`

// Delete all backup codes for a user (when regenerating)
func (q *Queries) DeleteAllBackupCodes(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllBackupCodes, userID)
	return err
}

const deleteTOTPSecret = `-- name: DeleteTOTPSecret :exec
DELETE FROM public.user_totp_secrets
WHERE user_id = $1
`

// Delete TOTP secret for a user
func (q *Queries) DeleteTOTPSecret(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTOTPSecret, userID)
	return err
}

const deleteUserMFASettings = `-- name: DeleteUserMFASettings :exec
DELETE FROM public.user_mfa_settings
WHERE user_id = $1
`

// Delete MFA settings for a user
func (q *Queries) DeleteUserMFASettings(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserMFASettings, userID)
	return err
}

const deleteWebAuthnCredential = `-- name: DeleteWebAuthnCredential :exec
DELETE FROM public.webauthn_credentials
WHERE id = $1 AND user_id = $2
`

type DeleteWebAuthnCredentialParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
}

// Delete a WebAuthn credential
func (q *Queries) DeleteWebAuthnCredential(ctx context.Context, arg DeleteWebAuthnCredentialParams) error {
	_, err := q.db.Exec(ctx, deleteWebAuthnCredential, arg.ID, arg.UserID)
	return err
}

const disableTOTP = `-- name: DisableTOTP :exec
UPDATE public.user_totp_secrets
SET enabled = false,
    updated_at = NOW()
WHERE user_id = $1
`

// Disable TOTP for a user
func (q *Queries) DisableTOTP(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, disableTOTP, userID)
	return err
}

const enableTOTP = `-- name: EnableTOTP :exec
UPDATE public.user_totp_secrets
SET enabled = true,
    updated_at = NOW()
WHERE user_id = $1
`

// Enable TOTP for a user (after verification)
func (q *Queries) EnableTOTP(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, enableTOTP, userID)
	return err
}

const getBackupCodeByHash = `-- name: GetBackupCodeByHash :one
SELECT id, user_id, code_hash, used_at, used_from_ip, created_at FROM public.mfa_backup_codes
WHERE user_id = $1 AND code_hash = $2 AND used_at IS NULL
`

type GetBackupCodeByHashParams struct {
	UserID   uuid.UUID `json:"userId"`
	CodeHash string    `json:"codeHash"`
}

// Get a backup code by its hash
func (q *Queries) GetBackupCodeByHash(ctx context.Context, arg GetBackupCodeByHashParams) (MfaBackupCode, error) {
	row := q.db.QueryRow(ctx, getBackupCodeByHash, arg.UserID, arg.CodeHash)
	var i MfaBackupCode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CodeHash,
		&i.UsedAt,
		&i.UsedFromIp,
		&i.CreatedAt,
	)
	return i, err
}

const getUnusedBackupCodes = `-- name: GetUnusedBackupCodes :many
SELECT id, user_id, code_hash, used_at, used_from_ip, created_at FROM public.mfa_backup_codes
WHERE user_id = $1 AND used_at IS NULL
ORDER BY created_at DESC
`

// Get all unused backup codes for a user
func (q *Queries) GetUnusedBackupCodes(ctx context.Context, userID uuid.UUID) ([]MfaBackupCode, error) {
	rows, err := q.db.Query(ctx, getUnusedBackupCodes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MfaBackupCode{}
	for rows.Next() {
		var i MfaBackupCode
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CodeHash,
			&i.UsedAt,
			&i.UsedFromIp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMFASettings = `-- name: GetUserMFASettings :one

SELECT user_id, totp_enabled, webauthn_enabled, backup_codes_generated, require_mfa, remember_device_enabled, remember_device_duration_days, trusted_devices, created_at, updated_at FROM public.user_mfa_settings
WHERE user_id = $1
`

// ============================================================================
// MFA Settings Queries
// ============================================================================
// Get MFA settings for a user
func (q *Queries) GetUserMFASettings(ctx context.Context, userID uuid.UUID) (UserMfaSetting, error) {
	row := q.db.QueryRow(ctx, getUserMFASettings, userID)
	var i UserMfaSetting
	err := row.Scan(
		&i.UserID,
		&i.TotpEnabled,
		&i.WebauthnEnabled,
		&i.BackupCodesGenerated,
		&i.RequireMfa,
		&i.RememberDeviceEnabled,
		&i.RememberDeviceDurationDays,
		&i.TrustedDevices,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserMFAStatus = `-- name: GetUserMFAStatus :one

SELECT
    (SELECT COUNT(*) > 0 FROM public.user_totp_secrets WHERE user_totp_secrets.user_id = $1 AND enabled = true) as has_totp,
    (SELECT COUNT(*) FROM public.webauthn_credentials WHERE webauthn_credentials.user_id = $1) as webauthn_count,
    (SELECT COUNT(*) FROM public.mfa_backup_codes WHERE mfa_backup_codes.user_id = $1 AND used_at IS NULL) as unused_backup_codes,
    COALESCE((SELECT require_mfa FROM public.user_mfa_settings WHERE user_mfa_settings.user_id = $1), false)::boolean as require_mfa
`

type GetUserMFAStatusRow struct {
	HasTotp           bool  `json:"hasTotp"`
	WebauthnCount     int64 `json:"webauthnCount"`
	UnusedBackupCodes int64 `json:"unusedBackupCodes"`
	RequireMfa        bool  `json:"requireMfa"`
}

// ============================================================================
// Combined Status Queries
// ============================================================================
// Get comprehensive MFA status for a user
// Note: COALESCE is used for require_mfa to handle the case when user_mfa_settings doesn't exist
func (q *Queries) GetUserMFAStatus(ctx context.Context, userID uuid.UUID) (GetUserMFAStatusRow, error) {
	row := q.db.QueryRow(ctx, getUserMFAStatus, userID)
	var i GetUserMFAStatusRow
	err := row.Scan(
		&i.HasTotp,
		&i.WebauthnCount,
		&i.UnusedBackupCodes,
		&i.RequireMfa,
	)
	return i, err
}

const getUserTOTPSecret = `-- name: GetUserTOTPSecret :one

SELECT user_id, encrypted_secret, verified_at, enabled, last_used_at, created_at, updated_at, last_used_code FROM public.user_totp_secrets
WHERE user_id = $1
`

// ============================================================================
// TOTP (Time-based One-Time Password) Queries
// ============================================================================
// Get TOTP secret for a user
func (q *Queries) GetUserTOTPSecret(ctx context.Context, userID uuid.UUID) (UserTotpSecret, error) {
	row := q.db.QueryRow(ctx, getUserTOTPSecret, userID)
	var i UserTotpSecret
	err := row.Scan(
		&i.UserID,
		&i.EncryptedSecret,
		&i.VerifiedAt,
		&i.Enabled,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedCode,
	)
	return i, err
}

const getWebAuthnCredential = `-- name: GetWebAuthnCredential :one
SELECT id, user_id, credential_id, public_key, sign_count, clone_detected, aaguid, attestation_type, transports, backup_eligible, backup_state, user_present, user_verified, name, created_at, last_used_at FROM public.webauthn_credentials
WHERE id = $1
`

// Get a specific WebAuthn credential by ID
func (q *Queries) GetWebAuthnCredential(ctx context.Context, id uuid.UUID) (WebauthnCredential, error) {
	row := q.db.QueryRow(ctx, getWebAuthnCredential, id)
	var i WebauthnCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CredentialID,
		&i.PublicKey,
		&i.SignCount,
		&i.CloneDetected,
		&i.Aaguid,
		&i.AttestationType,
		&i.Transports,
		&i.BackupEligible,
		&i.BackupState,
		&i.UserPresent,
		&i.UserVerified,
		&i.Name,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const getWebAuthnCredentialByCredentialID = `-- name: GetWebAuthnCredentialByCredentialID :one
SELECT id, user_id, credential_id, public_key, sign_count, clone_detected, aaguid, attestation_type, transports, backup_eligible, backup_state, user_present, user_verified, name, created_at, last_used_at FROM public.webauthn_credentials
WHERE credential_id = $1
`

// Get a WebAuthn credential by its credential ID
func (q *Queries) GetWebAuthnCredentialByCredentialID(ctx context.Context, credentialID []byte) (WebauthnCredential, error) {
	row := q.db.QueryRow(ctx, getWebAuthnCredentialByCredentialID, credentialID)
	var i WebauthnCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CredentialID,
		&i.PublicKey,
		&i.SignCount,
		&i.CloneDetected,
		&i.Aaguid,
		&i.AttestationType,
		&i.Transports,
		&i.BackupEligible,
		&i.BackupState,
		&i.UserPresent,
		&i.UserVerified,
		&i.Name,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const hasAnyMFAMethod = `-- name: HasAnyMFAMethod :one
SELECT (
    EXISTS(SELECT 1 FROM public.user_totp_secrets WHERE user_totp_secrets.user_id = $1 AND enabled = true)
    OR
    EXISTS(SELECT 1 FROM public.webauthn_credentials WHERE webauthn_credentials.user_id = $1)
) as has_mfa
`

// Check if user has any MFA method enabled
func (q *Queries) HasAnyMFAMethod(ctx context.Context, userID uuid.UUID) (*bool, error) {
	row := q.db.QueryRow(ctx, hasAnyMFAMethod, userID)
	var has_mfa *bool
	err := row.Scan(&has_mfa)
	return has_mfa, err
}

const listWebAuthnCredentials = `-- name: ListWebAuthnCredentials :many

SELECT id, user_id, credential_id, public_key, sign_count, clone_detected, aaguid, attestation_type, transports, backup_eligible, backup_state, user_present, user_verified, name, created_at, last_used_at FROM public.webauthn_credentials
WHERE user_id = $1
ORDER BY last_used_at DESC NULLS LAST, created_at DESC
`

// ============================================================================
// WebAuthn Credential Queries
// ============================================================================
// List all WebAuthn credentials for a user
func (q *Queries) ListWebAuthnCredentials(ctx context.Context, userID uuid.UUID) ([]WebauthnCredential, error) {
	rows, err := q.db.Query(ctx, listWebAuthnCredentials, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebauthnCredential{}
	for rows.Next() {
		var i WebauthnCredential
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CredentialID,
			&i.PublicKey,
			&i.SignCount,
			&i.CloneDetected,
			&i.Aaguid,
			&i.AttestationType,
			&i.Transports,
			&i.BackupEligible,
			&i.BackupState,
			&i.UserPresent,
			&i.UserVerified,
			&i.Name,
			&i.CreatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markWebAuthnCloneDetected = `-- name: MarkWebAuthnCloneDetected :exec
UPDATE public.webauthn_credentials
SET clone_detected = true
WHERE credential_id = $1
`

// Mark a credential as potentially cloned
func (q *Queries) MarkWebAuthnCloneDetected(ctx context.Context, credentialID []byte) error {
	_, err := q.db.Exec(ctx, markWebAuthnCloneDetected, credentialID)
	return err
}

const updateMFASettingsBackupCodesGenerated = `-- name: UpdateMFASettingsBackupCodesGenerated :exec
UPDATE public.user_mfa_settings
SET backup_codes_generated = $2,
    updated_at = NOW()
WHERE user_id = $1
`

type UpdateMFASettingsBackupCodesGeneratedParams struct {
	UserID               uuid.UUID `json:"userId"`
	BackupCodesGenerated bool      `json:"backupCodesGenerated"`
}

// Update backup codes generated flag
func (q *Queries) UpdateMFASettingsBackupCodesGenerated(ctx context.Context, arg UpdateMFASettingsBackupCodesGeneratedParams) error {
	_, err := q.db.Exec(ctx, updateMFASettingsBackupCodesGenerated, arg.UserID, arg.BackupCodesGenerated)
	return err
}

const updateMFASettingsRememberDevice = `-- name: UpdateMFASettingsRememberDevice :exec
UPDATE public.user_mfa_settings
SET remember_device_enabled = $2,
    remember_device_duration_days = $3,
    updated_at = NOW()
WHERE user_id = $1
`

type UpdateMFASettingsRememberDeviceParams struct {
	UserID                     uuid.UUID `json:"userId"`
	RememberDeviceEnabled      bool      `json:"rememberDeviceEnabled"`
	RememberDeviceDurationDays int32     `json:"rememberDeviceDurationDays"`
}

// Update remember device settings
func (q *Queries) UpdateMFASettingsRememberDevice(ctx context.Context, arg UpdateMFASettingsRememberDeviceParams) error {
	_, err := q.db.Exec(ctx, updateMFASettingsRememberDevice, arg.UserID, arg.RememberDeviceEnabled, arg.RememberDeviceDurationDays)
	return err
}

const updateMFASettingsRequireMFA = `-- name: UpdateMFASettingsRequireMFA :exec
UPDATE public.user_mfa_settings
SET require_mfa = $2,
    updated_at = NOW()
WHERE user_id = $1
`

type UpdateMFASettingsRequireMFAParams struct {
	UserID     uuid.UUID `json:"userId"`
	RequireMfa bool      `json:"requireMfa"`
}

// Update require MFA flag (admin setting)
func (q *Queries) UpdateMFASettingsRequireMFA(ctx context.Context, arg UpdateMFASettingsRequireMFAParams) error {
	_, err := q.db.Exec(ctx, updateMFASettingsRequireMFA, arg.UserID, arg.RequireMfa)
	return err
}

const updateMFASettingsTOTPEnabled = `-- name: UpdateMFASettingsTOTPEnabled :exec
UPDATE public.user_mfa_settings
SET totp_enabled = $2,
    updated_at = NOW()
WHERE user_id = $1
`

type UpdateMFASettingsTOTPEnabledParams struct {
	UserID      uuid.UUID `json:"userId"`
	TotpEnabled bool      `json:"totpEnabled"`
}

// Update TOTP enabled flag
func (q *Queries) UpdateMFASettingsTOTPEnabled(ctx context.Context, arg UpdateMFASettingsTOTPEnabledParams) error {
	_, err := q.db.Exec(ctx, updateMFASettingsTOTPEnabled, arg.UserID, arg.TotpEnabled)
	return err
}

const updateMFASettingsWebAuthnEnabled = `-- name: UpdateMFASettingsWebAuthnEnabled :exec
UPDATE public.user_mfa_settings
SET webauthn_enabled = $2,
    updated_at = NOW()
WHERE user_id = $1
`

type UpdateMFASettingsWebAuthnEnabledParams struct {
	UserID          uuid.UUID `json:"userId"`
	WebauthnEnabled bool      `json:"webauthnEnabled"`
}

// Update WebAuthn enabled flag
func (q *Queries) UpdateMFASettingsWebAuthnEnabled(ctx context.Context, arg UpdateMFASettingsWebAuthnEnabledParams) error {
	_, err := q.db.Exec(ctx, updateMFASettingsWebAuthnEnabled, arg.UserID, arg.WebauthnEnabled)
	return err
}

const updateTOTPLastUsed = `-- name: UpdateTOTPLastUsed :exec
UPDATE public.user_totp_secrets
SET last_used_at = NOW(),
    last_used_code = $2,
    updated_at = NOW()
WHERE user_id = $1
`

type UpdateTOTPLastUsedParams struct {
	UserID       uuid.UUID `json:"userId"`
	LastUsedCode *string   `json:"lastUsedCode"`
}

// Update last used timestamp and code for TOTP (replay protection)
func (q *Queries) UpdateTOTPLastUsed(ctx context.Context, arg UpdateTOTPLastUsedParams) error {
	_, err := q.db.Exec(ctx, updateTOTPLastUsed, arg.UserID, arg.LastUsedCode)
	return err
}

const updateTOTPSecret = `-- name: UpdateTOTPSecret :exec
UPDATE public.user_totp_secrets
SET encrypted_secret = $2,
    verified_at = NULL,
    enabled = false,
    updated_at = NOW()
WHERE user_id = $1
`

type UpdateTOTPSecretParams struct {
	UserID          uuid.UUID `json:"userId"`
	EncryptedSecret []byte    `json:"encryptedSecret"`
}

// Update TOTP secret (for re-enrollment)
func (q *Queries) UpdateTOTPSecret(ctx context.Context, arg UpdateTOTPSecretParams) error {
	_, err := q.db.Exec(ctx, updateTOTPSecret, arg.UserID, arg.EncryptedSecret)
	return err
}

const updateWebAuthnCounter = `-- name: UpdateWebAuthnCounter :exec
UPDATE public.webauthn_credentials
SET sign_count = $2,
    last_used_at = NOW()
WHERE credential_id = $1
`

type UpdateWebAuthnCounterParams struct {
	CredentialID []byte `json:"credentialId"`
	SignCount    int32  `json:"signCount"`
}

// Update sign count and last used timestamp
func (q *Queries) UpdateWebAuthnCounter(ctx context.Context, arg UpdateWebAuthnCounterParams) error {
	_, err := q.db.Exec(ctx, updateWebAuthnCounter, arg.CredentialID, arg.SignCount)
	return err
}

const updateWebAuthnCredentialName = `-- name: UpdateWebAuthnCredentialName :exec
UPDATE public.webauthn_credentials
SET name = $2
WHERE id = $1
`

type UpdateWebAuthnCredentialNameParams struct {
	ID   uuid.UUID `json:"id"`
	Name *string   `json:"name"`
}

// Update the user-facing name of a credential
func (q *Queries) UpdateWebAuthnCredentialName(ctx context.Context, arg UpdateWebAuthnCredentialNameParams) error {
	_, err := q.db.Exec(ctx, updateWebAuthnCredentialName, arg.ID, arg.Name)
	return err
}

const useBackupCode = `-- name: UseBackupCode :exec
UPDATE public.mfa_backup_codes
SET used_at = NOW(),
    used_from_ip = $3
WHERE id = $1 AND user_id = $2 AND used_at IS NULL
`

type UseBackupCodeParams struct {
	ID         uuid.UUID  `json:"id"`
	UserID     uuid.UUID  `json:"userId"`
	UsedFromIp netip.Addr `json:"usedFromIp"`
}

// Mark a backup code as used
func (q *Queries) UseBackupCode(ctx context.Context, arg UseBackupCodeParams) error {
	_, err := q.db.Exec(ctx, useBackupCode, arg.ID, arg.UserID, arg.UsedFromIp)
	return err
}

const verifyTOTPSecret = `-- name: VerifyTOTPSecret :exec
UPDATE public.user_totp_secrets
SET verified_at = NOW(),
    enabled = true,
    updated_at = NOW()
WHERE user_id = $1 AND verified_at IS NULL
`

// Mark TOTP as verified and enabled
func (q *Queries) VerifyTOTPSecret(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, verifyTOTPSecret, userID)
	return err
}
