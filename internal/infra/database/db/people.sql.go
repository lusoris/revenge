// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: people.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countPeople = `-- name: CountPeople :one
SELECT COUNT(*) FROM people
`

func (q *Queries) CountPeople(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPeople)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPerson = `-- name: CreatePerson :one
INSERT INTO people (
    name, sort_name, original_name,
    biography, birthdate, deathdate, birthplace, gender,
    primary_image_url, primary_image_blurhash,
    tmdb_id, imdb_id, tvdb_id, musicbrainz_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, name, sort_name, original_name, biography, birthdate, deathdate, birthplace, gender, primary_image_url, primary_image_blurhash, tmdb_id, imdb_id, tvdb_id, musicbrainz_id, created_at, updated_at
`

type CreatePersonParams struct {
	Name                 string      `json:"name"`
	SortName             *string     `json:"sortName"`
	OriginalName         *string     `json:"originalName"`
	Biography            *string     `json:"biography"`
	Birthdate            pgtype.Date `json:"birthdate"`
	Deathdate            pgtype.Date `json:"deathdate"`
	Birthplace           *string     `json:"birthplace"`
	Gender               *string     `json:"gender"`
	PrimaryImageUrl      *string     `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string     `json:"primaryImageBlurhash"`
	TmdbID               *int32      `json:"tmdbId"`
	ImdbID               *string     `json:"imdbId"`
	TvdbID               *int32      `json:"tvdbId"`
	MusicbrainzID        pgtype.UUID `json:"musicbrainzId"`
}

func (q *Queries) CreatePerson(ctx context.Context, arg CreatePersonParams) (Person, error) {
	row := q.db.QueryRow(ctx, createPerson,
		arg.Name,
		arg.SortName,
		arg.OriginalName,
		arg.Biography,
		arg.Birthdate,
		arg.Deathdate,
		arg.Birthplace,
		arg.Gender,
		arg.PrimaryImageUrl,
		arg.PrimaryImageBlurhash,
		arg.TmdbID,
		arg.ImdbID,
		arg.TvdbID,
		arg.MusicbrainzID,
	)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SortName,
		&i.OriginalName,
		&i.Biography,
		&i.Birthdate,
		&i.Deathdate,
		&i.Birthplace,
		&i.Gender,
		&i.PrimaryImageUrl,
		&i.PrimaryImageBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.MusicbrainzID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePerson = `-- name: DeletePerson :exec
DELETE FROM people WHERE id = $1
`

func (q *Queries) DeletePerson(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePerson, id)
	return err
}

const getPersonByID = `-- name: GetPersonByID :one
SELECT id, name, sort_name, original_name, biography, birthdate, deathdate, birthplace, gender, primary_image_url, primary_image_blurhash, tmdb_id, imdb_id, tvdb_id, musicbrainz_id, created_at, updated_at FROM people WHERE id = $1
`

func (q *Queries) GetPersonByID(ctx context.Context, id uuid.UUID) (Person, error) {
	row := q.db.QueryRow(ctx, getPersonByID, id)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SortName,
		&i.OriginalName,
		&i.Biography,
		&i.Birthdate,
		&i.Deathdate,
		&i.Birthplace,
		&i.Gender,
		&i.PrimaryImageUrl,
		&i.PrimaryImageBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.MusicbrainzID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPersonByImdbID = `-- name: GetPersonByImdbID :one
SELECT id, name, sort_name, original_name, biography, birthdate, deathdate, birthplace, gender, primary_image_url, primary_image_blurhash, tmdb_id, imdb_id, tvdb_id, musicbrainz_id, created_at, updated_at FROM people WHERE imdb_id = $1
`

func (q *Queries) GetPersonByImdbID(ctx context.Context, imdbID *string) (Person, error) {
	row := q.db.QueryRow(ctx, getPersonByImdbID, imdbID)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SortName,
		&i.OriginalName,
		&i.Biography,
		&i.Birthdate,
		&i.Deathdate,
		&i.Birthplace,
		&i.Gender,
		&i.PrimaryImageUrl,
		&i.PrimaryImageBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.MusicbrainzID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPersonByTmdbID = `-- name: GetPersonByTmdbID :one
SELECT id, name, sort_name, original_name, biography, birthdate, deathdate, birthplace, gender, primary_image_url, primary_image_blurhash, tmdb_id, imdb_id, tvdb_id, musicbrainz_id, created_at, updated_at FROM people WHERE tmdb_id = $1
`

func (q *Queries) GetPersonByTmdbID(ctx context.Context, tmdbID *int32) (Person, error) {
	row := q.db.QueryRow(ctx, getPersonByTmdbID, tmdbID)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SortName,
		&i.OriginalName,
		&i.Biography,
		&i.Birthdate,
		&i.Deathdate,
		&i.Birthplace,
		&i.Gender,
		&i.PrimaryImageUrl,
		&i.PrimaryImageBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.MusicbrainzID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPeople = `-- name: ListPeople :many
SELECT id, name, sort_name, original_name, biography, birthdate, deathdate, birthplace, gender, primary_image_url, primary_image_blurhash, tmdb_id, imdb_id, tvdb_id, musicbrainz_id, created_at, updated_at FROM people
ORDER BY name ASC
LIMIT $1 OFFSET $2
`

type ListPeopleParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPeople(ctx context.Context, arg ListPeopleParams) ([]Person, error) {
	rows, err := q.db.Query(ctx, listPeople, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Person{}
	for rows.Next() {
		var i Person
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SortName,
			&i.OriginalName,
			&i.Biography,
			&i.Birthdate,
			&i.Deathdate,
			&i.Birthplace,
			&i.Gender,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.MusicbrainzID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const personExistsByTmdbID = `-- name: PersonExistsByTmdbID :one
SELECT EXISTS(SELECT 1 FROM people WHERE tmdb_id = $1)
`

func (q *Queries) PersonExistsByTmdbID(ctx context.Context, tmdbID *int32) (bool, error) {
	row := q.db.QueryRow(ctx, personExistsByTmdbID, tmdbID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const searchPeople = `-- name: SearchPeople :many
SELECT id, name, sort_name, original_name, biography, birthdate, deathdate, birthplace, gender, primary_image_url, primary_image_blurhash, tmdb_id, imdb_id, tvdb_id, musicbrainz_id, created_at, updated_at FROM people
WHERE name ILIKE '%' || $1 || '%'
ORDER BY
    CASE WHEN name ILIKE $1 THEN 0 ELSE 1 END,
    name ASC
LIMIT $2
`

type SearchPeopleParams struct {
	Column1 *string `json:"column1"`
	Limit   int32   `json:"limit"`
}

func (q *Queries) SearchPeople(ctx context.Context, arg SearchPeopleParams) ([]Person, error) {
	rows, err := q.db.Query(ctx, searchPeople, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Person{}
	for rows.Next() {
		var i Person
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SortName,
			&i.OriginalName,
			&i.Biography,
			&i.Birthdate,
			&i.Deathdate,
			&i.Birthplace,
			&i.Gender,
			&i.PrimaryImageUrl,
			&i.PrimaryImageBlurhash,
			&i.TmdbID,
			&i.ImdbID,
			&i.TvdbID,
			&i.MusicbrainzID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePerson = `-- name: UpdatePerson :one
UPDATE people SET
    name = COALESCE($1, name),
    sort_name = COALESCE($2, sort_name),
    original_name = COALESCE($3, original_name),
    biography = COALESCE($4, biography),
    birthdate = COALESCE($5, birthdate),
    deathdate = COALESCE($6, deathdate),
    birthplace = COALESCE($7, birthplace),
    gender = COALESCE($8, gender),
    primary_image_url = COALESCE($9, primary_image_url),
    primary_image_blurhash = COALESCE($10, primary_image_blurhash),
    tmdb_id = COALESCE($11, tmdb_id),
    imdb_id = COALESCE($12, imdb_id),
    tvdb_id = COALESCE($13, tvdb_id),
    musicbrainz_id = COALESCE($14, musicbrainz_id)
WHERE id = $15
RETURNING id, name, sort_name, original_name, biography, birthdate, deathdate, birthplace, gender, primary_image_url, primary_image_blurhash, tmdb_id, imdb_id, tvdb_id, musicbrainz_id, created_at, updated_at
`

type UpdatePersonParams struct {
	Name                 *string     `json:"name"`
	SortName             *string     `json:"sortName"`
	OriginalName         *string     `json:"originalName"`
	Biography            *string     `json:"biography"`
	Birthdate            pgtype.Date `json:"birthdate"`
	Deathdate            pgtype.Date `json:"deathdate"`
	Birthplace           *string     `json:"birthplace"`
	Gender               *string     `json:"gender"`
	PrimaryImageUrl      *string     `json:"primaryImageUrl"`
	PrimaryImageBlurhash *string     `json:"primaryImageBlurhash"`
	TmdbID               *int32      `json:"tmdbId"`
	ImdbID               *string     `json:"imdbId"`
	TvdbID               *int32      `json:"tvdbId"`
	MusicbrainzID        pgtype.UUID `json:"musicbrainzId"`
	ID                   uuid.UUID   `json:"id"`
}

func (q *Queries) UpdatePerson(ctx context.Context, arg UpdatePersonParams) (Person, error) {
	row := q.db.QueryRow(ctx, updatePerson,
		arg.Name,
		arg.SortName,
		arg.OriginalName,
		arg.Biography,
		arg.Birthdate,
		arg.Deathdate,
		arg.Birthplace,
		arg.Gender,
		arg.PrimaryImageUrl,
		arg.PrimaryImageBlurhash,
		arg.TmdbID,
		arg.ImdbID,
		arg.TvdbID,
		arg.MusicbrainzID,
		arg.ID,
	)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SortName,
		&i.OriginalName,
		&i.Biography,
		&i.Birthdate,
		&i.Deathdate,
		&i.Birthplace,
		&i.Gender,
		&i.PrimaryImageUrl,
		&i.PrimaryImageBlurhash,
		&i.TmdbID,
		&i.ImdbID,
		&i.TvdbID,
		&i.MusicbrainzID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
