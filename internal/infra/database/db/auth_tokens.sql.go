// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth_tokens.sql

package db

import (
	"context"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const clearFailedLoginAttemptsByUsername = `-- name: ClearFailedLoginAttemptsByUsername :exec
DELETE FROM shared.failed_login_attempts
WHERE username = $1
`

func (q *Queries) ClearFailedLoginAttemptsByUsername(ctx context.Context, username string) error {
	_, err := q.db.Exec(ctx, clearFailedLoginAttemptsByUsername, username)
	return err
}

const countActiveAuthTokensByUser = `-- name: CountActiveAuthTokensByUser :one
SELECT COUNT(*) FROM shared.auth_tokens
WHERE user_id = $1
  AND revoked_at IS NULL
  AND expires_at > NOW()
`

func (q *Queries) CountActiveAuthTokensByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveAuthTokensByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFailedLoginAttemptsByIP = `-- name: CountFailedLoginAttemptsByIP :one
SELECT COUNT(*) FROM shared.failed_login_attempts
WHERE ip_address = $1
  AND attempted_at > $2
`

type CountFailedLoginAttemptsByIPParams struct {
	IpAddress   string    `json:"ipAddress"`
	AttemptedAt time.Time `json:"attemptedAt"`
}

func (q *Queries) CountFailedLoginAttemptsByIP(ctx context.Context, arg CountFailedLoginAttemptsByIPParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFailedLoginAttemptsByIP, arg.IpAddress, arg.AttemptedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFailedLoginAttemptsByUsername = `-- name: CountFailedLoginAttemptsByUsername :one
SELECT COUNT(*) FROM shared.failed_login_attempts
WHERE username = $1
  AND attempted_at > $2
`

type CountFailedLoginAttemptsByUsernameParams struct {
	Username    string    `json:"username"`
	AttemptedAt time.Time `json:"attemptedAt"`
}

func (q *Queries) CountFailedLoginAttemptsByUsername(ctx context.Context, arg CountFailedLoginAttemptsByUsernameParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFailedLoginAttemptsByUsername, arg.Username, arg.AttemptedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuthToken = `-- name: CreateAuthToken :one
INSERT INTO shared.auth_tokens (
    user_id,
    token_hash,
    token_type,
    device_name,
    device_fingerprint,
    ip_address,
    user_agent,
    expires_at,
    session_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, user_id, token_hash, token_type, device_name, device_fingerprint, ip_address, user_agent, expires_at, revoked_at, last_used_at, created_at, updated_at, session_id
`

type CreateAuthTokenParams struct {
	UserID            uuid.UUID   `json:"userId"`
	TokenHash         string      `json:"tokenHash"`
	TokenType         string      `json:"tokenType"`
	DeviceName        *string     `json:"deviceName"`
	DeviceFingerprint *string     `json:"deviceFingerprint"`
	IpAddress         netip.Addr  `json:"ipAddress"`
	UserAgent         *string     `json:"userAgent"`
	ExpiresAt         time.Time   `json:"expiresAt"`
	SessionID         pgtype.UUID `json:"sessionId"`
}

func (q *Queries) CreateAuthToken(ctx context.Context, arg CreateAuthTokenParams) (SharedAuthToken, error) {
	row := q.db.QueryRow(ctx, createAuthToken,
		arg.UserID,
		arg.TokenHash,
		arg.TokenType,
		arg.DeviceName,
		arg.DeviceFingerprint,
		arg.IpAddress,
		arg.UserAgent,
		arg.ExpiresAt,
		arg.SessionID,
	)
	var i SharedAuthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.TokenType,
		&i.DeviceName,
		&i.DeviceFingerprint,
		&i.IpAddress,
		&i.UserAgent,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SessionID,
	)
	return i, err
}

const createEmailVerificationToken = `-- name: CreateEmailVerificationToken :one

INSERT INTO shared.email_verification_tokens (
    user_id,
    token_hash,
    email,
    ip_address,
    user_agent,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, token_hash, email, ip_address, user_agent, expires_at, verified_at, created_at
`

type CreateEmailVerificationTokenParams struct {
	UserID    uuid.UUID  `json:"userId"`
	TokenHash string     `json:"tokenHash"`
	Email     string     `json:"email"`
	IpAddress netip.Addr `json:"ipAddress"`
	UserAgent *string    `json:"userAgent"`
	ExpiresAt time.Time  `json:"expiresAt"`
}

// Email Verification Tokens
func (q *Queries) CreateEmailVerificationToken(ctx context.Context, arg CreateEmailVerificationTokenParams) (SharedEmailVerificationToken, error) {
	row := q.db.QueryRow(ctx, createEmailVerificationToken,
		arg.UserID,
		arg.TokenHash,
		arg.Email,
		arg.IpAddress,
		arg.UserAgent,
		arg.ExpiresAt,
	)
	var i SharedEmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Email,
		&i.IpAddress,
		&i.UserAgent,
		&i.ExpiresAt,
		&i.VerifiedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createPasswordResetToken = `-- name: CreatePasswordResetToken :one

INSERT INTO shared.password_reset_tokens (
    user_id,
    token_hash,
    ip_address,
    user_agent,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, user_id, token_hash, ip_address, user_agent, expires_at, used_at, created_at
`

type CreatePasswordResetTokenParams struct {
	UserID    uuid.UUID  `json:"userId"`
	TokenHash string     `json:"tokenHash"`
	IpAddress netip.Addr `json:"ipAddress"`
	UserAgent *string    `json:"userAgent"`
	ExpiresAt time.Time  `json:"expiresAt"`
}

// Password Reset Tokens
func (q *Queries) CreatePasswordResetToken(ctx context.Context, arg CreatePasswordResetTokenParams) (SharedPasswordResetToken, error) {
	row := q.db.QueryRow(ctx, createPasswordResetToken,
		arg.UserID,
		arg.TokenHash,
		arg.IpAddress,
		arg.UserAgent,
		arg.ExpiresAt,
	)
	var i SharedPasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.IpAddress,
		&i.UserAgent,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExpiredAuthTokens = `-- name: DeleteExpiredAuthTokens :exec
DELETE FROM shared.auth_tokens
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredAuthTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredAuthTokens)
	return err
}

const deleteExpiredEmailVerificationTokens = `-- name: DeleteExpiredEmailVerificationTokens :exec
DELETE FROM shared.email_verification_tokens
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredEmailVerificationTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredEmailVerificationTokens)
	return err
}

const deleteExpiredPasswordResetTokens = `-- name: DeleteExpiredPasswordResetTokens :exec
DELETE FROM shared.password_reset_tokens
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredPasswordResetTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredPasswordResetTokens)
	return err
}

const deleteOldFailedLoginAttempts = `-- name: DeleteOldFailedLoginAttempts :exec
DELETE FROM shared.failed_login_attempts
WHERE attempted_at < NOW() - INTERVAL '24 hours'
`

func (q *Queries) DeleteOldFailedLoginAttempts(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOldFailedLoginAttempts)
	return err
}

const deleteRevokedAuthTokens = `-- name: DeleteRevokedAuthTokens :exec
DELETE FROM shared.auth_tokens
WHERE revoked_at IS NOT NULL
  AND revoked_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) DeleteRevokedAuthTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteRevokedAuthTokens)
	return err
}

const deleteUsedPasswordResetTokens = `-- name: DeleteUsedPasswordResetTokens :exec
DELETE FROM shared.password_reset_tokens
WHERE used_at IS NOT NULL
  AND used_at < NOW() - INTERVAL '7 days'
`

func (q *Queries) DeleteUsedPasswordResetTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteUsedPasswordResetTokens)
	return err
}

const deleteVerifiedEmailTokens = `-- name: DeleteVerifiedEmailTokens :exec
DELETE FROM shared.email_verification_tokens
WHERE verified_at IS NOT NULL
  AND verified_at < NOW() - INTERVAL '7 days'
`

func (q *Queries) DeleteVerifiedEmailTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteVerifiedEmailTokens)
	return err
}

const getAuthTokenByHash = `-- name: GetAuthTokenByHash :one
SELECT id, user_id, token_hash, token_type, device_name, device_fingerprint, ip_address, user_agent, expires_at, revoked_at, last_used_at, created_at, updated_at, session_id FROM shared.auth_tokens
WHERE token_hash = $1
  AND revoked_at IS NULL
  AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetAuthTokenByHash(ctx context.Context, tokenHash string) (SharedAuthToken, error) {
	row := q.db.QueryRow(ctx, getAuthTokenByHash, tokenHash)
	var i SharedAuthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.TokenType,
		&i.DeviceName,
		&i.DeviceFingerprint,
		&i.IpAddress,
		&i.UserAgent,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SessionID,
	)
	return i, err
}

const getAuthTokensByDeviceFingerprint = `-- name: GetAuthTokensByDeviceFingerprint :many
SELECT id, user_id, token_hash, token_type, device_name, device_fingerprint, ip_address, user_agent, expires_at, revoked_at, last_used_at, created_at, updated_at, session_id FROM shared.auth_tokens
WHERE user_id = $1
  AND device_fingerprint = $2
  AND revoked_at IS NULL
  AND expires_at > NOW()
ORDER BY created_at DESC
`

type GetAuthTokensByDeviceFingerprintParams struct {
	UserID            uuid.UUID `json:"userId"`
	DeviceFingerprint *string   `json:"deviceFingerprint"`
}

func (q *Queries) GetAuthTokensByDeviceFingerprint(ctx context.Context, arg GetAuthTokensByDeviceFingerprintParams) ([]SharedAuthToken, error) {
	rows, err := q.db.Query(ctx, getAuthTokensByDeviceFingerprint, arg.UserID, arg.DeviceFingerprint)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharedAuthToken{}
	for rows.Next() {
		var i SharedAuthToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.TokenType,
			&i.DeviceName,
			&i.DeviceFingerprint,
			&i.IpAddress,
			&i.UserAgent,
			&i.ExpiresAt,
			&i.RevokedAt,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SessionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthTokensByUserID = `-- name: GetAuthTokensByUserID :many
SELECT id, user_id, token_hash, token_type, device_name, device_fingerprint, ip_address, user_agent, expires_at, revoked_at, last_used_at, created_at, updated_at, session_id FROM shared.auth_tokens
WHERE user_id = $1
  AND revoked_at IS NULL
  AND expires_at > NOW()
ORDER BY created_at DESC
`

func (q *Queries) GetAuthTokensByUserID(ctx context.Context, userID uuid.UUID) ([]SharedAuthToken, error) {
	rows, err := q.db.Query(ctx, getAuthTokensByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharedAuthToken{}
	for rows.Next() {
		var i SharedAuthToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.TokenType,
			&i.DeviceName,
			&i.DeviceFingerprint,
			&i.IpAddress,
			&i.UserAgent,
			&i.ExpiresAt,
			&i.RevokedAt,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SessionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailVerificationToken = `-- name: GetEmailVerificationToken :one
SELECT id, user_id, token_hash, email, ip_address, user_agent, expires_at, verified_at, created_at FROM shared.email_verification_tokens
WHERE token_hash = $1
  AND verified_at IS NULL
  AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetEmailVerificationToken(ctx context.Context, tokenHash string) (SharedEmailVerificationToken, error) {
	row := q.db.QueryRow(ctx, getEmailVerificationToken, tokenHash)
	var i SharedEmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Email,
		&i.IpAddress,
		&i.UserAgent,
		&i.ExpiresAt,
		&i.VerifiedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPasswordResetToken = `-- name: GetPasswordResetToken :one
SELECT id, user_id, token_hash, ip_address, user_agent, expires_at, used_at, created_at FROM shared.password_reset_tokens
WHERE token_hash = $1
  AND used_at IS NULL
  AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetPasswordResetToken(ctx context.Context, tokenHash string) (SharedPasswordResetToken, error) {
	row := q.db.QueryRow(ctx, getPasswordResetToken, tokenHash)
	var i SharedPasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.IpAddress,
		&i.UserAgent,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const invalidateEmailVerificationTokensByEmail = `-- name: InvalidateEmailVerificationTokensByEmail :exec
UPDATE shared.email_verification_tokens
SET verified_at = NOW()
WHERE email = $1
  AND verified_at IS NULL
`

func (q *Queries) InvalidateEmailVerificationTokensByEmail(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, invalidateEmailVerificationTokensByEmail, email)
	return err
}

const invalidateUserEmailVerificationTokens = `-- name: InvalidateUserEmailVerificationTokens :exec
UPDATE shared.email_verification_tokens
SET verified_at = NOW()
WHERE user_id = $1
  AND verified_at IS NULL
`

func (q *Queries) InvalidateUserEmailVerificationTokens(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, invalidateUserEmailVerificationTokens, userID)
	return err
}

const invalidateUserPasswordResetTokens = `-- name: InvalidateUserPasswordResetTokens :exec
UPDATE shared.password_reset_tokens
SET used_at = NOW()
WHERE user_id = $1
  AND used_at IS NULL
`

func (q *Queries) InvalidateUserPasswordResetTokens(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, invalidateUserPasswordResetTokens, userID)
	return err
}

const markEmailVerificationTokenUsed = `-- name: MarkEmailVerificationTokenUsed :exec
UPDATE shared.email_verification_tokens
SET verified_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkEmailVerificationTokenUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markEmailVerificationTokenUsed, id)
	return err
}

const markPasswordResetTokenUsed = `-- name: MarkPasswordResetTokenUsed :exec
UPDATE shared.password_reset_tokens
SET used_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkPasswordResetTokenUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markPasswordResetTokenUsed, id)
	return err
}

const recordFailedLoginAttempt = `-- name: RecordFailedLoginAttempt :exec

INSERT INTO shared.failed_login_attempts (
    username,
    ip_address
) VALUES (
    $1, $2
)
`

type RecordFailedLoginAttemptParams struct {
	Username  string `json:"username"`
	IpAddress string `json:"ipAddress"`
}

// Failed Login Attempts (Account Lockout / Rate Limiting)
func (q *Queries) RecordFailedLoginAttempt(ctx context.Context, arg RecordFailedLoginAttemptParams) error {
	_, err := q.db.Exec(ctx, recordFailedLoginAttempt, arg.Username, arg.IpAddress)
	return err
}

const revokeAllUserAuthTokens = `-- name: RevokeAllUserAuthTokens :exec
UPDATE shared.auth_tokens
SET revoked_at = NOW(),
    updated_at = NOW()
WHERE user_id = $1
  AND revoked_at IS NULL
`

func (q *Queries) RevokeAllUserAuthTokens(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeAllUserAuthTokens, userID)
	return err
}

const revokeAllUserAuthTokensExcept = `-- name: RevokeAllUserAuthTokensExcept :exec
UPDATE shared.auth_tokens
SET revoked_at = NOW(),
    updated_at = NOW()
WHERE user_id = $1
  AND id != $2
  AND revoked_at IS NULL
`

type RevokeAllUserAuthTokensExceptParams struct {
	UserID uuid.UUID `json:"userId"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) RevokeAllUserAuthTokensExcept(ctx context.Context, arg RevokeAllUserAuthTokensExceptParams) error {
	_, err := q.db.Exec(ctx, revokeAllUserAuthTokensExcept, arg.UserID, arg.ID)
	return err
}

const revokeAuthToken = `-- name: RevokeAuthToken :exec
UPDATE shared.auth_tokens
SET revoked_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) RevokeAuthToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeAuthToken, id)
	return err
}

const revokeAuthTokenByHash = `-- name: RevokeAuthTokenByHash :exec
UPDATE shared.auth_tokens
SET revoked_at = NOW(),
    updated_at = NOW()
WHERE token_hash = $1
`

func (q *Queries) RevokeAuthTokenByHash(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, revokeAuthTokenByHash, tokenHash)
	return err
}

const updateAuthTokenLastUsed = `-- name: UpdateAuthTokenLastUsed :exec
UPDATE shared.auth_tokens
SET last_used_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateAuthTokenLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateAuthTokenLastUsed, id)
	return err
}
