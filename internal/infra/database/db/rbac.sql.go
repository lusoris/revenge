// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rbac.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countUsersByRoleName = `-- name: CountUsersByRoleName :one
SELECT COUNT(*) FROM users u
JOIN roles r ON r.id = u.role_id
WHERE r.name = $1
`

func (q *Queries) CountUsersByRoleName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersByRoleName, name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsersWithRole = `-- name: CountUsersWithRole :one
SELECT COUNT(*) FROM users WHERE role_id = $1
`

func (q *Queries) CountUsersWithRole(ctx context.Context, roleID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersWithRole, roleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (name, display_name, description, color, icon, priority, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, name, display_name, description, color, icon, is_system, is_default, priority, created_at, updated_at, created_by
`

type CreateRoleParams struct {
	Name        string      `json:"name"`
	DisplayName string      `json:"displayName"`
	Description *string     `json:"description"`
	Color       *string     `json:"color"`
	Icon        *string     `json:"icon"`
	Priority    int32       `json:"priority"`
	CreatedBy   pgtype.UUID `json:"createdBy"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, createRole,
		arg.Name,
		arg.DisplayName,
		arg.Description,
		arg.Color,
		arg.Icon,
		arg.Priority,
		arg.CreatedBy,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Color,
		&i.Icon,
		&i.IsSystem,
		&i.IsDefault,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles WHERE name = $1 AND is_system = false
`

func (q *Queries) DeleteRole(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteRole, name)
	return err
}

const getDefaultRole = `-- name: GetDefaultRole :one
SELECT id, name, display_name, description, color, icon, is_system, is_default, priority, created_at, updated_at, created_by
FROM roles
WHERE is_default = true
LIMIT 1
`

func (q *Queries) GetDefaultRole(ctx context.Context) (Role, error) {
	row := q.db.QueryRow(ctx, getDefaultRole)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Color,
		&i.Icon,
		&i.IsSystem,
		&i.IsDefault,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getPermissionDefinitionsByCategory = `-- name: GetPermissionDefinitionsByCategory :many
SELECT id, name, display_name, description, category, is_dangerous, created_at
FROM permission_definitions
WHERE category = $1
ORDER BY name
`

func (q *Queries) GetPermissionDefinitionsByCategory(ctx context.Context, category string) ([]PermissionDefinition, error) {
	rows, err := q.db.Query(ctx, getPermissionDefinitionsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PermissionDefinition{}
	for rows.Next() {
		var i PermissionDefinition
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.Category,
			&i.IsDangerous,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleByID = `-- name: GetRoleByID :one
SELECT id, name, display_name, description, color, icon, is_system, is_default, priority, created_at, updated_at, created_by
FROM roles
WHERE id = $1
`

func (q *Queries) GetRoleByID(ctx context.Context, id uuid.UUID) (Role, error) {
	row := q.db.QueryRow(ctx, getRoleByID, id)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Color,
		&i.Icon,
		&i.IsSystem,
		&i.IsDefault,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT id, name, display_name, description, color, icon, is_system, is_default, priority, created_at, updated_at, created_by
FROM roles
WHERE name = $1
`

func (q *Queries) GetRoleByName(ctx context.Context, name string) (Role, error) {
	row := q.db.QueryRow(ctx, getRoleByName, name)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Color,
		&i.Icon,
		&i.IsSystem,
		&i.IsDefault,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getUserRoleName = `-- name: GetUserRoleName :one
SELECT r.name
FROM users u
JOIN roles r ON r.id = u.role_id
WHERE u.id = $1
`

func (q *Queries) GetUserRoleName(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getUserRoleName, id)
	var name string
	err := row.Scan(&name)
	return name, err
}

const listPermissionDefinitions = `-- name: ListPermissionDefinitions :many
SELECT id, name, display_name, description, category, is_dangerous, created_at
FROM permission_definitions
ORDER BY category, name
`

func (q *Queries) ListPermissionDefinitions(ctx context.Context) ([]PermissionDefinition, error) {
	rows, err := q.db.Query(ctx, listPermissionDefinitions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PermissionDefinition{}
	for rows.Next() {
		var i PermissionDefinition
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.Category,
			&i.IsDangerous,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
SELECT id, name, display_name, description, color, icon, is_system, is_default, priority, created_at, updated_at, created_by
FROM roles
ORDER BY priority DESC, name ASC
`

func (q *Queries) ListRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.Query(ctx, listRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.Color,
			&i.Icon,
			&i.IsSystem,
			&i.IsDefault,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByRoleName = `-- name: ListUsersByRoleName :many
SELECT u.id, u.username, u.email, u.password_hash, u.is_admin, u.is_disabled, u.max_rating_level, u.adult_enabled, u.preferred_language, u.preferred_rating_system, u.last_login_at, u.created_at, u.updated_at, u.role, u.role_id FROM users u
JOIN roles r ON r.id = u.role_id
WHERE r.name = $1
ORDER BY u.created_at DESC
LIMIT $2 OFFSET $3
`

type ListUsersByRoleNameParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListUsersByRoleName(ctx context.Context, arg ListUsersByRoleNameParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersByRoleName, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.IsAdmin,
			&i.IsDisabled,
			&i.MaxRatingLevel,
			&i.AdultEnabled,
			&i.PreferredLanguage,
			&i.PreferredRatingSystem,
			&i.LastLoginAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
			&i.RoleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDefaultRole = `-- name: SetDefaultRole :exec
UPDATE roles SET is_default = (name = $1)
`

func (q *Queries) SetDefaultRole(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, setDefaultRole, name)
	return err
}

const setUserRole = `-- name: SetUserRole :exec
UPDATE users SET role_id = (SELECT id FROM roles WHERE name = $2)
WHERE users.id = $1
`

type SetUserRoleParams struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) SetUserRole(ctx context.Context, arg SetUserRoleParams) error {
	_, err := q.db.Exec(ctx, setUserRole, arg.ID, arg.Name)
	return err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles
SET display_name = $2, description = $3, color = $4, icon = $5, priority = $6, updated_at = NOW()
WHERE name = $1
RETURNING id, name, display_name, description, color, icon, is_system, is_default, priority, created_at, updated_at, created_by
`

type UpdateRoleParams struct {
	Name        string  `json:"name"`
	DisplayName string  `json:"displayName"`
	Description *string `json:"description"`
	Color       *string `json:"color"`
	Icon        *string `json:"icon"`
	Priority    int32   `json:"priority"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, updateRole,
		arg.Name,
		arg.DisplayName,
		arg.Description,
		arg.Color,
		arg.Icon,
		arg.Priority,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Color,
		&i.Icon,
		&i.IsSystem,
		&i.IsDefault,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}
