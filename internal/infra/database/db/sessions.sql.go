// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package db

import (
	"context"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countUserSessions = `-- name: CountUserSessions :one
SELECT count(*) FROM sessions WHERE user_id = $1
`

func (q *Queries) CountUserSessions(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserSessions, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    user_id, token_hash, refresh_token_hash, device_id, device_name,
    client_name, client_version, ip_address, expires_at, refresh_expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, user_id, token_hash, refresh_token_hash, device_id, device_name, client_name, client_version, ip_address, expires_at, refresh_expires_at, created_at
`

type CreateSessionParams struct {
	UserID           uuid.UUID          `json:"userId"`
	TokenHash        string             `json:"tokenHash"`
	RefreshTokenHash pgtype.Text        `json:"refreshTokenHash"`
	DeviceID         pgtype.Text        `json:"deviceId"`
	DeviceName       pgtype.Text        `json:"deviceName"`
	ClientName       pgtype.Text        `json:"clientName"`
	ClientVersion    pgtype.Text        `json:"clientVersion"`
	IpAddress        *netip.Addr        `json:"ipAddress"`
	ExpiresAt        time.Time          `json:"expiresAt"`
	RefreshExpiresAt pgtype.Timestamptz `json:"refreshExpiresAt"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.UserID,
		arg.TokenHash,
		arg.RefreshTokenHash,
		arg.DeviceID,
		arg.DeviceName,
		arg.ClientName,
		arg.ClientVersion,
		arg.IpAddress,
		arg.ExpiresAt,
		arg.RefreshExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.DeviceID,
		&i.DeviceName,
		&i.ClientName,
		&i.ClientVersion,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.RefreshExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :execrows
DELETE FROM sessions WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExpiredSessions)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSession, id)
	return err
}

const deleteSessionByTokenHash = `-- name: DeleteSessionByTokenHash :exec
DELETE FROM sessions WHERE token_hash = $1
`

func (q *Queries) DeleteSessionByTokenHash(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, deleteSessionByTokenHash, tokenHash)
	return err
}

const deleteUserSessions = `-- name: DeleteUserSessions :exec
DELETE FROM sessions WHERE user_id = $1
`

func (q *Queries) DeleteUserSessions(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserSessions, userID)
	return err
}

const getSessionByID = `-- name: GetSessionByID :one


SELECT id, user_id, token_hash, refresh_token_hash, device_id, device_name, client_name, client_version, ip_address, expires_at, refresh_expires_at, created_at FROM sessions WHERE id = $1 LIMIT 1
`

// Session queries for Revenge Go
// =============================================================================
// BASIC CRUD
// =============================================================================
func (q *Queries) GetSessionByID(ctx context.Context, id uuid.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.DeviceID,
		&i.DeviceName,
		&i.ClientName,
		&i.ClientVersion,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.RefreshExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionByRefreshTokenHash = `-- name: GetSessionByRefreshTokenHash :one
SELECT id, user_id, token_hash, refresh_token_hash, device_id, device_name, client_name, client_version, ip_address, expires_at, refresh_expires_at, created_at FROM sessions WHERE refresh_token_hash = $1 LIMIT 1
`

func (q *Queries) GetSessionByRefreshTokenHash(ctx context.Context, refreshTokenHash pgtype.Text) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByRefreshTokenHash, refreshTokenHash)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.DeviceID,
		&i.DeviceName,
		&i.ClientName,
		&i.ClientVersion,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.RefreshExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionByTokenHash = `-- name: GetSessionByTokenHash :one
SELECT id, user_id, token_hash, refresh_token_hash, device_id, device_name, client_name, client_version, ip_address, expires_at, refresh_expires_at, created_at FROM sessions WHERE token_hash = $1 LIMIT 1
`

func (q *Queries) GetSessionByTokenHash(ctx context.Context, tokenHash string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByTokenHash, tokenHash)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.DeviceID,
		&i.DeviceName,
		&i.ClientName,
		&i.ClientVersion,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.RefreshExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionWithUser = `-- name: GetSessionWithUser :one

SELECT
    s.id, s.user_id, s.token_hash, s.refresh_token_hash, s.device_id, s.device_name, s.client_name, s.client_version, s.ip_address, s.expires_at, s.refresh_expires_at, s.created_at,
    u.id AS user_id,
    u.username,
    u.email,
    u.display_name,
    u.is_admin,
    u.is_disabled
FROM sessions s
JOIN users u ON s.user_id = u.id
WHERE s.token_hash = $1 AND s.expires_at > NOW()
LIMIT 1
`

type GetSessionWithUserRow struct {
	ID               uuid.UUID          `json:"id"`
	UserID           uuid.UUID          `json:"userId"`
	TokenHash        string             `json:"tokenHash"`
	RefreshTokenHash pgtype.Text        `json:"refreshTokenHash"`
	DeviceID         pgtype.Text        `json:"deviceId"`
	DeviceName       pgtype.Text        `json:"deviceName"`
	ClientName       pgtype.Text        `json:"clientName"`
	ClientVersion    pgtype.Text        `json:"clientVersion"`
	IpAddress        *netip.Addr        `json:"ipAddress"`
	ExpiresAt        time.Time          `json:"expiresAt"`
	RefreshExpiresAt pgtype.Timestamptz `json:"refreshExpiresAt"`
	CreatedAt        time.Time          `json:"createdAt"`
	UserID_2         uuid.UUID          `json:"userId2"`
	Username         string             `json:"username"`
	Email            pgtype.Text        `json:"email"`
	DisplayName      pgtype.Text        `json:"displayName"`
	IsAdmin          bool               `json:"isAdmin"`
	IsDisabled       bool               `json:"isDisabled"`
}

// =============================================================================
// JOIN QUERIES
// =============================================================================
func (q *Queries) GetSessionWithUser(ctx context.Context, tokenHash string) (GetSessionWithUserRow, error) {
	row := q.db.QueryRow(ctx, getSessionWithUser, tokenHash)
	var i GetSessionWithUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.DeviceID,
		&i.DeviceName,
		&i.ClientName,
		&i.ClientVersion,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.RefreshExpiresAt,
		&i.CreatedAt,
		&i.UserID_2,
		&i.Username,
		&i.Email,
		&i.DisplayName,
		&i.IsAdmin,
		&i.IsDisabled,
	)
	return i, err
}

const listActiveSessions = `-- name: ListActiveSessions :many
SELECT id, user_id, token_hash, refresh_token_hash, device_id, device_name, client_name, client_version, ip_address, expires_at, refresh_expires_at, created_at FROM sessions
WHERE expires_at > NOW()
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListActiveSessionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListActiveSessions(ctx context.Context, arg ListActiveSessionsParams) ([]Session, error) {
	rows, err := q.db.Query(ctx, listActiveSessions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.RefreshTokenHash,
			&i.DeviceID,
			&i.DeviceName,
			&i.ClientName,
			&i.ClientVersion,
			&i.IpAddress,
			&i.ExpiresAt,
			&i.RefreshExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSessions = `-- name: ListUserSessions :many
SELECT id, user_id, token_hash, refresh_token_hash, device_id, device_name, client_name, client_version, ip_address, expires_at, refresh_expires_at, created_at FROM sessions
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListUserSessions(ctx context.Context, userID uuid.UUID) ([]Session, error) {
	rows, err := q.db.Query(ctx, listUserSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.RefreshTokenHash,
			&i.DeviceID,
			&i.DeviceName,
			&i.ClientName,
			&i.ClientVersion,
			&i.IpAddress,
			&i.ExpiresAt,
			&i.RefreshExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sessionExists = `-- name: SessionExists :one
SELECT EXISTS(SELECT 1 FROM sessions WHERE token_hash = $1 AND expires_at > NOW())
`

func (q *Queries) SessionExists(ctx context.Context, tokenHash string) (bool, error) {
	row := q.db.QueryRow(ctx, sessionExists, tokenHash)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateSessionRefreshToken = `-- name: UpdateSessionRefreshToken :exec
UPDATE sessions
SET
    refresh_token_hash = $2,
    refresh_expires_at = $3
WHERE id = $1
`

type UpdateSessionRefreshTokenParams struct {
	ID               uuid.UUID          `json:"id"`
	RefreshTokenHash pgtype.Text        `json:"refreshTokenHash"`
	RefreshExpiresAt pgtype.Timestamptz `json:"refreshExpiresAt"`
}

func (q *Queries) UpdateSessionRefreshToken(ctx context.Context, arg UpdateSessionRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, updateSessionRefreshToken, arg.ID, arg.RefreshTokenHash, arg.RefreshExpiresAt)
	return err
}
