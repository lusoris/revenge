// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package db

import (
	"context"
	"net/netip"
	"time"

	"github.com/google/uuid"
)

const countActiveUserSessions = `-- name: CountActiveUserSessions :one
SELECT COUNT(*) FROM shared.sessions
WHERE user_id = $1
  AND revoked_at IS NULL
  AND expires_at > NOW()
`

func (q *Queries) CountActiveUserSessions(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveUserSessions, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllActiveSessions = `-- name: CountAllActiveSessions :one
SELECT COUNT(*) FROM shared.sessions
WHERE revoked_at IS NULL
  AND expires_at > NOW()
`

func (q *Queries) CountAllActiveSessions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllActiveSessions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSession = `-- name: CreateSession :one

INSERT INTO shared.sessions (
    user_id,
    token_hash,
    refresh_token_hash,
    ip_address,
    user_agent,
    device_name,
    scopes,
    expires_at,
    last_activity_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, NOW()
) RETURNING id, user_id, token_hash, refresh_token_hash, ip_address, user_agent, device_name, scopes, expires_at, last_activity_at, created_at, revoked_at, revoke_reason, mfa_verified, mfa_verified_at
`

type CreateSessionParams struct {
	UserID           uuid.UUID  `json:"userId"`
	TokenHash        string     `json:"tokenHash"`
	RefreshTokenHash *string    `json:"refreshTokenHash"`
	IpAddress        netip.Addr `json:"ipAddress"`
	UserAgent        *string    `json:"userAgent"`
	DeviceName       *string    `json:"deviceName"`
	Scopes           []string   `json:"scopes"`
	ExpiresAt        time.Time  `json:"expiresAt"`
}

// Session Management Queries
// Persistent session tracking with device information
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (SharedSession, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.UserID,
		arg.TokenHash,
		arg.RefreshTokenHash,
		arg.IpAddress,
		arg.UserAgent,
		arg.DeviceName,
		arg.Scopes,
		arg.ExpiresAt,
	)
	var i SharedSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.IpAddress,
		&i.UserAgent,
		&i.DeviceName,
		&i.Scopes,
		&i.ExpiresAt,
		&i.LastActivityAt,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.RevokeReason,
		&i.MfaVerified,
		&i.MfaVerifiedAt,
	)
	return i, err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :execrows
DELETE FROM shared.sessions
WHERE expires_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExpiredSessions)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteRevokedSessions = `-- name: DeleteRevokedSessions :execrows
DELETE FROM shared.sessions
WHERE revoked_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) DeleteRevokedSessions(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRevokedSessions)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getInactiveSessions = `-- name: GetInactiveSessions :many
SELECT id, user_id, token_hash, refresh_token_hash, ip_address, user_agent, device_name, scopes, expires_at, last_activity_at, created_at, revoked_at, revoke_reason, mfa_verified, mfa_verified_at FROM shared.sessions
WHERE last_activity_at < $1::TIMESTAMPTZ
  AND revoked_at IS NULL
  AND expires_at > NOW()
`

// Sessions that haven't been active for N hours
func (q *Queries) GetInactiveSessions(ctx context.Context, inactiveSince time.Time) ([]SharedSession, error) {
	rows, err := q.db.Query(ctx, getInactiveSessions, inactiveSince)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharedSession{}
	for rows.Next() {
		var i SharedSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.RefreshTokenHash,
			&i.IpAddress,
			&i.UserAgent,
			&i.DeviceName,
			&i.Scopes,
			&i.ExpiresAt,
			&i.LastActivityAt,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.RevokeReason,
			&i.MfaVerified,
			&i.MfaVerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMFAVerifiedSessions = `-- name: GetMFAVerifiedSessions :many
SELECT id, user_id, token_hash, refresh_token_hash, ip_address, user_agent, device_name, scopes, expires_at, last_activity_at, created_at, revoked_at, revoke_reason, mfa_verified, mfa_verified_at FROM shared.sessions
WHERE user_id = $1
  AND mfa_verified = TRUE
  AND revoked_at IS NULL
  AND expires_at > NOW()
ORDER BY mfa_verified_at DESC
`

func (q *Queries) GetMFAVerifiedSessions(ctx context.Context, userID uuid.UUID) ([]SharedSession, error) {
	rows, err := q.db.Query(ctx, getMFAVerifiedSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharedSession{}
	for rows.Next() {
		var i SharedSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.RefreshTokenHash,
			&i.IpAddress,
			&i.UserAgent,
			&i.DeviceName,
			&i.Scopes,
			&i.ExpiresAt,
			&i.LastActivityAt,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.RevokeReason,
			&i.MfaVerified,
			&i.MfaVerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, user_id, token_hash, refresh_token_hash, ip_address, user_agent, device_name, scopes, expires_at, last_activity_at, created_at, revoked_at, revoke_reason, mfa_verified, mfa_verified_at FROM shared.sessions
WHERE id = $1
  AND revoked_at IS NULL
LIMIT 1
`

func (q *Queries) GetSessionByID(ctx context.Context, id uuid.UUID) (SharedSession, error) {
	row := q.db.QueryRow(ctx, getSessionByID, id)
	var i SharedSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.IpAddress,
		&i.UserAgent,
		&i.DeviceName,
		&i.Scopes,
		&i.ExpiresAt,
		&i.LastActivityAt,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.RevokeReason,
		&i.MfaVerified,
		&i.MfaVerifiedAt,
	)
	return i, err
}

const getSessionByRefreshTokenHash = `-- name: GetSessionByRefreshTokenHash :one
SELECT id, user_id, token_hash, refresh_token_hash, ip_address, user_agent, device_name, scopes, expires_at, last_activity_at, created_at, revoked_at, revoke_reason, mfa_verified, mfa_verified_at FROM shared.sessions
WHERE refresh_token_hash = $1
  AND revoked_at IS NULL
  AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetSessionByRefreshTokenHash(ctx context.Context, refreshTokenHash *string) (SharedSession, error) {
	row := q.db.QueryRow(ctx, getSessionByRefreshTokenHash, refreshTokenHash)
	var i SharedSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.IpAddress,
		&i.UserAgent,
		&i.DeviceName,
		&i.Scopes,
		&i.ExpiresAt,
		&i.LastActivityAt,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.RevokeReason,
		&i.MfaVerified,
		&i.MfaVerifiedAt,
	)
	return i, err
}

const getSessionByTokenHash = `-- name: GetSessionByTokenHash :one
SELECT id, user_id, token_hash, refresh_token_hash, ip_address, user_agent, device_name, scopes, expires_at, last_activity_at, created_at, revoked_at, revoke_reason, mfa_verified, mfa_verified_at FROM shared.sessions
WHERE token_hash = $1
  AND revoked_at IS NULL
  AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetSessionByTokenHash(ctx context.Context, tokenHash string) (SharedSession, error) {
	row := q.db.QueryRow(ctx, getSessionByTokenHash, tokenHash)
	var i SharedSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.IpAddress,
		&i.UserAgent,
		&i.DeviceName,
		&i.Scopes,
		&i.ExpiresAt,
		&i.LastActivityAt,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.RevokeReason,
		&i.MfaVerified,
		&i.MfaVerifiedAt,
	)
	return i, err
}

const listAllUserSessions = `-- name: ListAllUserSessions :many
SELECT id, user_id, token_hash, refresh_token_hash, ip_address, user_agent, device_name, scopes, expires_at, last_activity_at, created_at, revoked_at, revoke_reason, mfa_verified, mfa_verified_at FROM shared.sessions
WHERE user_id = $1
  AND revoked_at IS NULL
ORDER BY last_activity_at DESC
`

// Includes expired but not revoked sessions (for user to see full history)
func (q *Queries) ListAllUserSessions(ctx context.Context, userID uuid.UUID) ([]SharedSession, error) {
	rows, err := q.db.Query(ctx, listAllUserSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharedSession{}
	for rows.Next() {
		var i SharedSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.RefreshTokenHash,
			&i.IpAddress,
			&i.UserAgent,
			&i.DeviceName,
			&i.Scopes,
			&i.ExpiresAt,
			&i.LastActivityAt,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.RevokeReason,
			&i.MfaVerified,
			&i.MfaVerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSessions = `-- name: ListUserSessions :many
SELECT id, user_id, token_hash, refresh_token_hash, ip_address, user_agent, device_name, scopes, expires_at, last_activity_at, created_at, revoked_at, revoke_reason, mfa_verified, mfa_verified_at FROM shared.sessions
WHERE user_id = $1
  AND revoked_at IS NULL
  AND expires_at > NOW()
ORDER BY last_activity_at DESC
`

func (q *Queries) ListUserSessions(ctx context.Context, userID uuid.UUID) ([]SharedSession, error) {
	rows, err := q.db.Query(ctx, listUserSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharedSession{}
	for rows.Next() {
		var i SharedSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.RefreshTokenHash,
			&i.IpAddress,
			&i.UserAgent,
			&i.DeviceName,
			&i.Scopes,
			&i.ExpiresAt,
			&i.LastActivityAt,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.RevokeReason,
			&i.MfaVerified,
			&i.MfaVerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSessionMFAVerified = `-- name: MarkSessionMFAVerified :exec

UPDATE shared.sessions
SET mfa_verified = TRUE,
    mfa_verified_at = NOW()
WHERE id = $1
  AND revoked_at IS NULL
`

// MFA Session Tracking
func (q *Queries) MarkSessionMFAVerified(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markSessionMFAVerified, id)
	return err
}

const markSessionMFAVerifiedByTokenHash = `-- name: MarkSessionMFAVerifiedByTokenHash :exec
UPDATE shared.sessions
SET mfa_verified = TRUE,
    mfa_verified_at = NOW()
WHERE token_hash = $1
  AND revoked_at IS NULL
`

func (q *Queries) MarkSessionMFAVerifiedByTokenHash(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, markSessionMFAVerifiedByTokenHash, tokenHash)
	return err
}

const revokeAllUserSessions = `-- name: RevokeAllUserSessions :exec
UPDATE shared.sessions
SET revoked_at = NOW(),
    revoke_reason = $2
WHERE user_id = $1
  AND revoked_at IS NULL
`

type RevokeAllUserSessionsParams struct {
	UserID uuid.UUID `json:"userId"`
	Reason *string   `json:"reason"`
}

func (q *Queries) RevokeAllUserSessions(ctx context.Context, arg RevokeAllUserSessionsParams) error {
	_, err := q.db.Exec(ctx, revokeAllUserSessions, arg.UserID, arg.Reason)
	return err
}

const revokeAllUserSessionsExcept = `-- name: RevokeAllUserSessionsExcept :exec
UPDATE shared.sessions
SET revoked_at = NOW(),
    revoke_reason = $3
WHERE user_id = $1
  AND id != $2
  AND revoked_at IS NULL
`

type RevokeAllUserSessionsExceptParams struct {
	UserID uuid.UUID `json:"userId"`
	ID     uuid.UUID `json:"id"`
	Reason *string   `json:"reason"`
}

func (q *Queries) RevokeAllUserSessionsExcept(ctx context.Context, arg RevokeAllUserSessionsExceptParams) error {
	_, err := q.db.Exec(ctx, revokeAllUserSessionsExcept, arg.UserID, arg.ID, arg.Reason)
	return err
}

const revokeInactiveSessions = `-- name: RevokeInactiveSessions :exec
UPDATE shared.sessions
SET revoked_at = NOW(),
    revoke_reason = 'Inactivity timeout'
WHERE last_activity_at < $1::TIMESTAMPTZ
  AND revoked_at IS NULL
`

func (q *Queries) RevokeInactiveSessions(ctx context.Context, inactiveSince time.Time) error {
	_, err := q.db.Exec(ctx, revokeInactiveSessions, inactiveSince)
	return err
}

const revokeSession = `-- name: RevokeSession :exec
UPDATE shared.sessions
SET revoked_at = NOW(),
    revoke_reason = $2
WHERE id = $1
`

type RevokeSessionParams struct {
	ID     uuid.UUID `json:"id"`
	Reason *string   `json:"reason"`
}

func (q *Queries) RevokeSession(ctx context.Context, arg RevokeSessionParams) error {
	_, err := q.db.Exec(ctx, revokeSession, arg.ID, arg.Reason)
	return err
}

const revokeSessionByTokenHash = `-- name: RevokeSessionByTokenHash :exec
UPDATE shared.sessions
SET revoked_at = NOW(),
    revoke_reason = $2
WHERE token_hash = $1
`

type RevokeSessionByTokenHashParams struct {
	TokenHash string  `json:"tokenHash"`
	Reason    *string `json:"reason"`
}

func (q *Queries) RevokeSessionByTokenHash(ctx context.Context, arg RevokeSessionByTokenHashParams) error {
	_, err := q.db.Exec(ctx, revokeSessionByTokenHash, arg.TokenHash, arg.Reason)
	return err
}

const updateSessionActivity = `-- name: UpdateSessionActivity :exec
UPDATE shared.sessions
SET last_activity_at = NOW()
WHERE id = $1
  AND revoked_at IS NULL
`

func (q *Queries) UpdateSessionActivity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateSessionActivity, id)
	return err
}

const updateSessionActivityByTokenHash = `-- name: UpdateSessionActivityByTokenHash :exec
UPDATE shared.sessions
SET last_activity_at = NOW()
WHERE token_hash = $1
  AND revoked_at IS NULL
`

func (q *Queries) UpdateSessionActivityByTokenHash(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, updateSessionActivityByTokenHash, tokenHash)
	return err
}
