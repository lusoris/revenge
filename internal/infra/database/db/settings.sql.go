// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: settings.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const createServerSetting = `-- name: CreateServerSetting :one
INSERT INTO shared.server_settings (
    key,
    value,
    description,
    category,
    data_type,
    is_secret,
    is_public,
    allowed_values,
    min_value,
    max_value,
    pattern,
    updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING key, value, description, category, data_type, is_secret, is_public, allowed_values, min_value, max_value, pattern, created_at, updated_at, updated_by
`

type CreateServerSettingParams struct {
	Key           string          `json:"key"`
	Value         json.RawMessage `json:"value"`
	Description   *string         `json:"description"`
	Category      *string         `json:"category"`
	DataType      string          `json:"dataType"`
	IsSecret      *bool           `json:"isSecret"`
	IsPublic      *bool           `json:"isPublic"`
	AllowedValues []byte          `json:"allowedValues"`
	MinValue      pgtype.Numeric  `json:"minValue"`
	MaxValue      pgtype.Numeric  `json:"maxValue"`
	Pattern       *string         `json:"pattern"`
	UpdatedBy     pgtype.UUID     `json:"updatedBy"`
}

// Create a new server setting
func (q *Queries) CreateServerSetting(ctx context.Context, arg CreateServerSettingParams) (SharedServerSetting, error) {
	row := q.db.QueryRow(ctx, createServerSetting,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.Category,
		arg.DataType,
		arg.IsSecret,
		arg.IsPublic,
		arg.AllowedValues,
		arg.MinValue,
		arg.MaxValue,
		arg.Pattern,
		arg.UpdatedBy,
	)
	var i SharedServerSetting
	err := row.Scan(
		&i.Key,
		&i.Value,
		&i.Description,
		&i.Category,
		&i.DataType,
		&i.IsSecret,
		&i.IsPublic,
		&i.AllowedValues,
		&i.MinValue,
		&i.MaxValue,
		&i.Pattern,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteServerSetting = `-- name: DeleteServerSetting :exec
DELETE FROM shared.server_settings
WHERE key = $1
`

// Delete a server setting
func (q *Queries) DeleteServerSetting(ctx context.Context, key string) error {
	_, err := q.db.Exec(ctx, deleteServerSetting, key)
	return err
}

const getServerSetting = `-- name: GetServerSetting :one
SELECT key, value, description, category, data_type, is_secret, is_public, allowed_values, min_value, max_value, pattern, created_at, updated_at, updated_by FROM shared.server_settings
WHERE key = $1
LIMIT 1
`

// Get a server setting by key
func (q *Queries) GetServerSetting(ctx context.Context, key string) (SharedServerSetting, error) {
	row := q.db.QueryRow(ctx, getServerSetting, key)
	var i SharedServerSetting
	err := row.Scan(
		&i.Key,
		&i.Value,
		&i.Description,
		&i.Category,
		&i.DataType,
		&i.IsSecret,
		&i.IsPublic,
		&i.AllowedValues,
		&i.MinValue,
		&i.MaxValue,
		&i.Pattern,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const listPublicServerSettings = `-- name: ListPublicServerSettings :many
SELECT key, value, description, category, data_type, is_secret, is_public, allowed_values, min_value, max_value, pattern, created_at, updated_at, updated_by FROM shared.server_settings
WHERE is_public = TRUE
ORDER BY category, key
`

// Get public settings (exposed in API)
func (q *Queries) ListPublicServerSettings(ctx context.Context) ([]SharedServerSetting, error) {
	rows, err := q.db.Query(ctx, listPublicServerSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharedServerSetting{}
	for rows.Next() {
		var i SharedServerSetting
		if err := rows.Scan(
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Category,
			&i.DataType,
			&i.IsSecret,
			&i.IsPublic,
			&i.AllowedValues,
			&i.MinValue,
			&i.MaxValue,
			&i.Pattern,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServerSettings = `-- name: ListServerSettings :many
SELECT key, value, description, category, data_type, is_secret, is_public, allowed_values, min_value, max_value, pattern, created_at, updated_at, updated_by FROM shared.server_settings
ORDER BY category, key
`

// Get all server settings
func (q *Queries) ListServerSettings(ctx context.Context) ([]SharedServerSetting, error) {
	rows, err := q.db.Query(ctx, listServerSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharedServerSetting{}
	for rows.Next() {
		var i SharedServerSetting
		if err := rows.Scan(
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Category,
			&i.DataType,
			&i.IsSecret,
			&i.IsPublic,
			&i.AllowedValues,
			&i.MinValue,
			&i.MaxValue,
			&i.Pattern,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServerSettingsByCategory = `-- name: ListServerSettingsByCategory :many
SELECT key, value, description, category, data_type, is_secret, is_public, allowed_values, min_value, max_value, pattern, created_at, updated_at, updated_by FROM shared.server_settings
WHERE category = $1
ORDER BY key
`

// Get settings by category
func (q *Queries) ListServerSettingsByCategory(ctx context.Context, category *string) ([]SharedServerSetting, error) {
	rows, err := q.db.Query(ctx, listServerSettingsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharedServerSetting{}
	for rows.Next() {
		var i SharedServerSetting
		if err := rows.Scan(
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Category,
			&i.DataType,
			&i.IsSecret,
			&i.IsPublic,
			&i.AllowedValues,
			&i.MinValue,
			&i.MaxValue,
			&i.Pattern,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateServerSetting = `-- name: UpdateServerSetting :one
UPDATE shared.server_settings
SET
    value = $2,
    updated_at = NOW(),
    updated_by = $3
WHERE key = $1
RETURNING key, value, description, category, data_type, is_secret, is_public, allowed_values, min_value, max_value, pattern, created_at, updated_at, updated_by
`

type UpdateServerSettingParams struct {
	Key       string          `json:"key"`
	Value     json.RawMessage `json:"value"`
	UpdatedBy pgtype.UUID     `json:"updatedBy"`
}

// Update a server setting value
func (q *Queries) UpdateServerSetting(ctx context.Context, arg UpdateServerSettingParams) (SharedServerSetting, error) {
	row := q.db.QueryRow(ctx, updateServerSetting, arg.Key, arg.Value, arg.UpdatedBy)
	var i SharedServerSetting
	err := row.Scan(
		&i.Key,
		&i.Value,
		&i.Description,
		&i.Category,
		&i.DataType,
		&i.IsSecret,
		&i.IsPublic,
		&i.AllowedValues,
		&i.MinValue,
		&i.MaxValue,
		&i.Pattern,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const upsertServerSetting = `-- name: UpsertServerSetting :one
INSERT INTO shared.server_settings (
    key,
    value,
    description,
    category,
    data_type,
    is_secret,
    is_public,
    updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
ON CONFLICT (key) DO UPDATE
SET
    value = EXCLUDED.value,
    updated_at = NOW(),
    updated_by = EXCLUDED.updated_by
RETURNING key, value, description, category, data_type, is_secret, is_public, allowed_values, min_value, max_value, pattern, created_at, updated_at, updated_by
`

type UpsertServerSettingParams struct {
	Key         string          `json:"key"`
	Value       json.RawMessage `json:"value"`
	Description *string         `json:"description"`
	Category    *string         `json:"category"`
	DataType    string          `json:"dataType"`
	IsSecret    *bool           `json:"isSecret"`
	IsPublic    *bool           `json:"isPublic"`
	UpdatedBy   pgtype.UUID     `json:"updatedBy"`
}

// Insert or update a server setting
func (q *Queries) UpsertServerSetting(ctx context.Context, arg UpsertServerSettingParams) (SharedServerSetting, error) {
	row := q.db.QueryRow(ctx, upsertServerSetting,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.Category,
		arg.DataType,
		arg.IsSecret,
		arg.IsPublic,
		arg.UpdatedBy,
	)
	var i SharedServerSetting
	err := row.Scan(
		&i.Key,
		&i.Value,
		&i.Description,
		&i.Category,
		&i.DataType,
		&i.IsSecret,
		&i.IsPublic,
		&i.AllowedValues,
		&i.MinValue,
		&i.MaxValue,
		&i.Pattern,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}
