// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"encoding/json"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

// Audit log for tracking user actions and system events
type ActivityLog struct {
	ID       uuid.UUID   `json:"id"`
	UserID   pgtype.UUID `json:"userId"`
	Username *string     `json:"username"`
	// Action type: user.login, user.logout, library.create, settings.update, etc.
	Action       string      `json:"action"`
	ResourceType *string     `json:"resourceType"`
	ResourceID   pgtype.UUID `json:"resourceId"`
	// JSON object with field changes: {"field": {"old": "...", "new": "..."}}
	Changes []byte `json:"changes"`
	// Additional context data as JSON
	Metadata     []byte     `json:"metadata"`
	IpAddress    netip.Addr `json:"ipAddress"`
	UserAgent    *string    `json:"userAgent"`
	Success      *bool      `json:"success"`
	ErrorMessage *string    `json:"errorMessage"`
	CreatedAt    time.Time  `json:"createdAt"`
}

// Media libraries organizing content by type and location
type Library struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
	// Library content type: movie, tvshow, music, photo, book, audiobook, comic, podcast, adult
	Type string `json:"type"`
	// Array of file system paths to scan for this library
	Paths              []string `json:"paths"`
	Enabled            bool     `json:"enabled"`
	ScanOnStartup      bool     `json:"scanOnStartup"`
	RealtimeMonitoring bool     `json:"realtimeMonitoring"`
	// Primary metadata provider: tmdb, tvdb, musicbrainz, openlib, etc.
	MetadataProvider  *string `json:"metadataProvider"`
	PreferredLanguage string  `json:"preferredLanguage"`
	// Type-specific scanner configuration as JSONB
	ScannerConfig []byte    `json:"scannerConfig"`
	CreatedAt     time.Time `json:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt"`
}

// Per-user access permissions to libraries
type LibraryPermission struct {
	ID        uuid.UUID `json:"id"`
	LibraryID uuid.UUID `json:"libraryId"`
	UserID    uuid.UUID `json:"userId"`
	// Permission type: view, download, manage
	Permission string    `json:"permission"`
	CreatedAt  time.Time `json:"createdAt"`
}

// Track library scan jobs and their progress
type LibraryScan struct {
	ID        uuid.UUID `json:"id"`
	LibraryID uuid.UUID `json:"libraryId"`
	// Type of scan: full, incremental, metadata
	ScanType string `json:"scanType"`
	// Scan status: pending, running, completed, failed, cancelled
	Status          string             `json:"status"`
	ItemsScanned    int32              `json:"itemsScanned"`
	ItemsAdded      int32              `json:"itemsAdded"`
	ItemsUpdated    int32              `json:"itemsUpdated"`
	ItemsRemoved    int32              `json:"itemsRemoved"`
	ErrorsCount     int32              `json:"errorsCount"`
	ErrorMessage    *string            `json:"errorMessage"`
	StartedAt       pgtype.Timestamptz `json:"startedAt"`
	CompletedAt     pgtype.Timestamptz `json:"completedAt"`
	DurationSeconds *int32             `json:"durationSeconds"`
	CreatedAt       time.Time          `json:"createdAt"`
}

// One-time backup codes for MFA account recovery
type MfaBackupCode struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// Bcrypt hash of the backup code (codes are 16 chars alphanumeric)
	CodeHash string `json:"codeHash"`
	// When this code was used (NULL if unused)
	UsedAt pgtype.Timestamptz `json:"usedAt"`
	// IP address where code was used (for audit trail)
	UsedFromIp netip.Addr `json:"usedFromIp"`
	CreatedAt  time.Time  `json:"createdAt"`
}

// API keys for programmatic access with scope-based permissions
type SharedApiKey struct {
	ID          uuid.UUID `json:"id"`
	UserID      uuid.UUID `json:"userId"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
	// SHA-256 hash of the API key (never store plaintext)
	KeyHash string `json:"keyHash"`
	// First 8 chars for key identification (rv_xxxxxxxx)
	KeyPrefix string `json:"keyPrefix"`
	// Permission scopes: read, write, admin
	Scopes []string `json:"scopes"`
	// Key can be revoked by setting to false
	IsActive  bool               `json:"isActive"`
	ExpiresAt pgtype.Timestamptz `json:"expiresAt"`
	// Timestamp of last successful authentication
	LastUsedAt pgtype.Timestamptz `json:"lastUsedAt"`
	CreatedAt  time.Time          `json:"createdAt"`
	UpdatedAt  time.Time          `json:"updatedAt"`
}

// JWT refresh tokens for persistent user sessions
type SharedAuthToken struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// SHA-256 hash of the refresh token (never store plaintext)
	TokenHash  string  `json:"tokenHash"`
	TokenType  string  `json:"tokenType"`
	DeviceName *string `json:"deviceName"`
	// Unique identifier for the device/browser
	DeviceFingerprint *string            `json:"deviceFingerprint"`
	IpAddress         netip.Addr         `json:"ipAddress"`
	UserAgent         *string            `json:"userAgent"`
	ExpiresAt         time.Time          `json:"expiresAt"`
	RevokedAt         pgtype.Timestamptz `json:"revokedAt"`
	// Timestamp when token was last used for refresh
	LastUsedAt pgtype.Timestamptz `json:"lastUsedAt"`
	CreatedAt  time.Time          `json:"createdAt"`
	UpdatedAt  time.Time          `json:"updatedAt"`
}

// Default policies created. First user should be assigned admin role manually.
type SharedCasbinRule struct {
	ID int32 `json:"id"`
	// Policy type: p (policy) or g (role)
	Ptype string `json:"ptype"`
	// Subject (user/role)
	V0 *string `json:"v0"`
	// Object (resource)
	V1 *string `json:"v1"`
	// Action (read/write/delete)
	V2 *string `json:"v2"`
	V3 *string `json:"v3"`
	V4 *string `json:"v4"`
	V5 *string `json:"v5"`
}

// One-time tokens for email verification and email change flow
type SharedEmailVerificationToken struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// SHA-256 hash of the verification token (never store plaintext)
	TokenHash string `json:"tokenHash"`
	// Email address being verified (may differ from user.email during change)
	Email     string     `json:"email"`
	IpAddress netip.Addr `json:"ipAddress"`
	UserAgent *string    `json:"userAgent"`
	ExpiresAt time.Time  `json:"expiresAt"`
	// Timestamp when token was used (prevents reuse)
	VerifiedAt pgtype.Timestamptz `json:"verifiedAt"`
	CreatedAt  time.Time          `json:"createdAt"`
}

type SharedOidcProvider struct {
	ID                    uuid.UUID       `json:"id"`
	Name                  string          `json:"name"`
	DisplayName           string          `json:"displayName"`
	ProviderType          string          `json:"providerType"`
	IssuerUrl             string          `json:"issuerUrl"`
	ClientID              string          `json:"clientId"`
	ClientSecretEncrypted []byte          `json:"clientSecretEncrypted"`
	AuthorizationEndpoint *string         `json:"authorizationEndpoint"`
	TokenEndpoint         *string         `json:"tokenEndpoint"`
	UserinfoEndpoint      *string         `json:"userinfoEndpoint"`
	JwksUri               *string         `json:"jwksUri"`
	EndSessionEndpoint    *string         `json:"endSessionEndpoint"`
	Scopes                []string        `json:"scopes"`
	ClaimMappings         json.RawMessage `json:"claimMappings"`
	RoleMappings          json.RawMessage `json:"roleMappings"`
	AutoCreateUsers       bool            `json:"autoCreateUsers"`
	UpdateUserInfo        bool            `json:"updateUserInfo"`
	AllowLinking          bool            `json:"allowLinking"`
	IsEnabled             bool            `json:"isEnabled"`
	IsDefault             bool            `json:"isDefault"`
	CreatedAt             time.Time       `json:"createdAt"`
	UpdatedAt             time.Time       `json:"updatedAt"`
}

type SharedOidcState struct {
	ID           uuid.UUID   `json:"id"`
	State        string      `json:"state"`
	CodeVerifier *string     `json:"codeVerifier"`
	ProviderID   uuid.UUID   `json:"providerId"`
	UserID       pgtype.UUID `json:"userId"`
	RedirectUrl  *string     `json:"redirectUrl"`
	ExpiresAt    time.Time   `json:"expiresAt"`
	CreatedAt    time.Time   `json:"createdAt"`
}

type SharedOidcUserLink struct {
	ID                    uuid.UUID          `json:"id"`
	UserID                uuid.UUID          `json:"userId"`
	ProviderID            uuid.UUID          `json:"providerId"`
	Subject               string             `json:"subject"`
	Email                 *string            `json:"email"`
	Name                  *string            `json:"name"`
	PictureUrl            *string            `json:"pictureUrl"`
	AccessTokenEncrypted  []byte             `json:"accessTokenEncrypted"`
	RefreshTokenEncrypted []byte             `json:"refreshTokenEncrypted"`
	TokenExpiresAt        pgtype.Timestamptz `json:"tokenExpiresAt"`
	LastLoginAt           pgtype.Timestamptz `json:"lastLoginAt"`
	CreatedAt             time.Time          `json:"createdAt"`
	UpdatedAt             time.Time          `json:"updatedAt"`
}

// One-time tokens for password reset flow
type SharedPasswordResetToken struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// SHA-256 hash of the reset token (never store plaintext)
	TokenHash string     `json:"tokenHash"`
	IpAddress netip.Addr `json:"ipAddress"`
	UserAgent *string    `json:"userAgent"`
	ExpiresAt time.Time  `json:"expiresAt"`
	// Timestamp when token was used (prevents reuse)
	UsedAt    pgtype.Timestamptz `json:"usedAt"`
	CreatedAt time.Time          `json:"createdAt"`
}

// Server-wide configuration settings with validation
type SharedServerSetting struct {
	Key string `json:"key"`
	// Setting value stored as JSONB for type flexibility
	Value       json.RawMessage `json:"value"`
	Description *string         `json:"description"`
	Category    *string         `json:"category"`
	// Expected data type for validation
	DataType string `json:"dataType"`
	// Indicates sensitive values that should be encrypted
	IsSecret *bool `json:"isSecret"`
	// Settings exposed via public API (e.g., server name)
	IsPublic      *bool          `json:"isPublic"`
	AllowedValues []byte         `json:"allowedValues"`
	MinValue      pgtype.Numeric `json:"minValue"`
	MaxValue      pgtype.Numeric `json:"maxValue"`
	Pattern       *string        `json:"pattern"`
	CreatedAt     time.Time      `json:"createdAt"`
	UpdatedAt     time.Time      `json:"updatedAt"`
	UpdatedBy     pgtype.UUID    `json:"updatedBy"`
}

// User sessions with JWT token management
type SharedSession struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// SHA256 hash of JWT access token for validation
	TokenHash string `json:"tokenHash"`
	// SHA256 hash of refresh token for token rotation
	RefreshTokenHash *string    `json:"refreshTokenHash"`
	IpAddress        netip.Addr `json:"ipAddress"`
	UserAgent        *string    `json:"userAgent"`
	DeviceName       *string    `json:"deviceName"`
	// OAuth2-style scopes (e.g., legacy:read for QAR access)
	Scopes         []string           `json:"scopes"`
	ExpiresAt      time.Time          `json:"expiresAt"`
	LastActivityAt time.Time          `json:"lastActivityAt"`
	CreatedAt      time.Time          `json:"createdAt"`
	RevokedAt      pgtype.Timestamptz `json:"revokedAt"`
	RevokeReason   *string            `json:"revokeReason"`
	// Whether this session has passed MFA verification
	MfaVerified bool `json:"mfaVerified"`
	// Timestamp when MFA was verified for this session
	MfaVerifiedAt pgtype.Timestamptz `json:"mfaVerifiedAt"`
}

// User accounts with authentication and profile information
type SharedUser struct {
	ID       uuid.UUID `json:"id"`
	Username string    `json:"username"`
	Email    string    `json:"email"`
	// Argon2id password hash
	PasswordHash string  `json:"passwordHash"`
	DisplayName  *string `json:"displayName"`
	AvatarUrl    *string `json:"avatarUrl"`
	Locale       *string `json:"locale"`
	Timezone     *string `json:"timezone"`
	// Grants legacy:read scope for QAR (adult content) access
	QarEnabled      *bool              `json:"qarEnabled"`
	IsActive        *bool              `json:"isActive"`
	IsAdmin         *bool              `json:"isAdmin"`
	EmailVerified   *bool              `json:"emailVerified"`
	EmailVerifiedAt pgtype.Timestamptz `json:"emailVerifiedAt"`
	CreatedAt       time.Time          `json:"createdAt"`
	UpdatedAt       time.Time          `json:"updatedAt"`
	LastLoginAt     pgtype.Timestamptz `json:"lastLoginAt"`
	DeletedAt       pgtype.Timestamptz `json:"deletedAt"`
}

// User avatar storage with versioning and metadata
type SharedUserAvatar struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// Storage path relative to upload directory
	FilePath      string `json:"filePath"`
	FileSizeBytes int64  `json:"fileSizeBytes"`
	MimeType      string `json:"mimeType"`
	Width         int32  `json:"width"`
	Height        int32  `json:"height"`
	IsAnimated    *bool  `json:"isAnimated"`
	// Avatar version number (incremented on each upload)
	Version int32 `json:"version"`
	// Whether this is the currently active avatar
	IsCurrent             *bool              `json:"isCurrent"`
	UploadedAt            time.Time          `json:"uploadedAt"`
	UploadedFromIp        netip.Addr         `json:"uploadedFromIp"`
	UploadedFromUserAgent *string            `json:"uploadedFromUserAgent"`
	CreatedAt             time.Time          `json:"createdAt"`
	UpdatedAt             time.Time          `json:"updatedAt"`
	DeletedAt             pgtype.Timestamptz `json:"deletedAt"`
}

// User preferences for notifications, privacy, and display settings
type SharedUserPreference struct {
	UserID uuid.UUID `json:"userId"`
	// Email notification settings (enabled, frequency, types)
	EmailNotifications []byte `json:"emailNotifications"`
	// Push notification settings (enabled, device tokens)
	PushNotifications []byte `json:"pushNotifications"`
	// Digest notification settings (enabled, frequency)
	DigestNotifications []byte `json:"digestNotifications"`
	// Who can view the user profile (public, friends, private)
	ProfileVisibility *string   `json:"profileVisibility"`
	ShowEmail         *bool     `json:"showEmail"`
	ShowActivity      *bool     `json:"showActivity"`
	Theme             *string   `json:"theme"`
	DisplayLanguage   *string   `json:"displayLanguage"`
	ContentLanguage   *string   `json:"contentLanguage"`
	ShowAdultContent  *bool     `json:"showAdultContent"`
	ShowSpoilers      *bool     `json:"showSpoilers"`
	AutoPlayVideos    *bool     `json:"autoPlayVideos"`
	CreatedAt         time.Time `json:"createdAt"`
	UpdatedAt         time.Time `json:"updatedAt"`
}

// User-specific configuration settings
type SharedUserSetting struct {
	UserID uuid.UUID `json:"userId"`
	Key    string    `json:"key"`
	// Setting value stored as JSONB for type flexibility
	Value       json.RawMessage `json:"value"`
	Description *string         `json:"description"`
	// Setting category for organization
	Category *string `json:"category"`
	// Expected data type for validation
	DataType  string    `json:"dataType"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// Per-user MFA configuration and enforcement settings
type UserMfaSetting struct {
	UserID uuid.UUID `json:"userId"`
	// Whether TOTP (authenticator app) is enabled for this user
	TotpEnabled bool `json:"totpEnabled"`
	// Whether WebAuthn (passkeys/security keys) is enabled for this user
	WebauthnEnabled bool `json:"webauthnEnabled"`
	// Whether backup recovery codes have been generated
	BackupCodesGenerated bool `json:"backupCodesGenerated"`
	// Admin override to force MFA for this user
	RequireMfa                 bool  `json:"requireMfa"`
	RememberDeviceEnabled      bool  `json:"rememberDeviceEnabled"`
	RememberDeviceDurationDays int32 `json:"rememberDeviceDurationDays"`
	// JSON array of device fingerprints that skip MFA challenge
	TrustedDevices json.RawMessage `json:"trustedDevices"`
	CreatedAt      time.Time       `json:"createdAt"`
	UpdatedAt      time.Time       `json:"updatedAt"`
}

// TOTP (Time-based One-Time Password) secrets for multi-factor authentication
type UserTotpSecret struct {
	UserID uuid.UUID `json:"userId"`
	// AES-256-GCM encrypted base32-encoded TOTP secret
	EncryptedSecret []byte `json:"encryptedSecret"`
	// GCM nonce used for encryption (12 bytes)
	Nonce []byte `json:"nonce"`
	// When the TOTP was first successfully verified (enrollment completion)
	VerifiedAt pgtype.Timestamptz `json:"verifiedAt"`
	Enabled    bool               `json:"enabled"`
	LastUsedAt pgtype.Timestamptz `json:"lastUsedAt"`
	CreatedAt  time.Time          `json:"createdAt"`
	UpdatedAt  time.Time          `json:"updatedAt"`
}

// WebAuthn/FIDO2 credentials for passwordless and multi-factor authentication
type WebauthnCredential struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
	// Unique credential identifier from the authenticator
	CredentialID []byte `json:"credentialId"`
	// COSE-encoded public key for verifying assertions
	PublicKey []byte `json:"publicKey"`
	// Signature counter for detecting cloned authenticators (must increment)
	SignCount int32 `json:"signCount"`
	// Flag indicating potential authenticator cloning (counter decreased)
	CloneDetected bool `json:"cloneDetected"`
	// Authenticator Attestation GUID (identifies authenticator model)
	Aaguid          []byte `json:"aaguid"`
	AttestationType string `json:"attestationType"`
	// Communication methods supported by authenticator
	Transports     []string           `json:"transports"`
	BackupEligible bool               `json:"backupEligible"`
	BackupState    bool               `json:"backupState"`
	UserPresent    bool               `json:"userPresent"`
	UserVerified   bool               `json:"userVerified"`
	Name           *string            `json:"name"`
	CreatedAt      time.Time          `json:"createdAt"`
	LastUsedAt     pgtype.Timestamptz `json:"lastUsedAt"`
}
