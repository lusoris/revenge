// Code generated by mockery v2.53.5. DO NOT EDIT.

package library_test

import (
	context "context"
	time "time"

	uuid "github.com/google/uuid"
	library "github.com/lusoris/revenge/internal/service/library"
	mock "github.com/stretchr/testify/mock"
)

// MockLibraryRepository is an autogenerated mock type for the Repository type
type MockLibraryRepository struct {
	mock.Mock
}

type MockLibraryRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLibraryRepository) EXPECT() *MockLibraryRepository_Expecter {
	return &MockLibraryRepository_Expecter{mock: &_m.Mock}
}

// CheckPermission provides a mock function with given fields: ctx, libraryID, userID, permission
func (_m *MockLibraryRepository) CheckPermission(ctx context.Context, libraryID uuid.UUID, userID uuid.UUID, permission string) (bool, error) {
	ret := _m.Called(ctx, libraryID, userID, permission)

	if len(ret) == 0 {
		panic("no return value specified for CheckPermission")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string) (bool, error)); ok {
		return rf(ctx, libraryID, userID, permission)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string) bool); ok {
		r0 = rf(ctx, libraryID, userID, permission)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string) error); ok {
		r1 = rf(ctx, libraryID, userID, permission)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_CheckPermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPermission'
type MockLibraryRepository_CheckPermission_Call struct {
	*mock.Call
}

// CheckPermission is a helper method to define mock.On call
//   - ctx context.Context
//   - libraryID uuid.UUID
//   - userID uuid.UUID
//   - permission string
func (_e *MockLibraryRepository_Expecter) CheckPermission(ctx interface{}, libraryID interface{}, userID interface{}, permission interface{}) *MockLibraryRepository_CheckPermission_Call {
	return &MockLibraryRepository_CheckPermission_Call{Call: _e.mock.On("CheckPermission", ctx, libraryID, userID, permission)}
}

func (_c *MockLibraryRepository_CheckPermission_Call) Run(run func(ctx context.Context, libraryID uuid.UUID, userID uuid.UUID, permission string)) *MockLibraryRepository_CheckPermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string))
	})
	return _c
}

func (_c *MockLibraryRepository_CheckPermission_Call) Return(_a0 bool, _a1 error) *MockLibraryRepository_CheckPermission_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_CheckPermission_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string) (bool, error)) *MockLibraryRepository_CheckPermission_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function with given fields: ctx
func (_m *MockLibraryRepository) Count(ctx context.Context) (int64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockLibraryRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLibraryRepository_Expecter) Count(ctx interface{}) *MockLibraryRepository_Count_Call {
	return &MockLibraryRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockLibraryRepository_Count_Call) Run(run func(ctx context.Context)) *MockLibraryRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLibraryRepository_Count_Call) Return(_a0 int64, _a1 error) *MockLibraryRepository_Count_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_Count_Call) RunAndReturn(run func(context.Context) (int64, error)) *MockLibraryRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// CountByType provides a mock function with given fields: ctx, libType
func (_m *MockLibraryRepository) CountByType(ctx context.Context, libType string) (int64, error) {
	ret := _m.Called(ctx, libType)

	if len(ret) == 0 {
		panic("no return value specified for CountByType")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return rf(ctx, libType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, libType)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, libType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_CountByType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByType'
type MockLibraryRepository_CountByType_Call struct {
	*mock.Call
}

// CountByType is a helper method to define mock.On call
//   - ctx context.Context
//   - libType string
func (_e *MockLibraryRepository_Expecter) CountByType(ctx interface{}, libType interface{}) *MockLibraryRepository_CountByType_Call {
	return &MockLibraryRepository_CountByType_Call{Call: _e.mock.On("CountByType", ctx, libType)}
}

func (_c *MockLibraryRepository_CountByType_Call) Run(run func(ctx context.Context, libType string)) *MockLibraryRepository_CountByType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLibraryRepository_CountByType_Call) Return(_a0 int64, _a1 error) *MockLibraryRepository_CountByType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_CountByType_Call) RunAndReturn(run func(context.Context, string) (int64, error)) *MockLibraryRepository_CountByType_Call {
	_c.Call.Return(run)
	return _c
}

// CountPermissions provides a mock function with given fields: ctx, libraryID
func (_m *MockLibraryRepository) CountPermissions(ctx context.Context, libraryID uuid.UUID) (int64, error) {
	ret := _m.Called(ctx, libraryID)

	if len(ret) == 0 {
		panic("no return value specified for CountPermissions")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (int64, error)); ok {
		return rf(ctx, libraryID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) int64); ok {
		r0 = rf(ctx, libraryID)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, libraryID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_CountPermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountPermissions'
type MockLibraryRepository_CountPermissions_Call struct {
	*mock.Call
}

// CountPermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - libraryID uuid.UUID
func (_e *MockLibraryRepository_Expecter) CountPermissions(ctx interface{}, libraryID interface{}) *MockLibraryRepository_CountPermissions_Call {
	return &MockLibraryRepository_CountPermissions_Call{Call: _e.mock.On("CountPermissions", ctx, libraryID)}
}

func (_c *MockLibraryRepository_CountPermissions_Call) Run(run func(ctx context.Context, libraryID uuid.UUID)) *MockLibraryRepository_CountPermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockLibraryRepository_CountPermissions_Call) Return(_a0 int64, _a1 error) *MockLibraryRepository_CountPermissions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_CountPermissions_Call) RunAndReturn(run func(context.Context, uuid.UUID) (int64, error)) *MockLibraryRepository_CountPermissions_Call {
	_c.Call.Return(run)
	return _c
}

// CountScans provides a mock function with given fields: ctx, libraryID
func (_m *MockLibraryRepository) CountScans(ctx context.Context, libraryID uuid.UUID) (int64, error) {
	ret := _m.Called(ctx, libraryID)

	if len(ret) == 0 {
		panic("no return value specified for CountScans")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (int64, error)); ok {
		return rf(ctx, libraryID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) int64); ok {
		r0 = rf(ctx, libraryID)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, libraryID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_CountScans_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountScans'
type MockLibraryRepository_CountScans_Call struct {
	*mock.Call
}

// CountScans is a helper method to define mock.On call
//   - ctx context.Context
//   - libraryID uuid.UUID
func (_e *MockLibraryRepository_Expecter) CountScans(ctx interface{}, libraryID interface{}) *MockLibraryRepository_CountScans_Call {
	return &MockLibraryRepository_CountScans_Call{Call: _e.mock.On("CountScans", ctx, libraryID)}
}

func (_c *MockLibraryRepository_CountScans_Call) Run(run func(ctx context.Context, libraryID uuid.UUID)) *MockLibraryRepository_CountScans_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockLibraryRepository_CountScans_Call) Return(_a0 int64, _a1 error) *MockLibraryRepository_CountScans_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_CountScans_Call) RunAndReturn(run func(context.Context, uuid.UUID) (int64, error)) *MockLibraryRepository_CountScans_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: ctx, lib
func (_m *MockLibraryRepository) Create(ctx context.Context, lib *library.Library) error {
	ret := _m.Called(ctx, lib)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *library.Library) error); ok {
		r0 = rf(ctx, lib)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLibraryRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockLibraryRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - lib *library.Library
func (_e *MockLibraryRepository_Expecter) Create(ctx interface{}, lib interface{}) *MockLibraryRepository_Create_Call {
	return &MockLibraryRepository_Create_Call{Call: _e.mock.On("Create", ctx, lib)}
}

func (_c *MockLibraryRepository_Create_Call) Run(run func(ctx context.Context, lib *library.Library)) *MockLibraryRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*library.Library))
	})
	return _c
}

func (_c *MockLibraryRepository_Create_Call) Return(_a0 error) *MockLibraryRepository_Create_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLibraryRepository_Create_Call) RunAndReturn(run func(context.Context, *library.Library) error) *MockLibraryRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateScan provides a mock function with given fields: ctx, scan
func (_m *MockLibraryRepository) CreateScan(ctx context.Context, scan *library.LibraryScan) error {
	ret := _m.Called(ctx, scan)

	if len(ret) == 0 {
		panic("no return value specified for CreateScan")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *library.LibraryScan) error); ok {
		r0 = rf(ctx, scan)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLibraryRepository_CreateScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateScan'
type MockLibraryRepository_CreateScan_Call struct {
	*mock.Call
}

// CreateScan is a helper method to define mock.On call
//   - ctx context.Context
//   - scan *library.LibraryScan
func (_e *MockLibraryRepository_Expecter) CreateScan(ctx interface{}, scan interface{}) *MockLibraryRepository_CreateScan_Call {
	return &MockLibraryRepository_CreateScan_Call{Call: _e.mock.On("CreateScan", ctx, scan)}
}

func (_c *MockLibraryRepository_CreateScan_Call) Run(run func(ctx context.Context, scan *library.LibraryScan)) *MockLibraryRepository_CreateScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*library.LibraryScan))
	})
	return _c
}

func (_c *MockLibraryRepository_CreateScan_Call) Return(_a0 error) *MockLibraryRepository_CreateScan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLibraryRepository_CreateScan_Call) RunAndReturn(run func(context.Context, *library.LibraryScan) error) *MockLibraryRepository_CreateScan_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, id
func (_m *MockLibraryRepository) Delete(ctx context.Context, id uuid.UUID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLibraryRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockLibraryRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockLibraryRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockLibraryRepository_Delete_Call {
	return &MockLibraryRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockLibraryRepository_Delete_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockLibraryRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockLibraryRepository_Delete_Call) Return(_a0 error) *MockLibraryRepository_Delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLibraryRepository_Delete_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockLibraryRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteOldScans provides a mock function with given fields: ctx, olderThan
func (_m *MockLibraryRepository) DeleteOldScans(ctx context.Context, olderThan time.Time) (int64, error) {
	ret := _m.Called(ctx, olderThan)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOldScans")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Time) (int64, error)); ok {
		return rf(ctx, olderThan)
	}
	if rf, ok := ret.Get(0).(func(context.Context, time.Time) int64); ok {
		r0 = rf(ctx, olderThan)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, time.Time) error); ok {
		r1 = rf(ctx, olderThan)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_DeleteOldScans_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteOldScans'
type MockLibraryRepository_DeleteOldScans_Call struct {
	*mock.Call
}

// DeleteOldScans is a helper method to define mock.On call
//   - ctx context.Context
//   - olderThan time.Time
func (_e *MockLibraryRepository_Expecter) DeleteOldScans(ctx interface{}, olderThan interface{}) *MockLibraryRepository_DeleteOldScans_Call {
	return &MockLibraryRepository_DeleteOldScans_Call{Call: _e.mock.On("DeleteOldScans", ctx, olderThan)}
}

func (_c *MockLibraryRepository_DeleteOldScans_Call) Run(run func(ctx context.Context, olderThan time.Time)) *MockLibraryRepository_DeleteOldScans_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Time))
	})
	return _c
}

func (_c *MockLibraryRepository_DeleteOldScans_Call) Return(_a0 int64, _a1 error) *MockLibraryRepository_DeleteOldScans_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_DeleteOldScans_Call) RunAndReturn(run func(context.Context, time.Time) (int64, error)) *MockLibraryRepository_DeleteOldScans_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: ctx, id
func (_m *MockLibraryRepository) Get(ctx context.Context, id uuid.UUID) (*library.Library, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *library.Library
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*library.Library, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *library.Library); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*library.Library)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockLibraryRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockLibraryRepository_Expecter) Get(ctx interface{}, id interface{}) *MockLibraryRepository_Get_Call {
	return &MockLibraryRepository_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockLibraryRepository_Get_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockLibraryRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockLibraryRepository_Get_Call) Return(_a0 *library.Library, _a1 error) *MockLibraryRepository_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_Get_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*library.Library, error)) *MockLibraryRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetByName provides a mock function with given fields: ctx, name
func (_m *MockLibraryRepository) GetByName(ctx context.Context, name string) (*library.Library, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetByName")
	}

	var r0 *library.Library
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*library.Library, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *library.Library); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*library.Library)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_GetByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByName'
type MockLibraryRepository_GetByName_Call struct {
	*mock.Call
}

// GetByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockLibraryRepository_Expecter) GetByName(ctx interface{}, name interface{}) *MockLibraryRepository_GetByName_Call {
	return &MockLibraryRepository_GetByName_Call{Call: _e.mock.On("GetByName", ctx, name)}
}

func (_c *MockLibraryRepository_GetByName_Call) Run(run func(ctx context.Context, name string)) *MockLibraryRepository_GetByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLibraryRepository_GetByName_Call) Return(_a0 *library.Library, _a1 error) *MockLibraryRepository_GetByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_GetByName_Call) RunAndReturn(run func(context.Context, string) (*library.Library, error)) *MockLibraryRepository_GetByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestScan provides a mock function with given fields: ctx, libraryID
func (_m *MockLibraryRepository) GetLatestScan(ctx context.Context, libraryID uuid.UUID) (*library.LibraryScan, error) {
	ret := _m.Called(ctx, libraryID)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestScan")
	}

	var r0 *library.LibraryScan
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*library.LibraryScan, error)); ok {
		return rf(ctx, libraryID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *library.LibraryScan); ok {
		r0 = rf(ctx, libraryID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*library.LibraryScan)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, libraryID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_GetLatestScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestScan'
type MockLibraryRepository_GetLatestScan_Call struct {
	*mock.Call
}

// GetLatestScan is a helper method to define mock.On call
//   - ctx context.Context
//   - libraryID uuid.UUID
func (_e *MockLibraryRepository_Expecter) GetLatestScan(ctx interface{}, libraryID interface{}) *MockLibraryRepository_GetLatestScan_Call {
	return &MockLibraryRepository_GetLatestScan_Call{Call: _e.mock.On("GetLatestScan", ctx, libraryID)}
}

func (_c *MockLibraryRepository_GetLatestScan_Call) Run(run func(ctx context.Context, libraryID uuid.UUID)) *MockLibraryRepository_GetLatestScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockLibraryRepository_GetLatestScan_Call) Return(_a0 *library.LibraryScan, _a1 error) *MockLibraryRepository_GetLatestScan_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_GetLatestScan_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*library.LibraryScan, error)) *MockLibraryRepository_GetLatestScan_Call {
	_c.Call.Return(run)
	return _c
}

// GetPermission provides a mock function with given fields: ctx, libraryID, userID, permission
func (_m *MockLibraryRepository) GetPermission(ctx context.Context, libraryID uuid.UUID, userID uuid.UUID, permission string) (*library.Permission, error) {
	ret := _m.Called(ctx, libraryID, userID, permission)

	if len(ret) == 0 {
		panic("no return value specified for GetPermission")
	}

	var r0 *library.Permission
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string) (*library.Permission, error)); ok {
		return rf(ctx, libraryID, userID, permission)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string) *library.Permission); ok {
		r0 = rf(ctx, libraryID, userID, permission)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*library.Permission)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, string) error); ok {
		r1 = rf(ctx, libraryID, userID, permission)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_GetPermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPermission'
type MockLibraryRepository_GetPermission_Call struct {
	*mock.Call
}

// GetPermission is a helper method to define mock.On call
//   - ctx context.Context
//   - libraryID uuid.UUID
//   - userID uuid.UUID
//   - permission string
func (_e *MockLibraryRepository_Expecter) GetPermission(ctx interface{}, libraryID interface{}, userID interface{}, permission interface{}) *MockLibraryRepository_GetPermission_Call {
	return &MockLibraryRepository_GetPermission_Call{Call: _e.mock.On("GetPermission", ctx, libraryID, userID, permission)}
}

func (_c *MockLibraryRepository_GetPermission_Call) Run(run func(ctx context.Context, libraryID uuid.UUID, userID uuid.UUID, permission string)) *MockLibraryRepository_GetPermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string))
	})
	return _c
}

func (_c *MockLibraryRepository_GetPermission_Call) Return(_a0 *library.Permission, _a1 error) *MockLibraryRepository_GetPermission_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_GetPermission_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string) (*library.Permission, error)) *MockLibraryRepository_GetPermission_Call {
	_c.Call.Return(run)
	return _c
}

// GetRunningScans provides a mock function with given fields: ctx
func (_m *MockLibraryRepository) GetRunningScans(ctx context.Context) ([]library.LibraryScan, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetRunningScans")
	}

	var r0 []library.LibraryScan
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]library.LibraryScan, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []library.LibraryScan); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]library.LibraryScan)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_GetRunningScans_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRunningScans'
type MockLibraryRepository_GetRunningScans_Call struct {
	*mock.Call
}

// GetRunningScans is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLibraryRepository_Expecter) GetRunningScans(ctx interface{}) *MockLibraryRepository_GetRunningScans_Call {
	return &MockLibraryRepository_GetRunningScans_Call{Call: _e.mock.On("GetRunningScans", ctx)}
}

func (_c *MockLibraryRepository_GetRunningScans_Call) Run(run func(ctx context.Context)) *MockLibraryRepository_GetRunningScans_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLibraryRepository_GetRunningScans_Call) Return(_a0 []library.LibraryScan, _a1 error) *MockLibraryRepository_GetRunningScans_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_GetRunningScans_Call) RunAndReturn(run func(context.Context) ([]library.LibraryScan, error)) *MockLibraryRepository_GetRunningScans_Call {
	_c.Call.Return(run)
	return _c
}

// GetScan provides a mock function with given fields: ctx, id
func (_m *MockLibraryRepository) GetScan(ctx context.Context, id uuid.UUID) (*library.LibraryScan, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetScan")
	}

	var r0 *library.LibraryScan
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*library.LibraryScan, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *library.LibraryScan); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*library.LibraryScan)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_GetScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetScan'
type MockLibraryRepository_GetScan_Call struct {
	*mock.Call
}

// GetScan is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockLibraryRepository_Expecter) GetScan(ctx interface{}, id interface{}) *MockLibraryRepository_GetScan_Call {
	return &MockLibraryRepository_GetScan_Call{Call: _e.mock.On("GetScan", ctx, id)}
}

func (_c *MockLibraryRepository_GetScan_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockLibraryRepository_GetScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockLibraryRepository_GetScan_Call) Return(_a0 *library.LibraryScan, _a1 error) *MockLibraryRepository_GetScan_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_GetScan_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*library.LibraryScan, error)) *MockLibraryRepository_GetScan_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserAccessibleLibraries provides a mock function with given fields: ctx, userID
func (_m *MockLibraryRepository) GetUserAccessibleLibraries(ctx context.Context, userID uuid.UUID) ([]library.Library, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccessibleLibraries")
	}

	var r0 []library.Library
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]library.Library, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) []library.Library); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]library.Library)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_GetUserAccessibleLibraries_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserAccessibleLibraries'
type MockLibraryRepository_GetUserAccessibleLibraries_Call struct {
	*mock.Call
}

// GetUserAccessibleLibraries is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
func (_e *MockLibraryRepository_Expecter) GetUserAccessibleLibraries(ctx interface{}, userID interface{}) *MockLibraryRepository_GetUserAccessibleLibraries_Call {
	return &MockLibraryRepository_GetUserAccessibleLibraries_Call{Call: _e.mock.On("GetUserAccessibleLibraries", ctx, userID)}
}

func (_c *MockLibraryRepository_GetUserAccessibleLibraries_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockLibraryRepository_GetUserAccessibleLibraries_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockLibraryRepository_GetUserAccessibleLibraries_Call) Return(_a0 []library.Library, _a1 error) *MockLibraryRepository_GetUserAccessibleLibraries_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_GetUserAccessibleLibraries_Call) RunAndReturn(run func(context.Context, uuid.UUID) ([]library.Library, error)) *MockLibraryRepository_GetUserAccessibleLibraries_Call {
	_c.Call.Return(run)
	return _c
}

// GrantPermission provides a mock function with given fields: ctx, perm
func (_m *MockLibraryRepository) GrantPermission(ctx context.Context, perm *library.Permission) error {
	ret := _m.Called(ctx, perm)

	if len(ret) == 0 {
		panic("no return value specified for GrantPermission")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *library.Permission) error); ok {
		r0 = rf(ctx, perm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLibraryRepository_GrantPermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GrantPermission'
type MockLibraryRepository_GrantPermission_Call struct {
	*mock.Call
}

// GrantPermission is a helper method to define mock.On call
//   - ctx context.Context
//   - perm *library.Permission
func (_e *MockLibraryRepository_Expecter) GrantPermission(ctx interface{}, perm interface{}) *MockLibraryRepository_GrantPermission_Call {
	return &MockLibraryRepository_GrantPermission_Call{Call: _e.mock.On("GrantPermission", ctx, perm)}
}

func (_c *MockLibraryRepository_GrantPermission_Call) Run(run func(ctx context.Context, perm *library.Permission)) *MockLibraryRepository_GrantPermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*library.Permission))
	})
	return _c
}

func (_c *MockLibraryRepository_GrantPermission_Call) Return(_a0 error) *MockLibraryRepository_GrantPermission_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLibraryRepository_GrantPermission_Call) RunAndReturn(run func(context.Context, *library.Permission) error) *MockLibraryRepository_GrantPermission_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function with given fields: ctx
func (_m *MockLibraryRepository) List(ctx context.Context) ([]library.Library, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []library.Library
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]library.Library, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []library.Library); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]library.Library)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockLibraryRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLibraryRepository_Expecter) List(ctx interface{}) *MockLibraryRepository_List_Call {
	return &MockLibraryRepository_List_Call{Call: _e.mock.On("List", ctx)}
}

func (_c *MockLibraryRepository_List_Call) Run(run func(ctx context.Context)) *MockLibraryRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLibraryRepository_List_Call) Return(_a0 []library.Library, _a1 error) *MockLibraryRepository_List_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_List_Call) RunAndReturn(run func(context.Context) ([]library.Library, error)) *MockLibraryRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// ListByType provides a mock function with given fields: ctx, libType
func (_m *MockLibraryRepository) ListByType(ctx context.Context, libType string) ([]library.Library, error) {
	ret := _m.Called(ctx, libType)

	if len(ret) == 0 {
		panic("no return value specified for ListByType")
	}

	var r0 []library.Library
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]library.Library, error)); ok {
		return rf(ctx, libType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []library.Library); ok {
		r0 = rf(ctx, libType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]library.Library)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, libType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_ListByType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListByType'
type MockLibraryRepository_ListByType_Call struct {
	*mock.Call
}

// ListByType is a helper method to define mock.On call
//   - ctx context.Context
//   - libType string
func (_e *MockLibraryRepository_Expecter) ListByType(ctx interface{}, libType interface{}) *MockLibraryRepository_ListByType_Call {
	return &MockLibraryRepository_ListByType_Call{Call: _e.mock.On("ListByType", ctx, libType)}
}

func (_c *MockLibraryRepository_ListByType_Call) Run(run func(ctx context.Context, libType string)) *MockLibraryRepository_ListByType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLibraryRepository_ListByType_Call) Return(_a0 []library.Library, _a1 error) *MockLibraryRepository_ListByType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_ListByType_Call) RunAndReturn(run func(context.Context, string) ([]library.Library, error)) *MockLibraryRepository_ListByType_Call {
	_c.Call.Return(run)
	return _c
}

// ListEnabled provides a mock function with given fields: ctx
func (_m *MockLibraryRepository) ListEnabled(ctx context.Context) ([]library.Library, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListEnabled")
	}

	var r0 []library.Library
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]library.Library, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []library.Library); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]library.Library)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_ListEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEnabled'
type MockLibraryRepository_ListEnabled_Call struct {
	*mock.Call
}

// ListEnabled is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLibraryRepository_Expecter) ListEnabled(ctx interface{}) *MockLibraryRepository_ListEnabled_Call {
	return &MockLibraryRepository_ListEnabled_Call{Call: _e.mock.On("ListEnabled", ctx)}
}

func (_c *MockLibraryRepository_ListEnabled_Call) Run(run func(ctx context.Context)) *MockLibraryRepository_ListEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLibraryRepository_ListEnabled_Call) Return(_a0 []library.Library, _a1 error) *MockLibraryRepository_ListEnabled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_ListEnabled_Call) RunAndReturn(run func(context.Context) ([]library.Library, error)) *MockLibraryRepository_ListEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// ListPermissions provides a mock function with given fields: ctx, libraryID
func (_m *MockLibraryRepository) ListPermissions(ctx context.Context, libraryID uuid.UUID) ([]library.Permission, error) {
	ret := _m.Called(ctx, libraryID)

	if len(ret) == 0 {
		panic("no return value specified for ListPermissions")
	}

	var r0 []library.Permission
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]library.Permission, error)); ok {
		return rf(ctx, libraryID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) []library.Permission); ok {
		r0 = rf(ctx, libraryID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]library.Permission)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, libraryID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_ListPermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPermissions'
type MockLibraryRepository_ListPermissions_Call struct {
	*mock.Call
}

// ListPermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - libraryID uuid.UUID
func (_e *MockLibraryRepository_Expecter) ListPermissions(ctx interface{}, libraryID interface{}) *MockLibraryRepository_ListPermissions_Call {
	return &MockLibraryRepository_ListPermissions_Call{Call: _e.mock.On("ListPermissions", ctx, libraryID)}
}

func (_c *MockLibraryRepository_ListPermissions_Call) Run(run func(ctx context.Context, libraryID uuid.UUID)) *MockLibraryRepository_ListPermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockLibraryRepository_ListPermissions_Call) Return(_a0 []library.Permission, _a1 error) *MockLibraryRepository_ListPermissions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_ListPermissions_Call) RunAndReturn(run func(context.Context, uuid.UUID) ([]library.Permission, error)) *MockLibraryRepository_ListPermissions_Call {
	_c.Call.Return(run)
	return _c
}

// ListScans provides a mock function with given fields: ctx, libraryID, limit, offset
func (_m *MockLibraryRepository) ListScans(ctx context.Context, libraryID uuid.UUID, limit int32, offset int32) ([]library.LibraryScan, error) {
	ret := _m.Called(ctx, libraryID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListScans")
	}

	var r0 []library.LibraryScan
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int32, int32) ([]library.LibraryScan, error)); ok {
		return rf(ctx, libraryID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int32, int32) []library.LibraryScan); ok {
		r0 = rf(ctx, libraryID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]library.LibraryScan)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, int32, int32) error); ok {
		r1 = rf(ctx, libraryID, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_ListScans_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListScans'
type MockLibraryRepository_ListScans_Call struct {
	*mock.Call
}

// ListScans is a helper method to define mock.On call
//   - ctx context.Context
//   - libraryID uuid.UUID
//   - limit int32
//   - offset int32
func (_e *MockLibraryRepository_Expecter) ListScans(ctx interface{}, libraryID interface{}, limit interface{}, offset interface{}) *MockLibraryRepository_ListScans_Call {
	return &MockLibraryRepository_ListScans_Call{Call: _e.mock.On("ListScans", ctx, libraryID, limit, offset)}
}

func (_c *MockLibraryRepository_ListScans_Call) Run(run func(ctx context.Context, libraryID uuid.UUID, limit int32, offset int32)) *MockLibraryRepository_ListScans_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int32), args[3].(int32))
	})
	return _c
}

func (_c *MockLibraryRepository_ListScans_Call) Return(_a0 []library.LibraryScan, _a1 error) *MockLibraryRepository_ListScans_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_ListScans_Call) RunAndReturn(run func(context.Context, uuid.UUID, int32, int32) ([]library.LibraryScan, error)) *MockLibraryRepository_ListScans_Call {
	_c.Call.Return(run)
	return _c
}

// ListUserPermissions provides a mock function with given fields: ctx, userID
func (_m *MockLibraryRepository) ListUserPermissions(ctx context.Context, userID uuid.UUID) ([]library.Permission, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for ListUserPermissions")
	}

	var r0 []library.Permission
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]library.Permission, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) []library.Permission); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]library.Permission)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_ListUserPermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUserPermissions'
type MockLibraryRepository_ListUserPermissions_Call struct {
	*mock.Call
}

// ListUserPermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
func (_e *MockLibraryRepository_Expecter) ListUserPermissions(ctx interface{}, userID interface{}) *MockLibraryRepository_ListUserPermissions_Call {
	return &MockLibraryRepository_ListUserPermissions_Call{Call: _e.mock.On("ListUserPermissions", ctx, userID)}
}

func (_c *MockLibraryRepository_ListUserPermissions_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockLibraryRepository_ListUserPermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockLibraryRepository_ListUserPermissions_Call) Return(_a0 []library.Permission, _a1 error) *MockLibraryRepository_ListUserPermissions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_ListUserPermissions_Call) RunAndReturn(run func(context.Context, uuid.UUID) ([]library.Permission, error)) *MockLibraryRepository_ListUserPermissions_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeAllPermissions provides a mock function with given fields: ctx, libraryID
func (_m *MockLibraryRepository) RevokeAllPermissions(ctx context.Context, libraryID uuid.UUID) error {
	ret := _m.Called(ctx, libraryID)

	if len(ret) == 0 {
		panic("no return value specified for RevokeAllPermissions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, libraryID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLibraryRepository_RevokeAllPermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeAllPermissions'
type MockLibraryRepository_RevokeAllPermissions_Call struct {
	*mock.Call
}

// RevokeAllPermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - libraryID uuid.UUID
func (_e *MockLibraryRepository_Expecter) RevokeAllPermissions(ctx interface{}, libraryID interface{}) *MockLibraryRepository_RevokeAllPermissions_Call {
	return &MockLibraryRepository_RevokeAllPermissions_Call{Call: _e.mock.On("RevokeAllPermissions", ctx, libraryID)}
}

func (_c *MockLibraryRepository_RevokeAllPermissions_Call) Run(run func(ctx context.Context, libraryID uuid.UUID)) *MockLibraryRepository_RevokeAllPermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockLibraryRepository_RevokeAllPermissions_Call) Return(_a0 error) *MockLibraryRepository_RevokeAllPermissions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLibraryRepository_RevokeAllPermissions_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockLibraryRepository_RevokeAllPermissions_Call {
	_c.Call.Return(run)
	return _c
}

// RevokePermission provides a mock function with given fields: ctx, libraryID, userID, permission
func (_m *MockLibraryRepository) RevokePermission(ctx context.Context, libraryID uuid.UUID, userID uuid.UUID, permission string) error {
	ret := _m.Called(ctx, libraryID, userID, permission)

	if len(ret) == 0 {
		panic("no return value specified for RevokePermission")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, string) error); ok {
		r0 = rf(ctx, libraryID, userID, permission)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLibraryRepository_RevokePermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokePermission'
type MockLibraryRepository_RevokePermission_Call struct {
	*mock.Call
}

// RevokePermission is a helper method to define mock.On call
//   - ctx context.Context
//   - libraryID uuid.UUID
//   - userID uuid.UUID
//   - permission string
func (_e *MockLibraryRepository_Expecter) RevokePermission(ctx interface{}, libraryID interface{}, userID interface{}, permission interface{}) *MockLibraryRepository_RevokePermission_Call {
	return &MockLibraryRepository_RevokePermission_Call{Call: _e.mock.On("RevokePermission", ctx, libraryID, userID, permission)}
}

func (_c *MockLibraryRepository_RevokePermission_Call) Run(run func(ctx context.Context, libraryID uuid.UUID, userID uuid.UUID, permission string)) *MockLibraryRepository_RevokePermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(string))
	})
	return _c
}

func (_c *MockLibraryRepository_RevokePermission_Call) Return(_a0 error) *MockLibraryRepository_RevokePermission_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLibraryRepository_RevokePermission_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, string) error) *MockLibraryRepository_RevokePermission_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeUserPermissions provides a mock function with given fields: ctx, userID
func (_m *MockLibraryRepository) RevokeUserPermissions(ctx context.Context, userID uuid.UUID) error {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for RevokeUserPermissions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLibraryRepository_RevokeUserPermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeUserPermissions'
type MockLibraryRepository_RevokeUserPermissions_Call struct {
	*mock.Call
}

// RevokeUserPermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
func (_e *MockLibraryRepository_Expecter) RevokeUserPermissions(ctx interface{}, userID interface{}) *MockLibraryRepository_RevokeUserPermissions_Call {
	return &MockLibraryRepository_RevokeUserPermissions_Call{Call: _e.mock.On("RevokeUserPermissions", ctx, userID)}
}

func (_c *MockLibraryRepository_RevokeUserPermissions_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockLibraryRepository_RevokeUserPermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockLibraryRepository_RevokeUserPermissions_Call) Return(_a0 error) *MockLibraryRepository_RevokeUserPermissions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLibraryRepository_RevokeUserPermissions_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockLibraryRepository_RevokeUserPermissions_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, id, update
func (_m *MockLibraryRepository) Update(ctx context.Context, id uuid.UUID, update *library.LibraryUpdate) (*library.Library, error) {
	ret := _m.Called(ctx, id, update)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *library.Library
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *library.LibraryUpdate) (*library.Library, error)); ok {
		return rf(ctx, id, update)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *library.LibraryUpdate) *library.Library); ok {
		r0 = rf(ctx, id, update)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*library.Library)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *library.LibraryUpdate) error); ok {
		r1 = rf(ctx, id, update)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockLibraryRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
//   - update *library.LibraryUpdate
func (_e *MockLibraryRepository_Expecter) Update(ctx interface{}, id interface{}, update interface{}) *MockLibraryRepository_Update_Call {
	return &MockLibraryRepository_Update_Call{Call: _e.mock.On("Update", ctx, id, update)}
}

func (_c *MockLibraryRepository_Update_Call) Run(run func(ctx context.Context, id uuid.UUID, update *library.LibraryUpdate)) *MockLibraryRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*library.LibraryUpdate))
	})
	return _c
}

func (_c *MockLibraryRepository_Update_Call) Return(_a0 *library.Library, _a1 error) *MockLibraryRepository_Update_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_Update_Call) RunAndReturn(run func(context.Context, uuid.UUID, *library.LibraryUpdate) (*library.Library, error)) *MockLibraryRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateScanProgress provides a mock function with given fields: ctx, id, progress
func (_m *MockLibraryRepository) UpdateScanProgress(ctx context.Context, id uuid.UUID, progress *library.ScanProgress) (*library.LibraryScan, error) {
	ret := _m.Called(ctx, id, progress)

	if len(ret) == 0 {
		panic("no return value specified for UpdateScanProgress")
	}

	var r0 *library.LibraryScan
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *library.ScanProgress) (*library.LibraryScan, error)); ok {
		return rf(ctx, id, progress)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *library.ScanProgress) *library.LibraryScan); ok {
		r0 = rf(ctx, id, progress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*library.LibraryScan)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *library.ScanProgress) error); ok {
		r1 = rf(ctx, id, progress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_UpdateScanProgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateScanProgress'
type MockLibraryRepository_UpdateScanProgress_Call struct {
	*mock.Call
}

// UpdateScanProgress is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
//   - progress *library.ScanProgress
func (_e *MockLibraryRepository_Expecter) UpdateScanProgress(ctx interface{}, id interface{}, progress interface{}) *MockLibraryRepository_UpdateScanProgress_Call {
	return &MockLibraryRepository_UpdateScanProgress_Call{Call: _e.mock.On("UpdateScanProgress", ctx, id, progress)}
}

func (_c *MockLibraryRepository_UpdateScanProgress_Call) Run(run func(ctx context.Context, id uuid.UUID, progress *library.ScanProgress)) *MockLibraryRepository_UpdateScanProgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*library.ScanProgress))
	})
	return _c
}

func (_c *MockLibraryRepository_UpdateScanProgress_Call) Return(_a0 *library.LibraryScan, _a1 error) *MockLibraryRepository_UpdateScanProgress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_UpdateScanProgress_Call) RunAndReturn(run func(context.Context, uuid.UUID, *library.ScanProgress) (*library.LibraryScan, error)) *MockLibraryRepository_UpdateScanProgress_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateScanStatus provides a mock function with given fields: ctx, id, status
func (_m *MockLibraryRepository) UpdateScanStatus(ctx context.Context, id uuid.UUID, status *library.ScanStatusUpdate) (*library.LibraryScan, error) {
	ret := _m.Called(ctx, id, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateScanStatus")
	}

	var r0 *library.LibraryScan
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *library.ScanStatusUpdate) (*library.LibraryScan, error)); ok {
		return rf(ctx, id, status)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *library.ScanStatusUpdate) *library.LibraryScan); ok {
		r0 = rf(ctx, id, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*library.LibraryScan)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, *library.ScanStatusUpdate) error); ok {
		r1 = rf(ctx, id, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLibraryRepository_UpdateScanStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateScanStatus'
type MockLibraryRepository_UpdateScanStatus_Call struct {
	*mock.Call
}

// UpdateScanStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
//   - status *library.ScanStatusUpdate
func (_e *MockLibraryRepository_Expecter) UpdateScanStatus(ctx interface{}, id interface{}, status interface{}) *MockLibraryRepository_UpdateScanStatus_Call {
	return &MockLibraryRepository_UpdateScanStatus_Call{Call: _e.mock.On("UpdateScanStatus", ctx, id, status)}
}

func (_c *MockLibraryRepository_UpdateScanStatus_Call) Run(run func(ctx context.Context, id uuid.UUID, status *library.ScanStatusUpdate)) *MockLibraryRepository_UpdateScanStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*library.ScanStatusUpdate))
	})
	return _c
}

func (_c *MockLibraryRepository_UpdateScanStatus_Call) Return(_a0 *library.LibraryScan, _a1 error) *MockLibraryRepository_UpdateScanStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLibraryRepository_UpdateScanStatus_Call) RunAndReturn(run func(context.Context, uuid.UUID, *library.ScanStatusUpdate) (*library.LibraryScan, error)) *MockLibraryRepository_UpdateScanStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLibraryRepository creates a new instance of MockLibraryRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLibraryRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLibraryRepository {
	mock := &MockLibraryRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
