# Revenge - Internationalization (i18n)

<!-- SOURCES: casbin, fx, pgx, postgresql-arrays, postgresql-json, river, svelte-runes, svelte5, sveltekit -->

<!-- DESIGN: features/shared, 01_ARCHITECTURE, 02_DESIGN_PRINCIPLES, 03_METADATA_SYSTEM -->


> Complete multi-language support for UI, metadata, and content.


<!-- TOC-START -->

## Table of Contents

- [Status](#status)
- [Overview](#overview)
- [UI Internationalization](#ui-internationalization)
  - [Supported Languages (Initial)](#supported-languages-initial)
  - [Frontend Implementation (SvelteKit)](#frontend-implementation-sveltekit)
    - [Setup](#setup)
    - [Translation Files Structure](#translation-files-structure)
    - [Usage in Components](#usage-in-components)
  - [Backend Response Localization](#backend-response-localization)
- [Metadata Language](#metadata-language)
  - [User Language Preferences](#user-language-preferences)
  - [Translation Resolution](#translation-resolution)
  - [API Language Header](#api-language-header)
- [Audio/Subtitle Language Preferences](#audiosubtitle-language-preferences)
  - [User Preferences](#user-preferences)
  - [Track Selection Logic](#track-selection-logic)
- [RTL Language Support](#rtl-language-support)
  - [Supported RTL Languages](#supported-rtl-languages)
  - [CSS Support](#css-support)
  - [Dynamic Direction](#dynamic-direction)
- [Date/Time Formatting](#datetime-formatting)
  - [Relative Time](#relative-time)
  - [Duration Formatting](#duration-formatting)
- [Translation Workflow](#translation-workflow)
  - [Crowdin Integration](#crowdin-integration)
  - [CI/CD Integration](#cicd-integration)
- [Configuration](#configuration)
- [Summary](#summary)
- [Implementation Checklist](#implementation-checklist)
  - [Phase 1: Core Infrastructure](#phase-1-core-infrastructure)
  - [Phase 2: Frontend Setup](#phase-2-frontend-setup)
  - [Phase 3: Backend Service Layer](#phase-3-backend-service-layer)
  - [Phase 4: Background Jobs](#phase-4-background-jobs)
  - [Phase 5: API Integration](#phase-5-api-integration)
  - [Phase 6: Translation Workflow](#phase-6-translation-workflow)
- [Sources & Cross-References](#sources-cross-references)
  - [Cross-Reference Indexes](#cross-reference-indexes)
  - [Referenced Sources](#referenced-sources)
- [Related Design Docs](#related-design-docs)
  - [In This Section](#in-this-section)
  - [Related Topics](#related-topics)
  - [Indexes](#indexes)
- [Related](#related)

<!-- TOC-END -->

## Status

| Dimension | Status | Notes |
|-----------|--------|-------|
| Design | ‚úÖ | Full design with svelte-i18n, metadata translation, RTL support |
| Sources | ‚úÖ | svelte-i18n, date-fns, Crowdin integration documented |
| Instructions | ‚úÖ | Implementation checklist complete |
| Code | üî¥ |  |
| Linting | üî¥ |  |
| Unit Testing | üî¥ |  |
| Integration Testing | üî¥ |  |**Location**: `web/src/lib/i18n/` (frontend), `internal/service/i18n/` (backend metadata)

---

## Overview

Revenge supports multiple languages across three distinct areas:

| Area | Scope | Storage | Priority |
|------|-------|---------|----------|
| **UI Language** | Interface text, buttons, labels | Client-side (svelte-i18n) | User preference |
| **Metadata Language** | Titles, overviews, taglines | PostgreSQL translations | User preference ‚Üí Fallback chain |
| **Audio/Subtitle Language** | Track selection | Media files | User preference per content type |

---

## UI Internationalization

### Supported Languages (Initial)

| Code | Language | Completion Target |
|------|----------|-------------------|
| `en` | English | 100% (source) |
| `de` | German | 100% |
| `fr` | French | 100% |
| `es` | Spanish | 100% |
| `it` | Italian | 90% |
| `pt` | Portuguese | 90% |
| `nl` | Dutch | 80% |
| `pl` | Polish | 80% |
| `ru` | Russian | 80% |
| `ja` | Japanese | 70% |
| `zh` | Chinese (Simplified) | 70% |
| `ko` | Korean | 70% |

### Frontend Implementation (SvelteKit)

```
web/src/lib/i18n/
‚îú‚îÄ‚îÄ index.ts              # i18n setup
‚îú‚îÄ‚îÄ locales/
‚îÇ   ‚îú‚îÄ‚îÄ en.json           # English (source)
‚îÇ   ‚îú‚îÄ‚îÄ de.json           # German
‚îÇ   ‚îú‚îÄ‚îÄ fr.json           # French
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ types.ts              # TypeScript definitions
```

#### Setup

```typescript
// lib/i18n/index.ts
import { init, register, getLocaleFromNavigator, locale } from 'svelte-i18n';
import { browser } from '$app/environment';

// Register all locales (lazy loaded)
register('en', () => import('./locales/en.json'));
register('de', () => import('./locales/de.json'));
register('fr', () => import('./locales/fr.json'));
register('es', () => import('./locales/es.json'));
register('it', () => import('./locales/it.json'));
register('pt', () => import('./locales/pt.json'));
register('nl', () => import('./locales/nl.json'));
register('pl', () => import('./locales/pl.json'));
register('ru', () => import('./locales/ru.json'));
register('ja', () => import('./locales/ja.json'));
register('zh', () => import('./locales/zh.json'));
register('ko', () => import('./locales/ko.json'));

export const defaultLocale = 'en';
export const supportedLocales = ['en', 'de', 'fr', 'es', 'it', 'pt', 'nl', 'pl', 'ru', 'ja', 'zh', 'ko'];

// Initialize
init({
  fallbackLocale: defaultLocale,
  initialLocale: browser ? getStoredLocale() ?? getLocaleFromNavigator() : defaultLocale,
});

function getStoredLocale(): string | null {
  if (!browser) return null;
  return localStorage.getItem('locale');
}

// Persist locale changes
locale.subscribe((value) => {
  if (browser && value) {
    localStorage.setItem('locale', value);
    document.documentElement.lang = value;
  }
});
```

#### Translation Files Structure

```json
// locales/en.json
{
  "common": {
    "save": "Save",
    "cancel": "Cancel",
    "delete": "Delete",
    "edit": "Edit",
    "search": "Search",
    "loading": "Loading...",
    "error": "Error",
    "success": "Success",
    "confirm": "Confirm",
    "back": "Back",
    "next": "Next",
    "previous": "Previous"
  },
  "nav": {
    "home": "Home",
    "movies": "Movies",
    "shows": "TV Shows",
    "music": "Music",
    "audiobooks": "Audiobooks",
    "podcasts": "Podcasts",
    "photos": "Photos",
    "collections": "Collections",
    "favorites": "Favorites",
    "watchlist": "Watchlist",
    "settings": "Settings",
    "admin": "Admin"
  },
  "auth": {
    "login": "Log In",
    "logout": "Log Out",
    "register": "Register",
    "email": "Email",
    "password": "Password",
    "rememberMe": "Remember me",
    "forgotPassword": "Forgot password?",
    "loginWith": "Log in with {provider}"
  },
  "media": {
    "play": "Play",
    "resume": "Resume",
    "addToWatchlist": "Add to Watchlist",
    "removeFromWatchlist": "Remove from Watchlist",
    "markWatched": "Mark as Watched",
    "markUnwatched": "Mark as Unwatched",
    "rating": "Rating",
    "yourRating": "Your Rating",
    "genres": "Genres",
    "cast": "Cast",
    "crew": "Crew",
    "director": "Director",
    "runtime": "Runtime",
    "releaseDate": "Release Date",
    "overview": "Overview",
    "similar": "Similar",
    "recommended": "Recommended"
  },
  "player": {
    "play": "Play",
    "pause": "Pause",
    "mute": "Mute",
    "unmute": "Unmute",
    "fullscreen": "Fullscreen",
    "exitFullscreen": "Exit Fullscreen",
    "subtitles": "Subtitles",
    "audioTrack": "Audio Track",
    "quality": "Quality",
    "speed": "Playback Speed",
    "skipIntro": "Skip Intro",
    "nextEpisode": "Next Episode",
    "previousEpisode": "Previous Episode"
  },
  "settings": {
    "profile": "Profile",
    "language": "Language",
    "theme": "Theme",
    "themeLight": "Light",
    "themeDark": "Dark",
    "themeSystem": "System",
    "playback": "Playback",
    "notifications": "Notifications",
    "privacy": "Privacy",
    "defaultAudioLanguage": "Default Audio Language",
    "defaultSubtitleLanguage": "Default Subtitle Language",
    "autoPlayNext": "Auto-play Next Episode",
    "skipIntros": "Skip Intros Automatically"
  },
  "admin": {
    "dashboard": "Dashboard",
    "users": "Users",
    "libraries": "Libraries",
    "settings": "Server Settings",
    "logs": "Activity Logs",
    "tasks": "Tasks",
    "createUser": "Create User",
    "editUser": "Edit User",
    "deleteUser": "Delete User",
    "scanLibrary": "Scan Library",
    "refreshMetadata": "Refresh Metadata"
  },
  "errors": {
    "notFound": "Not found",
    "unauthorized": "Unauthorized",
    "forbidden": "Access denied",
    "serverError": "Server error",
    "networkError": "Network error",
    "tryAgain": "Please try again"
  },
  "time": {
    "now": "Just now",
    "minutesAgo": "{count} minute ago | {count} minutes ago",
    "hoursAgo": "{count} hour ago | {count} hours ago",
    "daysAgo": "{count} day ago | {count} days ago",
    "weeksAgo": "{count} week ago | {count} weeks ago"
  }
}
```

```json
// locales/de.json
{
  "common": {
    "save": "Speichern",
    "cancel": "Abbrechen",
    "delete": "L√∂schen",
    "edit": "Bearbeiten",
    "search": "Suchen",
    "loading": "Laden...",
    "error": "Fehler",
    "success": "Erfolgreich",
    "confirm": "Best√§tigen",
    "back": "Zur√ºck",
    "next": "Weiter",
    "previous": "Vorherige"
  },
  "nav": {
    "home": "Startseite",
    "movies": "Filme",
    "shows": "Serien",
    "music": "Musik",
    "audiobooks": "H√∂rb√ºcher",
    "podcasts": "Podcasts",
    "photos": "Fotos",
    "collections": "Sammlungen",
    "favorites": "Favoriten",
    "watchlist": "Merkliste",
    "settings": "Einstellungen",
    "admin": "Admin"
  },
  "auth": {
    "login": "Anmelden",
    "logout": "Abmelden",
    "register": "Registrieren",
    "email": "E-Mail",
    "password": "Passwort",
    "rememberMe": "Angemeldet bleiben",
    "forgotPassword": "Passwort vergessen?",
    "loginWith": "Anmelden mit {provider}"
  }
  // ... more translations
}
```

#### Usage in Components

```svelte
<script lang="ts">
  import { t, locale } from 'svelte-i18n';
  import { supportedLocales } from '$lib/i18n';
</script>

<!-- Simple translation -->
<h1>{$t('nav.movies')}</h1>

<!-- With parameters -->
<p>{$t('time.minutesAgo', { values: { count: 5 } })}</p>

<!-- Pluralization -->
<p>{$t('items.count', { values: { count: items.length } })}</p>

<!-- Language selector -->
<select bind:value={$locale}>
  {#each supportedLocales as lang}
    <option value={lang}>{$t(`languages.${lang}`)}</option>
  {/each}
</select>
```

### Backend Response Localization

The backend doesn't localize responses directly. Instead:

1. Error codes are returned (not messages)
2. Frontend translates error codes
3. Metadata is fetched in user's preferred language

```go
// Backend returns structured errors
type APIError struct {
    Code    string            `json:"code"`    // "auth.invalid_credentials"
    Details map[string]string `json:"details"` // Parameters for interpolation
}

// Frontend translates
// $t(`errors.${error.code}`, { values: error.details })
```

---

## Metadata Language

### User Language Preferences

```sql
-- User language preferences
ALTER TABLE users ADD COLUMN language_preferences JSONB DEFAULT '{
    "ui": "en",
    "metadata": "en",
    "metadata_fallback": ["en"],
    "audio": "original",
    "subtitle": "off"
}';

-- Example
-- {
--   "ui": "de",
--   "metadata": "de",
--   "metadata_fallback": ["de", "en", "original"],
--   "audio": "de",            -- Preferred audio language
--   "subtitle": "de"          -- Preferred subtitle language, "off" for none
-- }
```

### Translation Resolution

```go
// Resolve metadata in user's preferred language
func (s *MovieService) GetMovieMetadata(ctx context.Context, movieID uuid.UUID, userID uuid.UUID) (*MovieMetadata, error) {
    user, err := s.users.GetByID(ctx, userID)
    if err != nil {
        return nil, err
    }

    prefs := user.LanguagePreferences

    // Try languages in order
    languages := append([]string{prefs.Metadata}, prefs.MetadataFallback...)

    var metadata *MovieMetadata
    var usedLanguage string

    for _, lang := range languages {
        trans, err := s.repo.GetTranslation(ctx, movieID, lang)
        if err == nil && trans.Title != "" {
            metadata = &MovieMetadata{
                Title:           trans.Title,
                Overview:        trans.Overview,
                Tagline:         trans.Tagline,
                Language:        lang,
                IsTranslating:   false,
            }
            usedLanguage = lang
            break
        }
    }

    if metadata == nil {
        // Use original/default
        movie, _ := s.repo.GetByID(ctx, movieID)
        metadata = &MovieMetadata{
            Title:         movie.Title,
            Overview:      movie.Overview,
            Language:      "original",
            IsTranslating: false,
        }
    }

    // If preferred language not available, queue translation job
    if usedLanguage != prefs.Metadata {
        exists, _ := s.repo.TranslationExists(ctx, movieID, prefs.Metadata)
        if !exists {
            s.jobs.Insert(ctx, &FetchTranslationArgs{
                Module:   "movie",
                ItemID:   movieID,
                Language: prefs.Metadata,
            })
            metadata.IsTranslating = true
        }
    }

    return metadata, nil
}
```

### API Language Header

```go
// Middleware to extract language preference
func LanguageMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Priority: Query param > Header > User preference > Default
        lang := r.URL.Query().Get("lang")
        if lang == "" {
            lang = r.Header.Get("Accept-Language")
        }
        if lang == "" {
            if user := auth.UserFromContext(r.Context()); user != nil {
                lang = user.LanguagePreferences.Metadata
            }
        }
        if lang == "" {
            lang = "en"
        }

        // Validate language
        lang = normalizeLanguage(lang)

        ctx := context.WithValue(r.Context(), languageKey, lang)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

func normalizeLanguage(lang string) string {
    // "de-DE" -> "de"
    // "en-US" -> "en"
    parts := strings.Split(lang, "-")
    return strings.ToLower(parts[0])
}
```

---

## Audio/Subtitle Language Preferences

### User Preferences

```go
type AudioSubtitlePreferences struct {
    // Preferred audio language (ISO 639-1 or "original")
    AudioLanguage string `json:"audio_language"`

    // Preferred subtitle language (ISO 639-1 or "off" or "forced")
    SubtitleLanguage string `json:"subtitle_language"`

    // Show forced subtitles even when matching audio
    ShowForcedSubtitles bool `json:"show_forced_subtitles"`

    // Per-content type overrides
    Overrides map[string]AudioSubtitleOverride `json:"overrides"`
}

type AudioSubtitleOverride struct {
    AudioLanguage    string `json:"audio_language"`
    SubtitleLanguage string `json:"subtitle_language"`
}

// Example preferences:
// {
//   "audio_language": "de",
//   "subtitle_language": "off",
//   "show_forced_subtitles": true,
//   "overrides": {
//     "anime": {
//       "audio_language": "ja",
//       "subtitle_language": "de"
//     }
//   }
// }
```

### Track Selection Logic

```go
type StreamSelector struct {
    prefs AudioSubtitlePreferences
}

func (s *StreamSelector) SelectStreams(media *MediaFile, contentType string) StreamSelection {
    // Check for content-type override
    prefs := s.prefs
    if override, ok := prefs.Overrides[contentType]; ok {
        prefs.AudioLanguage = override.AudioLanguage
        prefs.SubtitleLanguage = override.SubtitleLanguage
    }

    selection := StreamSelection{}

    // Select audio track
    selection.AudioTrack = s.selectAudioTrack(media.AudioTracks, prefs.AudioLanguage)

    // Select subtitle track
    if prefs.SubtitleLanguage != "off" {
        selection.SubtitleTrack = s.selectSubtitleTrack(
            media.SubtitleTracks,
            prefs.SubtitleLanguage,
            selection.AudioTrack.Language,
            prefs.ShowForcedSubtitles,
        )
    }

    return selection
}

func (s *StreamSelector) selectAudioTrack(tracks []AudioTrack, preferred string) *AudioTrack {
    if preferred == "original" {
        // Find default/original track
        for _, t := range tracks {
            if t.IsDefault {
                return &t
            }
        }
        return &tracks[0]
    }

    // Find preferred language
    for _, t := range tracks {
        if t.Language == preferred {
            return &t
        }
    }

    // Fallback to default
    for _, t := range tracks {
        if t.IsDefault {
            return &t
        }
    }

    return &tracks[0]
}

func (s *StreamSelector) selectSubtitleTrack(tracks []SubtitleTrack, preferred, audioLang string, showForced bool) *SubtitleTrack {
    // If preferred is "forced", only show forced subs
    if preferred == "forced" {
        for _, t := range tracks {
            if t.IsForced && t.Language == audioLang {
                return &t
            }
        }
        return nil
    }

    // If audio matches preferred subtitle language, only show forced if enabled
    if preferred == audioLang && !showForced {
        for _, t := range tracks {
            if t.IsForced && t.Language == audioLang {
                return &t
            }
        }
        return nil
    }

    // Find preferred language subtitle
    for _, t := range tracks {
        if t.Language == preferred && !t.IsForced {
            return &t
        }
    }

    // Check forced in audio language
    if showForced {
        for _, t := range tracks {
            if t.IsForced && t.Language == audioLang {
                return &t
            }
        }
    }

    return nil
}
```

---

## RTL Language Support

### Supported RTL Languages

| Code | Language |
|------|----------|
| `ar` | Arabic |
| `he` | Hebrew |
| `fa` | Persian |
| `ur` | Urdu |

### CSS Support

```css
/* app.css */
[dir="rtl"] {
  /* Flip layout for RTL */
  direction: rtl;
  text-align: right;
}

/* Flip icons that have directionality */
[dir="rtl"] .icon-arrow-right {
  transform: scaleX(-1);
}

/* Keep LTR for numbers and code */
[dir="rtl"] .numeric,
[dir="rtl"] code {
  direction: ltr;
  unicode-bidi: embed;
}
```

### Dynamic Direction

```svelte
<script lang="ts">
  import { locale } from 'svelte-i18n';

  const rtlLanguages = ['ar', 'he', 'fa', 'ur'];

  $: isRTL = rtlLanguages.includes($locale?.split('-')[0] || '');
</script>

<svelte:body dir={isRTL ? 'rtl' : 'ltr'} />
```

---

## Date/Time Formatting

### Relative Time

```typescript
// lib/utils/format.ts
import { formatDistance, formatRelative, format } from 'date-fns';
import { de, fr, es, ja, zhCN } from 'date-fns/locale';
import { locale } from 'svelte-i18n';
import { get } from 'svelte/store';

const localeMap: Record<string, Locale> = {
  de,
  fr,
  es,
  ja,
  zh: zhCN,
};

export function formatRelativeTime(date: Date): string {
  const currentLocale = get(locale) || 'en';
  const dateFnsLocale = localeMap[currentLocale];

  return formatDistance(date, new Date(), {
    addSuffix: true,
    locale: dateFnsLocale,
  });
}

export function formatDateTime(date: Date, formatStr: string = 'PPpp'): string {
  const currentLocale = get(locale) || 'en';
  const dateFnsLocale = localeMap[currentLocale];

  return format(date, formatStr, {
    locale: dateFnsLocale,
  });
}
```

### Duration Formatting

```typescript
export function formatDuration(minutes: number): string {
  const hours = Math.floor(minutes / 60);
  const mins = minutes % 60;

  if (hours === 0) {
    return `${mins}m`;
  }

  if (mins === 0) {
    return `${hours}h`;
  }

  return `${hours}h ${mins}m`;
}

// Localized version using Intl
export function formatDurationLocalized(minutes: number, locale: string): string {
  const hours = Math.floor(minutes / 60);
  const mins = minutes % 60;

  const parts: string[] = [];

  if (hours > 0) {
    parts.push(new Intl.NumberFormat(locale, {
      style: 'unit',
      unit: 'hour',
      unitDisplay: 'short',
    }).format(hours));
  }

  if (mins > 0) {
    parts.push(new Intl.NumberFormat(locale, {
      style: 'unit',
      unit: 'minute',
      unitDisplay: 'short',
    }).format(mins));
  }

  return parts.join(' ');
}
```

---

## Translation Workflow

### Crowdin Integration

```yaml
# crowdin.yml
project_id_env: CROWDIN_PROJECT_ID
api_token_env: CROWDIN_API_TOKEN
preserve_hierarchy: true

files:
  - source: /web/src/lib/i18n/locales/en.json
    translation: /web/src/lib/i18n/locales/%two_letters_code%.json
```

### CI/CD Integration

```yaml
# .github/workflows/i18n.yml
name: Sync Translations

on:
  push:
    paths:
      - 'web/src/lib/i18n/locales/en.json'
    branches:
      - main
  schedule:
    - cron: '0 0 * * *'  # Daily

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Upload source to Crowdin
        uses: crowdin/github-action@v1
        with:
          upload_sources: true
          download_translations: false
        env:
          CROWDIN_PROJECT_ID: ${{ secrets.CROWDIN_PROJECT_ID }}
          CROWDIN_API_TOKEN: ${{ secrets.CROWDIN_API_TOKEN }}

  download:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    steps:
      - uses: actions/checkout@v4

      - name: Download translations from Crowdin
        uses: crowdin/github-action@v1
        with:
          upload_sources: false
          download_translations: true
          create_pull_request: true
          pull_request_title: 'i18n: Update translations from Crowdin'
        env:
          CROWDIN_PROJECT_ID: ${{ secrets.CROWDIN_PROJECT_ID }}
          CROWDIN_API_TOKEN: ${{ secrets.CROWDIN_API_TOKEN }}
```

---

## Configuration

```yaml
# configs/config.yaml
i18n:
  # Default languages
  default_ui_language: "en"
  default_metadata_language: "en"

  # Available UI languages
  ui_languages:
    - "en"
    - "de"
    - "fr"
    - "es"
    - "it"
    - "pt"
    - "nl"
    - "pl"
    - "ru"
    - "ja"
    - "zh"
    - "ko"

  # Languages to prefetch metadata for
  metadata_prefetch:
    - "en"
    - "de"

  # Date/time format preferences
  date_format: "locale"  # "locale", "iso", "us", "eu"
  time_format: "locale"  # "locale", "12h", "24h"
```

---

## Summary

| Aspect | Implementation |
|--------|----------------|
| UI i18n | svelte-i18n with lazy loading |
| Metadata Language | Per-user preference with fallback chain |
| Audio/Subtitle | User preferences with content-type overrides |
| RTL Support | CSS dir attribute + flipped icons |
| Date/Time | date-fns with locale support |
| Translation Workflow | Crowdin with CI/CD sync |

---

## Implementation Checklist

### Phase 1: Core Infrastructure
- [ ] Create frontend package structure `web/src/lib/i18n/`
- [ ] Create backend package structure `internal/service/i18n/`
- [ ] Define translation file structure (JSON format)
- [ ] Define `LanguagePreferences` entity in user model
- [ ] Define `MetadataTranslation` entity for content translations
- [ ] Create repository interfaces for translation storage
- [ ] Register fx module `internal/service/i18n/module.go`

### Phase 2: Frontend Setup
- [ ] Install and configure svelte-i18n
- [ ] Create `index.ts` with locale registration (lazy loading)
- [ ] Create English source translation file `en.json`
- [ ] Create initial translation files for priority languages (de, fr, es)
- [ ] Implement locale persistence (localStorage)
- [ ] Implement locale detection (navigator, stored preference)
- [ ] Add RTL support CSS and dynamic dir attribute
- [ ] Configure date-fns with locale support
- [ ] Create translation key TypeScript definitions

### Phase 3: Backend Service Layer
- [ ] Implement `LanguageMiddleware` for Accept-Language parsing
- [ ] Implement `MetadataResolver` with fallback chain logic
- [ ] Implement language normalization (`de-DE` -> `de`)
- [ ] Implement `StreamSelector` for audio/subtitle track selection
- [ ] Add user language preference to user service
- [ ] Implement translation fetch job for missing languages

### Phase 4: Background Jobs
- [ ] Create River job `FetchTranslationArgs` for metadata translation
- [ ] Create job for batch translation prefetch (configured languages)
- [ ] Create job for translation sync from metadata providers (TMDB, MusicBrainz)

### Phase 5: API Integration
- [ ] Add `language` query parameter support to content endpoints
- [ ] Add `Accept-Language` header support
- [ ] Implement user language preference endpoints
- [ ] Add translation status to content responses (`isTranslating` flag)
- [ ] Return error codes (not messages) for frontend translation
- [ ] Add translation management endpoints (admin)

### Phase 6: Translation Workflow
- [ ] Set up Crowdin project
- [ ] Create `crowdin.yml` configuration
- [ ] Create GitHub Actions workflow for source upload
- [ ] Create GitHub Actions workflow for translation download
- [ ] Configure automatic PR creation for translations
- [ ] Document translation contribution process

---


## Related

- [User Management](../../operations/USER_MANAGEMENT.md) - User preferences storage
- [Metadata Providers](../../integrations/metadata/METADATA_PROVIDERS.md) - Translation sources
