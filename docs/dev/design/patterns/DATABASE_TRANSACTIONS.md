# Database Transaction Patterns

> How transactions work in the service layer. Written from code as of 2026-02-06.

---

## When to Use Transactions

Use transactions when a service method must modify multiple rows/tables atomically. If any step fails, all changes roll back.

**Examples in codebase:**
- `auth.Register` — create user + create email verification token
- `auth.VerifyEmail` — mark token used + update email_verified
- `auth.ChangePassword` — update password + revoke all tokens
- `auth.ResetPassword` — update password + mark token used + revoke all tokens

**Don't use transactions for:**
- Single-row reads or writes (sqlc queries are already atomic)
- Cross-service operations (use eventual consistency via jobs instead)

---

## The Pattern

Services that need transactions receive `*pgxpool.Pool` in their constructor:

```go
type Service struct {
    pool *pgxpool.Pool   // For transactions
    repo Repository       // For non-transactional queries
    // ...
}

func NewService(pool *pgxpool.Pool, repo Repository, ...) *Service {
    return &Service{pool: pool, repo: repo, ...}
}
```

### Transaction method template

```go
func (s *Service) DoAtomicThing(ctx context.Context, ...) error {
    // 1. Read-only work OUTSIDE the transaction
    data, err := s.repo.GetSomething(ctx, id)
    if err != nil {
        return fmt.Errorf("failed to get data: %w", err)
    }

    // 2. Begin transaction
    tx, err := s.pool.Begin(ctx)
    if err != nil {
        return fmt.Errorf("failed to begin transaction: %w", err)
    }
    defer func() {
        _ = tx.Rollback(ctx)  // No-op if already committed
    }()

    // 3. Create transaction-scoped queries
    txQueries := db.New(tx)

    // 4. All mutations inside the transaction
    if err := txQueries.Step1(ctx, ...); err != nil {
        return fmt.Errorf("step 1 failed: %w", err)
    }
    if err := txQueries.Step2(ctx, ...); err != nil {
        return fmt.Errorf("step 2 failed: %w", err)
    }

    // 5. Commit
    if err := tx.Commit(ctx); err != nil {
        return fmt.Errorf("failed to commit: %w", err)
    }

    // 6. Non-critical work AFTER the transaction (logging, cache invalidation)
    _ = s.activityLogger.LogAction(ctx, ...)

    return nil
}
```

---

## Key: `db.New(tx)` for Transaction-Scoped Queries

The sqlc-generated `db.Queries` type accepts both `*pgxpool.Pool` and `pgx.Tx` via the `DBTX` interface:

```go
// Generated by sqlc
type DBTX interface {
    Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
    Query(context.Context, string, ...interface{}) (pgx.Rows, error)
    QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries {
    return &Queries{db: db}
}
```

This means:
- `db.New(pool)` — queries run independently (auto-commit)
- `db.New(tx)` — queries run within the transaction

**Never mix** `s.repo` methods (which use the pool) with `txQueries` methods (which use the tx) in the same atomic operation.

---

## Real Examples

### auth.VerifyEmail (2 operations)

```go
func (s *Service) VerifyEmail(ctx context.Context, token string) error {
    tokenHash := s.tokenManager.HashRefreshToken(token)

    // Read-only: outside transaction
    emailToken, err := s.repo.GetEmailVerificationToken(ctx, tokenHash)
    if err != nil {
        return fmt.Errorf("invalid or expired verification token: %w", err)
    }

    // Transaction: mark token + verify email
    tx, err := s.pool.Begin(ctx)
    if err != nil {
        return fmt.Errorf("failed to begin transaction: %w", err)
    }
    defer func() { _ = tx.Rollback(ctx) }()

    txQueries := db.New(tx)
    if err := txQueries.MarkEmailVerificationTokenUsed(ctx, emailToken.ID); err != nil {
        return fmt.Errorf("failed to mark token as used: %w", err)
    }
    if err := txQueries.VerifyEmail(ctx, emailToken.UserID); err != nil {
        return fmt.Errorf("failed to update user: %w", err)
    }

    return tx.Commit(ctx)
}
```

### auth.ChangePassword (2 operations + post-tx logging)

```go
func (s *Service) ChangePassword(ctx context.Context, userID uuid.UUID, oldPassword, newPassword string) error {
    // Validation outside tx
    user, err := s.repo.GetUserByID(ctx, userID)
    // ... verify old password ...

    newPasswordHash, err := s.hasher.HashPassword(newPassword)
    // ...

    // Transaction: update password + revoke tokens
    tx, err := s.pool.Begin(ctx)
    if err != nil { return fmt.Errorf("failed to begin transaction: %w", err) }
    defer func() { _ = tx.Rollback(ctx) }()

    txQueries := db.New(tx)
    if err := txQueries.UpdatePassword(ctx, db.UpdatePasswordParams{
        ID: userID, PasswordHash: newPasswordHash,
    }); err != nil {
        return fmt.Errorf("failed to update password: %w", err)
    }
    if err := txQueries.RevokeAllUserAuthTokens(ctx, userID); err != nil {
        return fmt.Errorf("failed to revoke tokens: %w", err)
    }

    if err := tx.Commit(ctx); err != nil {
        return fmt.Errorf("failed to commit: %w", err)
    }

    // Post-transaction: activity logging (non-critical)
    _ = s.activityLogger.LogAction(ctx, activity.LogActionRequest{
        UserID: user.ID, Action: activity.ActionUserPasswordChanged,
    })

    return nil
}
```

---

## Rules

1. **Reads outside, writes inside.** Only put mutations in the transaction to minimize lock duration.
2. **Always `defer tx.Rollback(ctx)`** immediately after `Begin()`. It's a no-op after successful `Commit()`.
3. **Use `txQueries := db.New(tx)`** for all operations inside the transaction.
4. **Don't mix `s.repo` and `txQueries`** — repo uses the pool (different connection), txQueries uses the tx.
5. **Non-critical work after commit.** Activity logging, cache invalidation, etc. go after `tx.Commit()`.
6. **Wrap errors with context.** Every operation gets `fmt.Errorf("what failed: %w", err)`.
7. **No nested transactions.** PostgreSQL doesn't support true nested tx. If you need savepoints, use `tx.Begin(ctx)` for a sub-transaction (creates a savepoint).
8. **Isolation level:** Default (ReadCommitted) for all current transactions. No need to change unless you have read-modify-write races.

---

## Services Using Transactions

| Service | Pool injected? | Transaction methods |
|---------|---------------|-------------------|
| auth | Yes | Register, VerifyEmail, ChangePassword, ResetPassword |
| user | Yes | (pool available, used for future atomic operations) |
| Others | No | No transaction support needed yet |

If your service needs transactions, add `*pgxpool.Pool` as the first parameter to `NewService()` and update the fx module accordingly.
