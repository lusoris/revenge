# New Service Checklist

> Step-by-step guide for adding a new service to the Revenge codebase. Written from code as of 2026-02-06.

---

## File Structure

```
internal/service/{name}/
├── repository.go          # Repository interface
├── repository_pg.go       # PostgreSQL implementation (sqlc)
├── service.go             # Service struct, constructor, business logic
├── cached_service.go      # Optional: CachedService wrapper
├── module.go              # fx module
├── service_test.go        # Integration tests (testcontainers)
├── service_unit_test.go   # Unit tests (mocks)
└── mock_repository_test.go # Generated by mockery
```

---

## 1. Define the Repository Interface

File: `internal/service/{name}/repository.go`

```go
package myservice

import (
    "context"
    "github.com/google/uuid"
    "github.com/lusoris/revenge/internal/infra/database/db"
)

type Repository interface {
    Get(ctx context.Context, id uuid.UUID) (*db.SharedMyEntity, error)
    List(ctx context.Context) ([]db.SharedMyEntity, error)
    Create(ctx context.Context, params db.CreateMyEntityParams) (db.SharedMyEntity, error)
    Update(ctx context.Context, params db.UpdateMyEntityParams) (db.SharedMyEntity, error)
    Delete(ctx context.Context, id uuid.UUID) error
}
```

**Rules:**
- Context is always the first parameter
- Methods return sqlc-generated types (`db.Shared*`) or domain types
- Error is always the last return value

---

## 2. Implement the PostgreSQL Repository

File: `internal/service/{name}/repository_pg.go`

```go
package myservice

import (
    "context"
    "github.com/jackc/pgx/v5/pgxpool"
    "github.com/lusoris/revenge/internal/infra/database/db"
)

type pgRepository struct {
    pool    *pgxpool.Pool
    queries *db.Queries
}

func NewPostgresRepository(pool *pgxpool.Pool) Repository {
    return &pgRepository{
        pool:    pool,
        queries: db.New(pool),
    }
}

func (r *pgRepository) Get(ctx context.Context, id uuid.UUID) (*db.SharedMyEntity, error) {
    result, err := r.queries.GetMyEntity(ctx, id)
    if err != nil {
        return nil, err
    }
    return &result, nil
}
```

**Two constructor variants exist in the codebase:**
- `NewPostgresRepository(pool *pgxpool.Pool)` — creates its own `db.Queries` (settings, library)
- `NewRepositoryPg(queries *db.Queries)` — receives pre-created queries (apikeys, auth)

Both work. The pool variant is preferred when the repo needs transactions later.

---

## 3. Create the Service

File: `internal/service/{name}/service.go`

**Simple service** (settings pattern — interface-based):

```go
package myservice

type Service interface {
    Get(ctx context.Context, id uuid.UUID) (*MyEntity, error)
    List(ctx context.Context) ([]MyEntity, error)
    Create(ctx context.Context, req CreateRequest) (*MyEntity, error)
}

type service struct {
    repo Repository
}

func NewService(repo Repository) Service {
    return &service{repo: repo}
}
```

**Complex service** (auth pattern — struct-based, with pool for transactions):

```go
package myservice

type Service struct {
    pool           *pgxpool.Pool
    repo           Repository
    activityLogger activity.Logger
    // ... other dependencies
}

func NewService(pool *pgxpool.Pool, repo Repository, logger activity.Logger) *Service {
    return &Service{
        pool:           pool,
        repo:           repo,
        activityLogger: logger,
    }
}
```

**When to use which:**
- Interface-based (`Service` interface + unexported `service` struct): when the service is simple, no transactions needed
- Struct-based (`*Service` exported): when the service needs `pool.Begin()` for transactions, or has many dependencies

**Sentinel errors** (define at package level):

```go
var (
    ErrNotFound     = errors.New("myservice: not found")
    ErrMaxExceeded  = errors.New("myservice: maximum exceeded")
)
```

---

## 4. Add Transaction Support (if needed)

Only services that modify multiple rows atomically need `*pgxpool.Pool`. Pattern from `auth.Service`:

```go
func (s *Service) DoAtomicThing(ctx context.Context, id uuid.UUID) error {
    tx, err := s.pool.Begin(ctx)
    if err != nil {
        return fmt.Errorf("failed to begin transaction: %w", err)
    }
    defer func() { _ = tx.Rollback(ctx) }()

    txQueries := db.New(tx)

    if err := txQueries.Step1(ctx, ...); err != nil {
        return fmt.Errorf("step 1 failed: %w", err)
    }
    if err := txQueries.Step2(ctx, ...); err != nil {
        return fmt.Errorf("step 2 failed: %w", err)
    }

    if err := tx.Commit(ctx); err != nil {
        return fmt.Errorf("failed to commit: %w", err)
    }
    return nil
}
```

Key: create `db.New(tx)` to get transaction-scoped queries. The `db.Queries` type accepts both `*pgxpool.Pool` and `pgx.Tx`.

---

## 5. Add Caching (optional)

File: `internal/service/{name}/cached_service.go`

```go
package myservice

import (
    "context"
    "time"
    "github.com/lusoris/revenge/internal/infra/cache"
    "go.uber.org/zap"
)

type CachedService struct {
    Service                    // Embed the interface (or *Service for struct-based)
    cache  *cache.Cache
    logger *zap.Logger
}

func NewCachedService(svc Service, c *cache.Cache, logger *zap.Logger) *CachedService {
    return &CachedService{
        Service: svc,
        cache:   c,
        logger:  logger.Named("myservice-cache"),
    }
}

func (s *CachedService) Get(ctx context.Context, id uuid.UUID) (*MyEntity, error) {
    if s.cache == nil {
        return s.Service.Get(ctx, id)
    }

    cacheKey := cache.MyEntityKey(id.String())

    var entity MyEntity
    if err := s.cache.GetJSON(ctx, cacheKey, &entity); err == nil {
        return &entity, nil
    }

    result, err := s.Service.Get(ctx, id)
    if err != nil {
        return nil, err
    }

    // Cache async — never block the request
    go func() {
        cacheCtx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
        defer cancel()
        _ = s.cache.SetJSON(cacheCtx, cacheKey, result, 5*time.Minute)
    }()

    return result, nil
}
```

**Patterns in codebase:**
- Settings, movie, library: embed `Service` interface
- User, library: embed `*Service` pointer
- RBAC: wraps non-JSON values in helper structs (`cachedBool`, `cachedStringSlice`)

**Rules:**
- Always check `s.cache == nil` — graceful degradation if cache unavailable
- Cache writes are async (goroutine with timeout)
- Write operations must invalidate relevant cache keys

---

## 6. Wire the fx Module

File: `internal/service/{name}/module.go`

**Simple (settings pattern):**

```go
package myservice

import "go.uber.org/fx"

var Module = fx.Module("myservice",
    fx.Provide(
        NewPostgresRepository,
        NewService,
    ),
)
```

**With config extraction (apikeys pattern):**

```go
var Module = fx.Module("myservice",
    fx.Provide(
        func(queries *db.Queries) Repository { return NewRepositoryPg(queries) },
        func(repo Repository, logger *zap.Logger, cfg *config.Config) *Service {
            return NewService(repo, logger, cfg.MyService.MaxItems)
        },
    ),
)
```

**With caching (settings pattern):**

```go
var Module = fx.Module("myservice",
    fx.Provide(
        func(pool *pgxpool.Pool) Repository { return NewPostgresRepository(pool) },
        NewService,
        NewCachedService,
    ),
)
```

---

## 7. Register in the App Module

File: `internal/app/module.go` — add your module to the `fx.Module("app", ...)` list:

```go
var Module = fx.Module("app",
    // ... infrastructure modules ...
    myservice.Module,
    // ... other service modules ...
    api.Module,  // API is always last
)
```

---

## 8. Add API Handler Methods

File: `internal/api/handler_{name}.go`

```go
func (h *Handler) ListMyEntities(ctx context.Context) (ogen.ListMyEntitiesRes, error) {
    userID, ok := h.getUserID(ctx)
    if !ok {
        return &ogen.Error{Code: 401, Message: "Authentication required"}, nil
    }

    entities, err := h.myService.List(ctx)
    if err != nil {
        h.logger.Error("failed to list entities", zap.Error(err))
        return &ogen.Error{Code: 500, Message: "Failed to list entities"}, nil
    }

    // Convert domain types to ogen types
    result := make([]ogen.MyEntity, len(entities))
    for i, e := range entities {
        result[i] = domainToOgen(e)
    }
    return &ogen.MyEntityListResponse{Items: result}, nil
}
```

**Handler wiring** — add the service to `Handler` struct in `handler.go` and `ServerParams` in `server.go`:

```go
// handler.go
type Handler struct {
    // ...
    myService *myservice.Service  // or myservice.Service for interface
}

// server.go
type ServerParams struct {
    fx.In
    // ...
    MyService *myservice.Service `optional:"true"`  // optional if not always available
}
```

---

## 9. Write Tests

**Unit tests** (mock repository):

```go
package myservice_test

func setupService(repo myservice.Repository) *myservice.Service {
    return myservice.NewService(repo)
}

func TestCreate_Success(t *testing.T) {
    mockRepo := NewMockRepository(t)  // mockery-generated
    svc := setupService(mockRepo)

    mockRepo.On("Create", mock.Anything, mock.AnythingOfType("db.CreateMyEntityParams")).
        Return(db.SharedMyEntity{ID: id, Name: "test"}, nil)

    result, err := svc.Create(ctx, myservice.CreateRequest{Name: "test"})

    require.NoError(t, err)
    assert.Equal(t, "test", result.Name)
    mockRepo.AssertExpectations(t)
}
```

**Integration tests** (real database):

```go
package myservice

func setupTestService(t *testing.T) (Service, testutil.DB) {
    t.Helper()
    testDB := testutil.NewFastTestDB(t)
    repo := NewPostgresRepository(testDB.Pool())
    svc := NewService(repo)
    return svc, testDB
}

func TestService_CRUD(t *testing.T) {
    t.Parallel()
    svc, _ := setupTestService(t)
    ctx := context.Background()

    t.Run("create and get", func(t *testing.T) {
        created, err := svc.Create(ctx, CreateRequest{Name: "test"})
        require.NoError(t, err)

        retrieved, err := svc.Get(ctx, created.ID)
        require.NoError(t, err)
        assert.Equal(t, "test", retrieved.Name)
    })
}
```

Generate mocks: `mockery --name=Repository --dir=internal/service/{name} --output=internal/service/{name} --outpkg={name} --inpackage`

---

## Quick Reference

| Step | File | Required? |
|------|------|-----------|
| SQL queries | `internal/infra/database/queries/{name}.sql` | Yes |
| Generate sqlc | `make generate` | Yes |
| Repository interface | `repository.go` | Yes |
| PostgreSQL impl | `repository_pg.go` | Yes |
| Service | `service.go` | Yes |
| Cached service | `cached_service.go` | Optional |
| fx module | `module.go` | Yes |
| App wiring | `internal/app/module.go` | Yes |
| OpenAPI spec | `api/openapi/paths/{name}.yaml` | If API needed |
| API handler | `internal/api/handler_{name}.go` | If API needed |
| Unit tests | `service_unit_test.go` | Yes |
| Integration tests | `service_test.go` | Yes |
| Migration | `make migrate-create NAME=add_{name}` | If new tables |
