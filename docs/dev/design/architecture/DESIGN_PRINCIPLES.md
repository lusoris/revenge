# Design Principles

**Last Updated**: 2026-02-06

Patterns and conventions observed in the Revenge codebase.

---

## Core Principles

### PostgreSQL Only

No SQLite, no multi-database abstraction. Every repository targets PostgreSQL directly through pgx. This avoids compatibility layers and lets the codebase use PostgreSQL-specific features (JSONB columns, arrays, advisory locks, `gen_random_uuid()`).

### Spec-First API

The API is defined in OpenAPI YAML (`api/openapi/`), then code-generated with ogen. Handlers implement a generated interface rather than registering routes manually. This makes the API contract the source of truth - clients and server always agree on types and validation.

### Interface-Driven Dependencies

Every service and repository defines an interface. Implementations are injected via fx. This means:
- Content modules receive `Repository` and `MetadataProvider` interfaces, not concrete types
- Tests can substitute mocks (generated by mockery) without touching production wiring
- The metadata system injects adapters that bridge shared metadata types to content-specific domain types

### Context-First Functions

Every function that does I/O takes `context.Context` as the first parameter. No exceptions in the repository, service, or handler layers.

---

## Error Handling

### Sentinel Errors

The `internal/errors` package defines project-wide sentinel errors using `go-faster/errors`:

```go
var (
    ErrNotFound      = errors.New("not found")
    ErrUnauthorized  = errors.New("unauthorized")
    ErrForbidden     = errors.New("forbidden")
    ErrConflict      = errors.New("conflict")
    ErrValidation    = errors.New("validation failed")
    ErrBadRequest    = errors.New("bad request")
    ErrUnavailable   = errors.New("service unavailable")
    ErrTimeout       = errors.New("timeout")
)
```

### Error Wrapping Chain

Errors are wrapped with context at each layer. The full chain is preserved so `errors.Is()` works through any depth:

```
Handler → Service → Repository → PostgreSQL
  each layer wraps with: errors.Wrap(err, "context message")
```

### API Error Translation

`api.ToAPIError()` converts sentinel errors to HTTP status codes via a switch on `errors.Is()`. Unknown errors return 500 without exposing internal details.

### Domain-Specific Errors

The metadata service defines its own sentinel errors (`ErrNoProviders`, `ErrRateLimited`, `ErrProviderUnavailable`) and structured error types (`ProviderError`, `AggregateError`) for multi-provider error aggregation.

---

## Module Pattern

Every package exposes an fx `Module` variable:

```go
var Module = fx.Module("movie",
    fx.Provide(
        NewPostgresRepository,
        provideService,
        NewHandler,
    ),
)
```

The top-level `app.Module` composes all sub-modules. This gives each package control over its own wiring while keeping the composition explicit in one place.

---

## Repository Pattern

### Interface + PostgreSQL Implementation

Each module defines a `Repository` interface with domain-specific operations:

```go
type Repository interface {
    GetMovie(ctx context.Context, id uuid.UUID) (*Movie, error)
    CreateMovie(ctx context.Context, params CreateMovieParams) (*Movie, error)
    // ... grouped by concern: CRUD, files, credits, genres, watch progress
}
```

The implementation (`repository_pg.go`) uses sqlc-generated queries from embedded SQL migrations. No ORM.

### Params Structs

Create and update operations use dedicated params structs with pointer fields for optional values. This avoids the "zero value vs not provided" ambiguity:

```go
type UpdateMovieParams struct {
    ID       uuid.UUID
    Title    *string    // nil = don't update
    Year     *int32     // nil = don't update
    // ...
}
```

---

## Testing Patterns

### Table-Driven Tests

Tests use `[]struct` slices with named test cases:

```go
tests := []struct {
    name string
    err  error
    msg  string
}{
    {"ErrNotFound", errors.ErrNotFound, "not found"},
    {"ErrUnauthorized", errors.ErrUnauthorized, "unauthorized"},
}
for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) {
        // ...
    })
}
```

### Testing Libraries

- **testify**: `assert` for soft assertions, `require` for fatal assertions
- **mockery**: Generates mock implementations from interfaces (e.g., `mock_repository_test.go`)
- **testcontainers**: Integration tests spin up real PostgreSQL, Dragonfly, Typesense containers

### Test File Naming

- `*_test.go` - unit tests in the same package
- `mock_*_test.go` - mockery-generated mocks
- `*_integration_test.go` - tests requiring external services

---

## Configuration

### Struct Tags with koanf

Configuration is a single `Config` struct with nested sub-configs, each tagged for koanf:

```go
type Config struct {
    Server   ServerConfig   `koanf:"server"`
    Database DatabaseConfig `koanf:"database"`
    Cache    CacheConfig    `koanf:"cache"`
    // ...20 sub-configs
}
```

### YAML + Environment Override

Base config from YAML file, overridden by environment variables with `REVENGE_` prefix. This means `REVENGE_DATABASE_URL` overrides `database.url` in YAML.

---

## Adapter Pattern

The metadata system uses adapters to bridge between shared metadata types and content-specific domain types:

```
metadata.Service (shared)
    ↓ MovieMetadata, Credits, Images
movie.Adapter (bridge)
    ↓ movie.Movie, movie.MovieCredit, movie.MovieGenre
movie.Service (content)
```

Each adapter:
- Implements the content module's `MetadataProvider` interface
- Delegates to the shared `metadata.Service`
- Maps between type systems (e.g., `metadata.MovieMetadata` → `movie.Movie`)
- Handles multi-language data, age rating mapping, decimal conversion

---

## Compile-Time Interface Checks

Packages use blank identifier assignments to verify interface compliance at compile time:

```go
var _ Service = (*service)(nil)
var _ movie.MetadataProvider = (*Adapter)(nil)
```

This catches interface drift immediately rather than at runtime.

---

## Naming Conventions

| Item | Convention | Example |
|------|-----------|---------|
| Packages | lowercase, single word | `movie`, `metadata`, `auth` |
| Interfaces | noun or noun phrase | `Repository`, `Service`, `MetadataProvider` |
| Constructors | `New` + type name | `NewService()`, `NewPostgresRepository()` |
| fx providers | `provide` + name (unexported) | `provideService()`, `provideLibraryService()` |
| Files | snake_case | `repository_pg.go`, `handler_test.go` |
| Test files | `*_test.go` in same package | `errors_test.go`, `service_unit_test.go` |
| IDs | UUIDv7 (`uuid.Must(uuid.NewV7())`) | Time-sortable unique identifiers |

---

## Related Documentation

- [Architecture](ARCHITECTURE.md) - System structure and layers
- [Metadata System](METADATA_SYSTEM.md) - Multi-provider metadata aggregation
- [Tech Stack](../technical/TECH_STACK.md) - Technology choices and rationale
