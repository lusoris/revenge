# StashDB GraphQL API GraphQL Schema

# Auto-fetched from https://stashdb.org/graphql
# Last Updated: 2026-01-29T20:13:27.101135+00:00

input ActivateNewUserInput {
  name: String!
  activation_key: ID!
  password: String!
}

input ApplyEditInput {
  id: ID!
}

type BodyModification {
  location: String!
  description: String
}

input BodyModificationCriterionInput {
  location: String
  description: String
  modifier: CriterionModifier!
}

input BodyModificationInput {
  location: String!
  description: String
}

"""The `Boolean` scalar type represents `true` or `false`."""
input BreastTypeCriterionInput {
  value: BreastTypeEnum
  modifier: CriterionModifier!
}

enum BreastTypeEnum {
  NATURAL
  FAKE
  NA
}

input CancelEditInput {
  id: ID!
}

type CommentCommentedEdit {
  comment: EditComment!
}

type CommentOwnEdit {
  comment: EditComment!
}

type CommentVotedEdit {
  comment: EditComment!
}

enum CriterionModifier {
  EQUALS
  NOT_EQUALS
  GREATER_THAN
  LESS_THAN
  IS_NULL
  NOT_NULL
  INCLUDES_ALL
  INCLUDES
  EXCLUDES
}

scalar Date

enum DateAccuracyEnum {
  YEAR
  MONTH
  DAY
}

input DateCriterionInput {
  value: Date!
  modifier: CriterionModifier!
}

scalar DateTime

type DownvoteOwnEdit {
  edit: Edit!
}

type Draft {
  id: ID!
  created: Time!
  expires: Time!
  data: DraftData!
}

union DraftData = SceneDraft | PerformerDraft

type DraftEntity {
  name: String!
  id: ID
}

input DraftEntityInput {
  name: String!
  id: ID
}

type DraftFingerprint {
  hash: String!
  algorithm: FingerprintAlgorithm!
  duration: Int!
}

type DraftSubmissionStatus {
  id: ID
}

type Edit {
  id: ID!
  user: User
  """Object being edited - null if creating a new object"""
  target: EditTarget
  target_type: TargetTypeEnum!
  """Objects to merge with the target. Only applicable to merges"""
  merge_sources: [EditTarget!]!
  operation: OperationEnum!
  bot: Boolean!
  details: EditDetails
  """Previous state of fields being modified - null if operation is create or delete."""
  old_details: EditDetails
  """Entity specific options"""
  options: PerformerEditOptions
  comments: [EditComment!]!
  votes: [EditVote!]!
  """ = Accepted - Rejected"""
  vote_count: Int!
  """Is the edit considered destructive."""
  destructive: Boolean!
  status: VoteStatusEnum!
  applied: Boolean!
  update_count: Int!
  updatable: Boolean!
  created: Time!
  updated: Time
  closed: Time
  expires: Time
}

type EditComment {
  id: ID!
  user: User
  date: Time!
  comment: String!
  edit: Edit!
}

input EditCommentInput {
  id: ID!
  comment: String!
}

union EditDetails = PerformerEdit | SceneEdit | StudioEdit | TagEdit

input EditInput {
  id: ID
  operation: OperationEnum!
  merge_source_ids: [ID!]
  comment: String
  bot: Boolean
}

input EditQueryInput {
  user_id: ID
  status: VoteStatusEnum
  operation: OperationEnum
  vote_count: IntCriterionInput
  applied: Boolean
  target_type: TargetTypeEnum
  target_id: ID
  is_favorite: Boolean
  voted: UserVotedFilterEnum
  is_bot: Boolean
  include_user_submitted: Boolean
  page: Int!
  per_page: Int!
  direction: SortDirectionEnum!
  sort: EditSortEnum!
}

enum EditSortEnum {
  CREATED_AT
  UPDATED_AT
  CLOSED_AT
}

union EditTarget = Performer | Scene | Studio | Tag

type EditVote {
  user: User
  date: Time!
  vote: VoteTypeEnum!
}

input EditVoteInput {
  id: ID!
  vote: VoteTypeEnum!
}

enum EthnicityEnum {
  CAUCASIAN
  BLACK
  ASIAN
  INDIAN
  LATIN
  MIDDLE_EASTERN
  MIXED
  OTHER
}

enum EthnicityFilterEnum {
  UNKNOWN
  CAUCASIAN
  BLACK
  ASIAN
  INDIAN
  LATIN
  MIDDLE_EASTERN
  MIXED
  OTHER
}

input EyeColorCriterionInput {
  value: EyeColorEnum
  modifier: CriterionModifier!
}

enum EyeColorEnum {
  BLUE
  BROWN
  GREY
  GREEN
  HAZEL
  RED
}

type FailedOwnEdit {
  edit: Edit!
}

enum FavoriteFilter {
  PERFORMER
  STUDIO
  ALL
}

type FavoritePerformerEdit {
  edit: Edit!
}

type FavoritePerformerScene {
  scene: Scene!
}

type FavoriteStudioEdit {
  edit: Edit!
}

type FavoriteStudioScene {
  scene: Scene!
}

type Fingerprint {
  hash: String!
  algorithm: FingerprintAlgorithm!
  duration: Int!
  """number of times this fingerprint has been submitted (excluding reports)"""
  submissions: Int!
  """number of times this fingerprint has been reported"""
  reports: Int!
  created: Time!
  updated: Time!
  """true if the current user submitted this fingerprint"""
  user_submitted: Boolean!
  """true if the current user reported this fingerprint"""
  user_reported: Boolean!
}

enum FingerprintAlgorithm {
  MD5
  OSHASH
  PHASH
}

input FingerprintEditInput {
  user_ids: [ID!]
  hash: String!
  algorithm: FingerprintAlgorithm!
  duration: Int!
  created: Time!
  submissions: Int
  updated: Time
}

input FingerprintInput {
  user_ids: [ID!]
  hash: String!
  algorithm: FingerprintAlgorithm!
  duration: Int!
}

input FingerprintQueryInput {
  hash: String!
  algorithm: FingerprintAlgorithm!
}

input FingerprintSubmission {
  scene_id: ID!
  fingerprint: FingerprintInput!
  unmatch: Boolean
  vote: FingerprintSubmissionType
}

enum FingerprintSubmissionType {
  VALID
  INVALID
  REMOVE
}

type FingerprintedSceneEdit {
  edit: Edit!
}

"""The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point)."""
type FuzzyDate {
  date: Date!
  accuracy: DateAccuracyEnum!
}

enum GenderEnum {
  MALE
  FEMALE
  TRANSGENDER_MALE
  TRANSGENDER_FEMALE
  INTERSEX
  NON_BINARY
}

enum GenderFilterEnum {
  UNKNOWN
  MALE
  FEMALE
  TRANSGENDER_MALE
  TRANSGENDER_FEMALE
  INTERSEX
  NON_BINARY
}

input GenerateInviteCodeInput {
  keys: Int
  uses: Int
  ttl: Int
}

input GrantInviteInput {
  user_id: ID!
  amount: Int!
}

input HairColorCriterionInput {
  value: HairColorEnum
  modifier: CriterionModifier!
}

enum HairColorEnum {
  BLONDE
  BRUNETTE
  BLACK
  RED
  AUBURN
  GREY
  BALD
  VARIOUS
  WHITE
  OTHER
}

"""The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as "4") or integer (such as 4) input value will be accepted as an ID."""
input IDCriterionInput {
  value: [ID!]!
  modifier: CriterionModifier!
}

type Image {
  id: ID!
  url: String!
  width: Int!
  height: Int!
}

input ImageCreateInput {
  url: String
  file: Upload
}

input ImageDestroyInput {
  id: ID!
}

input ImageUpdateInput {
  id: ID!
  url: String
}

"""The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1."""
input IntCriterionInput {
  value: Int!
  modifier: CriterionModifier!
}

type InviteKey {
  id: ID!
  uses: Int
  expires: Time
}

input MarkNotificationReadInput {
  type: NotificationEnum!
  id: ID!
}

type Measurements {
  cup_size: String
  band_size: Int
  waist: Int
  hip: Int
}

input MultiIDCriterionInput {
  value: [ID!]
  modifier: CriterionModifier!
}

input MultiStringCriterionInput {
  value: [String!]!
  modifier: CriterionModifier!
}

type Mutation {
  sceneCreate(input: SceneCreateInput!): Scene
  sceneUpdate(input: SceneUpdateInput!): Scene
  sceneDestroy(input: SceneDestroyInput!): Boolean!
  performerCreate(input: PerformerCreateInput!): Performer
  performerUpdate(input: PerformerUpdateInput!): Performer
  performerDestroy(input: PerformerDestroyInput!): Boolean!
  studioCreate(input: StudioCreateInput!): Studio
  studioUpdate(input: StudioUpdateInput!): Studio
  studioDestroy(input: StudioDestroyInput!): Boolean!
  tagCreate(input: TagCreateInput!): Tag
  tagUpdate(input: TagUpdateInput!): Tag
  tagDestroy(input: TagDestroyInput!): Boolean!
  userCreate(input: UserCreateInput!): User
  userUpdate(input: UserUpdateInput!): User
  userDestroy(input: UserDestroyInput!): Boolean!
  imageCreate(input: ImageCreateInput!): Image
  imageDestroy(input: ImageDestroyInput!): Boolean!
  """User interface for registering"""
  newUser(input: NewUserInput!): ID
  activateNewUser(input: ActivateNewUserInput!): User
  generateInviteCode: ID
  """Generates an invite code using an invite token"""
  generateInviteCodes(input: GenerateInviteCodeInput): [ID!]!
  """Removes a pending invite code - refunding the token"""
  rescindInviteCode(code: ID!): Boolean!
  """Adds invite tokens for a user"""
  grantInvite(input: GrantInviteInput!): Int!
  """Removes invite tokens from a user"""
  revokeInvite(input: RevokeInviteInput!): Int!
  tagCategoryCreate(input: TagCategoryCreateInput!): TagCategory
  tagCategoryUpdate(input: TagCategoryUpdateInput!): TagCategory
  tagCategoryDestroy(input: TagCategoryDestroyInput!): Boolean!
  siteCreate(input: SiteCreateInput!): Site
  siteUpdate(input: SiteUpdateInput!): Site
  siteDestroy(input: SiteDestroyInput!): Boolean!
  """Regenerates the api key for the given user, or the current user if id not provided"""
  regenerateAPIKey(userID: ID): String!
  """Generates an email to reset a user password"""
  resetPassword(input: ResetPasswordInput!): Boolean!
  """Changes the password for the current user"""
  changePassword(input: UserChangePasswordInput!): Boolean!
  """Request an email change for the current user"""
  requestChangeEmail: UserChangeEmailStatus!
  validateChangeEmail(token: ID!, email: String!): UserChangeEmailStatus!
  confirmChangeEmail(token: ID!): UserChangeEmailStatus!
  """Propose a new scene or modification to a scene"""
  sceneEdit(input: SceneEditInput!): Edit!
  """Propose a new performer or modification to a performer"""
  performerEdit(input: PerformerEditInput!): Edit!
  """Propose a new studio or modification to a studio"""
  studioEdit(input: StudioEditInput!): Edit!
  """Propose a new tag or modification to a tag"""
  tagEdit(input: TagEditInput!): Edit!
  """Update a pending scene edit"""
  sceneEditUpdate(id: ID!, input: SceneEditInput!): Edit!
  """Update a pending performer edit"""
  performerEditUpdate(id: ID!, input: PerformerEditInput!): Edit!
  """Update a pending studio edit"""
  studioEditUpdate(id: ID!, input: StudioEditInput!): Edit!
  """Update a pending tag edit"""
  tagEditUpdate(id: ID!, input: TagEditInput!): Edit!
  """Vote to accept/reject an edit"""
  editVote(input: EditVoteInput!): Edit!
  """Comment on an edit"""
  editComment(input: EditCommentInput!): Edit!
  """Apply edit without voting"""
  applyEdit(input: ApplyEditInput!): Edit!
  """Cancel edit without voting"""
  cancelEdit(input: CancelEditInput!): Edit!
  """Matches/unmatches a scene to fingerprint"""
  submitFingerprint(input: FingerprintSubmission!): Boolean!
  """Draft submissions"""
  submitSceneDraft(input: SceneDraftInput!): DraftSubmissionStatus!
  submitPerformerDraft(input: PerformerDraftInput!): DraftSubmissionStatus!
  destroyDraft(id: ID!): Boolean!
  """Favorite or unfavorite a performer"""
  favoritePerformer(id: ID!, favorite: Boolean!): Boolean!
  """Favorite or unfavorite a studio"""
  favoriteStudio(id: ID!, favorite: Boolean!): Boolean!
  """Mark all of the current users notifications as read."""
  markNotificationsRead(notification: MarkNotificationReadInput): Boolean!
  """Update notification subscriptions for current user."""
  updateNotificationSubscriptions(subscriptions: [NotificationEnum!]!): Boolean!
}

input NewUserInput {
  email: String!
  invite_key: ID
}

type Notification {
  created: Time!
  read: Boolean!
  data: NotificationData!
}

union NotificationData = FavoritePerformerScene | FavoritePerformerEdit | FavoriteStudioScene | FavoriteStudioEdit | CommentOwnEdit | CommentCommentedEdit | CommentVotedEdit | DownvoteOwnEdit | FailedOwnEdit | UpdatedEdit | FingerprintedSceneEdit

enum NotificationEnum {
  FAVORITE_PERFORMER_SCENE
  FAVORITE_PERFORMER_EDIT
  FAVORITE_STUDIO_SCENE
  FAVORITE_STUDIO_EDIT
  COMMENT_OWN_EDIT
  DOWNVOTE_OWN_EDIT
  FAILED_OWN_EDIT
  COMMENT_COMMENTED_EDIT
  COMMENT_VOTED_EDIT
  UPDATED_EDIT
  FINGERPRINTED_SCENE_EDIT
}

enum OperationEnum {
  CREATE
  MODIFY
  DESTROY
  MERGE
}

type Performer {
  id: ID!
  name: String!
  disambiguation: String
  aliases: [String!]!
  gender: GenderEnum
  urls: [URL!]!
  birthdate: FuzzyDate
  birth_date: String
  death_date: String
  age: Int
  ethnicity: EthnicityEnum
  country: String
  eye_color: EyeColorEnum
  hair_color: HairColorEnum
  """Height in cm"""
  height: Int
  measurements: Measurements!
  cup_size: String
  band_size: Int
  waist_size: Int
  hip_size: Int
  breast_type: BreastTypeEnum
  career_start_year: Int
  career_end_year: Int
  tattoos: [BodyModification!]
  piercings: [BodyModification!]
  images: [Image!]!
  deleted: Boolean!
  edits: [Edit!]!
  scene_count: Int!
  scenes(input: PerformerScenesInput): [Scene!]!
  """IDs of performers that were merged into this one"""
  merged_ids: [ID!]!
  """ID of performer that replaces this one"""
  merged_into_id: ID
  studios: [PerformerStudio!]!
  is_favorite: Boolean!
  created: Time!
  updated: Time!
}

type PerformerAppearance {
  performer: Performer!
  """Performing as alias"""
  as: String
}

input PerformerAppearanceInput {
  performer_id: ID!
  as: String
}

input PerformerCreateInput {
  name: String!
  disambiguation: String
  aliases: [String!]
  gender: GenderEnum
  urls: [URLInput!]
  birthdate: String
  deathdate: String
  ethnicity: EthnicityEnum
  country: String
  eye_color: EyeColorEnum
  hair_color: HairColorEnum
  height: Int
  cup_size: String
  band_size: Int
  waist_size: Int
  hip_size: Int
  breast_type: BreastTypeEnum
  career_start_year: Int
  career_end_year: Int
  tattoos: [BodyModificationInput!]
  piercings: [BodyModificationInput!]
  image_ids: [ID!]
  draft_id: ID
}

input PerformerDestroyInput {
  id: ID!
}

type PerformerDraft {
  id: ID
  name: String!
  disambiguation: String
  aliases: String
  gender: String
  birthdate: String
  deathdate: String
  urls: [String!]
  ethnicity: String
  country: String
  eye_color: String
  hair_color: String
  height: String
  measurements: String
  breast_type: String
  tattoos: String
  piercings: String
  career_start_year: Int
  career_end_year: Int
  image: Image
}

input PerformerDraftInput {
  id: ID
  disambiguation: String
  name: String!
  aliases: String
  gender: String
  birthdate: String
  deathdate: String
  urls: [String!]
  ethnicity: String
  country: String
  eye_color: String
  hair_color: String
  height: String
  measurements: String
  breast_type: String
  tattoos: String
  piercings: String
  career_start_year: Int
  career_end_year: Int
  image: Upload
}

type PerformerEdit {
  name: String
  disambiguation: String
  added_aliases: [String!]
  removed_aliases: [String!]
  gender: GenderEnum
  added_urls: [URL!]
  removed_urls: [URL!]
  birthdate: String
  deathdate: String
  ethnicity: EthnicityEnum
  country: String
  eye_color: EyeColorEnum
  hair_color: HairColorEnum
  """Height in cm"""
  height: Int
  cup_size: String
  band_size: Int
  waist_size: Int
  hip_size: Int
  breast_type: BreastTypeEnum
  career_start_year: Int
  career_end_year: Int
  added_tattoos: [BodyModification!]
  removed_tattoos: [BodyModification!]
  added_piercings: [BodyModification!]
  removed_piercings: [BodyModification!]
  added_images: [Image!]
  removed_images: [Image!]
  draft_id: ID
  aliases: [String!]!
  urls: [URL!]!
  images: [Image!]!
  tattoos: [BodyModification!]!
  piercings: [BodyModification!]!
}

input PerformerEditDetailsInput {
  name: String
  disambiguation: String
  aliases: [String!]
  gender: GenderEnum
  urls: [URLInput!]
  birthdate: String
  deathdate: String
  ethnicity: EthnicityEnum
  country: String
  eye_color: EyeColorEnum
  hair_color: HairColorEnum
  height: Int
  cup_size: String
  band_size: Int
  waist_size: Int
  hip_size: Int
  breast_type: BreastTypeEnum
  career_start_year: Int
  career_end_year: Int
  tattoos: [BodyModificationInput!]
  piercings: [BodyModificationInput!]
  image_ids: [ID!]
  draft_id: ID
}

input PerformerEditInput {
  edit: EditInput!
  details: PerformerEditDetailsInput
  options: PerformerEditOptionsInput
}

type PerformerEditOptions {
  """Set performer alias on scenes without alias to old name if name is changed"""
  set_modify_aliases: Boolean!
  """Set performer alias on scenes attached to merge sources to old name"""
  set_merge_aliases: Boolean!
}

input PerformerEditOptionsInput {
  set_modify_aliases: Boolean
  set_merge_aliases: Boolean
}

input PerformerQueryInput {
  names: String
  name: String
  alias: String
  disambiguation: StringCriterionInput
  gender: GenderFilterEnum
  url: String
  birthdate: DateCriterionInput
  deathdate: DateCriterionInput
  birth_year: IntCriterionInput
  age: IntCriterionInput
  ethnicity: EthnicityFilterEnum
  country: StringCriterionInput
  eye_color: EyeColorCriterionInput
  hair_color: HairColorCriterionInput
  height: IntCriterionInput
  cup_size: StringCriterionInput
  band_size: IntCriterionInput
  waist_size: IntCriterionInput
  hip_size: IntCriterionInput
  breast_type: BreastTypeCriterionInput
  career_start_year: IntCriterionInput
  career_end_year: IntCriterionInput
  tattoos: BodyModificationCriterionInput
  piercings: BodyModificationCriterionInput
  is_favorite: Boolean
  performed_with: ID
  studio_id: ID
  page: Int!
  per_page: Int!
  direction: SortDirectionEnum!
  sort: PerformerSortEnum!
}

input PerformerScenesInput {
  performed_with: ID
  studio_id: ID
  tags: MultiIDCriterionInput
}

enum PerformerSortEnum {
  NAME
  BIRTHDATE
  DEATHDATE
  SCENE_COUNT
  CAREER_START_YEAR
  DEBUT
  LAST_SCENE
  CREATED_AT
  UPDATED_AT
}

type PerformerStudio {
  studio: Studio!
  scene_count: Int!
}

input PerformerUpdateInput {
  id: ID!
  name: String
  disambiguation: String
  aliases: [String!]
  gender: GenderEnum
  urls: [URLInput!]
  birthdate: String
  deathdate: String
  ethnicity: EthnicityEnum
  country: String
  eye_color: EyeColorEnum
  hair_color: HairColorEnum
  height: Int
  cup_size: String
  band_size: Int
  waist_size: Int
  hip_size: Int
  breast_type: BreastTypeEnum
  career_start_year: Int
  career_end_year: Int
  tattoos: [BodyModificationInput!]
  piercings: [BodyModificationInput!]
  image_ids: [ID!]
}

"""The query root for this schema"""
type Query {
  """Find a performer by ID"""
  findPerformer(id: ID!): Performer
  queryPerformers(input: PerformerQueryInput!): QueryPerformersResultType!
  """Find a studio by ID or name"""
  findStudio(id: ID, name: String): Studio
  queryStudios(input: StudioQueryInput!): QueryStudiosResultType!
  """Find a tag by ID or name"""
  findTag(id: ID, name: String): Tag
  """Find a tag with a matching name or alias"""
  findTagOrAlias(name: String!): Tag
  queryTags(input: TagQueryInput!): QueryTagsResultType!
  """Find a tag category by ID"""
  findTagCategory(id: ID!): TagCategory
  queryTagCategories: QueryTagCategoriesResultType!
  """Find a scene by ID"""
  findScene(id: ID!): Scene
  """Finds a scene by an algorithm-specific checksum"""
  findSceneByFingerprint(fingerprint: FingerprintQueryInput!): [Scene!]!
  """Finds scenes that match a list of hashes"""
  findScenesByFingerprints(fingerprints: [String!]!): [Scene!]!
  findScenesByFullFingerprints(fingerprints: [FingerprintQueryInput!]!): [Scene!]!
  findScenesBySceneFingerprints(fingerprints: [[FingerprintQueryInput!]!]!): [[Scene]!]!
  queryScenes(input: SceneQueryInput!): QueryScenesResultType!
  """Find an external site by ID"""
  findSite(id: ID!): Site
  querySites: QuerySitesResultType!
  findEdit(id: ID!): Edit
  queryEdits(input: EditQueryInput!): QueryEditsResultType!
  """Find user by ID or username"""
  findUser(id: ID, username: String): User
  queryUsers(input: UserQueryInput!): QueryUsersResultType!
  """Returns currently authenticated user"""
  me: User
  searchPerformer(term: String!, limit: Int): [Performer!]!
  searchScene(term: String!, limit: Int): [Scene!]!
  searchTag(term: String!, limit: Int): [Tag!]!
  searchStudio(term: String!, limit: Int): [Studio!]!
  findDraft(id: ID!): Draft
  findDrafts: [Draft!]!
  queryExistingScene(input: QueryExistingSceneInput!): QueryExistingSceneResult!
  queryExistingPerformer(input: QueryExistingPerformerInput!): QueryExistingPerformerResult!
  version: Version!
  getConfig: StashBoxConfig!
  queryNotifications(input: QueryNotificationsInput!): QueryNotificationsResult!
  getUnreadNotificationCount: Int!
}

type QueryEditsResultType {
  count: Int!
  edits: [Edit!]!
}

input QueryExistingPerformerInput {
  name: String
  disambiguation: String
  urls: [String!]!
}

type QueryExistingPerformerResult {
  edits: [Edit!]!
  performers: [Performer!]!
}

input QueryExistingSceneInput {
  title: String
  studio_id: ID
  fingerprints: [FingerprintInput!]!
}

type QueryExistingSceneResult {
  edits: [Edit!]!
  scenes: [Scene!]!
}

input QueryNotificationsInput {
  page: Int!
  per_page: Int!
  type: NotificationEnum
  unread_only: Boolean
}

type QueryNotificationsResult {
  count: Int!
  notifications: [Notification!]!
}

type QueryPerformersResultType {
  count: Int!
  performers: [Performer!]!
}

type QueryScenesResultType {
  count: Int!
  scenes: [Scene!]!
}

type QuerySitesResultType {
  count: Int!
  sites: [Site!]!
}

type QueryStudiosResultType {
  count: Int!
  studios: [Studio!]!
}

type QueryTagCategoriesResultType {
  count: Int!
  tag_categories: [TagCategory!]!
}

type QueryTagsResultType {
  count: Int!
  tags: [Tag!]!
}

type QueryUsersResultType {
  count: Int!
  users: [User!]!
}

input ResetPasswordInput {
  email: String!
}

input RevokeInviteInput {
  user_id: ID!
  amount: Int!
}

input RoleCriterionInput {
  value: [RoleEnum!]!
  modifier: CriterionModifier!
}

enum RoleEnum {
  READ
  VOTE
  EDIT
  MODIFY
  ADMIN
  INVITE
  MANAGE_INVITES
  BOT
  READ_ONLY
  EDIT_TAGS
}

type Scene {
  id: ID!
  title: String
  details: String
  date: String
  release_date: String
  production_date: String
  urls: [URL!]!
  studio: Studio
  tags: [Tag!]!
  images: [Image!]!
  performers: [PerformerAppearance!]!
  fingerprints(is_submitted: Boolean = False): [Fingerprint!]!
  duration: Int
  director: String
  code: String
  deleted: Boolean!
  edits: [Edit!]!
  created: Time!
  updated: Time!
}

input SceneCreateInput {
  title: String
  details: String
  urls: [URLInput!]
  date: String!
  production_date: String
  studio_id: ID
  performers: [PerformerAppearanceInput!]
  tag_ids: [ID!]
  image_ids: [ID!]
  fingerprints: [FingerprintEditInput!]!
  duration: Int
  director: String
  code: String
}

input SceneDestroyInput {
  id: ID!
}

type SceneDraft {
  id: ID
  title: String
  code: String
  details: String
  director: String
  urls: [String!]
  date: String
  production_date: String
  studio: SceneDraftStudio
  performers: [SceneDraftPerformer!]!
  tags: [SceneDraftTag!]
  image: Image
  fingerprints: [DraftFingerprint!]!
}

input SceneDraftInput {
  id: ID
  title: String
  code: String
  details: String
  director: String
  url: String
  urls: [String!]
  date: String
  production_date: String
  studio: DraftEntityInput
  performers: [DraftEntityInput!]!
  tags: [DraftEntityInput!]
  image: Upload
  fingerprints: [FingerprintInput!]!
}

union SceneDraftPerformer = Performer | DraftEntity

union SceneDraftStudio = Studio | DraftEntity

union SceneDraftTag = Tag | DraftEntity

type SceneEdit {
  title: String
  details: String
  added_urls: [URL!]
  removed_urls: [URL!]
  date: String
  production_date: String
  studio: Studio
  """Added or modified performer appearance entries"""
  added_performers: [PerformerAppearance!]
  removed_performers: [PerformerAppearance!]
  added_tags: [Tag!]
  removed_tags: [Tag!]
  added_images: [Image!]
  removed_images: [Image!]
  added_fingerprints: [Fingerprint!]
  removed_fingerprints: [Fingerprint!]
  duration: Int
  director: String
  code: String
  draft_id: ID
  urls: [URL!]!
  performers: [PerformerAppearance!]!
  tags: [Tag!]!
  images: [Image!]!
  fingerprints: [Fingerprint!]!
}

input SceneEditDetailsInput {
  title: String
  details: String
  urls: [URLInput!]
  date: String
  production_date: String
  studio_id: ID
  performers: [PerformerAppearanceInput!]
  tag_ids: [ID!]
  image_ids: [ID!]
  duration: Int
  director: String
  code: String
  fingerprints: [FingerprintInput!]
  draft_id: ID
}

input SceneEditInput {
  edit: EditInput!
  details: SceneEditDetailsInput
}

input SceneQueryInput {
  text: String
  title: String
  url: String
  date: DateCriterionInput
  production_date: DateCriterionInput
  studios: MultiIDCriterionInput
  parentStudio: String
  tags: MultiIDCriterionInput
  performers: MultiIDCriterionInput
  alias: StringCriterionInput
  fingerprints: MultiStringCriterionInput
  favorites: FavoriteFilter
  has_fingerprint_submissions: Boolean
  page: Int!
  per_page: Int!
  direction: SortDirectionEnum!
  sort: SceneSortEnum!
}

enum SceneSortEnum {
  TITLE
  DATE
  TRENDING
  CREATED_AT
  UPDATED_AT
}

input SceneUpdateInput {
  id: ID!
  title: String
  details: String
  urls: [URLInput!]
  date: String
  production_date: String
  studio_id: ID
  performers: [PerformerAppearanceInput!]
  tag_ids: [ID!]
  image_ids: [ID!]
  fingerprints: [FingerprintEditInput!]
  duration: Int
  director: String
  code: String
}

type Site {
  id: ID!
  name: String!
  description: String
  url: String
  regex: String
  valid_types: [ValidSiteTypeEnum!]!
  icon: String!
  created: Time!
  updated: Time!
}

input SiteCreateInput {
  name: String!
  description: String
  url: String
  regex: String
  valid_types: [ValidSiteTypeEnum!]!
}

input SiteDestroyInput {
  id: ID!
}

input SiteUpdateInput {
  id: ID!
  name: String!
  description: String
  url: String
  regex: String
  valid_types: [ValidSiteTypeEnum!]!
}

enum SortDirectionEnum {
  ASC
  DESC
}

type StashBoxConfig {
  host_url: String!
  require_invite: Boolean!
  require_activation: Boolean!
  vote_promotion_threshold: Int
  vote_application_threshold: Int!
  voting_period: Int!
  min_destructive_voting_period: Int!
  vote_cron_interval: String!
  guidelines_url: String!
  require_scene_draft: Boolean!
  edit_update_limit: Int!
  require_tag_role: Boolean!
}

"""The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text."""
input StringCriterionInput {
  value: String!
  modifier: CriterionModifier!
}

type Studio {
  id: ID!
  name: String!
  aliases: [String!]!
  urls: [URL!]!
  parent: Studio
  child_studios: [Studio!]!
  images: [Image!]!
  deleted: Boolean!
  is_favorite: Boolean!
  created: Time!
  updated: Time!
  performers(input: PerformerQueryInput!): QueryPerformersResultType!
}

input StudioCreateInput {
  name: String!
  aliases: [String!]
  urls: [URLInput!]
  parent_id: ID
  image_ids: [ID!]
}

input StudioDestroyInput {
  id: ID!
}

type StudioEdit {
  name: String
  """Added and modified URLs"""
  added_urls: [URL!]
  removed_urls: [URL!]
  parent: Studio
  added_images: [Image!]
  removed_images: [Image!]
  added_aliases: [String!]
  removed_aliases: [String!]
  images: [Image!]!
  urls: [URL!]!
}

input StudioEditDetailsInput {
  name: String
  aliases: [String!]
  urls: [URLInput!]
  parent_id: ID
  image_ids: [ID!]
}

input StudioEditInput {
  edit: EditInput!
  details: StudioEditDetailsInput
}

input StudioQueryInput {
  name: String
  names: String
  url: String
  parent: IDCriterionInput
  has_parent: Boolean
  is_favorite: Boolean
  page: Int!
  per_page: Int!
  direction: SortDirectionEnum!
  sort: StudioSortEnum!
}

enum StudioSortEnum {
  NAME
  CREATED_AT
  UPDATED_AT
}

input StudioUpdateInput {
  id: ID!
  name: String
  aliases: [String!]
  urls: [URLInput!]
  parent_id: ID
  image_ids: [ID!]
}

type Tag {
  id: ID!
  name: String!
  description: String
  aliases: [String!]!
  deleted: Boolean!
  edits: [Edit!]!
  category: TagCategory
  created: Time!
  updated: Time!
}

type TagCategory {
  id: ID!
  name: String!
  group: TagGroupEnum!
  description: String
}

input TagCategoryCreateInput {
  name: String!
  group: TagGroupEnum!
  description: String
}

input TagCategoryDestroyInput {
  id: ID!
}

input TagCategoryUpdateInput {
  id: ID!
  name: String
  group: TagGroupEnum
  description: String
}

input TagCreateInput {
  name: String!
  description: String
  aliases: [String!]
  category_id: ID
}

input TagDestroyInput {
  id: ID!
}

type TagEdit {
  name: String
  description: String
  added_aliases: [String!]
  removed_aliases: [String!]
  category: TagCategory
  aliases: [String!]!
}

input TagEditDetailsInput {
  name: String
  description: String
  aliases: [String!]
  category_id: ID
}

input TagEditInput {
  edit: EditInput!
  details: TagEditDetailsInput
}

enum TagGroupEnum {
  PEOPLE
  SCENE
  ACTION
}

input TagQueryInput {
  text: String
  names: String
  name: String
  category_id: ID
  page: Int!
  per_page: Int!
  direction: SortDirectionEnum!
  sort: TagSortEnum!
}

enum TagSortEnum {
  NAME
  CREATED_AT
  UPDATED_AT
}

input TagUpdateInput {
  id: ID!
  name: String
  description: String
  aliases: [String!]
  category_id: ID
}

enum TargetTypeEnum {
  SCENE
  STUDIO
  PERFORMER
  TAG
}

scalar Time

type URL {
  url: String!
  type: String!
  site: Site!
}

input URLInput {
  url: String!
  site_id: ID!
}

type UpdatedEdit {
  edit: Edit!
}

scalar Upload

type User {
  id: ID!
  name: String!
  """Should not be visible to other users"""
  roles: [RoleEnum!]
  """Should not be visible to other users"""
  email: String
  """Should not be visible to other users"""
  api_key: String
  notification_subscriptions: [NotificationEnum!]!
  """ Vote counts by type """
  vote_count: UserVoteCount!
  """ Edit counts by status """
  edit_count: UserEditCount!
  """Calls to the API from this user over a configurable time period"""
  api_calls: Int!
  invited_by: User
  invite_tokens: Int
  active_invite_codes: [String!]
  invite_codes: [InviteKey!]
}

input UserChangeEmailInput {
  existing_email_token: ID
  new_email_token: ID
  new_email: String
}

enum UserChangeEmailStatus {
  CONFIRM_OLD
  CONFIRM_NEW
  EXPIRED
  INVALID_TOKEN
  SUCCESS
  ERROR
}

input UserChangePasswordInput {
  existing_password: String
  new_password: String!
  reset_key: ID
}

input UserCreateInput {
  name: String!
  password: String!
  roles: [RoleEnum!]!
  email: String!
  invited_by_id: ID
}

input UserDestroyInput {
  id: ID!
}

type UserEditCount {
  accepted: Int!
  rejected: Int!
  pending: Int!
  immediate_accepted: Int!
  immediate_rejected: Int!
  failed: Int!
  canceled: Int!
}

input UserQueryInput {
  name: String
  email: String
  roles: RoleCriterionInput
  apiKey: String
  successful_edits: IntCriterionInput
  unsuccessful_edits: IntCriterionInput
  successful_votes: IntCriterionInput
  unsuccessful_votes: IntCriterionInput
  api_calls: IntCriterionInput
  invited_by: ID
  page: Int!
  per_page: Int!
}

input UserUpdateInput {
  id: ID!
  name: String
  password: String
  roles: [RoleEnum!]
  email: String
}

type UserVoteCount {
  abstain: Int!
  accept: Int!
  reject: Int!
  immediate_accept: Int!
  immediate_reject: Int!
}

enum UserVotedFilterEnum {
  ABSTAIN
  ACCEPT
  REJECT
  NOT_VOTED
}

enum ValidSiteTypeEnum {
  PERFORMER
  SCENE
  STUDIO
}

type Version {
  hash: String!
  build_time: String!
  build_type: String!
  version: String!
}

enum VoteStatusEnum {
  ACCEPTED
  REJECTED
  PENDING
  IMMEDIATE_ACCEPTED
  IMMEDIATE_REJECTED
  FAILED
  CANCELED
}

enum VoteTypeEnum {
  ABSTAIN
  ACCEPT
  REJECT
  IMMEDIATE_ACCEPT
  IMMEDIATE_REJECT
}
